<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceOrders</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.Specialized;
using System.Globalization;
using System.Reflection;
using System.Threading;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;
using Microsoft.Dynamics365.LocalizationFramework;
using CrtTransactionService = Microsoft.Dynamics.Commerce.Runtime.TransactionService;
using DataModel = Microsoft.Dynamics.Commerce.Runtime.DataModel;
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;

/// <summary>
/// The <c>RetailTransactionServiceOrders</c> implements the customer order related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceOrders
{
    public static RetailTransactionServiceOrders_ExtendedParameters extendedParameters = RetailTransactionServiceOrders_ExtendedParameters::construct();

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    #define.Star('*')
    #define.UpdatedInAx('UpdatedInAx')
    #define.Message('Message')
    #define.RetryNum(3)

    #ISOCountryRegionCodes

    #EECountryRegionCodes

    #define.Discounts('Discounts')
    #define.Discount('Discount')
    #define.CustomerDiscountType('CustomerDiscountType')
    #define.DiscountCode('DiscountCode')
    #define.DiscountOriginType('DiscountOriginType')
    #define.ManualDiscountType('ManualDiscountType')
    #define.PeriodicDiscountOfferId('PeriodicDiscountOfferId')
    #define.OfferName('OfferName')
    #define.DiscountAmount('DiscountAmount')
    #define.DealPrice('DealPrice')
    #define.OriginalPrice('OriginalPrice')
    #define.IsPriceOverridden('IsPriceOverridden')
    #define.TotalManualDiscountAmount('TotalManualDiscountAmount')
    #define.TotalManualDiscountPercentage('TotalManualDiscountPercentage')
    #define.DiscountCodes('DiscountCodes')
    #define.LineManualDiscountAmount('LineManualDiscountAmount')
    #define.LineManualDiscountPercentage('LineManualDiscountPercentage')
    #define.LineDscAmount('LineDscAmount')
    #define.PeriodicDiscount('PeriodicDiscount')
    #define.PeriodicPercentageDiscount('PeriodicPercentageDiscount')
    #define.TotalDiscount('TotalDiscount')
    #define.TotalPctDiscount('TotalPctDiscount')
    #define.LoyaltyCardId('LoyaltyCardId')
    #define.FulfillmentStoreId('FulfillmentStoreId')
    #define.CommissionSalesGroup('CommissionSalesGroup')
    #define.Coupons('Coupons')
    #define.Coupon('Coupon')
    #define.CodeId('CodeId')
    #define.DiscountOFferId('DiscountOfferId')
    #RetailCustAffiliation
    #define.SerialItemsActiveInSalesProcess('ItemsActiveInSalesProcess')
    private const str productRecordIdAttribute = 'ProductRecordId';
    private const str lineNumberColumn = 'LineNumber';
    private const str BundleIdColumn = 'BundleId';
    private const str TrueStr = 'true';
    private const str FalseStr = 'false';
    private const str AmountStr = 'Amount';
    private const str AmountRefundedStr = 'AmountRefunded';
    private const str AmountLeftToRefundStr = 'AmountLeftToRefund';
    private const str PercentageStr = 'Percentage';
    private const str TaxItemGroupStr = 'TaxItemGroup';
    private const str TaxBaseAmountStr = 'TaxBaseAmount';
    private const str TaxGroupStr = 'TaxGroup';
    private const str TaxCodeStr = 'TaxCode';
    private const str CodeStr = 'Code';
    private const str ChargeTypeStr = 'ChargeType';
    private const str MarkupAutoTableRecIdStr = 'MarkupAutoTableRecId';
    private const str MarkupAutoLineRecIdStr = 'MarkupAutoLineRecId';
    private const str IsOverriddenLineStr = 'IsOverriddenLine';
    private const str DescriptionStr = 'Description';
    private const str CurrencyCodeStr = 'CurrencyCode';
    private const str ModuleTypeStr = 'ModuleType';
    private const str TaxOverrideCodeElement = 'TaxOverrideCode';
    private const str IsTaxIncludedInPrice = 'IsTaxIncludedInPrice';
    private const str InvoicePaidStatusValueAttribute = 'InvoicePaidStatusValue';
    private const str InvoiceSubtotalAttribute = 'InvoiceSubtotal';
    private const str TotalChargesAttribute = 'TotalCharges';
    private const str TotalTaxAmountAttribute = 'TotalTaxAmount';
    private const str TotalLineDiscountAttribute = 'TotalLineDiscount';
    private const str TotalDiscountAttribute = 'TotalDiscount';
    private const str AmountPaidAttribute = 'InvoiceAmountPaid';
    private const str AmountBalanceAttribute = 'InvoiceAmountBalance';

    private const str LinePercentageDiscountStr = 'LinePercentageDiscount';
    private const str StatementIdStr            = 'StatementId';
    private const str QtyReturnableStr          = 'QtyReturnable';
    private const str ReasonCodeLinesParamName = 'ReasonCodeLines';
    private const str GuidStr = 'Guid';
    private const str InvoiceLineIdsElementName = 'InvoiceLineIds';

    public const str ClassCommerceProperty = 'Microsoft.Dynamics.Commerce.Runtime.DataModel.CommerceProperty';
    public const str ClassCommercePropertyValue = 'Microsoft.Dynamics.Commerce.Runtime.DataModel.CommercePropertyValue';
    public const str ClassTaxMeasureInfo = 'Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder.TaxMeasureInfo';
    public const str PropertyExtensionProperties = 'ExtensionProperties';
    public const str RetailTransactionAggregationFieldListPropertyName = 'RetailTransactionAggregationFieldList';
    public const str PropertyTaxCalculationType = 'TaxCalculationType';
    public const str PropertyTaxMeasures = 'TaxMeasures';
    public const str PropertyKey = 'Key';
    public const str PropertyValue = 'Value';
    public const str PropertyCommerceProperty = 'CommerceProperty';
    public const str PropertyStringValue = 'StringValue';
    public const str PropertyBooleanValue = 'BooleanValue';
    public const str CustomerOrderElement = 'CustomerOrder';

    public const str InvoiceAddressIndiaPropertyName = 'INVOICEADDRESS_IN';
    public const str HSNCodePropertyName = 'HSNCODE_IN';
    public const str ITCCategoryPropertyName = 'ITCCATEGORY_IN';
    public const str IsExemptPropertyName = 'EXEMPT_IN';
    public const str NonGSTPropertyName = 'NONGST_IN';
    public const str ServiceAccountingCodePropertyName = 'SERVICEACCOUNTINGCODE_IN';
    public const str ServiceCategoryPropertyName = 'SERVICECATEGORY_IN';
    public const str TaxRateTypePropertyName = 'TaxRateType';
    public const str FulfillmentStoreIdPropertyName = 'FULFILLMENTSTOREID_IN';

    private const str TenderDiscount = 'TenderDiscountAmount';
    private const str TenderDiscountPercentage = 'TenderDiscountPercentage';

    private const str PickupTimeslotStartDateTime = 'PickupTimeslotStartDateTime';
    private const str PickupTimeslotEndDateTime = 'PickupTimeslotEndDateTime';
    public const str CommercePropertyType = 'CommercePropertyType';
    public const str SimplePropertyType = 'SimplePropertyType';

    // This matches the CRT enum
    // /Components/Platform/Libraries/Runtime/Entities/DataModel/RetailOperation.cs
    private const int POSOperationPayCard = 201;

    private const str SuccessKey = 'Success';
    private const str ErrorMessageKey = 'ErrorMessage';
    private const str ElementKey = 'Element';

    private const str ChannelIdStr = 'ChannelId';
    private const str ChannelReferenceIdStr = 'ChannelReferenceId';
    private const str CreatedDateTimeStr = 'CreatedDateTime';
    private const str CustomerIdStr = 'CustomerId';
    private const str DeliveryModeStr = 'DeliveryMode';
    private const str GrossAmountStr = 'GrossAmount';
    private const str InventoryLocationIdStr = 'InventoryLocationId';
    private const str ReceiptIdStr = 'ReceiptId';
    private const str RequestedDeliveryDateStr = 'RequestedDeliveryDate';
    private const str SalesIdStr = 'SalesId';
    private const str SalesLinesStr = 'SalesLines';
    private const str StatusStr = 'Status';
    private const str TaxAmountStr = 'TaxAmount';
    private const str TransactionIdStr = 'TransactionId';
    private const str TotalAmountStr = 'TotalAmount';
    private const str TaxAdjustmentMapKeyTemplate = '#%1#%2#%3';
    private const str IsPriceKeyedIn = 'IsPriceKeyedIn';
    private const str IsTaxExemptedForPriceInclusive = 'IsTaxExemptedForPriceInclusive';
    private const str TaxExemptPriceInclusiveOriginalPrice = 'TaxExemptPriceInclusiveOriginalPrice';
    private const str TaxExemptPriceInclusiveReductionAmount = 'TaxExemptPriceInclusiveReductionAmount';
    private const str ModuleTypeValueStr = 'ModuleTypeValue';
    private const str CalculatedProratedAmountStr = 'CalculatedProratedAmount';
    private const str CatalogRecId = 'CatalogRecId';
    private const str OrderedByCustomerNameStr = 'OrderedByCustomerName';
    private const str IsInvoicedStr = 'IsInvoiced';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getCustomerOrderInfoForShipFulfillmentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order info for the given Id for shipping fulfillment lines.
    /// The order will have sales line information only for provided sales line ids.
    /// The quantity is the quantity to be shipped which is provided.
    /// </summary>
    /// <param name="_salesId">
    /// Value of the SalesId for which order needs to be fetched.
    /// </param>
    /// <param name="fulfillmentLineInfo">
    /// Map of salesLineNum => quantity being shipped
    /// </param>
    /// <returns>
    /// A container having the order details in a XML string.
    /// </returns>
    public static container getCustomerOrderInfoForShipFulfillmentLine(SalesId _salesId, Map fulfillmentLineInfo)
    {
        str                 error = '';
        boolean             success = false;
        SalesTable salesTable;
        SalesLine           salesLine;
        InventDim           inventDim;
        MarkupTrans         markupTrans;
        RetailStaffTable    retailStaffTable;
        RetailLoyaltyCard   retailLoyaltyCard;
        Counter             infologline    = infolog.num();
        XmlDocument         xmldoc;
        XmlElement          xmlRoot,xmlRecord,xmlItem,xmlCharges,xmlHeaderInfo, xmlLineCharges, xmlLineRecord, xmlCoupon;
        int                 fromLine;
        InventTransIdSum    inventTransIdSum;
        RetailStoreTable    retailStoreTable;
        RetailStoreId       storeId = '';
        RetailStoreId       fulfillmentStoreId = '';
        DirPartyTable       dirPartyTable;
        HcmWorker           hcmWorker;
        str                 salespersonStaffId = '';
        RetailSalesTable    retailSalesTable;
        int i, length;
        container           discountCodes;
        boolean             countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        boolean             hasLoyaltyPayment;
        UnitOfMeasure       unitOfMeasure;
        int                 numberOfDecimals;
        PriceUnit           priceUnit;
        InventDimCombination inventDimCombination;
        CustTable            custTable;
        container           coupons;

        if (!fulfillmentLineInfo || !fulfillmentLineInfo.elements() || !fulfillmentLineInfo.elements() > 1)
        {
            error = "@Retail:InvalidFunctionParameter";
            success = false;
            return [success, error];
        }

        try
        {
            fromLine = Global::infologLine();

            // Find a Sales Order via SalesId directly
            salesTable = SalesTable::find(_salesId);
            xmldoc =  XmlDocument::newBlank();

            if (salesTable)
            {
                xmlRoot = xmldoc.createElement(CustomerOrderElement);

                //Get the sales order header info
                xmlHeaderInfo = xmldoc.createElement('CustomerAccount');
                xmlHeaderInfo.innerText(salesTable.CustAccount);
                xmlRoot.appendChild(xmlHeaderInfo);

                //Get customer record id
                custTable = CustTable::find(salesTable.CustAccount);
                xmlHeaderInfo = xmldoc.createElement('CustomerRecordId');
                xmlHeaderInfo.innerText(int642str(custTable.Party));
                xmlRoot.appendChild(xmlHeaderInfo);

                //Get latest contract version.
                str latestContractVersion = CustomerOrderContractVersionHelper::GetLatestContractVersion().ToString();
                xmlHeaderInfo = xmldoc.createElement('ContractVersion');
                xmlHeaderInfo.innerText(latestContractVersion);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Id');
                xmlHeaderInfo.innerText(salesTable.SalesId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('AddressRecord');
                xmlHeaderInfo.innerText(int642str(salesTable.DeliveryPostalAddress));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('InventLocationId');
                xmlHeaderInfo.innerText(salesTable.InventLocationId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('InventSiteId');
                xmlHeaderInfo.innerText(salesTable.InventSiteId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Comment');
                xmlHeaderInfo.innerText(salesTable.CustomerRef);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Status');
                xmlHeaderInfo.innerText(int2str(enum2int(salesTable.SalesStatus)));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('DocumentStatus');
                xmlHeaderInfo.innerText(int2str(enum2int(salesTable.DocumentStatus)));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CreationDate');
                xmlHeaderInfo.innerText(DateTimeUtil::toStr(salesTable.CreatedDateTime)); //Formatted as yyyy-MM-ddTHH:mm:ss
                xmlRoot.appendChild(xmlHeaderInfo);

                retailSalesTable = salesTable.retailSalesTable();

                // Add discountCodes
                // DiscountCodes property is obsolete. We are setting discount codes here for N-1 compatibility.
                discountCodes = retailSalesTable.DiscountCodes;
                length = conLen(discountCodes);
                for (i = 1; i <= length; i++)
                {
                    xmlHeaderInfo = xmldoc.createElement(#DiscountCodes);
                    xmlHeaderInfo.innerText(conPeek(discountCodes, i));
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Add coupons.
                coupons = retailSalesTable.Coupons;
                length = conLen(Coupons);
                xmlHeaderInfo = xmldoc.createElement(#Coupons);
                for (i = 1; i <= length; i = i + 3)
                {
                    xmlCoupon = xmldoc.createElement(#Coupon);
                    xmlCoupon.setAttribute(#CodeId, conPeek(coupons, i));
                    xmlCoupon.setAttribute(CodeStr, conPeek(coupons, i + 1));
                    xmlCoupon.setAttribute(#DiscountOfferId, conPeek(coupons, i + 2));
                    xmlHeaderInfo.appendChild(xmlCoupon);
                }

                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountAmount);
                xmlHeaderInfo.innerText(RetailTransactionServiceOrders::amountToStr(retailSalesTable.TotalManualDiscountAmount));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountPercentage);
                xmlHeaderInfo.innerText(RetailTransactionServiceOrders::percentToStr(retailSalesTable.TotalManualDiscountPercentage));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('ChannelReferenceId');
                xmlHeaderInfo.innerText(retailSalesTable.ChannelReferenceId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Email');
                xmlHeaderInfo.innerText(salesTable.Email);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CommissionSalesGroup');
                xmlHeaderInfo.innerText(salesTable.SalesGroup);
                xmlRoot.appendChild(xmlHeaderInfo);

                select firstonly StaffId from retailStaffTable
                    join hcmWorker where retailStaffTable.StaffId == hcmWorker.PersonnelNumber
                                        && hcmWorker.RecId == salesTable.WorkerSalesResponsible;
                if (retailStaffTable)
                {
                    salespersonStaffId = retailStaffTable.StaffId;
                }
                else if (salesTable.WorkerSalesResponsible)
                {
                    salespersonStaffId = int642str(salesTable.WorkerSalesResponsible);
                    select firstonly Name from dirPartyTable
                        join RecId from hcmWorker where
                        hcmWorker.RecId == salesTable.WorkerSalesResponsible && hcmWorker.Person == dirPartyTable.RecId;
                    if (dirPartyTable)
                    {
                        xmlHeaderInfo = xmldoc.createElement('SalespersonName');
                        xmlHeaderInfo.innerText(dirPartyTable.Name);
                        xmlRoot.appendChild(xmlHeaderInfo);
                    }
                }

                if (salespersonStaffId != '')
                {
                    xmlHeaderInfo = xmldoc.createElement('SalespersonStaffId');
                    xmlHeaderInfo.innerText(salespersonStaffId);
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Get store number assume one warehouse per store
                select firstonly StoreNumber from retailStoreTable
                    where retailStoreTable.InventLocation == salesTable.InventLocationId
                       && retailStoreTable.inventLocationDataAreaId == curExt();
                if (retailStoreTable)
                {
                    storeId = retailStoreTable.StoreNumber;
                }

                xmlHeaderInfo = xmldoc.createElement('StoreId');
                xmlHeaderInfo.innerText(storeId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('IsTaxIncludedInPrice');
                xmlHeaderInfo.innerText(salesTable.InclTax == NoYes::Yes ? TrueStr : FalseStr);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CurrencyCode');
                xmlHeaderInfo.innerText(salesTable.CurrencyCode);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('DeliveryMode');
                xmlHeaderInfo.innerText(salesTable.DlvMode);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('RequestedDeliveryDate');
                xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::dateToString(salesTable.ShippingDateRequested));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Sets PrepaymentAmountOverridden property.
                RetailTransactionServiceOrders::setHeaderDepositOverridenXml(xmldoc, xmlRoot, salesTable);

                // Loyalty
                if  (salesTable.retailSalesTable().RetailLoyaltyCard)
                {
                    select firstOnly CardNumber from retailLoyaltycard
                        where retailLoyaltycard.RecId == salesTable.retailSalesTable().RetailLoyaltyCard;

                    xmlHeaderInfo = xmldoc.createElement('LoyaltyCardId');
                    xmlHeaderInfo.innerText(retailLoyaltycard.CardNumber);
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                hasLoyaltyPayment = RetailLoyaltyCardRewardPointTrans::IsSalesOrderPaidByLoyalty(salesTable.SalesId, salesTable.dataAreaId);
                xmlHeaderInfo = xmldoc.createElement('HasLoyaltyPayment');
                xmlHeaderInfo.innerText(hasLoyaltyPayment ? TrueStr : FalseStr);
                xmlRoot.appendChild(xmlHeaderInfo);

                // DataAreaId
                xmlHeaderInfo = xmldoc.createElement('DataAreaId');
                xmlHeaderInfo.innerText(salesTable.DataAreaId);
                xmlRoot.appendChild(xmlHeaderInfo);

                // Affiliations
                xmlHeaderInfo = RetailSalesAffiliation::getSalesAffiliatonXML(xmldoc, salesTable.SalesId);
                if (xmlHeaderInfo)
                {
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Previously invoiced amount
                xmlHeaderInfo = xmldoc.createElement('PreviouslyInvoicedAmount');
                xmlHeaderInfo.innerText(num2str(salesTable.amountInvoiced(),5,3,1,0));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Get Customer order Header retail attributes
                RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRoot, _salesId, salesTable.DataAreaId);

                //Get the info of items
                xmlItem = xmldoc.createElement('Items');
                MapEnumerator fulfillmentLineInfoEnumerator = fulfillmentLineInfo.getEnumerator();

                while (fulfillmentLineInfoEnumerator.moveNext())
                {
                    LineNumber lineNumber = fulfillmentLineInfoEnumerator.currentKey();
                    SalesQty quantity = fulfillmentLineInfoEnumerator.currentValue();

                    while select
                            SalesId,
                            ItemId,
                            SalesPrice,
                            priceUnit,
                            SalesQty,
                            SalesStatus,
                            SalesUnit,
                            LineDisc,
                            LinePercent,
                            LineAmount,
                            TaxGroup,
                            TaxItemGroup,
                            SalesMarkup,
                            DlvMode,
                            DeliveryPostalAddress,
                            ShippingDateRequested,
                            RetailVariantId,
                            StockedProduct,
                            InventTransId,
                            RemainSalesPhysical,
                            CustomerRef,
                            InventDimId,
                            LineNum,
                            SalesGroup,
                            DataAreaId
                        from salesLine
                        where salesLine.SalesId == _salesId && SalesLine.LineNum == lineNumber
                        join InventLocationId, InventSerialId, InventBatchId, InventColorId, InventSizeId, InventStyleId, InventVersionId, ConfigId from inventDim
                            where salesLine.InventDimId == inventDim.InventDimId
                    {
                        xmlRecord = xmldoc.createElement('Item');

                        xmlRecord.setAttribute('RecId', int642str(salesLine.RecId));

                        inventDimCombination = InventDimCombination::findVariantId(salesLine.RetailVariantId);
                        xmlRecord.setAttribute('InventDimensionId', inventDimCombination.InventDimId);

                        xmlRecord.setAttribute('ItemId', salesLine.ItemId);

                        xmlRecord.setAttribute(lineNumberColumn, RetailTransactionServiceUtilities::lineNumToString(salesLine.LineNum));

                        // Need a version number to tell if Hybrid X++ code is present
                        // Version 1 was for above properties QuantityRemained and QuantityShipped so MPOS can tell if X++ change present
                        xmlRecord.setAttribute('LineVersion', '1');

                        priceUnit = salesLine.PriceUnit;
                        if (!priceUnit)
                        {
                            priceUnit = 1;
                        }

                        xmlRecord.setAttribute('Price', num2str(salesLine.SalesPrice/priceUnit,5,3,1,0));
                        unitOfMeasure = UnitOfMeasure::findBySymbol(salesLine.SalesUnit);
                        if (unitOfMeasure.RecId)
                        {
                            numberOfDecimals = unitOfMeasure.DecimalPrecision;
                        }
                        else
                        {
                            numberOfDecimals = 3;
                        }

                        // Quantity being shipped.
                        xmlRecord.setAttribute('Quantity', num2str(quantity,5,numberOfDecimals,1,0));

                        InventQty qtyCanceled = (SalesLine.SalesQty - salesLine.RemainSalesPhysical - salesLine.invoicedInTotal()) >= 0 ?
                            (SalesLine.SalesQty - salesLine.RemainSalesPhysical - salesLine.invoicedInTotal()) : 0;
                        xmlRecord.setAttribute('QuantityCanceled', num2str(qtyCanceled, 5, numberOfDecimals, 1, 0));

                        if (salesLine.StockedProduct)
                        {
                            InventTransOriginId inventTransOriginId = InventTransOriginSalesLine::findInventTransOriginId(salesLine.DataAreaId, salesLine.InventTransId);

                            inventTransIdSum = InventTransIdSum::newTransIdNoChildType(inventTransOriginId);
                            xmlRecord.setAttribute('QuantityPicked',num2str(
                                EcoResProductUnitConverter::convertForReleasedProduct(salesLine.ItemId,
                                                                                      salesLine.InventDimId,
                                                                                      -inventTransIdSum.physical() - inventTransIdSum.financial(),
                                                                                      UnitOfMeasure::unitOfMeasureIdBySymbol(InventTableModule::find(salesLine.ItemId, ModuleInventPurchSales::Invent).UnitId),
                                                                                      unitOfMeasure.RecId,
                                                                                      NoYes::Yes)
                                ,5,numberOfDecimals,1,0));
                        }
                        else
                        {
                            XmlRecord.setAttribute('QuantityPicked',num2str((salesLine.SalesQty - salesLine.RemainSalesPhysical),5,numberOfDecimals,1,0));
                        }

                        // Quantity that is still available for pickup in the stores
                        xmlRecord.setAttribute('QuantityRemained', num2str(salesLine.RemainSalesPhysical,5,numberOfDecimals,1,0));

                        // Quantities that were already picked in the HQ, are showed as "shipped" in MPOS,
                        // as they won't be available for pick-up anymore.
                        xmlRecord.setAttribute('QuantityShipped', num2str(salesLine.deliveredInTotal(),5,numberOfDecimals,1,0));

                        xmlRecord.setAttribute('Status', int2str(enum2int(salesLine.SalesStatus)));

                        xmlRecord.setAttribute('Unit', salesLine.SalesUnit);
                        xmlRecord.setAttribute('Discount',num2str(salesLine.LineDisc,5,3,1,0));
                        xmlRecord.setAttribute('DiscountPercent',num2str(salesLine.LinePercent,5,3,1,0));
                        xmlRecord.setAttribute('NetAmount',num2str(salesLine.LineAmount,5,3,1,0));
                        xmlRecord.setAttribute(TaxGroupStr, salesLine.TaxGroup);
                        xmlRecord.setAttribute(TaxItemGroupStr, salesLine.TaxItemGroup);
                        xmlRecord.setAttribute('SalesMarkup', num2str(salesLine.SalesMarkup,5,3,1,0));
                        xmlRecord.setAttribute('InventLocationId', inventDim.InventLocationId);
                        xmlRecord.setAttribute('DeliveryMode', salesLine.DlvMode);
                        xmlRecord.setAttribute('AddressRecord', int642str(salesLine.DeliveryPostalAddress));
                        xmlRecord.setAttribute('RequestedDeliveryDate', RetailTransactionServiceUtilities::dateToString(salesLine.ShippingDateRequested));
                        xmlRecord.setAttribute('VariantId', salesLine.RetailVariantId);
                        xmlRecord.setAttribute('Comment', salesLine.CustomerRef);
                        xmlRecord.setAttribute('CommissionSalesGroup', salesLine.SalesGroup);

                        // Add details from retail sales line
                        RetailTransactionServiceOrders::getRetailSalesLine(xmlRecord, salesLine);

                        if (!salesLine.RetailVariantId)
                        {
                            // Get InventDim values.
                            RetailTransactionService::getInventDimValues(salesLine.ItemId, inventDim, xmlRecord);
                        }

                        xmlRecord.setAttribute('SerialId', inventDim.InventSerialId);
                        xmlRecord.setAttribute('BatchId', inventDim.InventBatchId);

                        //Get the line-level charge info
                        RetailTransactionServiceOrders::setLineLevelCharges(xmldoc, xmlRecord, salesLine.RecId, salesLine.TableId);

                        if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
                        {
                            //Get line level price info
                            RetailTransactionServiceOrders::addPriceLineXml(xmlDoc, xmlRecord, salesLine, false);
                        }

                        //Get line level discount info
                        RetailTransactionServiceOrders::addDiscountLineXml(xmldoc, xmlRecord, salesLine.salesPurchLineInterface(), false);

                        //Get customer order retail line level attributes
                        RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRecord, _salesId, salesLine.DataAreaId, salesLine.LineNum);

                        // Add line-level extension properties as commerce properties.
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                        {
                            XmlElement xmlCollection = RetailTransactionServiceOrders::fillSalesLineExtensionProprtiesForInvoice_IN(
                                xmldoc, 
                                salesLine,
                                RetailTransactionServiceOrders::CommercePropertyType);

                            xmlRecord.appendChild(xmlCollection);
                        }

                        xmlItem.appendChild(xmlRecord);
                    }
                }

                //Get header-level info of charges
                xmlCharges = RetailTransactionServiceOrders::setHeaderCharges(xmldoc, salesTable.RecId, salesTable.TableId);

                //
                // Add payment history
                //
                XmlElement xmlPayments = xmlRoot.ownerDocument().createElement('Payments');
                xmlPayments = RetailTransactionServiceOrders::AddPaymentHistoryXML(xmlRoot, xmlPayments, salesTable);

                if (RetailOrdersFeatureControl::isSettleInvoiceAndPaymentJournalDuringShipOrderFulfillment())
                {
                    xmlRoot.appendChild(xmlPayments);
                }

                //
                // Compose all the pieces.
                //
                xmlRoot.appendChild(xmlItem);
                xmlRoot.appendChild(xmlCharges);
                xmldoc.appendChild(xmlRoot);
                success = true;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRetailTransactionServiceInvoiceContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates RetailTransactionServiceInvoiceContext data with CustomerOrderInfo.
    /// </summary>
    private static RetailTransactionServiceInvoiceContext createRetailTransactionServiceInvoiceContext(CustomerOrderInfo _custOrderInfo)
    {
        var context = RetailTransactionServiceInvoiceContext::construct();

        context.parmStore(_custOrderInfo.StoreId);
        context.parmTerminal(_custOrderInfo.TerminalId);
        context.parmTransactionId(_custOrderInfo.TransactionId);
        context.parmChannel(str2Int64(_custOrderInfo.ChannelRecordId));
        context.parmCustAccount(_custOrderInfo.CustomerAccount);
        context.parmSalesId(_custOrderInfo.Id);
        context.parmBusinessDate(str2Date(_custOrderInfo.BusinessDateString, 321));

        return context;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxLineXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Sales Tax Line XML for the given SalesLine InventTransId
    /// </summary>
    /// <param name="_xmlDoc">
    /// Parent XML document.
    /// </param>
    /// <param name="_xmlItem">
    /// Parent XML node the Discount Line XML will be added to.
    /// </param>
    /// <param name="_invoiceId">
    /// InventTransId of the sales line.
    /// </param>
    /// <param name="_itemId">
    /// Itme Id of the sales line.
    /// </param>
    /// <param name="_salesId">
    /// Sales Order Id.
    /// </param>
    /// <param name="_transLineNum">
    /// Line Number of transaction.
    /// </param>
    /// <param name="_invoiceDate">
    /// Date invoiced.
    /// </param>
    /// <param name="_channelRecId">
    /// Retail channel record id.
    /// </param>
    /// <remarks>
    /// Gets XML representing the associated TaxLines for the given SalesLine and adds them to the given Item and line number xml node.
    /// </remarks>
    private static void addTaxLineXml(XmlDocument _xmlDoc, XmlElement _xmlItem, InvoiceId _invoiceId, ItemIdSmall _itemId, SalesIdBase _salesId, LineNum _transLineNum, InvoiceDate _invoiceDate, RefRecId _channelRecId = 0)
    {
        const str TaxLinesStr = 'TaxLines';
        const str TaxLineStr = 'TaxLine';
        const str IsIncludedInPriceStr = 'IsIncludedInPrice';

        TaxTrans                taxTrans;
        CustInvoiceTrans        custInvoiceTrans;

        XmlElement xmlLineTaxs, xmlLineRecord;

        //Get line level TaxLines info
        xmlLineTaxs = _xmlDoc.createElement(TaxLinesStr);

        // Get the relevant tax lines, excluding tax lines on charges, because taxes on charges are associated with the charge, not the sales line
        while select RecId, ItemId
                from custInvoiceTrans
                        where custInvoiceTrans.InvoiceId == _invoiceId
                        && CustInvoiceTrans.InvoiceDate == _invoiceDate
                        && custInvoiceTrans.SalesId == _salesId
                        && custInvoiceTrans.ItemId == _itemId
                        && custInvoiceTrans.LineNum == _transLineNum
                    join SourceRegulateAmountCur, TaxCode, TaxItemGroup, TaxValue, SourceBaseAmountCur, SourceCurrencyCode from taxTrans
                        where taxTrans.inventTransId == custInvoiceTrans.inventTransId
                            && taxTrans.SourceRecId == custInvoiceTrans.RecId
                            && taxTrans.SourceTableId == custInvoiceTrans.TableId
        {
            // We should honor SourceRegulateAmountCur instead of SourceTaxAmountCur, in case channel and HQ has different tax rate
            real taxAmount = taxTrans.SourceRegulateAmountCur;
            real baseAmount = taxTrans.SourceBaseAmountCur;
            CurrencyCode returnStoreCurrency;

            if (_channelRecId)
            {
                returnStoreCurrency = RetailChannelTable::findByRecId(_channelRecId).Currency;
            }

            if (returnStoreCurrency != '' && taxTrans.SourceCurrencyCode != returnStoreCurrency)
            {
                taxAmount = CurrencyExchangeHelper::curAmount2CurAmount(taxAmount, taxTrans.SourceCurrencyCode, returnStoreCurrency, _invoiceDate);
                baseAmount = CurrencyExchangeHelper::curAmount2CurAmount(baseAmount, taxTrans.SourceCurrencyCode, returnStoreCurrency, _invoiceDate);
            }

            xmllinerecord = _xmlDoc.createElement(TaxLineStr);
            xmllinerecord.setAttribute(TaxBaseAmountStr, num2str(baseAmount, 5, 3, 1, 0));
            xmllinerecord.setAttribute(TaxGroupStr, taxTrans.TaxItemGroup);
            xmllinerecord.setAttribute(TaxCodeStr, taxTrans.TaxCode);
            xmllinerecord.setAttribute(PercentageStr, num2str(taxTrans.TaxValue, 5, 3, 1, 0));
            xmllinerecord.setAttribute(AmountStr, num2str(taxAmount, 5, 3, 1, 0));
            xmlLineRecord.setAttribute(AmountRefundedStr, num2Str(RetailTransactionServiceOrders::getTaxAmountRefunded(custInvoiceTrans.RecId, taxTrans.TaxCode), 5, 3, 1, 0));
            xmllinerecord.setAttribute(IsIncludedInPriceStr, enum2Str(RetailTransactionServiceOrders::getOrderTaxIncludeStatus(_salesId, taxTrans)));

            xmlLineTaxs.appendChild(xmlLineRecord);
        }

        _xmlItem.appendChild(xmlLineTaxs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountRefunded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets how much tax has already been refunded for a specific invoice line.
    /// </summary>
    /// <param name="_taxCode">
    /// The tax code for the tax that is on the original invoice sales line.
    /// </param>
    /// <param name="_custInvoiceTransRecId">
    /// The recid for the original invoice line.
    /// </param>
    /// <remarks>
    /// The logic in the query is as follows:
    /// 1. Given the original invoice line, find the return sales lines against that invoice line using the InventTransId and InventTransIdReturn
    /// 2. After finding all the return sales lines against the invoice line, find the tax information for those return sales lines
    /// 3. Use the InventTransId for the return sales lines and join with TaxTrans to find the specific tax information and filter by TaxCode
    /// </remarks>
    private static real getTaxAmountRefunded(RecId _custInvoiceTransRecId, TaxCode _taxCode)
    {
        TaxTrans                returnedTaxTrans;
        CustInvoiceTrans        returnedCustInvoiceTrans;
        SalesLine               salesLineReturn;
        real                    taxAmount = 0;

        // Get the InventTransId for the original invoice line.
        select InventTransId
            from returnedCustInvoiceTrans
                where returnedCustInvoiceTrans.RecId == _custInvoiceTransRecId;

        // Find all InventTransIds for return sales lines against the original invoice line.
        while select InventTransId
            from salesLineReturn
                where salesLineReturn.InventTransIdReturn == returnedCustInvoiceTrans.InventTransId
        {
            // Getting sum of how much tax has already been refunded for a particular invoice line and taxCode
            select sum(TaxAmount)
                from returnedTaxTrans
                    where returnedTaxTrans.SourceTableId == tableNum(CustInvoiceTrans)
                        && returnedTaxTrans.TaxCode == _taxCode
                        && returnedTaxTrans.InventTransId == salesLineReturn.InventTransId;

            taxAmount += returnedTaxTrans.TaxAmount;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChargeTaxLineXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds charge tax line XML for the given markupTrans recid.
    /// </summary>
    /// <param name="_xmlDoc">
    /// Parent XML document.
    /// </param>
    /// <param name="_chargeXml">
    /// Parent XML node the charge Line tax XML will be added to.
    /// </param>
    /// <param name="_markupTrans">
    /// The markup trans.
    /// </param>
    /// <param name="_salesId">
    /// Sales Order Id.
    /// </param>
    /// <param name="_headerCharge">
    /// Identifier for if charge is for header or line.
    /// </param>
    private static void addChargeTaxLineXml(XmlDocument _xmlDoc, XmlElement _chargeXml, MarkupTrans _markupTrans, SalesId _salesId, RecId _transRecId, RecId _transTableRecId, boolean _headerCharge)
    {
        const str TaxLinesStr = 'TaxLines';
        const str TaxLineStr = 'TaxLine';
        const str IsIncludedInPriceStr = 'IsIncludedInPrice';

        TaxTrans    taxTrans;
        MarkupTrans markupTrans;

        XmlElement xmlLineTaxes, xmlLineRecord;

        xmlLineTaxes = _xmlDoc.createElement(TaxLinesStr);

        while select sum(TaxAmount), sum(TaxBaseAmount), TaxCode, TaxItemGroup, TaxValue from taxTrans
            group by TaxCode, TaxItemGroup, TaxValue
                where taxTrans.SourceTableId == tableNum(MarkupTrans)
                    && taxTrans.ExemptTax != NoYes::Yes
            join RecId from markupTrans
                where markupTrans.TransRecId == _transRecId
                    && markupTrans.TransTableId == _transTableRecId
                    && markupTrans.MarkupCode == _markupTrans.MarkupCode
                    && markupTrans.ModuleType == _markupTrans.ModuleType
                    && markupTrans.TaxGroup == _markupTrans.TaxGroup
                    && markupTrans.TaxItemGroup == _markupTrans.TaxItemGroup
                    && markupTrans.RecId == taxTrans.SourceRecId
        {
            xmllinerecord = _xmlDoc.createElement(TaxLineStr);
            xmllinerecord.setAttribute(TaxBaseAmountStr, num2str(taxTrans.TaxBaseAmount, 5, 3, 1, 0));
            xmllinerecord.setAttribute(TaxGroupStr, taxTrans.TaxItemGroup);
            xmllinerecord.setAttribute(TaxCodeStr, taxTrans.TaxCode);
            xmllinerecord.setAttribute(PercentageStr, num2str(taxTrans.TaxValue, 5, 3, 1, 0));
            xmllinerecord.setAttribute(AmountStr, num2str(taxTrans.TaxAmount, 5, 3, 1, 0));
            xmllinerecord.setAttribute(IsIncludedInPriceStr, enum2Str(RetailTransactionServiceOrders::getOrderTaxIncludeStatus(_salesId, taxTrans)));

            if (_headerCharge)
            {
                xmllinerecord.setAttribute(AmountRefundedStr, num2Str(RetailTransactionServiceOrders::getHeaderChargeTaxAmountRefunded(_markupTrans, _salesId, taxTrans.TaxCode), 5, 3, 1, 0));
            }
            else
            {
                xmllinerecord.setAttribute(AmountRefundedStr, num2Str(RetailTransactionServiceOrders::getLineChargeTaxAmountRefunded(_markupTrans, _salesId, taxTrans.TaxCode), 5, 3, 1, 0));
            }

            xmlLineTaxes.appendChild(xmlLineRecord);
        }

        _chargeXml.appendChild(xmlLineTaxes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderChargeTaxAmountRefunded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets how much tax has already been refunded for a specific header charge tax code.
    /// </summary>
    /// <param name="_markupTrans">
    /// The original markup trans.
    /// </param
    /// <param name="_salesId">
    /// The transaction sales id.
    /// </param
    /// <param name="_taxCode">
    /// The tax code for the tax that is on the original invoice sales line.
    /// </param>
    /// <remarks>
    /// The logic in the query is as follows:
    /// 1. Given the original sales id, find the return sales ids and their invoices using the InventTransId and InventTransIdReturn
    /// 2. After finding all the return header invoices (custInvoiceJours) against the original salesId, find the return charge information
    /// 3. Use the SourceTableId for the return charges and join with TaxTrans to find the specific tax information and filter by TaxCode
    /// </remarks>
    private static real getHeaderChargeTaxAmountRefunded(MarkupTrans _markupTrans, SalesId _salesId, TaxCode _taxCode)
    {
        TaxTrans                returnedTaxTrans;
        InventTransOrigin       inventTransOrigin;
        SalesLine               salesLineReturn;
        CustInvoiceJour         custInvoiceJour;
        MarkUpTrans             returnedMarkupTrans;

        if (_salesId != '')
        {
            // Getting sum of how much tax has already been refunded for a particular header charge and taxCode
            select sum(TaxAmount)
                from returnedTaxTrans
                    where returnedTaxTrans.SourceTableId == tableNum(MarkupTrans)
                        && returnedTaxTrans.TaxCode == _taxCode
                exists join returnedMarkupTrans
                    where returnedMarkupTrans.MarkupCode == _markupTrans.markupCode
                        && returnedMarkupTrans.ModuleType == _markupTrans.ModuleType
                        && returnedMarkupTrans.TaxGroup == _markupTrans.TaxGroup
                        && returnedMarkupTrans.TaxItemGroup == _markupTrans.TaxItemGroup
                        && returnedMarkupTrans.TransTableId == tableNum(CustInvoiceJour)
                        && returnedMarkupTrans.RecId == returnedTaxTrans.SourceRecId
                exists join custInvoiceJour
                    where custInvoiceJour.RecId == returnedMarkupTrans.TransRecId
                exists join salesLineReturn
                    where salesLineReturn.SalesId == custInvoiceJour.SalesId
                exists join inventTransOrigin
                    where inventTransOrigin.InventTransId == salesLineReturn.InventTransIdReturn
                        && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                        && inventTransOrigin.ReferenceId == _salesId;
        }

        return returnedTaxTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineChargeTaxAmountRefunded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets how much tax has already been refunded for a specific line charge tax code.
    /// </summary>
    /// <param name="_markupTrans">
    /// The original markup trans.
    /// </param
    /// <param name="_salesId">
    /// The transaction sales id.
    /// </param
    /// <param name="_taxCode">
    /// The tax code for the tax that is on the original invoice sales line.
    /// </param>
    /// <remarks>
    /// The logic in the query is as follows:
    /// 1. Given the original sales id, find the return sales ids and their invoices using the InventTransId and InventTransIdReturn
    /// 2. After finding all the return line invoices (custInvoiceTrans) against the original salesId, find the return charge information
    /// 3. Use the SourceTableId for the return charges and join with TaxTrans to find the specific tax information and filter by TaxCode
    /// </remarks>
    private static real getLineChargeTaxAmountRefunded(MarkupTrans _markupTrans, SalesId _salesId, TaxCode _taxCode)
    {
        TaxTrans                returnedTaxTrans;
        InventTransOrigin       inventTransOrigin;
        SalesLine               salesLineReturn;
        CustInvoiceTrans        custInvoiceTrans;
        MarkUpTrans             returnedMarkupTrans;

        if (_salesId != '')
        {
            // Getting sum of how much tax has already been refunded for a particular line charge and taxCode
            select sum(TaxAmount)
                from returnedTaxTrans
                    where returnedTaxTrans.SourceTableId == tableNum(MarkupTrans)
                        && returnedTaxTrans.TaxCode == _taxCode
                exists join returnedMarkupTrans
                    where returnedMarkupTrans.MarkupCode == _markupTrans.markupCode
                        && returnedMarkupTrans.ModuleType == _markupTrans.ModuleType
                        && returnedMarkupTrans.TaxGroup == _markupTrans.TaxGroup
                        && returnedMarkupTrans.TaxItemGroup == _markupTrans.TaxItemGroup
                        && returnedMarkupTrans.TransTableId == tableNum(CustInvoiceTrans)
                        && returnedMarkupTrans.RecId == returnedTaxTrans.SourceRecId
                exists join custInvoiceTrans
                    where custInvoiceTrans.RecId == returnedMarkupTrans.TransRecId
                exists join salesLineReturn
                    where salesLineReturn.SalesId == custInvoiceTrans.SalesId
                exists join inventTransOrigin
                    where inventTransOrigin.InventTransId == salesLineReturn.InventTransIdReturn
                        && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                        && inventTransOrigin.ReferenceId == _salesId;
        }

        return returnedTaxTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderTaxIncludeStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether the order with given sales id is prices include sales tax.
    /// </summary>
    /// <param name="_salesId">
    /// The sales Id for the order.
    /// </param>
    /// <param name="_taxTrans">
    /// TaxTransaction relevant to the sales Line or charge Line.
    /// </param>
    /// <returns>Whether the order with given sales id is prices include sales tax.</returns>
    /// <remarks>
    /// TaxTrans buffer has value in field TaxCode, TaxItemGroup, TaxValue.
    /// </remarks>
    protected static boolean getOrderTaxIncludeStatus(SalesIdBase _salesId, TaxTrans _taxTrans)
    {
        SalesTable salesTable;
        boolean inclTax = false;

        if (_salesId != null)
        {
            select firstonly InclTax from salesTable
                   where salesTable.Salesid == _salesId;

            inclTax = salesTable.InclTax;
        }

        return inclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineDeliveryModesForShipping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line delivery modes for shipping.
    /// </summary>
    /// <param name = "xmlArgumentString">
    /// The XML document containing the criteria for getting delivery modes.
    /// </param>
    /// <returns>
    /// XML string with the sales line identifier and delivery modes.
    /// </returns>
    public static container getLineDeliveryModesForShipping(str xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getLineDeliveryModes(xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllDeliveryModes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all line delivery modes.
    /// </summary>
    /// <param name = "xmlArgumentString">
    /// The XML document containing the criteria for getting delivery modes.
    /// </param>
    /// <returns>
    /// XML string with the sales line identifier and delivery modes.
    /// </returns>
    public static container getAllDeliveryModes(str xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getLineDeliveryModes(xmlArgumentString, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineDeliveryModes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line delivery modes based on parameter _shippingDeliveryModesOnly.
    /// </summary>
    /// <param name = "xmlArgumentString">
    /// The XML document containing the criteria for getting delivery modes.
    /// </param>
    /// <param name = "_shippingDeliveryModesOnly">
    /// A boolean specifying if the method should return all delivery modes or only delivery modes for shipping.
    /// </param>
    /// <returns>
    /// If _shippingDeliveryModesOnly is true, XML string with the sales line identifier and delivery modes for Shipping.
    /// If _shippingDeliveryModesOnly is false, XML string with the sales line identifier and all delivery modes.
    /// </returns>
    private static container getLineDeliveryModes(str xmlArgumentString = '', boolean _shippingDeliveryModesOnly = true)
    {
        str channelId;
        RetailOriginId originId;
        str salesLineId;
        ItemId itemId;
        InventDimId inventDimId;
        LogisticsAddressCountryRegionId countryRegionId;
        LogisticsAddressStateId state;
        Query q;
        QueryRun qr;
        XmlDocument xmlDoc;
        XmlElement xmlRoot;
        List salesOrderXmlList = new List(Types::Class);
        XmlDocument argsXml;
        XmlElement argsRoot;
        XmlElement xmlRecord, xmlChildRecordRoot, xmlChildRecord, xmlSalesLineDeliveryOption, xmlDeliveryOptions;
        XmlNodeList xmlSalesLinesList;
        DlvMode dlvMode;
        str error = '';
        boolean success = false;
        int fromLine;

        // Output xml.
        xmlDoc =  RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        xmlRoot = xmlDoc.createElement('ArrayOfSalesLineDeliveryOption');
        xmlRoot.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

        // Validate argument passed.
        if (xmlArgumentString == null || xmlArgumentString == '')
        {
            error = "@Retail:InvalidFunctionParameter";
            success = false;
            return [success, error, xmlDoc.toString()];
        }

        try
        {
            // Parse the arguments
            argsXml = new XmlDocument();
            argsXml.loadXml(xmlArgumentString);

            if (argsXml != null)
            {
                fromLine = Global::infologLine();

                argsRoot = argsXml.documentElement().getNamedElement('GetLineDeliveryOptionsCriteria');

                // Load the sales lines.
                if (argsRoot != null)
                {
                    xmlSalesLinesList = argsRoot.childNodes();
                }

                if (xmlSalesLinesList != null && xmlSalesLinesList.length() > 0)
                {
                    RetailParameters rp = RetailParameters::find();

                    for (int i = 0; i < xmlSalesLinesList.length(); i++)
                    {
                        xmlRecord = xmlSalesLinesList.item(i);
                        channelId = xmlRecord.getAttribute('ChannelId');
                        originId = str2Int64(channelId);
                        salesLineId = xmlRecord.getAttribute('SalesLineId');
                        itemId = xmlRecord.getAttribute('ItemId');
                        inventDimId = xmlRecord.getAttribute('InventDimId');
                        countryRegionId = xmlRecord.getAttribute('ThreeLetterISORegionName');
                        state = xmlRecord.getAttribute('State');
                        RetailChannelTable rct = RetailChannelTable::findByRecId(originId);

                        xmlSalesLineDeliveryOption = xmlDoc.createElement('SalesLineDeliveryOption');
                        xmlChildRecord = xmlDoc.createElement('SalesLineId');
                        xmlChildRecord.innerText(salesLineId);
                        xmlSalesLineDeliveryOption.appendChild(xmlChildRecord);
                        xmlDeliveryOptions = xmlDoc.createElement('DeliveryOptions');

                        // Get valid query to get the delivery modes.
                        q = RetailShippingDeliveryMode::GetValidDlvModeQuery(
                            originId,
                            itemId,
                            inventDimId,
                            countryRegionId,
                            state);
                        qr = new QueryRun(q);

                        // For each result create xml elements to be returned as output.
                        while (qr.next())
                        {
                            dlvMode = qr.get(tableNum(DlvMode));

                            if (_shippingDeliveryModesOnly && rp.ShowOnlyCarrierOptionsForShipOrders == NoYes::Yes && rct.ChannelType == RetailChannelType::RetailStore)
                            {
                                if (dlvMode.Code == rp.CarryOutDeliveryModeCode ||
                                    RetailDlvMode::isPickupDeliveryMode(dlvMode.Code) ||
                                    dlvMode.Code == rp.ElectronicDeliveryModeCode)
                                    continue;
                            }

                            xmlChildRecordRoot = xmlDoc.createElement('DeliveryOption');

                            xmlChildRecord = xmlDoc.createElement('RecordId');
                            xmlChildRecord.innerText(int642Str(dlvMode.RecId));
                            xmlChildRecordRoot.appendChild(xmlChildRecord);

                            xmlChildRecord = xmlDoc.createElement('Code');
                            xmlChildRecord.innerText(dlvMode.Code);
                            xmlChildRecordRoot.appendChild(xmlChildRecord);

                            xmlChildRecord = xmlDoc.createElement('Description');
                            xmlChildRecord.innerText(dlvMode.Txt);
                            xmlChildRecordRoot.appendChild(xmlChildRecord);

                            xmlChildRecord = xmlDoc.createElement('ChargeGroup');
                            xmlChildRecord.innerText(dlvMode.MarkupGroup);
                            xmlChildRecordRoot.appendChild(xmlChildRecord);

                            xmlDeliveryOptions.appendChild(xmlChildRecordRoot);
                        }

                        xmlSalesLineDeliveryOption.appendChild(xmlDeliveryOptions);
                        xmlRoot.appendChild(xmlSalesLineDeliveryOption);
                    }

                    xmlDoc.appendChild(xmlRoot);
                    success = true;
                }
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmlDoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPriceLineXml</Name>
				<Source><![CDATA[
    private static void addPriceLineXml(XmlDocument _xmlDoc, XmlElement _xmlItem, Common _salesPurchLine, boolean _fromQuote)
    {
        RetailSalesPriceAdjustmentLineMap retailSalesPriceAdjustmentLineMap;

        if (_fromQuote)
        {
            RetailSalesQuotationPriceAdjustmentLine adjustmentLine;
            retailSalesPriceAdjustmentLineMap = adjustmentLine;
        }
        else
        {
            RetailSalesPriceAdjustmentLine adjustmentLine;
            retailSalesPriceAdjustmentLineMap = adjustmentLine;
        }

        InventTransId inventTransId = _fromQuote ? (_salesPurchLine as SalesQuotationLine).InventTransId : (_salesPurchLine as SalesLine).InventTransId;
        XmlElement xmlLinePrices, xmlLineRecord;
        xmlLinePrices = _xmlDoc.createElement(RetailTransactionTransformerHelper::getPricesStr());

        while select RetailPeriodicDiscountLineRefRecId, Amount from retailSalesPriceAdjustmentLineMap
            where retailSalesPriceAdjustmentLineMap.InventTransId == inventTransId
        {
            xmlLineRecord = _xmlDoc.createElement(RetailTransactionTransformerHelper::getPriceStr());
            xmlLineRecord.setAttribute(RetailTransactionTransformerHelper::getPriceTypeStr(), any2Str(PriceLineType::PriceAdjustmentPriceLine));
            xmlLineRecord.setAttribute(RetailTransactionTransformerHelper::getRecordIdStr(), int642Str(retailSalesPriceAdjustmentLineMap.RetailPeriodicDiscountLineRefRecId));
            xmlLineRecord.setAttribute(RetailTransactionTransformerHelper::getValueStr(), RetailTransactionServiceUtilities::realToString(retailSalesPriceAdjustmentLineMap.Amount));
            xmlLinePrices.appendChild(xmlLineRecord);
        }

        xmlLinePrices = RetailTransactionServiceOrders::addGUPPriceLineXml(_xmlDoc, _salesPurchLine, _fromQuote, xmlLinePrices);
        _xmlItem.appendChild(xmlLinePrices);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGUPPriceLineXml</Name>
				<Source><![CDATA[
    internal protected static XmlElement addGUPPriceLineXml(XmlDocument _xmlDoc, Common _salesPurchLine, boolean _fromQuote, XmlElement _xmlLinePrices)
    {
        return _xmlLinePrices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDiscountLineXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Sales Discount Line XML for the given SalesLine InventTransId
    /// </summary>
    /// <param name="_xmlDoc">
    /// Parent XML document.
    /// </param>
    /// <param name="_xmlItem">
    /// Parent XML node the Discount Line XML will be added to.
    /// </param>
    /// <param name="_inventTrans">
    /// InventTransId of the sales line.
    /// </param>
    /// <param name="_quantity">
    /// Quantity of the sales line.
    /// </param>
    /// <param name="_unitLineDiscount">
    /// Unit line discount.
    /// </param>
    /// <param name="_fromQuote">
    /// True if the discount lines are from a Quote, False if they are from a Sales Order.
    /// </param>
    /// <param name="_factorForEffectiveAmount">
    /// The factor for effective amount.
    /// </param>
    /// <remarks>
    /// Gets XML representing the associated SalesDiscountLines for the given SalesLine and adds them to the given Item xml node.
    /// </remarks>
    private static void addDiscountLineXml(XmlDocument _xmlDoc, XmlElement _xmlItem, SalesPurchLineInterface _salesPurchLineInterface, boolean _fromQuote, Percent _factorForEffectiveAmount = 1)
    {
        RetailSalesDiscountLine retailSalesDiscountLine;
        RetailSalesQuotationDiscountLine retailSalesQuoteDiscountLine;
        RetailPeriodicDiscount retailDiscount;
        XmlElement xmlLineDiscounts, xmlLineRecord;

        boolean hasDiscountLines = false;

        void fillSalesOrderDiscountLine()
        {
            DiscAmount effectiveAmount;
            DiscAmount discountAmount;

            // Backfill discount amount for R2 customer orders.
            discountAmount = retailSalesDiscountLine.DiscountAmount;

            effectiveAmount = retailSalesDiscountLine.Amount * _factorForEffectiveAmount;
            if (!discountAmount && !retailSalesDiscountLine.Percentage)
            {
                discountAmount = _salesPurchLineInterface.parmQty() ? effectiveAmount / _salesPurchLineInterface.parmQty() : 0;
            }

            xmlLineRecord = _xmlDoc.createElement(#Discount);

            xmlLineRecord.setAttribute(AmountStr, num2str(effectiveAmount,5,3,1,0));
            xmlLineRecord.setAttribute(#OfferName, retailDiscount.Name);
            xmlLineRecord.setAttribute(#DiscountAmount, num2str(discountAmount,5,3,1,0));
            xmlLineRecord = RetailTransactionServiceOrders::setAttributeForDiscountXmlRecord(xmlLineRecord, retailSalesDiscountLine);
            xmlLineDiscounts.appendChild(xmlLineRecord);
        }

        //Get line level discount info
        xmlLineDiscounts = _xmlDoc.createElement(#Discounts);

        if (_fromQuote)
        {
            while select Amount, DiscountOriginType, CustomerDiscountType, DiscountCode, ManualDiscountType, PeriodicDiscountOfferId, Percentage, DiscountAmount, DealPrice, BundleId from retailSalesQuoteDiscountLine
                    where retailSalesQuoteDiscountLine.InventTransId == _salesPurchLineInterface.parmInventTransId()
                outer join Name from retailDiscount
                    where retailSalesQuoteDiscountLine.PeriodicDiscountOfferId
                        && retailDiscount.OfferId == retailSalesQuoteDiscountLine.PeriodicDiscountOfferId
            {
                xmlLineRecord = _xmlDoc.createElement(#Discount);

                xmlLineRecord.setAttribute(AmountStr, num2str(retailSalesQuoteDiscountLine.Amount,5,3,1,0));
                xmlLineRecord.setAttribute(#OfferName, retailDiscount.Name);
                xmlLineRecord.setAttribute(#DiscountAmount, num2str(retailSalesQuoteDiscountLine.DiscountAmount,5,3,1,0));
                xmlLineRecord = RetailTransactionServiceOrders::setAttributeForDiscountXmlRecord(xmlLineRecord, retailSalesQuoteDiscountLine);
                xmlLineDiscounts.appendChild(xmlLineRecord);
            }
        }
        else
        {
            while select Amount, DiscountOriginType, CustomerDiscountType, DiscountCode, ManualDiscountType, PeriodicDiscountOfferId, Percentage, DiscountAmount, DealPrice, BundleId from retailSalesDiscountLine
                    where retailSalesDiscountLine.InventTransId == _salesPurchLineInterface.parmInventTransId()
                outer join Name from retailDiscount
                    where retailSalesDiscountLine.PeriodicDiscountOfferId
                        && retailDiscount.OfferId == retailSalesDiscountLine.PeriodicDiscountOfferId
            {
                fillSalesOrderDiscountLine();

                hasDiscountLines = true;
            }

            // This is to handle non Retail Sales order or quotation.
            if ((_salesPurchLineInterface.parmLineDiscAmount() || _salesPurchLineInterface.parmLineDiscPercent()) && !hasDiscountLines)
            {
                retailSalesDiscountLine.clear();
                retailSalesDiscountLine.initValue();
                retailSalesDiscountLine.InventTransId = _salesPurchLineInterface.parmInventTransId();
                retailSalesDiscountLine.DiscountOriginType = RetailDiscountOriginType::Customer;
                retailSalesDiscountLine.CustomerDiscountType = RetailCustomerDiscountType::Line;

                PriceUnit priceUnit = _salesPurchLineInterface.parmPriceUnit() == 0 ? 1 : _salesPurchLineInterface.parmPriceUnit();
                retailSalesDiscountLine.Amount = CurrencyExchange::round(
                    _salesPurchLineInterface.parmPrice() * _salesPurchLineInterface.parmQty() / priceUnit - _salesPurchLineInterface.parmLineAmount(),
                    _salesPurchLineInterface.parmCurrencyCode());
                retailSalesDiscountLine.DiscountAmount =  CurrencyExchange::round(
                    retailSalesDiscountLine.Amount / _salesPurchLineInterface.parmQty(),
                    _salesPurchLineInterface.parmCurrencyCode());

                fillSalesOrderDiscountLine();
            }
        }

        _xmlItem.appendChild(xmlLineDiscounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAttributeForDiscountXmlRecord</Name>
				<Source><![CDATA[
    internal protected static XmlElement setAttributeForDiscountXmlRecord(XmlElement _xmlLineRecord, RetailSalesQuotesDiscountLineMap _retailSalesQuotesDiscountLineMap)
    {
        _xmlLineRecord.setAttribute(#DiscountOriginType, int2str(_retailSalesQuotesDiscountLineMap.DiscountOriginType));
        _xmlLineRecord.setAttribute(#CustomerDiscountType, int2str(_retailSalesQuotesDiscountLineMap.CustomerDiscountType));
        _xmlLineRecord.setAttribute(#DiscountCode, _retailSalesQuotesDiscountLineMap.DiscountCode);
        _xmlLineRecord.setAttribute(#ManualDiscountType, int2str(_retailSalesQuotesDiscountLineMap.ManualDiscountType));
        _xmlLineRecord.setAttribute(#PeriodicDiscountOfferId, _retailSalesQuotesDiscountLineMap.PeriodicDiscountOfferId);
        _xmlLineRecord.setAttribute(#DealPrice, num2str(_retailSalesQuotesDiscountLineMap.DealPrice,5,3,1,0));
        _xmlLineRecord.setAttribute(PercentageStr, num2str(_retailSalesQuotesDiscountLineMap.Percentage,5,3,1,0));
        _xmlLineRecord.setAttribute(BundleIdColumn, int2str(_retailSalesQuotesDiscountLineMap.BundleId));
        return _xmlLineRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddAuthorizedPaymentsXmlCallCenter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the payment information for the authorized transactions related to a call center sale order.
    /// </summary>
    /// <param name="_xmlRoot"> Individual sales order root. </param>
    /// <param name="_xmlPayments"> Parent of the Payment elemet to be added. </param>
    /// <param name="_salesTable"> The sales order. </param>
    /// <returns> True if valid authorization was found and to _xmlPayments. </returns>
    private static boolean AddAuthorizedPaymentsXmlCallCenter(XmlElement _xmlRoot, XmlElement _xmlPayments, SalesTable _salesTable)
    {
        str cardPaymentAccountId;
        MCRCustPaymTable mCRCustPaymTable;
        CreditCardCust creditCardCust;
        CreditCardAuthTrans creditCardAuthTrans;
        boolean validAuthorizationFound = false;

        while select
                    LineNum,
                    TenderTypeId,
                    CardTypeId,
                    CurrencyCode,
                    IsPrepay,
                    IsCreditCardProcessed,
                    Amount,
                    PostedAmount,
                    PaymInfoRecId,
                    RecId,
                    Channel
                from mCRCustPaymTable
                order by mCRCustPaymTable.LineNum
                where
                    mCRCustPaymTable.RefTableId == _salesTable.TableId &&
                    mCRCustPaymTable.RefRecId == _salesTable.RecId &&
                    mCRCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard &&
                    (
                        mCRCustPaymTable.Status == MCRCustPaymStatus::Authorized ||
                        (
                            mCRCustPaymTable.Status == MCRCustPaymStatus::Paid &&
                            ((mCRCustPaymTable.Amount - mCRCustPaymTable.PostedAmount) != 0)
                        )
                    )
                join CardToken, ExpiryDate from creditCardCust
                where
                    creditCardCust.RecId == mCRCustPaymTable.PaymInfoRecId
                join CardTokenRequest, CardTokenResult, ProcessorStatus, Authorization from creditCardAuthTrans
                    where
                    creditCardAuthTrans.MCRPaymRecId == mCRCustPaymTable.RecId &&
                    creditCardAuthTrans.SalesId == _salesTable.SalesId &&
                    creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                    creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                    creditCardAuthTrans.ApprovalVoid == NoYes::No &&
                    creditCardAuthTrans.ApprovalExpired == NoYes::No
        {
            // Exclude authorizations from expired cards
            if (!CreditCard::checkExpireDate(creditCardCust.ExpiryDate))
            {
                continue;
            }

            validAuthorizationFound = true;

            // Get service account identifier from the authorization.
            cardPaymentAccountId = CreditCardAuthTrans::getServiceAccountIdFromCardTokenResult(creditCardAuthTrans);

            // Create the Payment Info xml element
            XmlElement paymentInfoXmlRecord = _xmlPayments.ownerDocument().createElement('Payment');

            // Add payment properties as xml attributes
            paymentInfoXmlRecord.setAttribute('PaymentType', mCRCustPaymTable.TenderTypeId);
            paymentInfoXmlRecord.setAttribute('CardType', mCRCustPaymTable.CardTypeId);
            paymentInfoXmlRecord.setAttribute('Amount', '0');
            paymentInfoXmlRecord.setAttribute('Currency', mCRCustPaymTable.CurrencyCode);
            paymentInfoXmlRecord.setAttribute('Prepayment', int2str(enum2int(mCRCustPaymTable.IsPrepay)));
            paymentInfoXmlRecord.setAttribute('CreditCardProcessorStatusValue', int2str(enum2int(creditCardAuthTrans.ProcessorStatus)));
            paymentInfoXmlRecord.setAttribute('PaymentCaptured', int2str(enum2int(NoYes::No)));
            paymentInfoXmlRecord.setAttribute('AuthorizedAmount', num2str(mCRCustPaymTable.getUnpostedAmount(),5,3,1,0));
            paymentInfoXmlRecord.setAttribute('PaymentRefRecId', int642str(mCRCustPaymTable.RecId));
            paymentInfoXmlRecord.setAttribute('CardPaymentAccountId', cardPaymentAccountId);
            paymentInfoXmlRecord.setAttribute('LineNum', RetailTransactionServiceUtilities::lineNumToString(mCRCustPaymTable.LineNum));
            paymentInfoXmlRecord.setAttribute('PaymentStatusValue', int2str(enum2int(RetailTenderLineStatus::PendingCommit)));
            paymentInfoXmlRecord.setAttribute('ChannelRecordId', int642str(mCRCustPaymTable.Channel));
            paymentInfoXmlRecord.setAttribute('AuthorizationReferenceId', creditCardAuthTrans.Authorization);

            // Add incremetal capture properties
            if (RetailIncrementalCaptureFeatureExposure::isEnabled() && creditCardAuthTrans.CardTokenResult != '')
            {
                CreditCardPaymentProperties creditCardAuthorizationResponseProperties = CreditCardPaymentProperties::fromXmlString(creditCardAuthTrans.CardTokenResult);
                CreditCardPaymentProperty SupportsMultipleCaptures = creditCardAuthorizationResponseProperties.find(RetailConst.GenericNamespace::get_AuthorizationResponse(),
                        RetailConst.AuthorizationResponseProperties::get_SupportsMultipleCaptures());

                if (SupportsMultipleCaptures != null && SupportsMultipleCaptures.parmStringValue() != '' && strLwr(SupportsMultipleCaptures.parmStringValue()) == 'true')
                {
                    paymentInfoXmlRecord.setAttribute('IsIncrementalCaptureEnabled', 'true');

                    CreditCardPaymentProperty isReAuthorizationSupported = creditCardAuthorizationResponseProperties.find(RetailConst.GenericNamespace::get_AuthorizationResponse(),
                        RetailConst.AuthorizationResponseProperties::get_IsReauthorizationSupported());

                    if (isReAuthorizationSupported != null && isReAuthorizationSupported.parmStringValue() != '' && strLwr(isReAuthorizationSupported.parmStringValue()) == 'true')
                    {
                        paymentInfoXmlRecord.setAttribute('IsReAuthorizationEnabled', 'true');
                    }
                }
            }

            // Add tokens as xml elements
            XmlElement cardTokenXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardToken');
            cardTokenXmlRecord.innerText(creditCardCust.CardToken);
            XmlElement cardAuthorizationXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardAuthorization');
            cardAuthorizationXmlRecord.innerText(creditCardAuthTrans.CardTokenResult);
            paymentInfoXmlRecord.appendChild(cardTokenXmlRecord);
            paymentInfoXmlRecord.appendChild(cardAuthorizationXmlRecord);

            // Add Payment Info to Payment Info collection
            _xmlPayments.appendChild(paymentInfoXmlRecord);

            // Log - Add Call center authorization to XML
            eventSource.EventWriteOrdersAddAuthorizedPaymentsXmlCallCenterMessage_V2(funcName(), mCRCustPaymTable.RecId, creditCardAuthTrans.RecId, _salesTable.RecId);
        }

        return validAuthorizationFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddAuthorizedPaymentsXmlNonCallCenter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the payment information for the authorized transactions related to a non-call center sale order.
    /// </summary>
    /// <param name="_xmlRoot"> Individual sales order root. </param>
    /// <param name="_xmlPayments"> Parent of the Payment elemet to be added. </param>
    /// <param name="_salesTable"> The sales order. </param>
    /// <param name="_retailChannelTable"> The Retail Channel Table of the order. </param>
    /// <returns><c>True</c> if valid payments were found; <c>false</c> otherwise.</returns>
    private static boolean AddAuthorizedPaymentsXmlNonCallCenter(XmlElement _xmlRoot, XmlElement _xmlPayments, SalesTable _salesTable, RetailChannelTable _retailChannelTable)
    {
        str cardPaymentAccountId;
        str authCardTypeId;
        CreditCardCust creditCardCust;
        CreditCardAuthTrans creditCardAuthTrans;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable, defaultRetailStoreTenderTypeTable, authTenderTypeTable;
        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable, defaultRetailStoreTenderTypeCardTable;
        RetailSalesTable retailSalesTable = _salesTable.retailSalesTable();
        boolean validAuthorizationFound = false;

        // Find matching tender type and card type for the store based on information in the sales order.
        // Transaction TenderType/CardType
        select firstonly TenderTypeId from retailStoreTenderTypeTable
          where retailStoreTenderTypeTable.Channel == retailSalesTable.RetailChannel &&
                retailStoreTenderTypeTable.tenderTypeId == retailSalesTable.CreditCardTenderTypeId
          join cardTypeId from retailStoreTenderTypeCardTable
                where retailStoreTenderTypeCardTable.Channel == retailSalesTable.RetailChannel &&
                      retailStoreTenderTypeCardTable.tenderTypeId == retailStoreTenderTypeTable.TenderTypeId &&
                      retailStoreTenderTypeCardTable.cardTypeId == retailSalesTable.CreditCardTypeId;

        while
            // Select authorizations for the Sales Order
            select CreditCardTypeName, CurrencyCode, CardTokenRequest, CardTokenResult, ApprovalAmountCur, ProcessorStatus, RecId, LineNum
            from creditCardAuthTrans
                where creditCardAuthTrans.SalesId == _salesTable.SalesId &&
                      creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                      creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                      creditCardAuthTrans.ApprovalVoid == NoYes::No &&
                      creditCardAuthTrans.ApprovalExpired == NoYes::No
                // CardToken from the creditCardCust attached to Sales Table
                join CardToken, ExpiryDate from creditCardCust
                    where creditCardCust.RecId == _salesTable.CreditCardCustRefId
        {
            // Exclude authorizations from expired cards
            if (!CreditCard::checkExpireDate(creditCardCust.ExpiryDate))
            {
                continue;
            }

            // Resolve TenderType and cardType.
            // First look into RetailSalesTable using the outer join. If not defined, use the second outer join to bring default TenderType/CardType
            // In case TenderType/CardType can't be resolved, skip authorization without adding it to CustOrderInfoXML
            if (retailStoreTenderTypeTable && retailStoreTenderTypeCardTable)
            {
                authTenderTypeTable = retailStoreTenderTypeTable;
                authCardTypeId = retailStoreTenderTypeCardTable.cardTypeId;
            }
            // If not found, find a tender type for the store that has Pay card operation and matches the card type
            else if (retailStoreTenderTypeTable.tenderTypeId == '')
            {
                // Default TenderType from the store and cardType from creditcardcust
                select firstonly TenderTypeId from defaultRetailStoreTenderTypeTable
                  where defaultRetailStoreTenderTypeTable.Channel == retailSalesTable.RetailChannel &&
                        defaultRetailStoreTenderTypeTable.posOperation == POSOperationPayCard
                  join cardTypeId from defaultRetailStoreTenderTypeCardTable
                       where defaultRetailStoreTenderTypeCardTable.tenderTypeId == defaultRetailStoreTenderTypeTable.tenderTypeId &&
                             defaultRetailStoreTenderTypeCardTable.Channel == retailSalesTable.RetailChannel &&
                             defaultRetailStoreTenderTypeCardTable.cardTypeId == creditCardCust.CreditCardTypeName;

                if (defaultRetailStoreTenderTypeTable && defaultRetailStoreTenderTypeCardTable)
                {
                    authTenderTypeTable = defaultRetailStoreTenderTypeTable;
                    authCardTypeId = defaultRetailStoreTenderTypeCardTable.cardTypeId;
                }
                else
                {
                    // Skip authorization in case tendertype/cardtype can't be resolved from both transaction
                    // and default credit card method of payment defined for the store.
                    // AUTHORIZATIONS WITH UNDEFINED TENDERTYPE/CARDTYPE WON'T BE ADDED TO CustOrderInfoXML
                    // Later on, if no authorizations were found, we will instead add the card token to be sent back to channel.
                    continue;
                }
            }

            validAuthorizationFound = true;

            // Get service account identifier from the authorization.
            cardPaymentAccountId = CreditCardAuthTrans::getServiceAccountIdFromCardTokenResult(creditCardAuthTrans);

            // Create the Payment Info xml element
            XmlElement paymentInfoXmlRecord = _xmlPayments.ownerDocument().createElement('Payment');

            // Add payment properties as xml attributes
            paymentInfoXmlRecord.setAttribute('PaymentType', authTenderTypeTable.tenderTypeId);
            paymentInfoXmlRecord.setAttribute('CardType', authCardTypeId);
            paymentInfoXmlRecord.setAttribute('Amount', '0');
            paymentInfoXmlRecord.setAttribute('Currency', creditCardAuthTrans.CurrencyCode);
            paymentInfoXmlRecord.setAttribute('Prepayment', int2str(enum2int(NoYes::No)));
            paymentInfoXmlRecord.setAttribute('PaymentCaptured', int2str(enum2int(NoYes::No)));
            paymentInfoXmlRecord.setAttribute('AuthorizedAmount', num2str(creditCardAuthTrans.ApprovalAmountCur,5,3,1,0));
            paymentInfoXmlRecord.setAttribute('PaymentRefRecId', int642str(creditCardAuthTrans.RecId));
            paymentInfoXmlRecord.setAttribute('CreditCardProcessorStatusValue', int2str(enum2int(creditCardAuthTrans.ProcessorStatus)));
            paymentInfoXmlRecord.setAttribute('CardPaymentAccountId', cardPaymentAccountId);
            paymentInfoXmlRecord.setAttribute('LineNum', RetailTransactionServiceUtilities::lineNumToString(creditCardAuthTrans.LineNum));
            paymentInfoXmlRecord.setAttribute('PaymentStatusValue', int2str(enum2int(RetailTenderLineStatus::PendingCommit)));

            // Add tokens as xml elements
            XmlElement cardTokenXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardToken');
            cardTokenXmlRecord.innerText(creditCardCust.CardToken);
            XmlElement cardAuthorizationXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardAuthorization');
            cardAuthorizationXmlRecord.innerText(creditCardAuthTrans.CardTokenResult);
            paymentInfoXmlRecord.appendChild(cardTokenXmlRecord);
            paymentInfoXmlRecord.appendChild(cardAuthorizationXmlRecord);

            // Add Payment Info to Payment Info collection
            _xmlPayments.appendChild(paymentInfoXmlRecord);

            // Log - Add Retail authorization to XML
            eventSource.EventWriteOrdersAddAuthorizedPaymentsXmlNonCallCenterMessage(funcName(), authTenderTypeTable.RecId, creditCardAuthTrans.RecId);
        }

        return validAuthorizationFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddAuthorizedPaymentsXmlCardToken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the payment information for the Credit Card Token related to a sales order.
    /// </summary>
    /// <param name="_xmlRoot"> Individual sales order root. </param>
    /// <param name="_xmlPayments"> Parent of the Payment elemet to be added. </param>
    /// <param name="_salesTable"> The sales order. </param>
    /// <param name="_retailChannelTable"> The Retail Channel Table of the order. </param>
    private static void AddAuthorizedPaymentsXmlCardToken(XmlElement _xmlRoot, XmlElement _xmlPayments, SalesTable _salesTable, RetailChannelTable _retailChannelTable)
    {
        str cardPaymentAccountId;
        str cardTokenTenderTypeId;
        str cardTokenCardTypeId;
        CreditCardCust creditCardCust;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable, defaultRetailStoreTenderTypeTable;
        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable, defaultRetailStoreTenderTypeCardTable;
        RetailSalesTable retailSalesTable = _salesTable.retailSalesTable();

        // Select card token for the Sales Order
        select CardToken, ExpiryDate from creditCardCust
            where creditCardCust.RecId == _salesTable.CreditCardCustRefId
            // Transaction TenderType/CardType
            outer join TenderTypeId from retailStoreTenderTypeTable
                where retailStoreTenderTypeTable.Channel        == retailSalesTable.RetailChannel &&
                      retailStoreTenderTypeTable.tenderTypeId   == retailSalesTable.CreditCardTenderTypeId
                outer join cardTypeId from retailStoreTenderTypeCardTable
                    where retailStoreTenderTypeCardTable.Channel        == retailSalesTable.RetailChannel &&
                          retailStoreTenderTypeCardTable.tenderTypeId   == retailStoreTenderTypeTable.TenderTypeId &&
                          retailStoreTenderTypeCardTable.cardTypeId     == retailSalesTable.CreditCardTypeId
            // Default TenderType from the store and cardType from creditcardcust
            outer join firstonly TenderTypeId from defaultRetailStoreTenderTypeTable
                    where defaultRetailStoreTenderTypeTable.Channel         == retailSalesTable.RetailChannel &&
                          defaultRetailStoreTenderTypeTable.posOperation    == POSOperationPayCard
                    outer join cardTypeId from defaultRetailStoreTenderTypeCardTable
                        where defaultRetailStoreTenderTypeCardTable.Channel         == retailSalesTable.RetailChannel &&
                              defaultRetailStoreTenderTypeCardTable.tenderTypeId    == defaultRetailStoreTenderTypeTable.tenderTypeId &&
                              defaultRetailStoreTenderTypeCardTable.cardTypeId      == creditCardCust.CreditCardTypeName;

        // If credit card attached to the sales order is not expired, add  a Payment Info
        if (creditCardCust && CreditCard::checkExpireDate(creditCardCust.ExpiryDate))
        {
            // Resolve TenderType and cardType.
            // First look into RetailSalesTable using the outer join. If not defined, use the second outer join to bring default TenderType/CardType
            // In case TenderType/CardType can't be resolved, skip authorization without adding it to CustOrderInfoXML
            if (retailStoreTenderTypeTable && retailStoreTenderTypeCardTable)
            {
                cardTokenTenderTypeId = retailStoreTenderTypeTable.tenderTypeId;
                cardTokenCardTypeId = retailStoreTenderTypeCardTable.cardTypeId;
            }
            else
            {
                // Skip adding the card token in case tendertype/cardtype can't be resolved from both transaction
                // and default credit card method of payment defined for the store.
                if (defaultRetailStoreTenderTypeTable && defaultRetailStoreTenderTypeCardTable)
                {
                    cardTokenTenderTypeId = defaultRetailStoreTenderTypeTable.tenderTypeId;
                    cardTokenCardTypeId = defaultRetailStoreTenderTypeCardTable.cardTypeId;
                }
                else
                {
                    return;
                }
            }

            // Get service account identifier from the card token.
            CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(creditCardCust.CardToken);
            cardPaymentAccountId = CreditCard::getPaymentAccountId(properties);

            // Create the Payment Info xml element
            XmlElement paymentInfoXmlRecord = _xmlPayments.ownerDocument().createElement('Payment');

            // Add payment properties as xml attributes
            paymentInfoXmlRecord.setAttribute('PaymentType', cardTokenTenderTypeId);
            paymentInfoXmlRecord.setAttribute('CardType', cardTokenCardTypeId);
            paymentInfoXmlRecord.setAttribute('Amount', '0');
            paymentInfoXmlRecord.setAttribute('Currency', Ledger::accountingCurrency(CompanyInfo::current()));
            paymentInfoXmlRecord.setAttribute('Prepayment', int2str(enum2int(NoYes::No)));
            paymentInfoXmlRecord.setAttribute('PaymentCaptured', int2str(enum2int(NoYes::No)));
            paymentInfoXmlRecord.setAttribute('AuthorizedAmount', '0');
            paymentInfoXmlRecord.setAttribute('PaymentRefRecId', '0');
            paymentInfoXmlRecord.setAttribute('CreditCardProcessorStatusValue', int2str(enum2int(CreditCardProcessorStatus::NA)));
            paymentInfoXmlRecord.setAttribute('CardPaymentAccountId', cardPaymentAccountId);
            paymentInfoXmlRecord.setAttribute('LineNum', '0');
            paymentInfoXmlRecord.setAttribute('PaymentStatusValue', int2str(enum2int(RetailTenderLineStatus::NotProcessed)));

            // Add tokens as xml elements
            XmlElement cardTokenXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardToken');
            cardTokenXmlRecord.innerText(creditCardCust.CardToken);
            XmlElement cardAuthorizationXmlRecord = paymentInfoXmlRecord.ownerDocument().createElement('CreditCardAuthorization');
            cardAuthorizationXmlRecord.innerText('');
            paymentInfoXmlRecord.appendChild(cardTokenXmlRecord);
            paymentInfoXmlRecord.appendChild(cardAuthorizationXmlRecord);

            // Add Payment Info to Payment Info collection
            _xmlPayments.appendChild(paymentInfoXmlRecord);

            // Log - Add Card Token to XML
            eventSource.EventWriteOrdersAddAuthorizedPaymentsXmlCardTokenMessage(funcName(), cardTokenTenderTypeId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddHistoryEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a Payment History element and add it to Payments XML node.
    /// </summary>
    /// <param name = "_xmlRoot">The xml document root.</param>
    /// <param name = "_xmlPayments">The payments node.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_paymentType">The tender type id.</param>
    /// <param name = "_prepayment">Is this a prepayment? (Y/N).</param>
    /// <param name = "_amount">The amount.</param>
    /// <param name = "_currency">The currency.</param>
    /// <param name = "_date">The date.</param>
    /// <param name = "_ledgerJournalTransRecId">The payment journal line recId.</param>
    /// <param name = "_paymentRefRecId">The <c>CreditCardAuthTrans</c> recId corresponding to the payment line.</param>
    /// <param name = "_captureToken">The capture token.</param>
    /// <param name = "_cardType">The card type.</param>
    /// <param name = "_refundableAmount">The refundable amount.</param>
    /// <param name = "_transactionPaymentTrans">The transaction corresponding to the payment line.</param>
    /// <param name = "_paymentRoundingDifference">The rounding difference corresponding to the payment line. Optional.</param>
    /// <returns>The payments node with the new added payment element.</returns>
    private static XmlElement AddHistoryEntry(XmlElement _xmlRoot,
        XmlElement _xmlPayments,
        SalesTable _salesTable,
        str _paymentType,
        NoYes _prepayment,
        AmountCur _amount,
        CurrencyCode _currency,
        TransDate _date,
        RecId _ledgerJournalTransRecId,
        RecId _paymentRefRecId,
        CreditCardPaymentCardToken _captureToken,
        RetailStoreCardTypeId _cardType,
        Amount _refundableAmount,
        RetailTransactionPaymentTrans _transactionPaymentTrans,
        Amount _paymentRoundingDifference = 0)
    {
        if (_transactionPaymentTrans)
        {
            _refundableAmount = _transactionPaymentTrans.RefundableAmount;
            _paymentType = _transactionPaymentTrans.tenderType;
        }

        XmlElement xmlRecord;

        // Create a payment Info history element
        xmlRecord = _xmlRoot.ownerDocument().createElement('Payment');
        xmlRecord.setAttribute(AmountStr, num2str(_amount, 5, 3, 1, 0));
        xmlRecord.setAttribute('CardType', _cardType);
        xmlRecord.setAttribute('Currency', _currency);
        xmlRecord.setAttribute('Date', RetailTransactionServiceUtilities::dateToString(_date));

        if (_transactionPaymentTrans)
        {
            xmlRecord.setAttribute('LineNum', RetailTransactionServiceUtilities::lineNumToString(_transactionPaymentTrans.lineNum));
        }

        xmlRecord.setAttribute('PaymentCaptured', int2str(1));
        xmlRecord.setAttribute('PaymentRefRecId', int642Str(_paymentRefRecId));
        xmlRecord.setAttribute('PaymentStatusValue', int2str(enum2int(RetailTenderLineStatus::Historical)));
        xmlRecord.setAttribute('PaymentType', _paymentType);
        xmlRecord.setAttribute('Prepayment', int2str(enum2int(_prepayment)));
        xmlRecord.setAttribute('RefundableAmount', RetailTransactionServiceUtilities::realToString(_refundableAmount));

        if (_transactionPaymentTrans)
        {
            xmlRecord.setAttribute('TransactionId', _transactionPaymentTrans.transactionId);
        }

        if (_paymentRefRecId)
        {
            CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::find(_paymentRefRecId);

            if (creditCardAuthTrans)
            {
                // Get service account identifier from the authorization.
                xmlRecord.setAttribute('CardPaymentAccountId', CreditCardAuthTrans::getServiceAccountIdFromCardTokenResult(creditCardAuthTrans));

                if (RetailIncrementalCaptureFeatureExposure::isEnabled())
                {
                    xmlRecord.setAttribute('AuthorizationReferenceId', creditCardAuthTrans.Authorization);
                }
            }
        }

        xmlRecord.setAttribute('RoundingDifference', num2str(_paymentRoundingDifference, 5, 16, 1, 0));

        XmlElement creditCardCaptureTokenXmlRecord = xmlRecord.ownerDocument().createElement('CreditCardCaptureToken');
        creditCardCaptureTokenXmlRecord.innerText(_captureToken);
        xmlRecord.appendChild(creditCardCaptureTokenXmlRecord);

        // get line-level info codes
        if (_ledgerJournalTransRecId)
        {
            XmlElement xmlHeaderInfoCodes = RetailTransactionServiceOrders::setTenderLineInfocodeLines(_xmlRoot.ownerDocument(), _salesTable.RecId, _ledgerJournalTransRecId, RetailInfoCodeLineRelatedTableType::Sales);
            xmlRecord.appendChild(xmlHeaderInfoCodes);
        }

        // Add the Payment Info to the XML Payments node
        _xmlPayments.appendChild(xmlRecord);

        // Log Add payment History XML
        eventSource.EventWriteOrdersAddHistoryEntryMessage(funcName(), _paymentType, int2str(enum2int(_prepayment)));

        // Return the new Payments XML node with the added element
        return _xmlPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddPaymentHistoryXML</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds prepaid amount information to root xml and creates and returns payments xml nodes.
    /// </summary>
    /// <param name = "_xmlRoot">The xml document root.</param>
    /// <param name = "_xmlPayments">The payments node.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_xmlPayments">The invoice identifier.</param>
    /// <param name="_allowExchangeOnReturnOrders">Load the historical payments setting the prepayment attribute to 0, avoiding reuse of the prepayments. Default to false.</param>
    /// <returns>The payments node.</returns>
    private static XmlElement AddPaymentHistoryXML(XmlElement _xmlRoot, XmlElement _xmlPayments, SalesTable _salesTable, boolean _allowExchangeOnReturnOrders = false)
    {
        // <GEERU>
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        // </GEERU>

        boolean _isOmniChannelPaymentsEnabled = RetailSharedParameters::find().EnableOmniChannelPayments;
        boolean _isChannelReturnPoliciesEnabled = FeatureStateProvider::isFeatureEnabled(RetailReturnPolicyChannelEnableFeature::instance());

        LedgerJournalTrans  ledgerJournalTrans;

        Set paymentTransRecIds = new Set(Types::Int64);

        //
        // 1. Get Pre-payments created from POS.
        //
        while select
            PaymReference,
            PaymMode,
            AmountCurCredit,
            AmountCurDebit,
            Prepayment,
            CreatedDateTime,
            CurrencyCode,
            TransDate,
            RecId,
            LineNum,
            CreditCardAuthTransRefId,
            McrRefPaymId
            // <GEERU>
            ,Accounttype
            // </GEERU>
            from ledgerJournalTrans
        where ledgerJournalTrans.PaymReference == _salesTable.SalesId
            && ledgerJournalTrans.Prepayment == NoYes::Yes
        {
            AmountCur amount;
            // <GEERU>
            if (countryRegion_W && ledgerJournalTrans.AccountType != LedgerJournalAcType::Cust)
            {
                amount = (ledgerJournalTrans.AmountCurDebit - ledgerJournalTrans.AmountCurCredit);
            }
            else
            {
                // </GEERU>
                amount = (ledgerJournalTrans.AmountCurCredit - ledgerJournalTrans.AmountCurDebit);
                // <GEERU>
            }
            // </GEERU>

            CreditCardPaymentCardToken cardCaptureToken;
            RetailStoreTenderTypeId tenderTypeId;
            RetailStoreCardTypeId cardTypeId;
            Amount refundableAmount;
            RetailTransactionPaymentTrans  transactionPaymentTrans;
            real roundingDifference = McrCustPaymTable::findByRecId(ledgerJournalTrans.McrRefPaymId).RoundingDifference;

            // get capture token and card type info only if omni-channel payment is enabled.
            if ( _isOmniChannelPaymentsEnabled && ledgerJournalTrans.CreditCardAuthTransRefId != 0)
            {
                [cardCaptureToken,
                     tenderTypeId,
                       cardTypeId,
                 refundableAmount] = RetailTransactionServiceOrders::calculateLinkedRefundProperties(ledgerJournalTrans.CreditCardAuthTransRefId);
            }

            tenderTypeId = tenderTypeId != '' ? tenderTypeId : ledgerJournalTrans.PaymMode;

            if (_isChannelReturnPoliciesEnabled)
            {
                transactionPaymentTrans = RetailTransactionServiceOrders::findPaymentTransByLedgerJournalTrans(_salesTable, ledgerJournalTrans, _isOmniChannelPaymentsEnabled, amount, cardTypeId, cardCaptureToken, paymentTransRecIds);
            }

            _xmlPayments = RetailTransactionServiceOrders::AddHistoryEntry( _xmlRoot,
                                                                _xmlPayments,
                                                                _salesTable,
                                                                tenderTypeId,
                                                                _allowExchangeOnReturnOrders ? 0 : ledgerJournalTrans.Prepayment,
                                                                amount,
                                                                ledgerJournalTrans.CurrencyCode,
                                                                ledgerJournalTrans.TransDate,
                                                                ledgerJournalTrans.RecId,
                                                                ledgerJournalTrans.CreditCardAuthTransRefId,
                                                                cardCaptureToken,
                                                                cardTypeId,
                                                                refundableAmount,
                                                                transactionPaymentTrans,
                                                                roundingDifference);
        }

        //
        // 2. Factor-in settlement activity from invoices.
        //
        CustTrans       custTrans;
        CustInvoiceJour custInvoiceJour;
        AmountCur       prepaymentApplied;
        CustInvoiceSalesLink    custInvoiceSalesLink;

        // For all payments (CustTrans) on all invoices (CustInvoiceJour) for this Sales Order...
        while select custTrans
            exists join custInvoiceJour
                where custInvoiceJour.InvoiceId == custTrans.invoice
                && custInvoiceJour.InvoiceAccount == custTrans.AccountNum
                && custInvoiceJour.InvoiceDate == custTrans.TransDate
                && custInvoiceJour.LedgerVoucher == custTrans.Voucher
            exists join custInvoiceSalesLink
                where custInvoiceSalesLink.salesId == custInvoiceJour.SalesId
                && custInvoiceSalesLink.invoiceId == custInvoiceJour.InvoiceId
                && custInvoiceSalesLink.invoiceDate == custInvoiceJour.InvoiceDate
                && custInvoiceSalesLink.origSalesId == _salesTable.SalesId
        {
            boolean custSettlementFound = false;

            CustSettlement            custSettlement;
            CustTrans                 orig_CustTrans;
            CreditCardAuthTrans       origCardAuthTrans;
            RetailCreditCardAuthTrans retailCardAuthTrans;

            // If custSettlement is available for the current custTrans then loop through each custSettlement record and create a payment line entry per each custSettlement record
            // This is necessary to allow linked refund per payment line for a multi payment scenario.
            while select custSettlement
                     where custTrans.recid == custSettlement.transrecid
                outer join orig_CustTrans
                     where orig_CustTrans.RecId == custSettlement.OffsetRecId
                outer join ledgerjournaltrans
                     where ledgerjournaltrans.Voucher == custSettlement.OffsetTransVoucher
                outer join origCardAuthTrans
                     where origCardAuthTrans.RecId == ledgerJournalTrans.CreditCardAuthTransRefId
                outer join retailCardAuthTrans
                     where retailCardAuthTrans.CreditCardAuthTrans == origCardAuthTrans.RecId
            {
                custSettlementFound = true;

                // if the offSetRecId points to a prepaid custTrans record then add to prepayment sum.
                // Note If "Process return Orders as sales orders" checkbox is enabled in Retail Parameters,
                // do not load prepayments applied when the caller is a return with Exchange transaction.
                // In this case, the prepayments were already consumed during the order invoicing process
                // (and should not be considered as new deposits.).
                if (orig_CustTrans.Prepayment)
                {
                    prepaymentApplied += _allowExchangeOnReturnOrders ? 0 : custSettlement.SettleAmountCur;
                }

                Amount                     refundableAmount;
                RetailStoreCardTypeId      cardTypeId;
                RetailStoreTenderTypeId    tenderTypeId;
                CreditCardPaymentCardToken cardCaptureToken;
                RetailTransactionPaymentTrans  transactionPaymentTrans;

                // if the current row represents a prepayment ledgerJournalTrans then skip it as we have already accounted for it.
                if (!(ledgerJournalTrans && ledgerJournalTrans.Prepayment))
                {
                    // if omni-channel payment is enabled and there is a corresponding CreditCardAuthTrans entry for the current ledger journal trans then
                    // calculate the linked refund properties for the payment line;
                    if ( _isOmniChannelPaymentsEnabled && ledgerJournalTrans.CreditCardAuthTransRefId != 0)
                    {
                        [cardCaptureToken,
                             tenderTypeId,
                               cardTypeId,
                         refundableAmount] = RetailTransactionServiceOrders::calculateLinkedRefundProperties(ledgerJournalTrans.CreditCardAuthTransRefId);
                    }

                    tenderTypeId = tenderTypeId != '' ? tenderTypeId : ledgerJournalTrans.PaymMode;

                    if (_isChannelReturnPoliciesEnabled)
                    {
                        transactionPaymentTrans = RetailTransactionServiceOrders::findPaymentTransByLedgerJournalTrans(_salesTable, ledgerJournalTrans, _isOmniChannelPaymentsEnabled, custSettlement.SettleAmountCur, cardTypeId, cardCaptureToken, paymentTransRecIds);
                    }

                    // add payment history
                    _xmlPayments = RetailTransactionServiceOrders::AddHistoryEntry(_xmlRoot,
                                                                     _xmlPayments,
                                                                     _salesTable,
                                                                     tenderTypeId,
                                                                     _allowExchangeOnReturnOrders ? 0 : custTrans.Prepayment,
                                                                     custSettlement.SettleAmountCur,
                                                                     custTrans.CurrencyCode,
                                                                     custSettlement.TransDate,
                                                                     ledgerJournalTrans.RecId,
                                                                     ledgerJournalTrans.CreditCardAuthTransRefId,
                                                                     cardCaptureToken,
                                                                     cardTypeId,
                                                                     refundableAmount,
                                                                     transactionPaymentTrans);
                }
            }

            // if custSettlement is not found for the current custTrans
            // then add the payment history based on the information on the custTrans record.
            if (!custSettlementFound)
            {
                RetailTransactionPaymentTrans transactionPaymentTrans;
                if (_isChannelReturnPoliciesEnabled)
                {
                    transactionPaymentTrans = RetailTransactionServiceOrders::findPaymentTransByCustTrans(_salesTable, custTrans);
                }

                _xmlPayments = RetailTransactionServiceOrders::AddHistoryEntry(_xmlRoot, _xmlPayments, _salesTable, '', _allowExchangeOnReturnOrders ? 0 : custTrans.Prepayment, custTrans.AmountCur, custTrans.CurrencyCode, custTrans.TransDate, 0, 0, '', '', 0, transactionPaymentTrans);
            }
        }

        // 3. Create an element for the settled prepayment amount.
        //
        XmlElement xmlPrepayApplied = _xmlRoot.ownerDocument().createElement('PrepaymentAmountApplied');
        xmlPrepayApplied.innerText(RetailTransactionServiceUtilities::realToString(prepaymentApplied));
        _xmlRoot.appendChild(xmlPrepayApplied);

        return _xmlPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLinkedRefundProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the refundable/refunded amounts and retrieves the tender type and card type and card capture token information.
    /// </summary>
    /// <param name = "_creditCardAuthTransRecId">The <c>CreditCardAuthTrans</c> for the capture token response.</param>
    /// <param name = "_getRefundedAmount">A boolean specifying if the method should return the refundedAmount instead of the refundableAmount.</param>
    /// <returns>A container consisting of [cardCaptureToken, tenderTypeId, cardTypeId, refundableAmount]. Optionally, [cardCaptureToken, tenderTypeId, cardTypeId, refundedAmount].</returns>
    /// <remarks>If a valid tender type or card type is not found for the specified credit card transaction this method does not return
    /// any of the linked refund related properties.</remarks>
    internal static container calculateLinkedRefundProperties(CreditCardAuthTransRefRecId _creditCardAuthTransRecId, boolean _getRefundedAmount = false)
    {
        CreditCardAuthTrans linkedCreditCardAuthTrans;

        CreditCardPaymentCardToken cardCaptureToken;
        RetailStoreTenderTypeId    tenderTypeId;
        RetailStoreCardTypeId      cardTypeId;
        Amount                     refundableAmount;
        boolean                    isLinkToPartialRefundAvailable;
        Amount                     linkedRefundTotalAmount;

        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::find(_creditCardAuthTransRecId);

        while select sum(ApprovalAmountCur), CurrencyCode
            from linkedCreditCardAuthTrans
            group by OrigAuthRecId, CurrencyCode
            where linkedCreditCardAuthTrans.OrigAuthRecId == _creditCardAuthTransRecId &&
            linkedCreditCardAuthTrans.ApprovalType == CreditCardOperation::Refund &&
            linkedCreditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
            linkedCreditCardAuthTrans.OrigAuthRecId != 0 // filter out legacy data which will have this new column set to zero
        {
            if (creditCardAuthTrans.CurrencyCode != linkedCreditCardAuthTrans.CurrencyCode)
            {
                CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()));
                Amount linkedRefundAmountInOrigCurrency = currencyExchHelper.calculateCurrencyToCurrency(linkedCreditCardAuthTrans.CurrencyCode, creditCardAuthTrans.CurrencyCode, linkedCreditCardAuthTrans.ApprovalAmountCur, true);
                linkedRefundTotalAmount += abs(linkedRefundAmountInOrigCurrency);
            }
            else
            {
                linkedRefundTotalAmount += abs(linkedCreditCardAuthTrans.ApprovalAmountCur);
            }

            isLinkToPartialRefundAvailable = true;
        }

        // populate capture token and card info only if the refund status is None (not processed) OR
        // if the refund is partially processed and has the corresponding original creditCardAuthTrans entry associated with it.
        // Note: If the partial refund doesnt have the corresponding original creditCardAuthTrans reference then it cant be link refunded.
        if (creditCardAuthTrans.RefundStatus == CreditCardRefundStatus::None ||
                    !(creditCardAuthTrans.RefundStatus == CreditCardRefundStatus::Processed && !isLinkToPartialRefundAvailable))
        {
            RetailCreditCardAuthTrans retailCreditCardAuthTrans = RetailCreditCardAuthTrans::findByCreditCardAuthTrans(creditCardAuthTrans);
            // populate the properties required for linked refund only if tendertype and card type are found for the current credit card auth transaction.
            if (retailCreditCardAuthTrans.CardTypeId != '' && retailCreditCardAuthTrans.TenderTypeId != '')
            {
                cardTypeId = retailCreditCardAuthTrans.CardTypeId;
                tenderTypeId = retailCreditCardAuthTrans.TenderTypeId;
                cardCaptureToken = creditCardAuthTrans.CardTokenResult;
                refundableAmount = creditCardAuthTrans.ApprovalAmountCur - linkedRefundTotalAmount;
                refundableAmount = CurrencyExchange::round(refundableAmount, creditCardAuthTrans.CurrencyCode);
            }
            else
            {
                eventSource.EventWriteOrdersCalculateLinkedRefundProperties(funcName());
            }

            // if <c>RetailCreditCardAuthTrans</c> record doesn't exists.
            // Then use original <c>CreditCardAuthTrans</c> record as refernece to create new refund record.
            if (retailCreditCardAuthTrans.RecId == 0
                && creditCardAuthTrans.RecId != 0
                && creditCardAuthTrans.MCRPaymRecId != 0
                && creditCardAuthTrans.RefundStatus == CreditCardRefundStatus::None
                && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                && !isLinkToPartialRefundAvailable)
            {
                McrCustPaymTable capturePaymentRecord = McrCustPaymTable::findByRecId(creditCardAuthTrans.MCRPaymRecId);
                
                cardTypeId = capturePaymentRecord.CardTypeId;
                tenderTypeId = capturePaymentRecord.TenderTypeId;
                cardCaptureToken = creditCardAuthTrans.CardTokenResult;
                refundableAmount = creditCardAuthTrans.ApprovalAmountCur - linkedRefundTotalAmount;
                refundableAmount = CurrencyExchange::round(refundableAmount, creditCardAuthTrans.CurrencyCode);
            }
        }

        if (_getRefundedAmount)
        {
            return [cardCaptureToken, tenderTypeId, cardTypeId, -linkedRefundTotalAmount];
        }
        else
        {
            return [cardCaptureToken, tenderTypeId, cardTypeId, refundableAmount];
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymentTransByLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find payment tran record based on the sales order's ledger journal tran.
    /// </summary>
    /// <param name = "_salesTable">The sales order.</param>
    /// <param name = "_ledgerJournalTrans">The ledger journal tran.</param>
    /// <param name = "_isOmniChannelPaymentsEnabled">Is omni channel enabled.</param>
    /// <param name = "_amount">The amount.</param>
    /// <param name = "_cardTypeId">The card type.</param>
    /// <param name = "_cardCaptureToken">The captured token.</param>
    /// <returns>A RetailTransactionPaymentTrans record.</returns>
    internal static RetailTransactionPaymentTrans findPaymentTransByLedgerJournalTrans
        (SalesTable _salesTable,
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _isOmniChannelPaymentsEnabled,
        AmountCur _amount,
        RetailStoreCardTypeId _cardTypeId,
        CreditCardPaymentCardToken _cardCaptureToken,
        Set _paymentTransRecIds)
    {
        RetailTransactionPaymentTrans  transactionPaymentTrans;
        RetailTransactionTable transactionTable;

        if ( _isOmniChannelPaymentsEnabled && _ledgerJournalTrans.CreditCardAuthTransRefId != 0)
        {
            // find with cardCaptureToken and cardTypeId
            select firstonly transactionPaymentTrans
                    index hint transactionLineIdx
                    exists join transactionTable
                    where transactionTable.salesOrderId == _salesTable.SalesId
                        && transactionPaymentTrans.Channel == transactionTable.Channel
                        && transactionPaymentTrans.store == transactionTable.store
                        && transactionPaymentTrans.terminal == transactionTable.terminal
                        && transactionPaymentTrans.transactionId == transactionTable.transactionId
                        && transactionPaymentTrans.amountMST == _amount
                        && transactionPaymentTrans.currency == _ledgerJournalTrans.CurrencyCode
                        && transactionPaymentTrans.cardTypeId == _cardTypeId
                        && transactionPaymentTrans.paymentAuthorization == _cardCaptureToken;
        }
        else
        {
            // find with transactionId and etc.
            while select transactionPaymentTrans
                        index hint transactionLineIdx
                        exists join transactionTable
                        where transactionTable.salesOrderId == _salesTable.SalesId
                            && transactionPaymentTrans.Channel == transactionTable.Channel
                            && transactionPaymentTrans.store == transactionTable.store
                            && transactionPaymentTrans.terminal == transactionTable.terminal
                            && transactionPaymentTrans.transactionId == transactionTable.transactionId
                            && transactionPaymentTrans.amountMST == _amount
                            && transactionPaymentTrans.currency == _ledgerJournalTrans.CurrencyCode
                            && transactionPaymentTrans.lineNum == _ledgerJournalTrans.LineNum
            {

                if (!_paymentTransRecIds.in(transactionPaymentTrans.RecId) && transactionPaymentTrans.RecId != 0)
                {
                    _paymentTransRecIds.add(transactionPaymentTrans.RecId);
                    break;
                }
            }
        }

        return transactionPaymentTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymentTransByCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find payment tran record based on the sales order's custTrans.
    /// </summary>
    /// <param name = "_salesTable">The sales order.</param>
    /// <param name = "_custTrans">The CustTrans record.</param>
    /// <returns>A RetailTransactionPaymentTrans record.</returns>
    private static RetailTransactionPaymentTrans findPaymentTransByCustTrans
        (SalesTable _salesTable,
        CustTrans _custTrans)
    {
        RetailTransactionPaymentTrans  transactionPaymentTrans;
        RetailTransactionTable transactionTable;

        select firstonly transactionPaymentTrans
            index hint transactionLineIdx
            exists join transactionTable
            where transactionTable.salesOrderId == _salesTable.SalesId
                && transactionPaymentTrans.Channel == transactionTable.Channel
                && transactionPaymentTrans.store == transactionTable.store
                && transactionPaymentTrans.terminal == transactionTable.terminal
                && transactionPaymentTrans.transactionId == transactionTable.transactionId
                && transactionPaymentTrans.amountMST == _custTrans.AmountCur
                && transactionPaymentTrans.currency == _custTrans.CurrencyCode;

        return transactionPaymentTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddPaymentInformationXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add payment history elements.
    /// If invoice identifier is provided the payment history will be limitied to the specified invoice as opposed to all payment lines of the corresponding order.
    /// </summary>
    /// <param name="_xmlRoot">
    /// Individual sales order root.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice identifier.
    /// </param>
    /// <param name="_allowExchangeOnReturnOrders">
    /// Load the historical payments setting the prepayment attribute to 0, avoiding reuse of the prepayments (usually during returns with exchanges). Default to false.
    /// </param>
    /// <remarks>
    /// Creates and adds 'Payment' and 'PrepaymentApplied' XML elements to the provided xml document.
    /// </remarks>
    private static void AddPaymentInformationXml(XmlElement _xmlRoot, SalesTable _salesTable, boolean _allowExchangeOnReturnOrders = false)
    {
        XmlElement  xmlRecord, _xmlPayments;
        AmountCur amount;
        boolean paymentsFound = false;

        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId( _salesTable.retailSalesTable().RetailChannel);;

        // Verify if Omni Channel Payments are enabled
        boolean _isOmniChannelPaymentsEnabled = RetailSharedParameters::find().EnableOmniChannelPayments;

        // <GEERU>
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        // </GEERU>

        //
        // 1. Create an element for the individual Payments
        //
        _xmlPayments = _xmlRoot.ownerDocument().createElement('Payments');

        //
        // 2. Add  Historical payment elements to the customer order xml document.
        //
        _xmlPayments = RetailTransactionServiceOrders::AddPaymentHistoryXML(_xmlRoot, _xmlPayments, _salesTable, _allowExchangeOnReturnOrders);

        if (_isOmniChannelPaymentsEnabled)
        {
            //
            // 3. Add authorized payments elements to the customer order xml document.
            //    (Only for Omni channel payments)
            //
            if(RetailTransactionPaymentsHelper::isCallCenterOrCommercePaymentsEnabledOrder(_salesTable))
            {
                paymentsFound = RetailTransactionServiceOrders::AddAuthorizedPaymentsXmlCallCenter(_xmlRoot, _xmlPayments, _salesTable);
            }
            else
            {
                paymentsFound = RetailTransactionServiceOrders::AddAuthorizedPaymentsXmlNonCallCenter(_xmlRoot, _xmlPayments, _salesTable, retailChannelTable);
            }

            // For Retail sales orders (POS, Online): Add card token in case authorizations for the sales order are not found
            if (!_salesTable.mcrIsCallCenter() && !paymentsFound)
            {
                RetailTransactionServiceOrders::AddAuthorizedPaymentsXmlCardToken(_xmlRoot, _xmlPayments, _salesTable, retailChannelTable);
            }

            // Log CustomerOrderInfo success generation using Omni Channel payment flow
            eventSource.EventWriteOrdersAddPaymentInformationXmlOmniFlow(funcName(), _salesTable.RecId);
        }
        else
        {
            // Log CustomerOrderInfo success generation using Regular Channel payment flow
            eventSource.EventWriteOrdersAddPaymentInformationXmlRegularFlow(funcName(), _salesTable.RecId);
        }

        //
        // 4. Add Payment XMl elements to the document.
        //
        _xmlRoot.appendChild(_xmlPayments);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountToStr</Name>
				<Source><![CDATA[
    private static str amountToStr(real _amount)
    {
        return num2str(_amount,5,3,1,0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxOverrideCode</Name>
				<Source><![CDATA[
    private static str getTaxOverrideCode(CustomerOrderInfo _custOrderInfo)
    {
        str taxOverrideCode = '';

        // Using reflection to support backward compatibility.
        PropertyInfo taxOverrideCodePropertyInfo = _custOrderInfo.GetType().GetProperty(TaxOverrideCodeElement);

        if (taxOverrideCodePropertyInfo != null)
        {
            taxOverrideCode = taxOverrideCodePropertyInfo.GetValue(_custOrderInfo);
        }

        return taxOverrideCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerJournalPaymentTransForCancelCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert ledger journal payment trans for cancel customer order
    /// </summary>
    /// <param name = "_contract">
    /// An instance of <c>ProjInvoiceProposalInsertLinesContract</c> class.
    ///</param>
    protected static void insertLedgerJournalPaymentTransForCancelCustomerOrder(RetailTransactionServiceOrdersParameter _contract)
    {
        RetailTransactionPaymentsHelper::insertLedgerJournalPaymentTrans(_contract.parmCustOrderXml(), _contract.parmDefaultCurrencyCode(), _contract.parmLedgerJournalTable(), _contract.parmVoucherPayment(), _contract.parmStoreId(), _contract.parmSalesId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be canceled.
    /// </param>
    /// <returns>
    /// A container having the status of order cancellation.
    /// </returns>
    public static container cancelCustomerOrder(str custOrderXmlStr)
    {
        int         i;
        str         error;
        boolean     success = false;
        SalesTable  salesTable;
        SalesLine   salesLine;
        MarkupTrans markupTrans;
        SalesId     salesId;
        MarkupCode  chargeCode;
        Voucher     voucherCharge;
        List        vouchersToSettle = new List(Types::String);
        Amount      chargeCodeAmount, totalChargeCodeAmount;
        TaxGroup   taxGroup;
        TaxItemGroup taxItemGroup;
        TaxAmountCur    exclusiveTaxAmountCur = 0;
        XmlDocument custOrderXml;
        XmlElement  xmlRoot;
        XmlElement  xmlRecord;
        XmlNodeList xmlRecordList;
        Counter     infologline    = infolog.num();
        LedgerJournalCheckPost  ledgerJournalCheckPost;
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        AmountCur   paymentAmount;
        AmountCur   paymentAmountCurrency;
        MarkupTable markupTable;
        int fromLine;
        str paymentMode, cardType;
        boolean     postCancellationCharge;
        boolean     hasPayments, prePayment;

        #Define.PaymentsNode('Payments')
        #Define.PaymTypeAttribute('PaymentType')

        RetailStoreId storeId;
        RetailStoreTable retailStoreTable;
        RetailTransactionId transactionId;
        RetailTerminalId terminalId;

        boolean                     isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        CurrencyCode currencyCode;
        currencyCode defaultCurrencyCode;
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        custOrderXml    = new XmlDocument();
        custOrderXml.loadXml(custOrderXmlStr);

        xmlRoot = custOrderXml.documentElement().getNamedElement('Id');
        salesId = xmlRoot.text();

        xmlRoot = custOrderXml.documentElement().getNamedElement('ContractVersion');
        str contractVersion = xmlRoot ? xmlRoot.text() : '';

        // Create customer order info object in order in order the validate version in the xml
        CustomerOrderInfo customerOrderInfo = new CustomerOrderInfo();
        CustomerOrderContractVersion contractVersionEnum = new CustomerOrderContractVersion();
        customerOrderInfo.ContractVersion = contractVersion ? str2Enum(contractVersionEnum, contractVersion) : CustomerOrderContractVersion::Base;
        container validationResult = RetailCommercePaymentsFeatureHelper::validateCustomerOrderVersion(customerOrderInfo, SalesTable::find(salesId));
        boolean validationResultSuccessful = conPeek(validationResult, 1);

        if (!validationResultSuccessful)
        {
            return validationResult;
        }

        xmlRoot = custOrderXml.documentElement().getNamedElement('StoreId');
        storeId = xmlRoot.text();

        xmlRoot = custOrderXml.documentElement().getNamedElement('TransactionId');
        transactionId = xmlRoot.text();

        xmlRoot = custOrderXml.documentElement().getNamedElement('TerminalId');
        terminalId = xmlRoot.text();

        RecId salesOrderRecId;

        try
        {
            ttsbegin;
            salesTable = SalesTable::find(salesId, true);
            salesOrderRecId = salesTable.RecId;
            fromLine = Global::infologLine();

            // Cancelling the order, Commerce RTS only supports to cancel order which is not fulfilled even partially.
            if (salesTable.DocumentStatus == DocumentStatus::None || (salesTable.DocumentStatus == DocumentStatus::Confirmation && !salesTable.mcrIsCallCenter()))
            {
                if (salesTable.SalesStatus == SalesStatus::Canceled)
                {
                    // Make cancelCustomerOrder idempotent: when cancelling an order which is already cancelled, we just return succeed instead of throwing error.
                    success = true;
                    error = '';

                    ttscommit;
                    return [success, error];
                }

                SalesUpdateRemain salesUpdateRemain = SalesUpdateRemain::construct();

                if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName()))
                {
                    salesUpdateRemain.setRefundPayments(false);
                }

                if (!salesUpdateRemain.cancelOpenOrderLinesDeliveryRemainder(salesTable))
                {
                    eventSource.EventWriteOrdersCancelCustomerOrderWithUnexpectedStatus(
                        salesOrderRecId,
                        enum2Symbol(enumNum(SalesStatus), salesTable.SalesStatus),
                        enum2Symbol(enumNum(DocumentStatus), salesTable.DocumentStatus));

                    throw error('@Retail:CancelOrderError');
                }
            }
            else
            {
                // Else the order is not cancellable by Commerce RTS. Customer need to cancel their order in HQ which provides full functionality of order operation.
                eventSource.EventWriteOrdersCancelCustomerOrderWithUnexpectedStatus(
                        salesOrderRecId,
                        enum2Symbol(enumNum(SalesStatus), salesTable.SalesStatus),
                        enum2Symbol(enumNum(DocumentStatus), salesTable.DocumentStatus));

                if (RetailCancelCustomerOrderRtsCheckOrderStatusFlight::instance().isEnabled())
                {
                    throw error('@Retail:CancelOrderError');
                }
            }

            retailStoreTable = RetailStoreTable::find(storeId);

            // Set up default currency
            xmlRoot = custOrderXml.documentElement().getNamedElement('CurrencyCode');
            if (xmlRoot && xmlRoot.text())
            {
                defaultCurrencyCode = xmlRoot.text();
            }
            else if (retailStoreTable.Currency)
            {
                defaultCurrencyCode = retailStoreTable.Currency;
            }
            else
            {
                defaultCurrencyCode = CompanyInfoHelper::standardCurrency();
            }

            //creation of charge codes
            xmlRoot = custOrderXml.documentElement().getNamedElement('Charges');
            xmlRecordList = xmlRoot.childNodes();
            if (xmlRecordList)
            {
                for (i = 0; i < xmlRecordList.length(); i++)
                {
                    xmlRecord = xmlRecordList.item(i);
                    chargeCode = xmlRecord.getAttribute(CodeStr);
                    chargeCodeAmount = str2num(xmlRecord.getAttribute(AmountStr));
                    totalChargeCodeAmount += chargeCodeAmount;

                    taxGroup = xmlRecord.getAttribute(TaxGroupStr);
                    taxItemGroup = xmlRecord.getAttribute(TaxItemGroupStr);

                    markupTrans.clear();
                    markupTrans.MarkupCode = chargeCode;        //Set markup code, then call initFromSalesTable, then initValue to ensure tax groups are initialized correctly
                    markupTrans.initFromSalesTable(salesTable);
                    markupTrans.initValue();
                    markupTrans.Value = chargeCodeAmount;
                    markupTrans.CurrencyCode = defaultCurrencyCode;
                    markupTrans.TaxGroup = taxGroup;
                    markupTrans.TaxItemGroup = taxItemGroup;
                    markupTrans.insert();
                    if (isIndia)
                    {
                        RetailTransactionServiceOrders::initMarkupTrans_IN(markupTrans, storeId, null, xmlRecord);
                    }
                }
            }

            if (countryRegion_W)
            {
                RetailTransactionServiceOrders::cancelCustomerOrderPaymentsAndSettlement_W(custOrderXml, salesTable);
            }
            else
            {
                xmlRoot = custOrderXml.documentElement().getNamedElement(#PaymentsNode);
                hasPayments = RetailTransactionServiceOrders::hasCapturedPayment(xmlRoot);

                // Creation of payment journal
                if (hasPayments || totalChargeCodeAmount != 0)
                {
                    ledgerJournalTable = RetailTransactionPaymentsHelper::CreateLedgerJournalForStore(salesTable.SalesId, defaultCurrencyCode, RetailChannelTable::findByRecId(retailStoreTable.RecId));
                    ledgerJournalTable.insert();

                    // Reset InclTax to match the SalesOrder because .Insert() forces it to match the value from LedgerJournalName
                    ledgerJournalTable.LedgerJournalInclTax = salesTable.InclTax;
                    ledgerJournalTable.update();

                    if (totalChargeCodeAmount)
                    {
                        voucherCharge = NumberSeq::newGetNum(CustParameters::numRefCustPaymVoucher()).num();
                        vouchersToSettle.addEnd(voucherCharge);

                        postCancellationCharge = RetailTransactionServiceOrders::addLedgerJournalTransForCancellationCharge(ledgerJournalTable,salesTable,chargeCode,defaultCurrencyCode,
                                                                              voucherCharge,taxGroup,taxItemGroup,totalChargeCodeAmount,storeId);

                    }

                    if (hasPayments)
                    {
                        RetailTransactionServiceOrdersParameter contract = new RetailTransactionServiceOrdersParameter();

                        contract.parmCustOrderXml(custOrderXml);
                        contract.parmDefaultCurrencyCode(defaultCurrencyCode);
                        contract.parmLedgerJournalTable(ledgerJournalTable);
                        contract.parmStoreId(storeId);
                        contract.parmSalesId(salesId);

                        if (!RetailCancelCustomerOrderMultipleVouchersSettlementFlight::instance().isEnabled())
                        {
                            Voucher voucherPayments = NumberSeq::newGetNum(CustParameters::numRefCustPaymVoucher()).num();
                            vouchersToSettle.addEnd(voucherPayments);
                            contract.parmVoucherPayment(voucherPayments);
                        }

                        RetailTransactionServiceOrders::insertLedgerJournalPaymentTransForCancelCustomerOrder(contract);

                        if (RetailCancelCustomerOrderMultipleVouchersSettlementFlight::instance().isEnabled())
                        {
                            LedgerJournalTrans ledgerJournalTransLocal;

                            while select Voucher from ledgerJournalTransLocal
                                where ledgerJournalTransLocal.JournalNum == ledgerJournalTable.JournalNum
                                    && ledgerJournalTransLocal.AccountType == LedgerJournalACType::Cust
                                    && ledgerJournalTransLocal.PaymReference == salesId
                                    && ledgerJournalTransLocal.SalesOrderId == salesId
                                    && ledgerJournalTransLocal.TransactionType == LedgerTransType::Payment
                                    && ledgerJournalTransLocal.AmountCurDebit
                            {
                                vouchersToSettle.addEnd(ledgerJournalTransLocal.Voucher);
                            }
                        }
                    }

                    if (hasPayments || postCancellationCharge)
                    {
                        ledgerJournalCheckPost = LedgerJournalCheckPostRetail::newRBOLedgerJournalTable(ledgerJournalTable, NoYes::Yes, NoYes::No,
                                                                                                            transactionId, storeId, terminalId);
                        LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);
                    }

                    RetailTransactionServiceOrders::settleCustomerOrderCancellation(salesTable, vouchersToSettle);
                }
            }

            // Void all Credit Card Pre-authorizations for the order (any type of order).
            // Also, create Payment events and update MCRCustPaymTable.Status for call center orders.
            salesTable.voidCreditCardPreauthorize();

            if (RetailParameters::find().UseAdvanceInvoice_W)
            {
                AdvanceInvoiceContract_W advanceInvoiceContract = new AdvanceInvoiceContract_W();
                advanceInvoiceContract.parmSalesTable(SalesTable);
                advanceInvoiceContract.initFromCustomerOrderXml(custOrderXmlStr);

                RetailTransactionServiceAdvanceInvoice_W::cancelCustAdvanceInvoicesByContract(advanceInvoiceContract);
            }

            // Void all warrantied relations on this CustomerOrder.
            if (WarrantyFeatureExposure::isWarrantySalesViaCustomerOrderFeatureEnabled())
            {
                WarrantiedRelationSalesLine::voidWarrantiedRelationByCustomerOrder(salesId);
            }

            error = '';
            success = true;
            ttscommit;
        }
        catch
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCancelCustomerOrderError(funcName(), salesOrderRecId);
            success = false;
        }
        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCapturedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the payments list has a captured payment.
    /// </summary>
    /// <param name = "_paymentList">Payments xml list.</param>
    /// <returns>True if a captured payment exists.</returns>
    private static boolean hasCapturedPayment(XmlElement _paymentRoot)
    {
        if (_paymentRoot && _paymentRoot.childNodes() && _paymentRoot.childNodes().length() > 0)
        {
            XmlNodeListIterator paymentIterator = new XMLNodeListIterator(_paymentRoot.childNodes());

            while (paymentIterator.more())
            {
                XmlElement currentPayment = paymentIterator.value();
                boolean paymentCaptured = currentPayment.getAttribute('PaymentCaptured') == TrueStr ? true : false;

                if (paymentCaptured)
                {
                    return true;
                }

                paymentIterator.next();
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelCustomerOrderPaymentsAndSettlement_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels customer order payments and settles prepayment and cancellation transactions.
    /// </summary>
    /// <param name="_custOrderXml">XML string having the header, line details and charges, refund payments.</param>
    /// <param name="_salesTable">The canceled sales order.</param>
    private static void cancelCustomerOrderPaymentsAndSettlement_W(XmlDocument _custOrderXml, SalesTable _salesTable)
    {
        ttsbegin;
        List refundPaymentsList = RetailTransactionPaymentsHelper::cancelCustomerOrderPayments_W(_custOrderXml, _salesTable);

        RetailTransactionServiceOrders::settleCustomerOrderCancellation(_salesTable, refundPaymentsList);

        if (refundPaymentsList)
        {
            TransactionLog::create(TransactionLogType::CustTransEdit, strFmt("@SYS70279", _salesTable.InvoiceAccount));
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCustomerQuoteToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a quotation to sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status of quote conversion and salesId of the sales order.
    /// </returns>
    public static container convertCustomerQuoteToOrder(str custOrderXmlStr)
    {
        container                   result = [false, '', ''];
        boolean                     success;
        str                         error;

        SalesQuotationTable         salesQuotationTable;
        SalesQuotationLine          salesQuotationLine;
        QuotationId                 quotationId;
        SalesId                     salesId;
        XmlDocument                 custOrderXml;
        XmlElement                  xmlRoot;
        container                   conSalesOrder;
        Counter                     infologline    = infolog.num();

        try
        {
            using(var telemetry = RetailInstrumentationSegment::construct(classStr(RetailTransactionServiceOrders), funcName()))
            {
                ttsbegin;
                success = false;
                salesId = '';

                custOrderXml   = new XmlDocument();
                custOrderXml.loadXml(custOrderXmlStr);

                xmlRoot = custOrderXml.documentElement().getNamedElement('QuotationId');
                quotationId = xmlRoot.text();

                select forupdate salesQuotationTable
                    where salesQuotationTable.QuotationId == quotationId;

                if (salesQuotationTable)
                {
                    if (salesQuotationTable.QuotationStatus == SalesQuotationStatus::Confirmed)
                    {
                        error = strFmt("@RET261017", quotationId);
                    }
                    else
                    {
                        conSalesOrder = RetailTransactionService::createCustomerOrder(custOrderXmlStr);

                        if (conPeek(conSalesOrder, 1) == true)
                        {
                            salesId = conPeek(conSalesOrder, 3);

                            salesQuotationTable.QuotationStatus = SalesQuotationStatus::Confirmed;
                            salesQuotationTable.ConfirmDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
                            salesQuotationTable.SalesIdRef = salesId;
                            salesQuotationTable.update();

                            while select forupdate salesQuotationLine
                                where salesQuotationLine.quotationId == quotationId
                            {
                                salesQuotationLine.QuotationStatus = SalesQuotationStatus::Confirmed;
                                salesQuotationLine.update();
                            }

                            success = true;
                        }
                        else
                        {
                            error = conPeek(conSalesOrder, 2);
                        }
                    }
                }
                else
                {
                    error = strFmt("@RET261018", quotationId);
                }
                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            if ((appl.ttsLevel() == 0)
                && (xSession::currentRetryCount() < #RetryNum))
            {
                retry;
            }
            else
            {
                throw Exception::Deadlock;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch(Exception::Error)
        {
            error = conPeek(conPeek(infolog.copy(infologline+1,infolog.num()),2),2);
            success = false;
        }

        if (error)
        {
            eventSource.EventWriteOrdersconvertCustomerQuoteToOrderError(funcName());
        }

        return [success, error, salesId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Intializes order header with data from customer master and customer invoice account.
    /// </summary>
    /// <param name = "_orderHeader">
    ///     Retail order/quotation header information.
    /// </param>
    /// <param name = "_custOrderInfo">
    ///     The customer order information.
    /// </param>
    protected static void initFromCustomer(boolean _createNew, boolean _isSales, RetailOrderHeaderMap _orderHeader, CustomerOrderInfo _custOrderInfo, str _origPaymMethod, str _origPaymMode, RecId _originalCreditCard)
    {
        _orderHeader.CustAccount = _custOrderInfo.CustomerAccount;

        // Init Order Header with data from Customer Master
        _orderHeader.initFromCustTable();
        // Init Order Header with extra info from Customer Invoice Account
        _orderHeader.initInvoiceAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailOrderHeader_MX</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Intializes order header extension with CFDI document type.
    /// </summary>
    /// <param name = "_orderHeader">
    ///     Retail order/quotation header information.
    /// </param>
    /// <param name = "_custOrderInfo">
    ///     The customer order information.
    /// </param>
    private static void updateRetailOrderHeader_MX(RetailOrderHeaderMap _orderHeader, CustomerOrderInfo _custOrderInfo)
    {
        if (_orderHeader.TableId == tableNum(SalesTable) && EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled())
        {
            RetailOrderHeaderExtensionMap orderHeaderExt = _orderHeader.RetailOrderHeaderMap::getRetailExtension();

            if (!orderHeaderExt.StatementId)
            {
                if (SalesTable::find(_custOrderInfo.Id).SalesType == SalesType::ReturnItem)
                {
                    SalesTable salesTableOrig;
                    RetailSalesTable retailSalesTableOrig;
                    SalesLine salesLine, salesLineOrig;
                    InventTrans inventTrans;
                    InventTransOrigin inventTransOriginOrig, inventTransOrigin;

                    select firstonly RecId from retailSalesTableOrig
                        where retailSalesTableOrig.RetailCFDIDocumentType_MX == RetailCFDIDocumentType_MX::CFDIGlobal
                        exists join salesTableOrig
                            where salesTableOrig.RecId == retailSalesTableOrig.SalesTable
                        exists join salesLineOrig
                            where salesLineOrig.SalesId == salesTableOrig.SalesId
                        exists join inventTransOriginOrig
                            where inventTransOriginOrig.InventTransId == salesLineOrig.InventTransId
                        exists join inventTrans
                            where inventTrans.ReturnInventTransOrigin == inventTransOriginOrig.RecId
                        exists join inventTransOrigin
                            where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                        exists join salesLine
                            where salesLine.InventTransId == inventTransOrigin.InventTransId
                                && salesLine.SalesId == _orderHeader.Id;

                    if (!retailSalesTableOrig)
                    {
                        orderHeaderExt.RetailCFDIDocumentType_MX = RetailCFDIDocumentType_MX::CFDINormal;
                    }
                }
                else
                {
                    CustInvoiceJour custInvoiceJour;

                    select firstonly RecId from custInvoiceJour
                            where custInvoiceJour.SalesId == _orderHeader.Id;

                    if (!custInvoiceJour)
                    {
                        if (EInvoiceCFDIParameters_MX::find().RetailExcludeCustOrdersFromCFDIGlobal)
                        {
                            orderHeaderExt.RetailCFDIDocumentType_MX = RetailCFDIDocumentType_MX::CFDINormal;
                        }
                    }
                }
                _orderHeader.RetailOrderHeaderMap::packRetailOrderHeaderExtension(orderHeaderExt);
                _orderHeader.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHeaderExpedite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Insert expedite value based on mode of delivery of sales order's header.
    /// </summary>
    /// <param name = "_expedite">
    ///     Expedite value based on mode of delivery setup.
    /// </param>
    /// <param name = "_salesId">
    ///     SalesId of Sales order.
    /// </param>
    private static void createHeaderExpedite(MCRExpedite _expedite, SalesId _salesId)
    {
        MCRSalesTableShipping salesTableShipping;
        salesTableShipping.initValue();
        salesTableShipping.SalesTable = SalesTable::Find(_salesId).RecId;
        salesTableShipping.Expedite = _expedite;

        if(salesTableShipping.validateWrite())
        {
            salesTableShipping.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateHeaderExpedite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Insert/update expedite value based on mode of delivery of sales order's header.
    /// </summary>
    /// <param name = "_createNew">
    ///     True, if sales order is getting created. False, if sales order is getting updated.
    /// </param>
    /// <param name = "_orderHeader">
    ///     Retail order/quotation header information.
    /// </param>
    private static void createOrUpdateHeaderExpedite(boolean _createNew, RetailOrderHeaderMap _orderHeader)
    {
        if(_createNew)
        {
            if(_orderHeader.DlvMode)
            {
                MCRExpedite expediteOfDlvMode = DlvMode::find(_orderHeader.DlvMode).mcrExpedite;

                RetailTransactionServiceOrders::createHeaderExpedite(expediteOfDlvMode, _orderHeader.Id);
            }
        }
        else
        {
            MCRExpedite expediteOfDlvMode = DlvMode::find(_orderHeader.DlvMode).mcrExpedite;

            if(expediteOfDlvMode != MCRSalesTableShipping::getExpediteStatus(SalesTable::Find(_orderHeader.Id).RecId))
            {
                MCRSalesTableShipping salesTableShipping = MCRSalesTableShipping::findSalesId(_orderHeader.Id,true);

                if(salesTableShipping)
                {
                    salesTableShipping.Expedite = expediteOfDlvMode;

                    if(salesTableShipping.validateWrite())
                    {
                        salesTableShipping.update();
                    }
                }
                else
                {
                    RetailTransactionServiceOrders::createHeaderExpedite(expediteOfDlvMode, _orderHeader.Id);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateRetailOrderHeader</Name>
				<Source><![CDATA[
    private static void createOrUpdateRetailOrderHeader(
                            RetailOrderHeaderMap orderHeader,
                            CustomerOrderInfo custOrderInfo,
                            boolean createNew,
                            Map taxAdjustmentsMap = null)
    {
        HcmWorker               hcmWorker = HcmWorker::findByPersonnelNumber(custOrderInfo.SalespersonStaffId);
        RetailChannelTable      retailChannelTable = RetailChannelTable::findByRecId(str2Int64(custOrderInfo.ChannelRecordId));
        RetailParameters        rboParameters = RetailParameters::find();
        RecId                   originalCreditCard = 0;
        str                     origPaymMethod, origPaymMode;
        NumberSequenceGroupId   numberSequenceGroup;
        RetailStoreTable        retailStore = RetailStoreTable::findRecId(retailChannelTable.RecId);
        MCRSalesTable           mcrSalesTable;
        LogisticsPostalAddressRecId postalAddressRecIdOrig;

        if (retailStore && retailStore.IsCallCenter && retailStore.LinkedCallCenter)
        {
            retailChannelTable = RetailChannelTable::findByRecId(retailStore.LinkedCallCenter);
        }

        boolean isSales = true;

        if (orderHeader.TableId == tableNum(SalesQuotationTable))
        {
            isSales = false;
        }

        RecId aggregationHeaderRecId = RetailStatementCompatibilityHelper::getAggregationHeaderRecId(custOrderInfo);
        CustTable custTable = custTable::find(custOrderInfo.CustomerAccount);
        eventSource.EventWriteOrdersCreateOrUpdateRetailOrderHeaderStart(isSales, custTable.RecId, custOrderInfo.StatementId, aggregationHeaderRecId);

        if (RetailEodTransactionAggregationHeaderCustOrderInfoUpdateFlight::instance().isEnabled())
        {
            str axCallStack = System.Environment::StackTrace;
            eventSource.EventWriteRetailEodTransactionAggregationHeaderCustOrderInfoValue(custOrderInfo.StatementId, aggregationHeaderRecId, custOrderInfo.ToXml(), axCallStack);
        }

        orderHeader.WorkerSalesResponsible = hcmWorker.RecId;
        orderHeader.WorkerSalesTaker = hcmWorker.RecId;

        // Init SalesTable from CustTable. In case this is a recall, restore original authorized CC payment
        // from SalesTable before the recall
        Email origEmail;
        boolean isRetailKeepSameNumberSequenceGroup = RetailKeepSameNumberSequenceGroupFlight::instance().isEnabled();

        if (!createNew)
        {
            if (isSales)
            {
                SalesTable salesTable =  SalesTable::find(custOrderInfo.Id);
                originalCreditCard = salesTable.CreditCardCustRefId;
                origPaymMethod = salesTable.Payment;
                origPaymMode = salesTable.PaymMode;
                postalAddressRecIdOrig = salesTable.DeliveryPostalAddress;
                if (isRetailKeepSameNumberSequenceGroup)
                {
                    numberSequenceGroup = salesTable.NumberSequenceGroup;
                }
            }
            else
            {
                if (isRetailKeepSameNumberSequenceGroup)
                {
                    SalesQuotationTable salesQuotationTable =  SalesQuotationTable::find(custOrderInfo.Id);
                    numberSequenceGroup = salesQuotationTable.NumberSequenceGroup;
                }
            }

            origEmail = orderHeader.Email;
        }

        if (RetailSkipInitFromCustomerDuringUpdateFlight::instance().isEnabled())
        {
            if (createNew)
            {
                RetailTransactionServiceOrders::initFromCustomer(createNew, isSales, orderHeader, custOrderInfo, origPaymMethod, origPaymMode, originalCreditCard);
            }
        }
        else
        {
            RetailTransactionServiceOrders::initFromCustomer(createNew, isSales, orderHeader, custOrderInfo, origPaymMethod, origPaymMode, originalCreditCard);
        }

        if (!createNew)
        {
            if (isSales)
            {
                orderHeader.getTableInInstanceHierarchy(tableNum(SalesTable)).setFieldValue("CreditCardCustRefId", originalCreditCard);
                orderHeader.getTableInInstanceHierarchy(tableNum(SalesTable)).setFieldValue("Payment", origPaymMethod);
                orderHeader.getTableInInstanceHierarchy(tableNum(SalesTable)).setFieldValue("PaymMode", origPaymMode);
            }

            if (isRetailKeepSameNumberSequenceGroup)
            {
                orderHeader.NumberSequenceGroup = numberSequenceGroup;
            }
            orderHeader.Email = origEmail;
        }

        orderHeader.InventLocationId = custOrderInfo.WarehouseId;
        orderHeader.setInventSiteId(InventLocation::find(custOrderInfo.WarehouseId).InventSiteId);

        // We should update the expedite value only for new sales order or existing sales order whose dlvMode is modified.
        boolean shouldUpdateHeaderExpediteBasedOnDlvMode = createNew || (orderHeader.DlvMode != custOrderInfo.DeliveryMode);

        orderHeader.DlvMode = custOrderInfo.DeliveryMode;
        orderHeader.ShippingDateRequested = str2Date(custOrderInfo.RequestedDeliveryDateString, 321);
        orderHeader.ReceiptDateRequested = str2Date(custOrderInfo.RequestedDeliveryDateString, 321);

        if (isSales && custOrderInfo.ConfirmedShipDateString)
        {
            SalesTable salesTable = orderHeader;
            salesTable.ShippingDateConfirmed = str2Date(custOrderInfo.ConfirmedShipDateString, 321);
        }

        orderHeader.CustomerRequisition = custOrderInfo.CustomerRequisition;
        orderHeader.CustomerRef = custOrderInfo.Comment;
        orderHeader.CurrencyCode = custOrderInfo.CurrencyCode ? custOrderInfo.CurrencyCode : CompanyInfoHelper::standardCurrency();

        if (RetailSkipShippingAddressPhoneNumberForPickupDlvModeFlight::instance().isEnabled())
        {
            // Use the shipping address's  phone number if the delivery mode is ship instead of customer's phone number.
            if (isSales && custOrderInfo.ShippingAddress.PhoneNumber && !RetailDlvMode::isPickupDeliveryMode(orderHeader.DlvMode))
            {
                orderHeader.Phone = custOrderInfo.ShippingAddress.PhoneNumber;
            }
        }
        else
        {
            if (isSales && custOrderInfo.ShippingAddress.PhoneNumber)
            {
                orderHeader.Phone = custOrderInfo.ShippingAddress.PhoneNumber;
            }
        }

        if (createNew && isSales &&
            (custOrderInfo.StatementId == '' || !RetailStatementFeatureControl::isSettlementNoneForSalesOrdersEnabled()))
        {
            SalesTable newSalesTable = orderHeader;
            newSalesTable.SettleVoucher = SettlementType::SelectedTransact;
        }

        // LocalizeTransactionEventNotification feature is enabled
        if (RetailUseChannelLanguageIdForOrderEventNotificationsFeatureExposure::isEnabled())
        {
            if (RetailLanguageIdCustomizationFlight::instance().isEnabled())
            {
                if (createNew)
                {
                    orderHeader.LanguageId = RetailTransactionServiceOrders::getCustomerOrderLanguageId(custOrderInfo, retailChannelTable);
                }
            }
            else
            {
                if (custOrderInfo.LanguageId != null && custOrderInfo.LanguageId != '')
                {
                    orderHeader.LanguageId = custOrderInfo.LanguageId;
                }
            }
        }

        // SalesGroup above is set from the customer settings.
        if (RetailDontOverrideCommissionSalesGroupFlight::instance().isEnabled())
        {
            if (custOrderInfo.CommissionSalesGroup != '')
            {
                // If the sales group is set at Channel side (mostly by the POS cashier),
                // override the value initialized by customer's default sales group.
                orderHeader.SalesGroup = custOrderInfo.CommissionSalesGroup;
            }
        }
        else
        {
            orderHeader.SalesGroup = custOrderInfo.CommissionSalesGroup;
        }

        orderHeader.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(
                                            custTable.DefaultDimension,
                                            retailChannelTable.DefaultDimension,
                                            RetailTerminalTable::find(custOrderInfo.TerminalId).DefaultDimension,
                                            hcmWorker.getDefaultDimension());

        if (custOrderInfo.IsTaxIncludedInPrice != '')
        {
            orderHeader.InclTax = custOrderInfo.IsTaxIncludedInPrice == 'True';
        }
        else
        {
            RetailStoreTable retailStoreTable = RetailStoreTable::findRecId(retailChannelTable.RecId);

            // If the transaction involved a walk-in customer, then RetailEx3 is always going to pick the PriceIncludeTax setting
            // from the Store. Otherwise, RetailEx3 would only get the setting from the store, if UseCustomerBasedTax is false.
            if (!retailStoreTable ||
                custOrderInfo.CustomerAccount == retailStoreTable.DefaultCustAccount ||
                !retailStoreTable.UseCustomerBasedTax)
            {
                orderHeader.InclTax = retailChannelTable.PriceIncludesSalesTax;
            }
        }

        if (!isSales)
        {
            SalesQuotationTable salesQuotationTable = orderHeader;
            if (custOrderInfo.ExpiryDateString)
            {
                salesQuotationTable.QuotationExpiryDate = str2Date(custOrderInfo.ExpiryDateString, 321);
            }
            else
            {
                salesQuotationTable.initExpiryDateFromQuotDate();
            }
            salesQuotationTable.initFollowUpDateFromExpiryDate();
            salesQuotationTable.QuotationStatus = SalesQuotationStatus::Created;
        }

        RefRecId postalAddressRecId = str2int64(custOrderInfo.AddressRecordId);
        LogisticsPostalAddress logisticsPostalAddress;
        if (postalAddressRecId)
        {
            logisticsPostalAddress = LogisticsPostalAddress::findRecId(postalAddressRecId);
        }
        else
        {
            if (!createNew && isSales)
            {
                postalAddressRecId = postalAddressRecIdOrig;
                logisticsPostalAddress = LogisticsPostalAddress::findRecId(postalAddressRecId);
            }
        }

        if (!postalAddressRecId || !logisticsPostalAddress)
        {
            boolean isDefaultCustomer = (retailChannelTable.DefaultCustAccount == custOrderInfo.CustomerAccount) && (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore);

            logisticsPostalAddress
                = RetailTransactionServiceCustomer::getExistingCustomerAddress(custOrderInfo.ShippingAddress.Street,
                    custOrderInfo.ShippingAddress.City,
                    custOrderInfo.ShippingAddress.State,
                    custOrderInfo.ShippingAddress.ZipCode,
                    custOrderInfo.ShippingAddress.ThreeLetterISORegionName,
                    custOrderInfo.ShippingAddress.StreetNumber,
                    custOrderInfo.ShippingAddress.County,
                    custOrderInfo.CustomerAccount,
                    custOrderInfo.ShippingAddress.Name,
                    custOrderInfo.ShippingAddress.BuildingCompliment,
                    custOrderInfo.ShippingAddress.DistrictName,
                    isDefaultCustomer);

            if (!logisticsPostalAddress)
            {
                container roleContainer;
                LogisticsPostalAddressRecId logisticsPostalAddressRecId;

                if (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore)
                {
                    roleContainer = [LogisticsLocationRole::findBytype(LogisticsLocationRoleType::Delivery).RecId];
                }
                else
                {
                    roleContainer = [LogisticsLocationRole::findBytype(LogisticsLocationRoleType::OneTime).RecId];
                }

                RetailTransactionServiceOrdersAddressParameters addressParamaters = new RetailTransactionServiceOrdersAddressParameters();
                addressParamaters.custAccount = custOrderInfo.CustomerAccount;
                addressParamaters.custName = custOrderInfo.ShippingAddress.Name;
                addressParamaters.streetNumber = custOrderInfo.ShippingAddress.StreetNumber;
                addressParamaters.street = custOrderInfo.ShippingAddress.Street;
                addressParamaters.city = custOrderInfo.ShippingAddress.City;
                addressParamaters.districtName = custOrderInfo.ShippingAddress.DistrictName;
                addressParamaters.county = custOrderInfo.ShippingAddress.county;
                addressParamaters.state = custOrderInfo.ShippingAddress.State;
                addressParamaters.zip = custOrderInfo.ShippingAddress.ZipCode;
                addressParamaters.country = custOrderInfo.ShippingAddress.ThreeLetterISORegionName;
                addressParamaters.phone = custOrderInfo.ShippingAddress.PhoneNumber;
                addressParamaters.email = custOrderInfo.ShippingAddress.Email;
                addressParamaters.buildingCompliment = custOrderInfo.ShippingAddress.BuildingCompliment;
                addressParamaters.roleContainer = roleContainer;
                addressParamaters.associateAddressToCustomer = isDefaultCustomer;
                addressParamaters.attentionTo = custOrderInfo.ShippingAddress.AttentionToAddressLine;

                logisticsPostalAddressRecId = RetailTransactionServiceOrders::createAddressUsingParameters(addressParamaters);

                logisticsPostalAddress = LogisticsPostalAddress::findRecId(LogisticsPostalAddressRecId);
            }
        }

        if (logisticsPostalAddress)
        {
            Email defaultEmail = orderHeader.Email;

            if (RetailSkipDeliveryRoleCheckDeliveryNameInCustomerOrderFlight::instance().isEnabled() && isSales)
            {
                // By passing 'true' as second parameter we are skipping delivery role check,
                // so that logisticsLocation.Description instead of party.Name is assigned to delivery name on sales order header.
                orderHeader.setLocation(logisticsPostalAddress.Location, true);
            }
            else
            {
                orderHeader.setLocation(logisticsPostalAddress.Location);
            }

            // if the address Location set above does not have an email, revert back to the customer's email
            if (!orderHeader.Email)
            {
                orderHeader.Email = defaultEmail;
            }
        }

        // Use the email address for the order if specified
        if (custOrderInfo.Email)
        {
            orderHeader.Email = custOrderInfo.Email;
        }

        RetailOrderHeaderExtensionMap orderHeaderExt = orderHeader.RetailOrderHeaderMap::getRetailExtension();

        if (!orderHeaderExt)
        {
            orderHeaderExt.RetailOrder = NoYes::Yes;

            // Set the statementId for sales orders, value is non-blank for orders coming from statement posting only.
            if (isSales)
            {
                orderHeaderExt.StatementId = ReflectionHelper::getObjectProperty(custOrderInfo, StatementIdStr);
            }
        }

        if (createNew)
        {
            // get all the discount codes on the transaction
            // Discount codes are obsolete. We are setting discount codes here for N-1 compatibility.
            StringCollection discountCodesCollection = custOrderInfo.DiscountCodes as StringCollection;
            int discountcodesCnt = discountCodesCollection.get_Count();
            container discountCodes = conNull();
            for (int i = 0; i < discountcodesCnt; i++)
            {
                discountCodes += [discountCodesCollection.get_Item(i) as System.String];
            }

            RetailHour          retailHourTable;
            select RecId from retailHourTable where retailHourTable.RetailHourOfDay == custOrderInfo.LocalHourOfDay;

            orderHeader.setPriceDiscChangePolicy(PriceDiscSystemSource::RetailPOS);
            orderHeaderExt.omInternalOrganization = retailChannelTable.OMOperatingUnitID;
            orderHeaderExt.RetailChannel = retailChannelTable.RecId;
            // As part of B2b orders from call center,
            // to keep the track of channel where order is created, OriginChannel is added.
            // to keep the data consistency origin channel will be updated during create
            // and should not be modfified once the order is created.
            orderHeaderExt.OriginChannel = retailChannelTable.RecId;
            orderHeaderExt.RetailStoreId = custOrderInfo.StoreId;
            orderHeaderExt.RetailTerminalId = custOrderInfo.TerminalId;
            orderHeaderExt.RetailHourOfDay = retailHourTable.RecId;
            orderHeaderExt.ChannelReferenceId = custOrderInfo.ChannelReferenceId;
            orderHeaderExt.InitialReceiptId = custOrderInfo.InitialReceiptId;
            orderHeaderExt.DiscountCodes = discountCodes;
            orderHeaderExt.TotalManualDiscountAmount = custOrderInfo.TotalManualDiscountAmount;
            orderHeaderExt.TotalManualDiscountPercentage = custOrderInfo.TotalManualDiscountPercentage;
            orderHeaderExt.OriginalTransactionTime = custOrderInfo.OriginalTransactionTime;
            orderHeaderExt.IsTaxExemptedForPriceInclusive = custOrderInfo.IsTaxExemptedForPriceInclusive;

            if (!RetailTaxUpdateTaxOverrideCodeForBothCreateAndUpdateFlight::instance().isEnabled())
            {
                orderHeaderExt.TaxOverrideCode = RetailTransactionServiceOrders::getTaxOverrideCode(custOrderInfo);
            }

            if (isSales)
            {
                orderHeaderExt.PaymentsType = RetailCommercePaymentsFeatureHelper::getPaymentsType(custOrderInfo);

                eventSource.EventWriteOrdersCreateOrUpdateRetailOrderHeaderPaymentsType(custTable.RecId, enum2Symbol(enumNum(RetailPaymentsType), orderHeaderExt.PaymentsType));
            }
        }

        // get all the coupons on the transaction
        if (isSales)
        {
            container coupons = conNull();
            PropertyInfo couponsPropertyInfo = custOrderInfo.GetType().GetProperty(#Coupons);
            if (couponsPropertyInfo)
            {
                CLRObject couponCollection = System.Activator::CreateInstance(couponsPropertyInfo.PropertyType);
                couponCollection = couponsPropertyInfo.GetValue(custOrderInfo);
                int couponsCnt = couponCollection.get_Count();

                if (couponsCnt > 0)
                {
                    var couponPropertyInfo = couponCollection.GetType().GetProperty('Item');

                    for (int i = 0; i < couponsCnt; i++)
                    {
                        System.Object[] indexes = new System.Object[1]();
                        indexes.SetValue(i, 0);
                        System.Object coupon = couponPropertyInfo.GetValue(couponCollection, indexes);
                        str id = coupon.GetType().GetProperty(#CodeId).GetValue(coupon);
                        str code = coupon.GetType().GetProperty(CodeStr).GetValue(coupon);
                        str discountOfferId = coupon.GetType().GetProperty(#DiscountOfferId).GetValue(coupon);

                        coupons += [id, code, discountOfferId];
                    }
                }

                orderHeaderExt.Coupons = coupons;
            }
        }

        orderHeaderExt.RetailPrepaymentOverridden = (isSales && custOrderInfo.PrepaymentAmountOverridden) ? NoYes::Yes : NoYes::No;
        orderHeaderExt.RetailLoyaltyCard = RetailLoyaltyCard::findByCardNumber(custOrderInfo.LoyaltyCardId).RecId;

        if (RetailTaxUpdateTaxOverrideCodeForBothCreateAndUpdateFlight::instance().isEnabled())
        {
            orderHeaderExt.TaxOverrideCode = RetailTransactionServiceOrders::getTaxOverrideCode(custOrderInfo);
        }

        //If there isn't any header-level DlvMode, try to get it from the lines.
        If (!orderHeader.DlvMode)
        {
            orderHeader.DlvMode = RetailTransactionServiceOrders::getDlvModeFromLines(custOrderInfo.Items);
        }

        //For sales order, set values for mcrSalesTable
        if (isSales && retailStore && retailStore.IsCallCenter)
        {
            mcrSalesTable.SourceId              = custOrderInfo.SourceId;
            mcrSalesTable.PriceOverride         = custOrderInfo.IsPriceOverride;
            mcrSalesTable.FTCExempt             = custOrderInfo.IsFTCExempt;
            mcrSalesTable.CatalogUpSellShown    = custOrderInfo.IsCatalogUpSellShown;
            mcrSalesTable.ContinuityOrder       = custOrderInfo.IsContinuityOrder;
            mcrSalesTable.ContinuityChild       = custOrderInfo.IsContinuityChild;
            mcrSalesTable.ContinuityLineEval    = custOrderInfo.ContinuityLineEval;
            mcrSalesTable.OutOfBalanceReleased  = custOrderInfo.OutOfBalanceReleaseType;
            mcrSalesTable.PaymOutOfBalance      = custOrderInfo.PaymentOutOfBalanceType;
            mcrSalesTable.SOAllocPriority       = custOrderInfo.AllocationPriority;
            mcrSalesTable.PromptedForInstBillingOption  = custOrderInfo.IsInstallmentBillingPrompt;
            mcrSalesTable.InstallmentOrderSubmitted     = custOrderInfo.IsInstallmentOrderSubmitted;
        }

        if (createNew)
        {
            // Inserting retailchannel field of sales table for retail channel sales order.
            orderHeader.RetailChannelTable = retailChannelTable.RecId;
        }

        RetailTransactionServiceOrders::checkOrderModeOfPayment(orderHeader);

        // Extensibility point before insertion of records
        RetailCustomerOrderHeaderParameters args = RetailCustomerOrderHeaderParameters::construct();
        args.custOrderInfo = custOrderInfo;
        args.orderHeader = orderHeader;
        args.orderHeaderExt = orderHeaderExt;
        args.mcrSalesTable = mcrSalesTable;
        args.createNew = createNew;

        RetailCreateCustomerOrderExtensions::orderHeaderBeforeInsert(args);

        // set sales agreement id if exists.
        RetailTransactionServiceSalesAgreement::setSalesAgreementOnHeader(orderHeader, custOrderInfo.SalesAgreementRecordId);

        orderHeader.RetailOrderHeaderMap::packRetailOrderHeaderExtension(orderHeaderExt, mcrSalesTable);

        if (isSales)
        {
            SalesTable salesTable = orderHeader;
            if (RetailSynchronizeOrderRequestedDeliveryDateValidationFlight::instance().isEnabled() && salesTable.isInterCompanyOrder())
            {
                RetailTransactionServiceOrders::setRequestedDeliveryDateForOrderHeader(orderHeader);
            }

            // Update expedite value based on mode of delivery.
            if (RetailUpdateExpediteValueBasedOnModeOfDeliveryFlight::instance().isEnabled()
                && shouldUpdateHeaderExpediteBasedOnDlvMode)
            {
                orderHeader.mcrDlvModeModified();
            }
        }

        // Create sales order and SKIP additional Markup charges
        if (createNew)
        {
            RetailStatementPostingLogger::Info(funcName(), #linenumber, 'Insert into salesTable.');
            orderHeader.insert(true);
        }
        else
        {
            RetailStatementPostingLogger::Error(funcName(), #linenumber, 'Update salesTable - In plan B, we should never call sales order update.');
            orderHeader.update();
        }

        if (!RetailUpdateExpediteValueBasedOnModeOfDeliveryFlight::instance().isEnabled())
        {
            RetailTransactionServiceOrders::createOrUpdateHeaderExpedite(createNew, orderHeader);
        }

        var taxCalculationBehaviorController = RetailTaxCalculationBehaviorCustomerOrderInfoController::construct(custOrderInfo);

        if (isSales && taxCalculationBehaviorController.allowHeaderLevelTaxAdjustments())
        {
            SalesTable salesTable = orderHeader;
            RetailTransactionServiceOrders::CreateTaxLines(salesTable.TableId, salesTable.RecId, custOrderInfo.Taxes, taxAdjustmentsMap);
        }

        // saves info codes
        RetailInfoCodeLineRelatedTableType tableType;
        if (isSales)
        {
            tableType = RetailInfoCodeLineRelatedTableType::Sales;
        }
        else
        {
            tableType = RetailInfoCodeLineRelatedTableType::Quote;
        }

        RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(orderHeader.RecId, orderHeader.RecId, ReflectionHelper::getObjectProperty(custOrderInfo, 'ReasonCodeLines'), tableType);

        // create or update retail attributes on header level
        RetailAttributeHelper::createOrUpdateRetailSalesOrderAttributeValues(
            str2int64(custOrderInfo.ChannelRecordId),
            custOrderInfo.StoreId,
            custOrderInfo.TerminalId,
            custOrderInfo.TransactionId,
            custOrderInfo.Id,
            custOrderInfo.DataAreaId,
            0,
            custOrderInfo.AttributeValues);

        RetailTransactionServiceOrders::CreateNotes(orderHeader.RecId, orderHeader.TableId, custOrderInfo.DataAreaId, custOrderInfo.Notes);

        eventSource.EventWriteOrdersCreateOrUpdateRetailOrderHeaderFinish(isSales, orderHeader.RecId, custTable.RecId, custOrderInfo.StatementId, aggregationHeaderRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOrderModeOfPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks payment method properits of retail Sales order
    /// </summary>
    /// <param name = "_orderHeader">Retail order to check</param>
    /// <exception cref="M:Exception::Error">Throws the exception in case validation fails.</exception>
    [Replaceable]
    protected static void checkOrderModeOfPayment(RetailOrderHeaderMap _orderHeader)
    {
        if (_orderHeader is SalesTable)
        {
            SalesTable salesTable = _orderHeader as SalesTable;

            if (salesTable.PaymMode && CustPaymModeTable::find(salesTable.PaymMode).IsSEPA)
            {
                if(salesTable.DirectDebitMandate)
                {
                    CustDirectDebitMandate::validateMandate(salesTable.DirectDebitMandate, false, true);
                }
                else
                {
                    str errorMessage = strFmt(
                    "@Retail:PaymentMethodHasDirectDebitButMandateIsNotSet",
                    salesTable.PaymMode,
                    salesTable.CustAccount);

                    throw error(errorMessage);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateTaxLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create tax lines for the given Retail transaction header or line entry.
    /// </summary>
    /// <param name="tableId">
    /// The table id of record that tax amounts will be added to.
    /// </param>
    /// <param name="recId">
    /// The record id of record that tax amounts will be added to.
    /// </param>
    /// <param name="taxInfoCollection">
    /// The collection of taxes are being created from.
    /// </param>
    /// <param name="taxAdjustmentsMap">
    /// The map containing all tax adjustments.
    /// </param>
    /// <remarks>
    /// Creates tax adjustments for tax amounts from Retail Transaction tax entries.
    /// </remarks>
    private static void CreateTaxLines(TableId tableId, RefRecId recId, TaxInfoCollection taxInfoCollection, Map taxAdjustmentsMap)
    {
        if (taxAdjustmentsMap == null)
        {
            // for quotations, returns & customer order updates, tax adjustments map is null.
            return;
        }

        for (int i = 0; i < taxInfoCollection.get_Count(); i++)
        {
            TaxInfo taxInfo = taxInfoCollection.get_Item(i) as TaxInfo;

            var taxCode = taxInfo.TaxCode;
            var key = RetailTransactionServiceOrders::generateTaxAdjusmentMapKey(tableId, recId, taxCode);

            if (taxAdjustmentsMap.exists(key))
            {
                TaxAmount existingAmount;
                [tableId, recId, taxCode, existingAmount]  = taxAdjustmentsMap.lookup(key);

                TaxAmount newAmount = taxInfo.Amount + existingAmount;

                taxAdjustmentsMap.insert(key, [tableId, recId, taxCode, newAmount]);
            }
            else
            {
                taxAdjustmentsMap.insert(key, [tableId, recId, taxCode, taxInfo.Amount]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTaxAdjusmentMapKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a string that will serve as a unique key for the tax adjustments map.
    /// </summary>
    /// <param name = "_tableId">The TableId.</param>
    /// <param name = "_recId">The RecId.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <returns>A string that can be used in the tax adjustments map, guaranteed to be unique.</returns>
    private static str generateTaxAdjusmentMapKey(TableId _tableId, RefRecId _recId, TaxCode _taxCode)
    {
        return strFmt('#%1#%2#%3', _tableId, _recId, _taxCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all the tax adjustments to the database.
    /// </summary>
    /// <param name = "_taxAdjustments">A map containing all the tax adjustments.</param>
    private static void insertTaxAdjustments(Map _taxAdjustments)
    {
        boolean shouldInvertSigns = RetailTaxAdjustmentSignToggle::instance().isEnabled();

        MapEnumerator mapEnumerator = _taxAdjustments.getEnumerator();

        RecordInsertList taxWorkRegulationList = new RecordInsertList(tableNum(TaxWorkRegulation));

        while (mapEnumerator.moveNext())
        {
            TableId tableId;
            RecId recId;
            TaxCode taxCode;
            TaxAmount taxAmount;

            [tableId, recId, taxCode, taxAmount]  = mapEnumerator.currentValue();

            if (shouldInvertSigns)
            {
                // The data we save in RetailTransactionTaxTrans & RetailTransactionChargeTaxTrans always have the opposite sign of what's expected in TaxWorkRegulation.
                // Example:
                // - Records for RetailTransactionSalesTrans representing a sale will have POSITIVE amounts in its tax transactions.
                // - SalesLine representing a sale must have NEGATIVE amounts on TaxWorkRegulation
                taxAmount = -taxAmount;
            }

            TaxWorkRegulation taxWorkRegulation;
            taxWorkRegulation.TaxRegulationAmountCur = taxAmount;
            taxWorkRegulation.ActualTaxRegulationAmountCur = taxAmount;
            taxWorkRegulation.HeadingTableId = tableId;
            taxWorkRegulation.HeadingRecId = recId;
            taxWorkRegulation.TaxCode = taxCode;
            taxWorkRegulation.TaxDirection = TaxDirection::OutgoingTax;
            taxWorkRegulation.ManualInsertedTax = NoYes::No;

            taxWorkRegulationList.add(taxWorkRegulation);
        }

        taxWorkRegulationList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateTaxMeasureAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create tax measure adjustments for the given Retail transaction header or line entry.
    /// </summary>
    /// <param name="headingTableId">
    /// The table id of transaction header record that tax amounts will be added to.
    /// </param>
    /// <param name="headingRecId">
    /// The record id of transaction header record that tax amounts will be added to.
    /// </param>
    /// <param name="tableId">
    /// The table id of record that tax amounts will be added to.
    /// </param>
    /// <param name="recId">
    /// The record id of record that tax amounts will be added to.
    /// </param>
    /// <param name="taxMeasureInfoCollection">
    /// The collection of tax measure are being created from.
    /// </param>
    /// <param name="taxAdjustmentsMap">
    /// The map containing all information about tax adjustments.
    /// </param>
    /// <remarks>
    /// Creates tax measure adjustments for tax amounts from Retail Transaction tax entries.
    /// </remarks>
    private static void CreateTaxMeasureAdjustments(
        RefTableId _headingTableId,
        RefRecId _headingRecId,
        TableId _tableId,
        RefRecId _recId,
        TaxMeasureInfoCollection _taxMeasureInfoCollection,
        Map _taxAdjustmentsMap)
    {
        const int taxAmountPositionInAdjustmentMapRow = 6;

        if (_taxAdjustmentsMap == null)
        {
            // for quotations, returns & customer order updates, tax adjustments map is null.
            return;
        }
        else if (RetailAdvancedGTETaxAdjustmentFeatureExposure::IsEnabled() &&
            _taxMeasureInfoCollection.get_Count() == 0)
        {
            // If no tax from retail, insert the map with empty path to indicate there is no tax in order to do tax applicability adjustment
            // to ensure that no tax is calculated at HQ too.
            _taxAdjustmentsMap.insert(strFmt(TaxAdjustmentMapKeyTemplate, _tableId, _recId, ''), [_tableId, _recId, _headingTableId, _headingRecId, '', 0]);
            return;
        }

        for (int i = 0; i < _taxMeasureInfoCollection.get_Count(); i++)
        {
            TaxMeasureInfo taxMeasureInfo = _taxMeasureInfoCollection.get_Item(i) as TaxMeasureInfo;

            if (taxMeasureInfo != null)
            {
                ERDataItemPath path = taxMeasureInfo.get_Path();
                var key = strFmt(TaxAdjustmentMapKeyTemplate, _tableId, _recId, path);

                TaxAmount taxAmount = taxMeasureInfo.get_Value();

                if (_taxAdjustmentsMap.exists(key))
                {
                    container taxAdjustmentsInfoContainer = _taxAdjustmentsMap.lookup(key);

                    taxAmount += conPeek(taxAdjustmentsInfoContainer, taxAmountPositionInAdjustmentMapRow);
                }

                _taxAdjustmentsMap.insert(key, [_tableId, _recId, _headingTableId, _headingRecId, path, taxAmount]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxMeasureAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all the tax measure adjustments to the database.
    /// </summary>
    /// <param name = "_taxAdjustmentsMap">A map containing all the information about tax adjustments.</param>
    /// <remarks>The adjustment includes two parts, one is component adjustment to adjust tax applicability which will be saved into
    /// TaxDocumentRowTaxDeterminedInfo table and TaxDocumentRowDeterminedComponent table, and another is tax value adjustment
    /// which will be saved into TaxDocumentRowMeasureAdjustment.</remarks>
    private static void insertTaxMeasureAdjustments(Map _taxAdjustmentsMap)
    {
        MapEnumerator mapEnumerator = _taxAdjustmentsMap.getEnumerator();

        RecordInsertList determinedInfoList = new RecordInsertList(tableNum(TaxDocumentRowTaxDeterminedInfo));
        RecordInsertList determinedComponentList = new RecordInsertList(tableNum(TaxDocumentRowDeterminedComponent));
        RecordInsertList measureAdjustmentList = new RecordInsertList(tableNum(TaxDocumentRowMeasureAdjustment));
        Set processedSalesLines  = new Set(Types::Container);
        Set processedLineComponents = new Set(Types::Container);

        TaxDocumentRowTaxDeterminedInfo determinedInfo;
        TaxDocumentRowDeterminedComponent determinedComponent;
        TaxDocumentRowMeasureAdjustment taxDocumentRowMeasureAdjustment;

        SystemSequence systemSequence = new SystemSequence();
        systemSequence.suspendRecIds(tableNum(TaxDocumentRowTaxDeterminedInfo));

        try
        {
            boolean isAdvancedGTETaxAdjustmentFeatureEnabled = RetailAdvancedGTETaxAdjustmentFeatureExposure::IsEnabled();

            while (mapEnumerator.moveNext())
            {
                RefTableId headingTableId;
                RefRecId headingRecId;
                TableId tableId;
                RefRecId recId;
                ERDataItemPath path;
                TaxAmount taxAmount;

                [tableId, recId, headingTableId, headingRecId, path, taxAmount]  = mapEnumerator.currentValue();

                if(isAdvancedGTETaxAdjustmentFeatureEnabled)
                {
                    if (!processedSalesLines .in([tableId, recId]))
                    {
                        // TaxDocumentRowTaxDeterminedInfo is for line level, just need one recored per line.
                        determinedInfo.HeadingTableId       = headingTableId;
                        determinedInfo.HeadingRecId         = headingRecId;
                        determinedInfo.OriginSourceTableId  = tableId;
                        determinedInfo.OriginSourceRecId    = recId;
                        determinedInfo.IsManualDetermined   = NoYes::Yes;
                        determinedInfo.RecId                = systemSequence.reserveValues(1, tableNum(TaxDocumentRowTaxDeterminedInfo));
                        determinedInfoList.add(determinedInfo);

                        processedSalesLines .add([tableId, recId]);
                    }


                    // Get tax component path which is the parent the path of tax amount measure
                    // e.g. "Header/Lines/GST/IGST/Tax Amount" => "Header/Lines/GST/IGST"
                    ERDataItemPath componentPath = ERPath::GetParent(path);

                    if (!processedLineComponents.in([tableId, recId, componentPath]))
                    {
                        // TaxDocumentRowDeterminedComponent is to determine the applicable component, it should be unique per one componenet.
                        determinedComponent.DeterminedInfo = determinedInfo.RecId;
                        determinedComponent.DocComponentPath = componentPath;
                        determinedComponentList.add(determinedComponent);

                        processedLineComponents.add([tableId, recId, componentPath]);
                    }
                }

                taxDocumentRowMeasureAdjustment.HeadingTableId = headingTableId;
                taxDocumentRowMeasureAdjustment.HeadingRecId = headingRecId;
                taxDocumentRowMeasureAdjustment.SourceTableId = tableId;
                taxDocumentRowMeasureAdjustment.SourceRecId = recId;
                taxDocumentRowMeasureAdjustment.Path = path;
                taxDocumentRowMeasureAdjustment.AdjustAmount = taxAmount;
                measureAdjustmentList.add(taxDocumentRowMeasureAdjustment);
            }

            determinedInfoList.insertDatabase();
            determinedComponentList.insertDatabase();
            measureAdjustmentList.insertDatabase();
        }
        finally
        {
            systemSequence.removeRecIdSuspension(tableNum(TaxDocumentRowTaxDeterminedInfo));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReturnReasonCodeForRetailSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates return reason code for the retail sales line.
    /// </summary>
    /// <param name = "_orderLine">The order line information.</param>
    /// <param name = "_itemInfo">The serialized item information.</param>
    private static void updateReturnReasonCodeForRetailSalesLine(
                                    RetailOrderLineMap _orderLine,
                                    ItemInfo _itemInfo)
    {
        // Replace reflection with strong typed access when the versioning problem is solved.
        PropertyInfo returnReasonCodeIdProperty = _itemInfo.GetType().GetProperty("ReturnReasonCodeId");
        if (returnReasonCodeIdProperty == null)
        {
            return;
        }

        RetailSalesLine retailSalesLine = RetailSalesLine::findBySalesLine(_orderLine.RecId, true);
        if (!retailSalesLine)
        {
            return;
        }

        retailSalesLine.ReturnReasonCodeId = returnReasonCodeIdProperty.GetValue(_itemInfo);
        retailSalesLine.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateRetailOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates retail order or quotation lines.
    /// </summary>
    /// <param name = "_orderHeader">Retail order/quotation header information.</param>
    /// <param name = "_customerOrderInfo">The customer order information.</param>
    /// <param name = "_aggregate">Indicates whether line aggregation required.</param>
    /// <param name="_isCustomerOrderReturnWithExchange">Indicates whether customer order mode is return with exchange.</param>
    /// <param name = "_advanceInvoiceContract">Advance invoice contract.</param>
    /// <param name="_taxAdjustmentsMap">The map containing all tax adjustments.</param>
    /// <param name="_reuseInventoryReservation">
    /// Determines if we can reuse the existing inventory reservation.
    /// </param>
    protected static void createOrUpdateRetailOrderLines(
                                    RetailOrderHeaderMap _orderHeader,
                                    CustomerOrderInfo _customerOrderInfo,
                                    boolean _aggregate = false,
                                    boolean _isCustomerOrderReturnWithExchange = false,
                                    AdvanceInvoiceContract_W _advanceInvoiceContract = null,
                                    Map _taxAdjustmentsMap = null,
                                    boolean _reuseInventoryReservation = false)

    {
        boolean                 isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        SalesLine               salesLine;
        SalesQuotationLine      salesQuotationLine;
        RetailOrderLineMap      orderLine;
        boolean                 isSales;
        SalesLine               originalSalesLine;
        InventDimId             returnInventDimId;
        RecId                   aggregationHeaderRecId = RetailStatementCompatibilityHelper::getAggregationHeaderRecId(_customerOrderInfo);

        var taxCalculationBehaviorController = RetailTaxCalculationBehaviorCustomerOrderInfoController::construct(_customerOrderInfo);

        ItemInfoCollection itemCollection = _customerOrderInfo.Items;
        switch (_orderHeader.TableId)
        {
            case tableNum(SalesQuotationTable):
                // Remove existing quote lines first before creating new ones.
                delete_from salesQuotationLine where salesQuotationLine.QuotationId == _orderHeader.Id;
                isSales = false;
                orderLine = salesQuotationLine;
                break;
            case tableNum(SalesTable):
                if (!_aggregate)
                {
                    SalesLine salesLineLookup;
                    while select RecId, SalesStatus from salesLineLookup
                        where salesLineLookup.SalesId == _orderHeader.Id
                    {
                        if (salesLineLookup.SalesStatus == SalesStatus::Canceled)
                        {
                            continue;
                        }

                        boolean lineFound = false;

                        for (int i=0; i < itemCollection.get_Count(); i++)
                        {
                            ItemInfo itemInfo = itemCollection.get_Item(i) as ItemInfo;
                            if (itemInfo.RecId == salesLineLookup.RecId)
                            {
                                lineFound = true;
                                break;
                            }
                        }

                        if (!lineFound)
                        {
                            delete_from salesLine where salesLine.RecId == salesLineLookup.RecId;

                            if (_advanceInvoiceContract != null)
                            {
                                _advanceInvoiceContract.parmCancelOpenedAdvanceInvoices(true);
                            }
                        }
                    }
                }
                isSales = true;
                orderLine = salesLine;
                break;
            default:
                return;
        }

        WMSJournalTable wmsJournalTable;
        WMSJournalTrans wmsJournalTrans;
        boolean hasInclTaxBeenSet = false;
        int numLines = 0;
        Set unshownAttributeNames = new Set(Types::String);
        RetailParameters retailParamsTable = RetailParameters::find();

        System.Diagnostics.Stopwatch inventoryRemovalStopWatch = new System.Diagnostics.Stopwatch();
        int countOfInventoryRemoval = 0;

        for (int i = 0; i < itemCollection.get_Count(); i++)
        {
            eventSource.EventWriteOrdersCreateOrUpdateRetailOrderLineStart(_orderHeader.RecId, i, _customerOrderInfo.StatementId, aggregationHeaderRecId);

            RefRecId fromInventTransOrigin;
            ItemInfo itemInfo = itemCollection.get_Item(i) as ItemInfo;
            InventTransId originalInventTransId;
            InventDim inventDim = RetailTransactionServiceOrders::createInventDim(itemInfo);
            boolean isReturnLine = itemInfo.Quantity < 0;

            // Update customer order return line's batch number with batch number of original salesline transaction.
            if (isSales && isReturnLine && SalesTable::find(_orderHeader.Id).getRetailSalesOrderType() == RetailSalesOrderType::CustomerOrder)
            {
                inventDim = RetailTransactionServiceOrders::updateBatchIdForReturnCustomerOrder(inventDim, itemInfo);
            }

            // Remove reservations here if:
            // - Statement posting is executing (statementId != '')
            // - Statement aggregation is ON
            // - AggregationHeader.RecId not is found (only happens if the CustomerOrderInfo XML was generated before the hotfix was installed).
            if (_customerOrderInfo.StatementId != ''
                && RetailEodStatementConfigurationAccessor::constructFromStatementId(_customerOrderInfo.StatementId).isAggregateBeforePosting()
                && aggregationHeaderRecId == 0)
            {
                container results;

                results = RetailTransactionServiceOrders::removeInventoryReservationsV2(_customerOrderInfo, itemInfo, inventoryRemovalStopWatch, inventDim, _reuseInventoryReservation);

                fromInventTransOrigin = conPeek(results, 1);
                returnInventDimId = conPeek(results, 2);
                countOfInventoryRemoval += conPeek(results, 3);
            }
            else
            {
                originalInventTransId = itemInfo.InventTransId;

                if (originalInventTransId)
                {
                    inventoryRemovalStopWatch.Start();

                    fromInventTransOrigin = InventTrans::findTransId(originalInventTransId).InventTransOrigin;

                    RetailTransactionSalesTrans salesTrans;
                    select sum(Qty) from salesTrans
                        group by ItemId, Unit, inventDimId, inventTransId
                        where   salesTrans.store            == _customerOrderInfo.StoreId
                            &&  salesTrans.inventTransId    == originalInventTransId;

                    if (salesTrans.qty)
                    {
                        returnInventDimId = salesTrans.inventDimId;

                        if (!_reuseInventoryReservation)
                        {
                            salesTrans.RemoveReservation();
                            salesTrans.DeleteInventoryReservation();
                            countOfInventoryRemoval++;
                        }
                    }

                    inventoryRemovalStopWatch.Stop();
                }
            }

            InventDim salesTransInventDim, trackingRegisterInventDim;

            // Since carry out will post invoice immediately, so the location of WHS enabled carry out item should not be cleared,
            // otherwise it will fail to post invoice in this method.
            boolean isCarryOutLine =  retailParamsTable.CarryOutDeliveryModeCode && itemInfo.DeliveryMode == retailParamsTable.CarryOutDeliveryModeCode;

            //Clear the location in the folllowing scenarios:
            //    1. Line is not cash and carry.
            //    2. Advanced Warehouse Management is enabled for the item.
            //    3. Delivery mode is not empty.
            //    4. Line is not a return.
            //    5. Location is not empty.
            if (RetailCreateCustomerOrderExtensions::allowResetRetailOrderLineWarehouse(itemInfo, inventDim, isCarryOutLine))
            {
                inventDim.wMSLocationId = '';
                inventDim = InventDim::findOrCreate(inventDim);
            }
            // Kept for backwards compatibility
            else if (isReturnLine && !RetailStatementCompatibilityHelper::useAggregatedWmsLocationId())
            {
                // Aggregated scenario for statement posting
                System.Object inventDimensionObject = ReflectionHelper::getObjectProperty(itemInfo, 'InventDimensionId');

                if (inventDimensionObject != null && inventDimensionObject.ToString() != '')
                {
                    InventDimId inventDimId = inventDimensionObject.toString();
                    inventDim.wMSLocationId = InventDim::find(inventDimId).wMSLocationId;
                }
                // Non aggregated scenarios for statement posting
                else if (returnInventDimId)
                {
                    inventDim.wMSLocationId = InventDim::find(returnInventDimId).wMSLocationId;
                }
            }

            boolean lineFound = false;
            if (!isReturnLine)
            {
                if (isSales && !itemInfo.Giftcard)
                {
                    if (!_aggregate)
                    {
                        salesLine = salesLine::findRecId(itemInfo.RecId, true);
                        if (salesLine)
                        {
                            // if we find the sales line we are updating an existing salesorder.
                            // if the status is cancelled during the update, this means we are working with a cancelled line
                            // and we skip this update for this line.
                            if (salesLine.SalesStatus == SalesStatus::Canceled)
                            {
                                continue;
                            }
                            lineFound = true;
                        }
                    }
                    else
                    {
                        salesLine = SalesLine::findByRetailSalesTrans(_orderHeader.Id, _orderHeader.CustAccount, itemInfo);

                        if (salesLine)
                        {
                            AmountCur totalItemLineDisc = itemInfo.Discount * itemInfo.Quantity;
                            itemInfo.Quantity += salesLine.SalesQty;

                            // delete the sales line if the quantity of the line is zero.
                            if (itemInfo.Quantity == 0)
                            {
                                SalesLine deleteSalesLine;
                                delete_from deleteSalesLine where deleteSalesLine.RecId == salesLine.RecId;
                                continue;
                            }
                            else
                            {
                                RetailSalesLine retailSalesLine = salesLine.retailSalesLine();
                                itemInfo.LineDscAmount += retailSalesLine.LineDscAmount;
                                itemInfo.PeriodicDiscount += retailSalesLine.PeriodicDiscount;
                                itemInfo.TotalDiscount += retailSalesLine.TotalDiscount;
                                itemInfo.TenderDiscount += retailSalesLine.TenderDiscount;
                                itemInfo.TenderDiscountPercentage += retailSalesLine.TenderDiscountPercentage;
                                itemInfo.LineManualDiscountAmount += retailSalesLine.LineManualDiscountAmount;

                                itemInfo.NetAmount += salesLine.LineAmount;
                                itemInfo.Discount = (salesLine.lineDisc * salesLine.SalesQty + totalItemLineDisc) / itemInfo.Quantity;

                                salesLine.selectForUpdate(true);
                                lineFound = true;
                            }
                        }
                    }
                    orderLine = salesLine;
                }
            }
            else
            {
                // if returnLine is found then assign it to salesLine and orderLine, lineFound will be true
                if (isSales && !itemInfo.Giftcard)
                {
                    if (!_aggregate)
                    {
                        SalesLine salesLineReturnFound = salesLine::findRecId(itemInfo.RecId, true);

                        // If salesLineReturnFound is not found then salesLine and orderLine remains same
                        // We need to check SalesQty to make sure that this not a return that has found the original line.
                        if (salesLineReturnFound && salesLineReturnFound.SalesQty < 0 && salesLineReturnFound.SalesId == _customerOrderInfo.Id)
                        {
                            salesLine = salesLineReturnFound;
                            orderLine = salesLineReturnFound;
                            lineFound = true;
                        }
                    }
                }
                InventTable inventTable = inventTable::find(itemInfo.ItemId);
                salesTransInventDim.data(inventDim);
                salesTransInventDim.moveDimParmDim(inventTable.inventDimParmSalesProcessActiveDim(), trackingRegisterInventDim);

                originalSalesLine = SalesLine::findInventTransId(itemInfo.ReturnInventTransId);

                // If originalSalesLine is not found then the SalesTable.InclTax will remain set as per channel settings
                if (RetailReturnOrderCopyInclTaxFromOriginalToggle::instance().isEnabled() && !hasInclTaxBeenSet && originalSalesLine.SalesId)
                {
                    // set prices includes sales tax property from original sales order created
                    SalesTable salesTable = _orderHeader;
                    salesTable.InclTax = SalesTable::find(originalSalesLine.SalesId).InclTax;
                    salesTable.update();
                    hasInclTaxBeenSet = true;
                }
            }

            if (!lineFound)
            {
                orderLine.clear();
                orderLine.Id = _orderHeader.Id;
                orderLine.RetailOrderLineMap::initFromHeader(_orderHeader);
            }

            orderLine.ItemId = itemInfo.ItemId;

            if (_customerOrderInfo.StatementId)
            {
                orderLine.SalesOrderCreationMethod = SalesSalesOrderCreationMethod::RetailStatement;
            }

            NoYes taxOnGiftCards;
            if (_customerOrderInfo.StatementId)
            {
                taxOnGiftCards = RetailEodStatementConfigurationAccessor::constructFromStatementId(_customerOrderInfo.StatementId).isTaxOnGiftCards();
            }
            else
            {
                taxOnGiftCards = retailParamsTable.TaxOnGiftCards;
            }

            orderLine.SalesQty = itemInfo.Quantity;

            // Skip assigning Tax Group and Item Tax group if Tax on Gift card is set and store has price included sales tax as well as line is a gift card line.
            RetailStoreTable retailStoreTableLocal = RetailStoreTable::findRecId(_orderHeader.retailChannelTable);
            if (!(taxOnGiftCards && retailStoreTableLocal.PriceIncludesSalesTax && itemInfo.Giftcard))
            {
                orderLine.RetailOrderLineMap::initMapFromInventTable(orderLine.inventTable());
            }

            if (lineFound)
            {
                // Let SalesLine calculate QtyOrdered value.
                salesLine.SalesUnit = itemInfo.Unit;
                salesLine.QtyOrdered = salesLine.calcQtyOrdered(itemInfo.Quantity);
                InventMovement::bufferSetRemainQty(salesLine);
            }

            orderLine.SalesPrice = itemInfo.Price;
            orderLine.SalesUnit = itemInfo.Unit;
            orderLine.LineDisc = itemInfo.Discount;
            orderLine.LinePercent = itemInfo.DiscountPercent;
            orderLine.LineAmount = itemInfo.NetAmount;

            // We should update the expedite value only for new sales line or existing sales line whose dlvMode is modified.
            boolean shouldUpdateLineExpediteBasedOnDlvMode = (!lineFound) || (orderLine.DlvMode != itemInfo.DeliveryMode);

            orderLine.DlvMode = itemInfo.DeliveryMode;

            //Price calculation per entered quantity is done on POS, so setting PriceUnit to 1
            //instead initializing it from the item's "Sell price unit".
            orderLine.PriceUnit = 1;

            if (isSales)
            {
                if (ReflectionHelper::getObjectProperty(_customerOrderInfo, StatementIdStr)!=null)
                {
                    // If customer order info has StatementId value, then the call is from Posting.
                    // Set the item reservation to Automatic.
                    System.Object statementIdProp = ReflectionHelper::getObjectProperty(_customerOrderInfo, StatementIdStr);
                    str statementId = statementIdProp.ToString();

                    if (statementId != '')
                    {
                        salesLine.Reservation = ItemReservation::Automatic;
                    }
                    else
                    {
                        if (!RetailReservationTypeFromSalesParametersFlight::instance().isEnabled())
                        {
                            SalesParameters salesParameters = SalesParameters::find();
                            salesLine.Reservation = salesParameters.Reservation;
                        }
                    }
                }
                else
                {
                    if (!RetailReservationTypeFromSalesParametersFlight::instance().isEnabled())
                    {
                        salesLine.Reservation = ItemReservation::Automatic;
                    }
                }

                // Set "Carry Out" items Delivery Now quantity to partially invoice the sales order for these items
                // Do not invoice in case RetailParameters.CarryOutDeliveryModeCode is not defined (Blank).
                if (salesLine.DlvMode == retailParamsTable.CarryOutDeliveryModeCode &&
                    retailParamsTable.CarryOutDeliveryModeCode != '' &&
                    salesLine.canInvoiceOrderLineFromCurrentSalesStatus())
                {
                    // We set the invent dim on carryout lines to ensure InventDeliverNow is set correctly
                    // on the sales line
                    if (!isReturnLine)
                    {
                        salesLine.InventDimId = inventDim.inventDimId;
                    }

                    salesLine.SalesDeliverNow = itemInfo.Quantity;
                    salesLine.setInventDeliverNow();
                }

                salesLine.copyShipCarrierInformation(salesLine);    //init ShipCarrier details from the .DlvMode field
                salesLine.SalesCategory = EcoResProductCategory::findByItemIdCategoryHierarchyRole(
                    orderLine.ItemId,
                    EcoResCategoryNamedHierarchyRole::Sales).Category;

                if (itemInfo.ConfirmedShipDateString)
                {
                    salesLine.ShippingDateConfirmed = str2Date(itemInfo.ConfirmedShipDateString, 321);
                }
            }

            orderLine.ShippingDateRequested = str2Date(itemInfo.RequestedDeliveryDateString, 321);
            orderLine.ReceiptDateRequested = str2Date(itemInfo.RequestedDeliveryDateString, 321);

            if (isSales && RetailSynchronizeOrderRequestedDeliveryDateValidationFlight::instance().isEnabled() && salesLine.salesTable().isInterCompanyOrder())
            {
                RetailTransactionServiceOrders::setRequestedDeliveryDateForOrderLines(orderLine);
            }

            RefRecId postalAddressRecId = str2int64(itemInfo.AddressRecordId);
            LogisticsPostalAddress logisticsPostalAddress;

            if (postalAddressRecId)
            {
                logisticsPostalAddress = LogisticsPostalAddress::findRecId(postalAddressRecId);
            }
            else if (itemInfo.Address)
            {
                RetailChannelTable      retailChannelTable = RetailChannelTable::findByRecId(str2Int64(_customerOrderInfo.ChannelRecordId));
                boolean isDefaultCustomer = (retailChannelTable.DefaultCustAccount == _customerOrderInfo.CustomerAccount) && (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore);

                logisticsPostalAddress
                = RetailTransactionServiceCustomer::getExistingCustomerAddress(itemInfo.Address.Street,
                    itemInfo.Address.City,
                    itemInfo.Address.State,
                    itemInfo.Address.ZipCode,
                    itemInfo.Address.ThreeLetterISORegionName,
                    itemInfo.Address.StreetNumber,
                    itemInfo.Address.County,
                    _customerOrderInfo.CustomerAccount,
                    itemInfo.Address.Name,
                    itemInfo.Address.BuildingCompliment,
                    itemInfo.Address.DistrictName,
                    isDefaultCustomer);

                if (!logisticsPostalAddress)
                {
                    container roleContainer;
                    LogisticsPostalAddressRecId logisticsPostalAddressRecId;

                    if (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore)
                    {
                        roleContainer = [LogisticsLocationRole::findBytype(LogisticsLocationRoleType::Delivery).RecId];
                    }
                    else
                    {
                        roleContainer = [LogisticsLocationRole::findBytype(LogisticsLocationRoleType::OneTime).RecId];
                    }

                    RetailTransactionServiceOrdersAddressParameters addressParamaters = new RetailTransactionServiceOrdersAddressParameters();
                    addressParamaters.custAccount = _customerOrderInfo.CustomerAccount;
                    addressParamaters.custName = itemInfo.Address.Name;
                    addressParamaters.streetNumber = itemInfo.Address.StreetNumber;
                    addressParamaters.street = itemInfo.Address.Street;
                    addressParamaters.city = itemInfo.Address.City;
                    addressParamaters.districtName = itemInfo.Address.DistrictName;
                    addressParamaters.county = itemInfo.Address.county;
                    addressParamaters.state = itemInfo.Address.State;
                    addressParamaters.zip = itemInfo.Address.ZipCode;
                    addressParamaters.country = itemInfo.Address.ThreeLetterISORegionName;
                    addressParamaters.phone = itemInfo.Address.PhoneNumber;
                    addressParamaters.email = itemInfo.Address.Email;
                    addressParamaters.buildingCompliment = itemInfo.Address.BuildingCompliment;
                    addressParamaters.roleContainer = roleContainer;
                    addressParamaters.associateAddressToCustomer = isDefaultCustomer;
                    addressParamaters.attentionTo = itemInfo.Address.AttentionToAddressLine;

                    logisticsPostalAddressRecId = RetailTransactionServiceOrders::createAddressUsingParameters(addressParamaters);

                    logisticsPostalAddress = LogisticsPostalAddress::findRecId(LogisticsPostalAddressRecId);
                }
            }

            if (logisticsPostalAddress)
            {
                orderLine.setLocation(logisticsPostalAddress.Location);
            }

            // We must always honor the tax group calculated in RetailServer, so we copy the tax group data from ItemInfo to OrderLine.
            if (!(retailParamsTable.TaxOnGiftCards && retailStoreTableLocal.PriceIncludesSalesTax && itemInfo.Giftcard))
            {
                orderLine.TaxGroup = RetailTransactionServiceOrders::getTaxGroup_W(itemInfo.Quantity, _orderHeader.CustAccount, _customerOrderInfo.StoreId, itemInfo.SalesTaxGroup);;
                orderLine.TaxItemGroup = itemInfo.ItemTaxGroup;
            }

            InventTable inventTable = inventTable::Find(salesLine.ItemId);
            if (inventTable && inventTable.DefaultDimension)
            {
                orderLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(orderLine.DefaultDimension, inventTable.DefaultDimension);
            }

            // If 'Prevent fulfillment store dimensions on sales lines' flag is off merge the fulfillment store dimension
            if (Retailparameters::find().UseSalesStoreDimensions == NoYes::No)
            {
                // Find Retail Store for the Sales Line fulfillment Store id.
                // If a Store is found, merge its dimension with priority.
                RetailStoreTable salesLineWarehouseStore;
                select firstonly salesLineWarehouseStore
                    where salesLineWarehouseStore.StoreNumber == itemInfo.FulfillmentStoreId;

                if (salesLineWarehouseStore)
                {
                    orderLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(salesLineWarehouseStore.DefaultDimension, orderLine.DefaultDimension);
                }
            }

            if (isSales && !lineFound)
            {
                // sets the default values for the below fields. The fields are dependent among them so don't change this order.
                salesLine.defaultField(fieldNum(SalesLine, DeliveryType));
                salesLine.defaultField(fieldNum(SalesLine, SourcingVendAccount));
                salesLine.defaultField(fieldNum(SalesLine, SourcingOrigin));
                salesLine.defaultField(fieldNum(SalesLine, SourcingCompanyId));
                salesLine.defaultField(fieldNum(SalesLine, SourcingInventSiteId));
                salesLine.defaultField(fieldNum(SalesLine, SourcingInventLocationId));

                // sets the sales line line number
                salesLine.LineNum = itemInfo.LineNumber;
            }

            if (WarrantyFeatureExposure::isWarrantySalesViaCustomerOrderFeatureEnabled() && !isSales)
            {
                // In the update scenario, all the exisitng lines will be removed and then added.
                // If new line is added while old lines voided, then the newlines will have line number restarting from 1, which are not matching the line number of request, and then the warrantable line settings will find incorrect line.
                salesQuotationLine.LineNum = itemInfo.LineNumber;
            }

            if (isReturnLine)
            {
                salesLine.setInventDimId(InventDim::findOrCreate(salesTransInventDim).InventDimId);
                salesLine.ExpectedRetQty = salesLine.SalesQty;
                salesLine.InventTransIdReturn = itemInfo.ReturnInventTransId;

                NoYes useFinancialDimensionFromReturnStore;
                if (_customerOrderInfo.StatementId != '')
                {
                    useFinancialDimensionFromReturnStore = RetailEodStatementConfigurationAccessor::constructFromStatementId(_customerOrderInfo.StatementId).isUseFinancialDimensionFromReturnStore();
                }
                else
                {
                    useFinancialDimensionFromReturnStore = retailParamsTable.UseFinancialDimensionFromReturnStore;
                }

                if (!useFinancialDimensionFromReturnStore && salesLine.InventTransIdReturn && originalSalesLine.RecId)
                {
                    orderLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(originalSalesLine.DefaultDimension, orderLine.DefaultDimension);
                }

                if (_isCustomerOrderReturnWithExchange)
                {
                    // For customer order return with exchange, invoice every returned product line.
                    // On legacy customer order return, the header would invoice all of the product lines.
                    salesLine.SalesDeliverNow = itemInfo.Quantity;
                    salesLine.setInventDeliverNow();
                }
            }
            else
            {
                MCRInventTable mcrInventTable = MCRInventTable::findByItemId(orderLine.ItemId);

                if (salesLine.isDropShipment() && mcrInventTable.DefaultDropShipmentWarehouse)
                {
                    inventDim.InventLocationId = mcrInventTable.DefaultDropShipmentWarehouse;
                    inventDim.InventSiteId = InventLocation::find(inventDim.InventLocationId).InventSiteId;
                    inventDim = InventDim::findOrCreate(inventDim);
                }

                orderLine.setInventDimId(inventDim.InventDimId);
            }

            orderLine.RetailVariant = itemInfo.VariantId;
            orderLine.CurrencyCode = _orderHeader.CurrencyCode;
            orderLine.SalesMarkup = itemInfo.SalesMarkup;
            orderLine.SalesGroup = itemInfo.CommissionSalesGroup;
            orderLine.CustomerRef = itemInfo.Comment;

            // there should be a way to avoid repeated calls to this fn.
            orderLine.setPriceDiscChangePolicy(PriceDiscSystemSource::RetailPOS);

            // Fills the external id and description of a sales line/Quotation line from customer .
            orderLine.initFromCustExternalItemDescription(inventDim);

            if (RetailEnableDeliveryDateControlFlight::instance().isEnabled())
            {
                orderLine.setDeliveryDateControlType(orderLine.InventDimId);
            }

            if (isSales)
            {
                salesLine.CostPrice = salesLine.inventTable().costPcsPrice(salesLine.InventDimId);
                salesLine.BarCode = itemInfo.BarCodeId;
                salesLine.BarCodeType = InventItemBarcode::findRetailBarcodeSetupId(salesLine.ItemId, itemInfo.BarCodeId, itemInfo.VariantId);
                salesLine.MatchingAgreementLine = itemInfo.SalesAgreementLineRecordId;
            }

            // isSales indicates that the current method is processing a SalesLine
            // and isReturnLine indicates that it is a return.
            // In this case we need to set the blocked quantity due to return location policy.
            if (isSales && isReturnLine)
            {
                System.Object statementIdObject = ReflectionHelper::getObjectProperty(_customerOrderInfo, StatementIdStr);

                if (statementIdObject != null && statementIdObject.ToString() != '')
                {
                    // Updating blocked quantity for orders coming from statement.
                    // There is no need to update InventDim since it was updated in calculate.
                    RetailTransactionServiceOrders::setBlockedQty(itemInfo, salesLine);
                }
                else
                {
                    // In case of customer orders for POS, the return policy should be applied according to the ReturnReasonCodeId.
                    // In cash and carry transactions this field is not populated (returns use infocode instead).
                    System.Object returnReasonCodeObject = ReflectionHelper::getObjectProperty(itemInfo, 'ReturnReasonCodeId');

                    if (returnReasonCodeObject != null && returnReasonCodeObject.toString() != '')
                    {
                        using (RetailTransactionServiceOrdersContext context = RetailTransactionServiceOrdersContext::construct())
                        {
                            context.parmChannelRecordId(str2Int64(ReflectionHelper::getObjectProperty(_customerOrderInfo, 'ChannelRecordId')));
                            RetailTransactionServiceOrders::updateInventDimForReturnOrder(orderLine, salesTransInventDim, returnReasonCodeObject.toString());
                        }
                    }
                }
            }

            // Update MCRSalesLine expedite value as per delivery mode of salesLine.
            if (RetailUpdateExpediteValueBasedOnModeOfDeliveryFlight::instance().isEnabled())
            {
                if (shouldUpdateLineExpediteBasedOnDlvMode)
                {
                    salesLine.mcrDlvModeModified();
                }
            }
            else
            {
                if (lineFound)
                {
                    if (orderLine.DlvMode && RetailUpdateMCRSalesLineExpediteFlight::instance().isEnabled())
                    {
                        MCRSalesLine mcrSalesLine = salesLine.mcrSalesLine();
                        mcrSalesLine.Expedite = DlvMode::find(orderLine.DlvMode).mcrExpedite;
                        salesLine.mcrPackMCRSalesLine(mcrSalesLine);
                    }
                }
            }

            // Extensibility point before insertion of records
            RetailCustomerOrderLineParameters args = RetailCustomerOrderLineParameters::construct();
            args.custOrderInfo = _customerOrderInfo;
            args.itemInfo = itemInfo;
            args.orderHeader = _orderHeader;
            args.orderLine = orderLine;

            if (lineFound)
            {
                if (_advanceInvoiceContract != null)
                {
                    _advanceInvoiceContract.parmCancelOpenedAdvanceInvoices(_advanceInvoiceContract.parmCancelOpenedAdvanceInvoices() || RetailTransactionServiceAdvanceInvoice_W::isSalesLineChanged(salesLine));
                }

                RetailCreateCustomerOrderExtensions::preOrderLineUpdate(args);

                salesLine.update();

                InventMovement inventMovement = InventMovement::construct(salesLine, InventMovSubType::None, null);
                if (inventMovement.mustRegisterTrackingDimension())
                {
                    // Check if Inventory Tracking Register Trans for serial number exists. If it exists, update it.
                    boolean isInventTrackingRegistered = InventTrackingRegisterUpdate::newFromMovement(inventMovement).updateTrackingDimension(inventDim);

                    // Inventory Tracking Register Trans for serial number doesn't exist, create it
                    if (!isInventTrackingRegistered)
                    {
                        InventTrackingRegisterUpdate::newFromMovement(inventMovement).registerTrackingDimension(inventDim, inventMovement.transQty());
                    }
                }
            }
            else
            {
                // Sales Order Line
                if (orderLine is SalesLine)
                {
                    SalesLineCreateLineParameters salesLineCreateLineParameters = SalesLineCreateLineParameters::construct();

                    salesLineCreateLineParameters.validation              = true;
                    salesLineCreateLineParameters.initFromSalesOrderTable = false;
                    salesLineCreateLineParameters.initFromItemOrCategory  = false;
                    salesLineCreateLineParameters.calcInventQty           = true;
                    salesLineCreateLineParameters.searchMarkup            = false;


                    boolean canReuseInventoryReservation = _reuseInventoryReservation;
                    // Before re-using the reservation, we must check if still exists.
                    if (_reuseInventoryReservation)
                    {
                        InventTransOrigin existsInventTransOrigin;

                        select firstonly RecId from existsInventTransOrigin where existsInventTransOrigin.InventTransId == originalInventTransId;

                        canReuseInventoryReservation = existsInventTransOrigin.RecId != 0;
                    }

                    // Create sales line WITHOUT searching for additional Markup charges
                    if (canReuseInventoryReservation && _reuseInventoryReservation && originalInventTransId)
                    {
                        orderLine.InventTransId = originalInventTransId;
                        salesLine.SkipAssignInventTransId = true;

                        salesLineCreateLineParameters.skipInventoryProcessing = true;

                        RetailCreateCustomerOrderExtensions::preSalesLineCreate(args, salesLineCreateLineParameters);

                        salesLine.createLineFromParameters(salesLineCreateLineParameters);

                        RetailTransactionServiceOrders::relateInventTransOriginToOrderLine(salesLine);

                        // handle case where return is in a different statement
                        if (isReturnLine && itemInfo.ReturnInventTransId)
                        {
                            RetailTransactionServiceOrders::updateReturnInventTrans(itemInfo, salesLine);
                        }
                    }
                    else
                    {
                        RetailCreateCustomerOrderExtensions::preSalesLineCreate(args, salesLineCreateLineParameters);

                        salesLine.createLineFromParameters(salesLineCreateLineParameters);
                    }

                    RetailTransactionServiceOrders::writeMCRSalesLineForNewSalesLine(salesLine, itemInfo);
                }
                // Sales Quotation Line
                else
                {
                    SalesQuotationLineCreateLineParameters salesQuotationLineCreateLineParameters = SalesQuotationLineCreateLineParameters::construct();

                    salesQuotationLineCreateLineParameters.validation                  = true;
                    salesQuotationLineCreateLineParameters.initFromSalesQuotationTable = false;
                    salesQuotationLineCreateLineParameters.initFromItemOrCategory      = false;
                    salesQuotationLineCreateLineParameters.calcInventQty               = true;
                    salesQuotationLineCreateLineParameters.searchMarkup                = false;

                    RetailCreateCustomerOrderExtensions::preSalesQuotationLineCreate(args, salesQuotationLineCreateLineParameters);

                    orderLine.createLineFromParameters(salesQuotationLineCreateLineParameters);
                }

                if (_advanceInvoiceContract != null)
                {
                    if (isCarryOutLine)
                    {
                        _advanceInvoiceContract.parmHasCarryOutLine(true);
                    }
                    else
                    {
                        _advanceInvoiceContract.parmCancelOpenedAdvanceInvoices(true);
                    }
                }

                // Update the InventTrackingRegisterTrans for serial number, where a reservation was already made
                if (InventTrackingRegisterTrans::isTrackingRegistrationConfigured() && orderLine.InventTransId)
                {
                    // Inventory Tracking Resgister Trans for serial number exists, update it
                    if (fromInventTransOrigin)
                    {
                        InventTrackingRegisterTrans inventTrackingRegisterTrans;

                        update_recordset inventTrackingRegisterTrans
                            setting InventTransOrigin = InventTrans::findTransId(orderLine.InventTransId).inventTransOrigin,
                            InventDimId = inventDim.inventDimId
                        where inventTrackingRegisterTrans.PhysicalRefRecId      == 0
                            && inventTrackingRegisterTrans.PhysicalRefTableId   == 0
                            && inventTrackingRegisterTrans.FinancialRefRecId    == 0
                            && inventTrackingRegisterTrans.FinancialRefTableId  == 0
                            && inventTrackingRegisterTrans.InventTransOrigin    == fromInventTransOrigin;
                    }
                    // Inventory Tracking Register Trans for serial number doesn't exist, create it
                    else
                    {
                        InventMovement inventMovement = InventMovement::construct(salesLine, InventMovSubType::None, null);
                        if (inventMovement.mustRegisterTrackingDimension())
                        {
                            if (!isReturnLine)
                            {
                                InventTrackingRegisterUpdate::newFromMovement(inventMovement).registerTrackingDimension(inventDim, inventMovement.transQty());
                            }
                            else
                            {
                                InventTrackingRegisterUpdate::newFromMovement(inventMovement).registerTrackingDimension(trackingRegisterInventDim, inventMovement.transQty());
                            }
                        }
                    }
                }
            }

            // Post Kit order if line's delivery mode is carry out
            if (isSales && isCarryOutLine)
            {
                RetailKitAssemblyOrder::postSalesLineAssemblyOrder(salesLine);
            }
            
            RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(str2Int64(_customerOrderInfo.ChannelRecordId));

            if (isIndia && isSales)
            {
                RetailTransactionServiceOrders::initSalesLine_IN(
                    salesLine,
                    _orderHeader,
                    retailChannelTable,
                    itemInfo);
            }

            if (isReturnLine)
            {
                SalesTable salesTable = _orderHeader;

                // RMA Numbers should only be populated for Return orders
                // Sales orders with negative lines should not have a RMA Number
                if (!salesTable.ReturnItemNum && salesTable.SalesType == SalesType::ReturnItem)
                {
                    salesTable.selectForUpdate(true);

                    NumberSeq  rmaNumberSeq = NumberSeq::newGetNum(SalesParameters::numRefReturnItemNum());
                    salesTable.ReturnItemNum = rmaNumberSeq.num();

                    salesTable.update();
                }

                if (InventTable::find(itemInfo.ItemId).isStocked())
                {
                    InventDimId inventDimId = salesLine.InventDimId;

                    // Item arrival journals should only be created for Return Orders
                    // Return orders will always have ReturnItemNum (RMA Number) and will be of type ReturnItem.
                    if (salesTable.ReturnItemNum && salesTable.SalesType == SalesType::ReturnItem)
                    {
                        if (!_reuseInventoryReservation)
                        {

                            if (!wmsJournalTable)
                            {
                                NumberSeq wmsJournalNumberSeq =  NumberSeq::newGetNum(WMSParameters::numRefWMSJournalId());

                                // Create item arrival journal
                                wmsJournalTable.initValue();
                                wmsJournalTable.JournalId = wmsJournalNumberSeq.num();

                                wmsJournalTable.JournalNameId = WMSParameters::find().ReceptionJournalNameId;
                                wmsJournalTable.ReturnItemNum = salesTable.ReturnItemNum;
                                wmsJournalTable.VendAccount = salesTable.CustAccount;
                                wmsJournalTable.InventTransType = InventTransType::Sales;
                                wmsJournalTable.InventTransRefId = salesTable.SalesId;
                                wmsJournalTable.JournalType = WMSJournalType::Reception;
                                wmsJournalTable.Posted = NoYes::No;

                                wmsJournalTable.ReturnDispositionCodeId = retailParamsTable.ReturnDispositionCodeId;
                                wmsJournalTable.insert();
                            }

                            // Create item arrival line
                            wmsJournalTrans.clear();
                            wmsJournalTrans.initFromWMSJournalTable(wmsJournalTable);
                            wmsJournalTrans.LineNum = i + 1;
                            wmsJournalTrans.IsReturnOrder = NoYes::Yes;
                            wmsJournalTrans.ItemId = salesLine.ItemId;
                            wmsJournalTrans.InventDimId = salesLine.InventDimId;
                            wmsJournalTrans.Qty = -salesLine.QtyOrdered;
                            wmsJournalTrans.ReturnDispositionCodeId = retailParamsTable.ReturnDispositionCodeId;
                            wmsJournalTrans.ReturnItemNum = salesTable.ReturnItemNum;
                            wmsJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                            wmsJournalTrans.VendAccount = salesLine.CustAccount;
                            wmsJournalTrans.InventTransType = InventTransType::Sales;
                            wmsJournalTrans.InventTransRefId = salesTable.SalesId;
                            wmsJournalTrans.InventTransId = salesLine.InventTransId;
                            wmsJournalTrans.returnCreateUpdateInventTrans();

                            wmsJournalTrans.insert();
                            numLines++;
                        }
                    }
                }
                else
                {
                    if (salesTable.ReturnItemNum && salesTable.SalesType == SalesType::ReturnItem)
                    {
                        WMSArrivalDetailTmp wmsArrivalDetailTmp;
                        wmsArrivalDetailTmp.ReturnDispositionCodeId  = retailParamsTable.returnDispositionCodeId;
                        wmsArrivalDetailTmp.InventQty = -itemInfo.Quantity;
                        wmsArrivalDetailTmp.insert();

                        SalesReturnNonStockedRegistrationHelper salesReturnNonStockedRegistrationHelper = SalesReturnNonStockedRegistrationHelper::construct();
                        salesReturnNonStockedRegistrationHelper.parmWMSArrivalDetailTmp(wmsArrivalDetailTmp);
                        salesReturnNonStockedRegistrationHelper.parmSalesLine(salesLine);
                        salesReturnNonStockedRegistrationHelper.updateOnRegistration();
                    }
                }
                RetailTransactionServiceOrders::updateReturnReasonCodeForRetailSalesLine(orderLine, itemInfo);

                // For return orders save tax exempt price reduction information on retail sales line.
                RetailSalesLine retailSalesLine = RetailSalesLine::findBySalesLine(orderLine.RecId, true);
                if (retailSalesLine.RecId != 0)
                {
                    retailSalesLine.TaxExemptPriceInclusiveOriginalPrice = itemInfo.TaxExemptPriceInclusiveOriginalPrice;
                    retailSalesLine.TaxExemptPriceInclusiveReductionAmount = itemInfo.TaxExemptPriceInclusiveReductionAmount;
                    retailSalesLine.write();
                }
            }
            else
            {
                RetailOrderLineExtensionMap orderLineExtension = orderLine.RetailOrderLineMap::getRetailExtension(orderLine.RecId);

                if (!orderLineExtension)
                {
                    orderLineExtension.RetailOrderLine = orderLine.RecId;
                }

                orderLineExtension.Catalog = itemInfo.Catalog;
                orderLineExtension.LineDscAmount = itemInfo.LineDscAmount;

                if (ReflectionHelper::hasObjectProperty(itemInfo, LinePercentageDiscountStr))
                {
                    orderLineExtension.LinePercentageDiscount = ReflectionHelper::getObjectProperty(itemInfo, LinePercentageDiscountStr);
                }

                orderLineExtension.PeriodicDiscount = itemInfo.PeriodicDiscount;
                orderLineExtension.PeriodicPercentageDiscount = itemInfo.PeriodicPercentageDiscount;
                orderLineExtension.TenderDiscount = itemInfo.TenderDiscount;
                orderLineExtension.TenderDiscountPercentage = itemInfo.TenderDiscountPercentage;
                orderLineExtension.TotalDiscount = itemInfo.TotalDiscount;
                orderLineExtension.TotalPctDiscount = itemInfo.TotalPctDiscount;
                orderLineExtension.LineManualDiscountAmount = itemInfo.LineManualDiscountAmount;
                orderLineExtension.LineManualDiscountPercentage = itemInfo.LineManualDiscountPercentage;
                orderLineExtension.TaxExemptPriceInclusiveOriginalPrice = itemInfo.TaxExemptPriceInclusiveOriginalPrice;
                orderLineExtension.TaxExemptPriceInclusiveReductionAmount = itemInfo.TaxExemptPriceInclusiveReductionAmount;
                if (RetailPricingCustomizableFeatureToggle::isPreventUnintendedRecalculationEnabled())
                {
                    orderLineExtension.IsPriceLocked = NoYes::Yes;
                }

                if (!RetailIgnoreFulfillmentStoreIdFromChannel::instance().isEnabled())
                {
                    orderLineExtension.FulfillmentStoreId = itemInfo.FulfillmentStoreId;
                }

                // For Online orders, the fulfillment store id is determined by HQ method SalesLine::mcrGetFulfillmentStore instead of from Channel side.
                // If channel is not online store, then we replace it with value provided.
                if (RetailSetFulfillmentStoreIdIfNotSetForNonOnlineStore::instance().isEnabled()
                    && retailChannelTable.ChannelType != RetailChannelType::OnlineStore
                    && retailChannelTable.ChannelType != RetailChannelType::SharePointOnlineStore)
                {
                    orderLineExtension.FulfillmentStoreId = itemInfo.FulfillmentStoreId;
                }

                if (isSales)
                {
                    if (itemInfo.PickupTimeslotStartDateTimeString != '' && itemInfo.PickupTimeslotEndDateTimeString != '')
                    {
                        orderLineExtension.PickupStartTime = DateTimeUtil::getDifference(DateTimeUtil::parse(itemInfo.PickupTimeslotStartDateTimeString), DateTimeUtil::newDateTime(orderLine.ShippingDateRequested, 0));
                        orderLineExtension.PickupEndTime = DateTimeUtil::getDifference(DateTimeUtil::parse(itemInfo.PickupTimeslotEndDateTimeString), DateTimeUtil::newDateTime(orderLine.ShippingDateRequested, 0));
                    }
                    else
                    {
                        // If pickup timeslot information does not exists, set to default values.
                        orderLineExtension.PickupStartTime = 0;
                        orderLineExtension.PickupEndTime = 0;
                    }
                }

                PropertyInfo originalPrice = itemInfo.GetType().GetProperty(#OriginalPrice);

                if (originalPrice != null)
                {
                    orderLineExtension.OriginalPrice = originalPrice.GetValue(itemInfo);
                }

                PropertyInfo isPriceOverridden = itemInfo.GetType().GetProperty(#IsPriceOverridden);

                if (isPriceOverridden != null)
                {
                    orderLineExtension.IsPriceOverridden = isPriceOverridden.GetValue(itemInfo);
                }

                PropertyInfo isPriceKeyedInValue = itemInfo.GetType().GetProperty(IsPriceKeyedIn);
                if (isPriceKeyedInValue != null)
                {
                    orderLineExtension.isPriceKeyedIn = isPriceKeyedInValue.GetValue(itemInfo);
                }

                // Update extension table.
                ttsbegin;
                orderLineExtension.write();
                ttscommit;
            }

            //creation of line-level charges codes
            RetailTransactionServiceOrders::createMarkupTrans(itemInfo.Charges, orderLine, _orderHeader.CurrencyCode, itemInfo.FulfillmentStoreId, _customerOrderInfo, _taxAdjustmentsMap, isReturnLine, isCarryOutLine, _orderHeader);

            if (taxCalculationBehaviorController.areLineLevelTaxAdjustmentsAllowed(isSales, isReturnLine, isCarryOutLine))
            {
                TaxCalculationType taxCalculationType;

                PropertyInfo propertyInfo = _customerOrderInfo.GetType().GetProperty(RetailTransactionServiceOrders::PropertyTaxCalculationType);
                if(propertyInfo != null)
                {
                    taxCalculationType = propertyInfo.GetValue(_customerOrderInfo);
                }

                if (taxCalculationType == enum2int(TaxCalculationType::GTE))
                {
                    RetailTransactionServiceOrders::CreateTaxMeasureAdjustments(_orderHeader.TableId, _orderHeader.RecId, salesLine.TableId, salesLine.RecId, itemInfo.TaxMeasures, _taxAdjustmentsMap);
                }
                else
                {
                    RetailTransactionServiceOrders::CreateTaxLines(salesLine.TableId, salesLine.RecId, itemInfo.Taxes, _taxAdjustmentsMap);
                }
            }

            // Add any DiscountLines related to this order Line.
            RetailTransactionServiceOrders::createDiscountLines(itemInfo.Discounts, orderLine, !isSales);

            if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
            {
                // Add any PriceLines related to this order Line.
                RetailTransactionServiceOrders::createPriceLines(itemInfo.Prices, orderLine, !isSales);
            }

            // Write InventTransId back to sales transaction lines
            if (originalInventTransId)
            {
                // Update inventTransId with sales order line's inventTransId
                RetailTransactionSalesTrans salesTransUpdateInventTransId;

                update_recordset salesTransUpdateInventTransId
                    setting InventTransId = orderLine.InventTransId
                    where   salesTransUpdateInventTransId.store         == _customerOrderInfo.StoreId
                        &&  salesTransUpdateInventTransId.InventTransId == originalInventTransId;
            }
            // Write InventTransId back to sales transaction lines when the transaction was non aggregated and had no temporary reservation
            else if (_customerOrderInfo.StatementId && _customerOrderInfo.TransactionId && itemInfo.LineNumber != 0)
            {
                // Update inventTransId with sales order line's inventTransId
                RetailTransactionSalesTrans salesTransUpdateInventTransId;

                update_recordset salesTransUpdateInventTransId
                    setting InventTransId = orderLine.InventTransId
                    where   salesTransUpdateInventTransId.Channel       == str2int64(_customerOrderInfo.ChannelRecordId)
                        &&  salesTransUpdateInventTransId.store         == _customerOrderInfo.StoreId
                        &&  salesTransUpdateInventTransId.terminalId    == _customerOrderInfo.TerminalId
                        &&  salesTransUpdateInventTransId.transactionId == _customerOrderInfo.TransactionId
                        &&  salesTransUpdateInventTransId.lineNum       == itemInfo.LineNumber;
            }

            // saves info codes
            RetailInfoCodeLineRelatedTableType tableType;
            if (isSales)
            {
                tableType = RetailInfoCodeLineRelatedTableType::Sales;
            }
            else
            {
                tableType = RetailInfoCodeLineRelatedTableType::Quote;
            }
            RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(_orderHeader.RecId, salesLine.RecId ? salesLine.RecId : salesQuotationLine.RecId, ReflectionHelper::getObjectProperty(itemInfo, 'ReasonCodeLines'), tableType);

            // Create retail attributes on line level
            RetailAttributeHelper::createOrUpdateRetailSalesOrderAttributeValues(
                str2int64(_customerOrderInfo.ChannelRecordId),
                _customerOrderInfo.StoreId,
                _customerOrderInfo.TerminalId,
                _customerOrderInfo.TransactionId,
                _customerOrderInfo.Id,
                _customerOrderInfo.DataAreaId,
                itemInfo.LineNumber,
                itemInfo.AttributeValues,
                unshownAttributeNames);

            eventSource.EventWriteOrdersCreateOrUpdateRetailOrderLineFinish(_orderHeader.RecId, i, _customerOrderInfo.StatementId, aggregationHeaderRecId);
        }

        if (countOfInventoryRemoval > 0)
        {
            eventSource.EventWriteOrdersCreateOrUpdateRetailOrderLinesCreated(funcName(), countOfInventoryRemoval, inventoryRemovalStopWatch.ElapsedMilliseconds);
        }

        if (wmsJournalTable)
        {
            // Update item arrival journal
            InventDim orderInventDim;
            orderInventDim.initValue();
            orderInventDim.InventSiteId = _orderHeader.InventSiteId;
            orderInventDim.InventLocationId = _orderHeader.InventLocationId;

            orderInventDim = InventDim::findOrCreate(orderInventDim);
            wmsJournalTable.InventDimId = orderInventDim.InventDimId;
            wmsJournalTable.NumOfLines = numLines;
            wmsJournalTable.SystemBlocked = NoYes::Yes;
            wmsJournalTable.update();

            // Post item arrival journal
            WMSJournalCheckPostReception wmsJournalCheckPostReception = WMSJournalCheckPostReception::newTypeJournalTable(JournalCheckPostType::Post, wmsJournalTable);
            wmsJournalCheckPostReception.runOperation();

        }

        // Set Warrantied Relation after creating Sales/Quotation Lines.
        RetailTransactionServiceWarranty::setWarrantiedRelation(_orderHeader, _customerOrderInfo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInventoryReservationsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlink and remove inventory reservations for sales transactions coming from customerOrderInfo and ItemInfo.
    /// This version is for old EOD code, where we look at entryStatus for state on RetailTransactionTable.
    /// </summary>
    /// <param name="_customerOrderInfo">
    /// CustomerOrderInfo object for the sales order.
    /// </param>
    /// <param name="_itemInfo">
    /// ItemInfo object for the sales order line.
    /// </param>
    /// <param name="_inventoryRemovalStopWatch">
    /// Stopwatch to count time spent in reservation removal.
    /// </param>
    /// <param name="_inventDim">
    /// InventDim object for the given line.
    /// </param>
    /// <param name="_reuseInventoryReservation">
    /// Determines if we can reuse the existing inventory reservation.
    /// </param>
    /// <returns>
    /// A container having the InventTransOrigin, InventDimId and the count for the the deleted reservations.
    /// </returns>
    protected static container removeInventoryReservationsV2(CustomerOrderInfo _customerOrderInfo, ItemInfo _itemInfo, System.Diagnostics.Stopwatch _inventoryRemovalStopWatch,InventDim _inventDim, boolean _reuseInventoryReservation = false)
    {
        RefRecId fromInventTransOrigin;
        InventDimId returnInventDimId;
        int countOfInventoryRemoval = 0;

        if (isConfigurationkeyEnabled(configurationKeyNum(RetailEodBackwardCompatibility)))
        {
            DiscPct linePercentageDiscount = ReflectionHelper::getObjectProperty(_itemInfo, LinePercentageDiscountStr);
            LineNum returnLineNum = ReflectionHelper::getObjectProperty(_itemInfo, 'ReturnLineNum');
            RetailStoreId returnStore = ReflectionHelper::getObjectProperty(_itemInfo, 'ReturnStore');
            RetailTerminalId returnTerminalId = ReflectionHelper::getObjectProperty(_itemInfo, 'ReturnTerminalId');
            RetailTransactionId returnTransactionId = ReflectionHelper::getObjectProperty(_itemInfo, 'ReturnTransactionId');

            RetailStatementId statementId = ReflectionHelper::getObjectProperty(_customerOrderInfo, 'StatementId');
            TransDate businessDate = str2Date(ReflectionHelper::getObjectProperty(_customerOrderInfo, 'BusinessDateString'), 321);

            AccountNum transactionCustAccount =
                        _customerOrderInfo.CustomerAccount == RetailStoreTable::find(_customerOrderInfo.StoreId).DefaultCustAccount ? '' : _customerOrderInfo.CustomerAccount;

            boolean aggregateSalesAndReturns = RetailParameters::isAggregateSalesAndReturns_W();

            RetailTransactionSalesTrans salesTrans;
            RetailTransactionTable transactionTable;

            while select sum(Qty) from salesTrans
                group by salesTrans.ItemId, salesTrans.Unit, salesTrans.inventDimId, salesTrans.inventTransId
                join transactionTable
                where
                // Join clause
                salesTrans.transactionId == transactionTable.transactionId
                &&  salesTrans.store == transactionTable.store
                &&  salesTrans.terminalId == transactionTable.terminal
                &&  salesTrans.Channel == transactionTable.Channel
                // Sales trans filter based on RetailTransactionTransformer
                &&  salesTrans.itemId == _itemInfo.ItemId
                &&  salesTrans.unit == _itemInfo.Unit
                &&  salesTrans.price == _itemInfo.Price
                &&  salesTrans.taxGroup == _itemInfo.SalesTaxGroup
                &&  salesTrans.TaxItemGroup ==  _itemInfo.ItemTaxGroup
                &&  salesTrans.variantId == _itemInfo.VariantId
                &&  salesTrans.InventLocationId == _inventDim.InventLocationId
                &&  salesTrans.InventBatchId == _inventDim.inventBatchId
                &&  salesTrans.InventSerialId == _inventDim.inventSerialId
                &&	salesTrans.PostingCalculatedWMSLocationId == _inventDim.wMSLocationId
                &&  salesTrans.totalDiscPct == _itemInfo.TotalPctDiscount
                &&  salesTrans.LinePercentageDiscount == linePercentageDiscount
                &&  salesTrans.LineManualDiscountPercentage == _itemInfo.LineManualDiscountPercentage
                &&  salesTrans.PeriodicPercentageDiscount == _itemInfo.PeriodicPercentageDiscount
                &&  salesTrans.SalesGroup == _itemInfo.CommissionSalesGroup
                // If aggregation of Sales and Returns is on then ignore return fields
                && (aggregateSalesAndReturns
                    || (salesTrans.ReturnLineNum == returnLineNum
                        && salesTrans.ReturnStore == returnStore
                        && salesTrans.ReturnTerminalId == returnTerminalId
                        && salesTrans.ReturnTransactionId == returnTransactionId)
                    )
                &&  salesTrans.lineNum != 0
                &&  salesTrans.transactionStatus != RetailEntryStatus::Voided
                // Transaction header filter based on RetailTransactionTransformer
                &&  transactionTable.Channel == str2Int64(_customerOrderInfo.ChannelRecordId)
                &&  transactionTable.store == _customerOrderInfo.StoreId
                &&  transactionTable.businessDate == businessDate
                &&  transactionTable.statementId == statementId
                &&  transactionTable.currency == _customerOrderInfo.CurrencyCode
                &&  transactionTable.custAccount == transactionCustAccount
                &&  transactionTable.LogisticsPostalAddress == str2Int64(_customerOrderInfo.AddressRecordId)
                &&  transactionTable.type == RetailTransactionType::Sales
                &&  transactionTable.entryStatus == RetailEntryStatus::CreatingOrder
                &&  transactionTable.SalesGroup == _customerOrderInfo.CommissionSalesGroup
            {
                // InventTransId may be blank in case of giftCard transactions.
                // When the inventory is reserved, if the transaction is gift card, then the itemId may be blank
                // and no reservation is performed.
                if (salesTrans.qty && salesTrans.inventTransId)
                {
                    _inventoryRemovalStopWatch.Start();

                    fromInventTransOrigin = InventTrans::findTransId(salesTrans.inventTransId).InventTransOrigin;

                    returnInventDimId = salesTrans.inventDimId;

                    if (!_reuseInventoryReservation)
                    {
                        salesTrans.RemoveReservation();
                        salesTrans.DeleteInventoryReservation();
                        countOfInventoryRemoval++;
                    }

                    _inventoryRemovalStopWatch.Stop();
                }
            }
        }

        return [fromInventTransOrigin, returnInventDimId, countOfInventoryRemoval];
    }

]]></Source>
			</Method>
			<Method>
				<Name>relateInventTransOriginToOrderLine</Name>
				<Source><![CDATA[
    private static void relateInventTransOriginToOrderLine(SalesLine _salesLine)
    {
        InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId, true);
        inventTransOrigin.ReferenceCategory = InventTransType::Sales;
        inventTransOrigin.ReferenceId = _salesLine.SalesId;
        inventTransOrigin.update();

        //ensure relation from salesLine to inventtransorigin
        InventMovement mov = InventMovement::construct(_salesLine);
        mov.inventTransOriginId(inventTransOrigin.RecId);
        mov.createOriginOwnerRelationship();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReturnInventTrans</Name>
				<Source><![CDATA[
    private static void updateReturnInventTrans(ItemInfo _itemInfo, SalesLine _salesLine)
    {
        InventTrans         inventTransReturnLine;
        InventTransOrigin   inventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId, true);

        while select forUpdate inventTransReturnLine
            where   inventTransReturnLine.InventTransOrigin         == inventTransOrigin.RecId
                &&  inventTransReturnLine.ReturnInventTransOrigin   == 0
        {
            inventTransReturnLine.ReturnInventTransOrigin = InventTransOrigin::findByInventTransId(_itemInfo.ReturnInventTransId).RecId;
            inventTransReturnLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBlockedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the RetailBlockQty in SalesLine according to the related value in ItemInfo.
    /// </summary>
    /// <param name = "_itemInfo">ItemInfo object.</param>
    /// <param name = "_orderLine">SalesLine record.</param>
    private static void setBlockedQty(ItemInfo _itemInfo, SalesLine _orderLine)
    {
        if (ReflectionHelper::hasObjectProperty(_itemInfo, 'BlockedQuantity'))
        {
            Qty blockedQty = ReflectionHelper::getObjectProperty(_itemInfo, 'BlockedQuantity');

            if (blockedQty)
            {
                _orderLine.RetailBlockQty = blockedQty;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewInvoiceBusinessDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines sales order invoice business date.
    /// </summary>
    /// <param name="_context">The RetailTransactionServiceInvoiceContext.</param>
    /// <returns>
    /// Customer order invoice business date.
    /// </returns>
    private static TransDate getNewInvoiceBusinessDate(RetailTransactionServiceInvoiceContext _context)
    {
        TransDate businessDate;

        if (_context != null && _context.parmBusinessDate())
        {
            businessDate = _context.parmBusinessDate();
        }
        else
        {
            businessDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return businessDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupTrans</Name>
				<Source><![CDATA[
    private static void createMarkupTrans(ChargeInfoCollection charges,
                                                Common retailOrderTable,
                                                CurrencyCode currencyCode,
                                                RetailStoreId storeId,
                                                CustomerOrderInfo custOrderInfo,
                                                Map taxAdjustmentsMap = null,
                                                boolean isReturn = false,
                                                boolean isCarryOut = false,
                                                RetailOrderHeaderMap _orderHeader = null)
    {
        boolean isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        MarkupTrans markupTrans;

        // Remove any charges that set on the SalesTable/SalesLine level
        delete_from markupTrans
                    where markupTrans.TransRecId == retailOrderTable.RecId
                       && markupTrans.TransTableId == retailOrderTable.TableId;

        // Determine charge tax adjustment behavior
        var taxCalculationBehaviorController = RetailTaxCalculationBehaviorCustomerOrderInfoController::construct(custOrderInfo);
        boolean areChargeLevelTaxAdjustmentsAllowed = taxCalculationBehaviorController.areChargeLevelTaxAdjustmentsAllowed(isReturn, isCarryOut);

        // Check for GTE tax calculation type
        boolean isGteTaxCalculationType = (custOrderInfo.TaxCalculationType == enum2int(TaxCalculationType::GTE));

        for(int i = 0; i < charges.get_Count(); i++)
        {
            ChargeInfo chargeInfo = charges.get_Item(i) as ChargeInfo;

            if (chargeInfo.IsInvoiced)
            {
                continue;
            }

            markupTrans.clear();
            markupTrans.initFromRetailOrderTable(retailOrderTable);
            markupTrans.initValue();
            markupTrans.ModuleType = chargeInfo.ModuleType;
            // This is for backwards compatibility, in case the binary hot fix to save the ModuleType with these charges is not installed
            if (markupTrans.ModuleType == MarkupModuleType::Invent)
            {
                markupTrans.ModuleType = MarkupModuleType::Cust;
            }
            markupTrans.Keep = chargeInfo.ShouldApplyEveryInvoice;
            markupTrans.MarkupAutoTableRecId = chargeInfo.MarkupAutoTableRecId;
            markupTrans.MarkupAutoLineRecId = chargeInfo.MarkupAutoLineRecId;
            markupTrans.Txt = chargeInfo.Description;
            markupTrans.IsOverriddenLine = chargeInfo.IsOverriddenLine;

            Microsoft.Dynamics.Commerce.Runtime.DataModel.ChargeType chargeType = chargeInfo.ChargeType;
            markupTrans.IsAutoCharge = chargeType == Microsoft.Dynamics.Commerce.Runtime.DataModel.ChargeType::AutoCharge;
            markupTrans.MarkupCode = chargeInfo.Code;
            markupTrans.Value = chargeInfo.Amount;
            markupTrans.CurrencyCode = currencyCode;
            markupTrans.TaxGroup = chargeInfo.SalesTaxGroup;
            markupTrans.TaxItemGroup = chargeInfo.TaxGroup;
            markupTrans.TaxExemptPriceInclusiveOriginalPrice = chargeInfo.TaxExemptPriceInclusiveOriginalAmount;
            markupTrans.TaxExemptPriceInclusiveReductionAmount = chargeInfo.TaxExemptPriceInclusiveReductionAmount;
            markupTrans.ModuleCategory = (retailOrderTable.TableId == tableNum(SalesLine) || retailOrderTable.TableId == tableNum(SalesQuotationLine)) ? HeadingLine::Line : HeadingLine::Heading;

            if (ReflectionHelper::hasObjectProperty(chargeInfo, CalculatedProratedAmountStr))
            {
                markupTrans.CalculatedProratedAmount = ReflectionHelper::getObjectProperty(chargeInfo, CalculatedProratedAmountStr);
            }

            markupTrans.insert();
            if (isIndia)
            {
                RetailTransactionServiceOrders::initMarkupTrans_IN(markupTrans, storeId, chargeInfo);
            }

            // Create tax adjustments for charges
            if (areChargeLevelTaxAdjustmentsAllowed)
            {
                if (!isGteTaxCalculationType)
                {
                    RetailTransactionServiceOrders::CreateTaxLines(markupTrans.TableId, markupTrans.RecId, chargeInfo.Taxes, taxAdjustmentsMap);
                }
                else if (_orderHeader)
                {
                    RetailTransactionServiceOrders::CreateTaxMeasureAdjustments(_orderHeader.TableId, _orderHeader.RecId, markupTrans.TableId, markupTrans.RecId, chargeInfo.TaxMeasures, taxAdjustmentsMap);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCallCenterOrderPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create payment record in MCRCustPaymTable
    /// </summary>
    /// <param name = "salesTable">Sales order.</param>
    /// <param name = "custOrderInfo">Retail transaction input.</param>
    /// <param name = "isReturnOrder">Flag indicate if the sales order is return order.</param>
    public static void createCallCenterOrderPayment(SalesTable salesTable, CustomerOrderInfo custOrderInfo, boolean isReturnOrder)
    {
        PaymentInfoCollection payments = custOrderInfo.Payments;
        RefRecId channelRecId = str2Int64(custOrderInfo.ChannelRecordId);
        ttsbegin;
        for (int i=0; i<payments.get_Count(); i++)
        {
            PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;

            MCRCustPaymTable newCallCenterPayment;

            [newCallCenterPayment] = RetailTransactionPaymentsHelper::createCallCenterPayment(salesTable, paymentInfo, isReturnOrder, MCRCustPaymStatus::NotSubmitted);

            if (!paymentInfo.PaymentCaptured)
            {
                newCallCenterPayment.reread();
                newCallCenterPayment.selectForUpdate(true);
                if (paymentInfo.CreditCardAuthorization)
                {
                    CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(paymentInfo.CreditCardAuthorization);
                    CreditCard::recordAuthorization(CreditCardProviderAuthorizationResult::constructFromXmlString(paymentInfo.CreditCardAuthorization),
                                            salesTable,
                                            CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                            true,
                                            strFmt("@SYS327114", salesTable.SalesId),
                                            '',
                                            true,
                                            newCallCenterPayment);
                }

                if (paymentInfo.CreditCardToken)
                {
                    str authorizationXml = paymentInfo.CreditCardToken;
                    CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(authorizationXml);

                    // Save CreditCard token (if it was sent), and attach to SalesTable record.
                    str uniqueCardId = properties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();
                    CreditCardCust ccCust = CreditCardCust::findByUniqueCardId(uniqueCardId);

                    if (!ccCust)
                    {
                        // This will attach the credit card blob to the customer
                        ccCust = CreditCard::addCreditCard(
                        authorizationXml,
                        salesTable.InvoiceAccount,
                        CreditCard::FindBestMatchCreditCardProcessorId(properties));

                        CreditCardCust::scopeCreditCardToken(ccCust.RecId, RetailTokenScope::SalesOrder);
                    }

                    newCallCenterPayment.PaymInfoTableId = ccCust.TableId;
                    newCallCenterPayment.PaymInfoRecId = ccCust.RecId;
                    newCallCenterPayment.isNonRecurring = (ccCust.TokenScope == RetailTokenScope::NonRecurring);
                }

                newCallCenterPayment.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRetailOrderPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create payment journal for a sales order.
    /// </summary>
    /// <param name = "salesTable">Sales order.</param>
    /// <param name = "custOrderInfo">Retail transaction input.</param>
    /// <param name = "isReturnOrder">Flag indicate if the sales order is return order.</param>
    /// <remarks>This method uses an optional parameter OrigSalesId which contains the salesId of the original sales order when the payment is
    /// created for a return order. This parameter can be set using parmCreateRetailOrderPayment_OrigSalesId on <c>RetailTransactionserviceOrders::extendedParameters.</c></remarks>
    public static void createRetailOrderPayment(SalesTable salesTable, CustomerOrderInfo custOrderInfo, boolean isReturnOrder)
    {
        SalesIdBase origSalesId = extendedParameters.parmCreateRetailOrderPayment_OrigSalesId();
        RetailTransactionServiceOrders::createOrUpdateRetailOrderPayments(
            RetailCreateOrUpdatePaymentsParameters::initializeRetailCreateOrUpdatePaymentsParameters(
                salesTable,
                custOrderInfo,
                isReturnOrder,
                null,
                origSalesId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateRetailOrderPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create or update payments  for a sales order.
    /// </summary>
    /// <param name = "_parameters">An instance of class <c>RetailCreateOrUpdatePaymentsParameters</c> to provide parameters to this method.</param>
    public static void createOrUpdateRetailOrderPayments(RetailCreateOrUpdatePaymentsParameters _parameters)
    {
        SalesTable                      salesTable = _parameters.salesTable;
        CustomerOrderInfo               custOrderInfo = _parameters.custOrderInfo;
        boolean                         isReturnOrder = _parameters.isReturnOrder;
        AdvanceInvoiceContract_W        advanceInvoiceContract = _parameters.advanceInvoiceContract;
        SalesIdBase                     origSalesId = _parameters.origSalesId;
        PaymentInfoCollection           payments = custOrderInfo.Payments;
        RefRecId                        channelRecId = str2Int64(custOrderInfo.ChannelRecordId);

        LedgerJournalTable              ledgerJournalTable;
        LedgerJournalTrans              ledgerJournalTrans;
        RetailMCRChannelTable           callCenterUsedForOrderCreation =  RetailMCRChannelTable::findChannelBySalesTable(salesTable);

        SalesTable                      origSalesTable = SalesTable::find(origSalesId);
        RetailMCRChannelTable           callCenterUsedForOriginalOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(origSalesTable);

        boolean                         isOrigOrderCreatedInCallCenter = callCenterUsedForOriginalOrderCreation && origSalesTable.mcrIsCallCenter();
        boolean                         isCallCenterOrder = callCenterUsedForOrderCreation && salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion;
        boolean                         isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName());

        boolean                         countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        Voucher                         voucher, rCashVoucher, custPaymVoucher;
        LedgerJournalTable              rCashJournalTable, custPaymJournalTable;
        boolean                         isRCash;
        boolean                         isOmniChannelPayment;
        boolean isRetailPaymentsNoPrepayForOnAccountFlightEnabled = FeatureStateProvider::isFeatureEnabled(
            RetailPaymentsNoPrepayForOnAccountFlight::instance());

        // Define containers to store new and declined payments
        container existingDeclinedPayments, newPayments;

        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();
        timer.Start();

        eventSource.EventWritePaymentsCreateOrUpdateRetailOrderPaymentsCallStarted(salesTable.RecId, isCommercePaymentsOrder);
        ttsbegin;

        for (int i=0; i<payments.get_Count(); i++)
        {
            PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;
            eventSource.EventWritePaymentsCreatingOrUpdatingRetailOrderPayments(salesTable.RecId, paymentInfo.PaymentRefRecId, isCommercePaymentsOrder);

            if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName()))
            {
                MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRecID(paymentInfo.PaymentRefRecId);

                // For commerce payments orders the channel for the payment should be where it was authorized if available.
                if (mcrCustPaymTable)
                {
                    channelRecId = mcrCustPaymTable.Channel;
                }
                else if (paymentInfo.ChannelRecordId)
                {
                    channelRecId = paymentInfo.ChannelRecordId;
                }
            }

            // If the payment is a Customer Account Payment, then do NOT create a separate journal as this will credit the customer's account balance.
            if (RetailStoreTenderTypeTable::find(channelRecId, paymentInfo.PaymentType).function == RetailTenderFunction::Customer)
            {
                // Customer account payment should not be considered a deposit.
                if (isRetailPaymentsNoPrepayForOnAccountFlightEnabled)
                {
                    paymentInfo.Prepayment = false;
                }

                if (isCommercePaymentsOrder && paymentInfo.PaymentRefRecId == 0 && paymentInfo.PaymentStatusValue == enum2int(RetailTenderLineStatus::Committed))
                {
                    // Create payment line to record customer account payment for Commerce Payment Orders.
                    RetailTransactionPaymentsHelper::createCallCenterPayment(
                            salesTable,
                            paymentInfo,
                            isReturnOrder,
                            MCRCustPaymStatus::Posted);

                    // Skip further processing as payment journals aren't require to be created for Customer order payments since it is just a promise to pay.
                    continue;
                }
                else
                {
                    // Skip this payment line and let AX automatically settle against the customer's account during invoicing.
                    continue;
                }
            }

            //  Execute country specific tasks
            if (countryRegion_W)
            {
                // Check if the payment is a RCash payment
                isRCash = RetailStoreTenderTypeTable::find(RetailStoreTable::find(custOrderInfo.StoreId).RecId, paymentInfo.PaymentType).accountType == RetailLedgerBank::RCash;

                // Select payment journal for cash/non-cash payments
                ledgerJournalTable = isRCash ? rCashJournalTable : custPaymJournalTable;
            }

            // Get Omni channel payment flag
            isOmniChannelPayment  = RetailTransactionPaymentsHelper::isOmniChannelPayment(salesTable, paymentInfo);

            // Process credit card authorizations using Omni Channel flow
            // (In Omni channel flow, authorizations are moved and captured across channels, enabling "card not present" cross channel scenarios)
            if (isOmniChannelPayment)
            {
                // Omni-Channel credit card payments flow:
                //
                // - 'Pending Commit' payments record authorization (CreditCardAuthTrans) and update Call center payment (MCRCustPaymTable)
                // - 'Commited' payments record capture (CreditCardAuthTrans) and update call center payment (MCRCustPaymTable)
                // - 'Voided' payments record void (CreditCardAuthTrans) and update call center payment (MCRCustPaymTable)

                if (paymentInfo.PaymentRefRecId == 0)
                {
                    //
                    // Flow to insert NEW payments created in channels during:
                    //   - Recalls for update
                    //   - Recalls for checkout
                    //

                    // The payment should be processed as a call center payment if the current order is a call center order, OR if
                    // the current order is a return order, the original order was a call center order and the payment is a linked refund.
                    boolean processCallCenterPayment = isCallCenterOrder || (isReturnOrder && isOrigOrderCreatedInCallCenter && paymentInfo.LinkedPaymentRefRecId);

                    // Verify if the channel is a call center and retrieve it
                    if (processCallCenterPayment)
                    {
                        // Call center Orders:
                        // Flow for NEW order payments
                        [
                            ledgerJournalTable,
                            ledgerJournalTrans,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            existingDeclinedPayments,
                            newPayments
                        ]
                        = RetailTransactionPaymentsHelper::processNewCallCenterPayment(
                            channelrecId,
                            salesTable,
                            custOrderInfo,
                            paymentInfo,
                            ledgerJournalTable,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            isRCash,
                            isReturnOrder,
                            existingDeclinedPayments,
                            newPayments,
                            advanceInvoiceContract);
                    }
                    else
                    {
                        // Retail Orders:
                        // Flow for NEW order payments
                        [
                            ledgerJournalTable,
                            ledgerJournalTrans,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            existingDeclinedPayments,
                            newPayments
                        ]
                        = RetailTransactionPaymentsHelper::processNewRetailPayment(
                            channelrecId,
                            salesTable,
                            custOrderInfo,
                            paymentInfo,
                            ledgerJournalTable,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            isRCash,
                            isReturnOrder,
                            existingDeclinedPayments,
                            newPayments,
                            advanceInvoiceContract);
                    }
                }
                else
                {
                    // Flow to update EXISTING payments sent back from channels during:
                    //   - Recalls for update
                    //   - Recalls for pickup

                    if (isCallCenterOrder)
                    {
                        // Call center Orders:
                        // Flow for EXISTING order payments
                        [
                            ledgerJournalTable,
                            ledgerJournalTrans,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            existingDeclinedPayments,
                            newPayments
                        ]
                        = RetailTransactionPaymentsHelper::processExistingCallCenterPayment(
                            channelrecId,
                            salesTable,
                            custOrderInfo,
                            paymentInfo,
                            ledgerJournalTable,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            isRCash,
                            isReturnOrder,
                            existingDeclinedPayments,
                            newPayments,
                            advanceInvoiceContract);
                    }
                    else
                    {
                        // Retail Orders:
                        // Flow for EXISTING order payments
                        [
                            ledgerJournalTable,
                            ledgerJournalTrans,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            existingDeclinedPayments,
                            newPayments
                        ]
                        = RetailTransactionPaymentsHelper::processExistingRetailPayment(
                            channelrecId,
                            salesTable,
                            custOrderInfo,
                            paymentInfo,
                            ledgerJournalTable,
                            rCashJournalTable,
                            custPaymJournalTable,
                            voucher,
                            rCashVoucher,
                            custPaymVoucher,
                            isRCash,
                            isReturnOrder,
                            existingDeclinedPayments,
                            newPayments,
                            advanceInvoiceContract);
                    }
                }
            }
            // (!isOmniChannelPayment)
            // Process credit card authorizations using Backward compatibility Channel flow
            // (In Backward compatibility flow, authorizations must be created in the same channel as they are captured, in CARD PRESENT mode.)
            else
            {
                //
                // Backward compatibility flow:
                //
                // - 'Not captured' payments have their credit card token added to the customer and sales order
                // - 'Captured' payments are recorded as posted payment journals
                //

                if (!paymentInfo.PaymentCaptured)
                {
                    // Authorization should happen only for payment lines who are pending commit
                    if (!RetailOrdersFeatureControl::isSettleInvoiceAndPaymentJournalDuringShipOrderFulfillment()
                        ||  paymentInfo.PaymentStatusValue == enum2int(RetailTenderLineStatus::PendingCommit)
                        || paymentInfo.PaymentStatusValue == enum2int(RetailTenderLineStatus::None))
                    {
                        switch (paymentInfo.CreditCardProcessorStatusValue)
                        {
                            case CreditCardProcessorStatus::NA:
                            case CreditCardProcessorStatus::Approved:
                                // Create Sales Order credit card authorizations and credit card tokens
                                RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentAuthorization(channelRecId, salesTable, paymentInfo, true);
                                break;
                        }

                    }
                }
                else
                {
                    // Payment should be captured only committed payment lines
                    if (!RetailOrdersFeatureControl::isSettleInvoiceAndPaymentJournalDuringShipOrderFulfillment()
                        ||  paymentInfo.PaymentStatusValue == enum2int(RetailTenderLineStatus::Committed)
                        || paymentInfo.PaymentStatusValue == enum2int(RetailTenderLineStatus::None))
                    {
                        switch (paymentInfo.CreditCardProcessorStatusValue)
                        {
                            case CreditCardProcessorStatus::Approved:
                            case CreditCardProcessorStatus::NA:
                                if (salesTable.mcrIsCallCenter())
                                {
                                    // Create Call center payment for new captured amount
                                    RetailTransactionPaymentsHelper::createCallCenterPayment(
                                    salesTable,
                                    paymentInfo,
                                    isReturnOrder,
                                    MCRCustPaymStatus::Paid,
                                    existingDeclinedPayments,
                                    newPayments);
                                }

                                // Create Sales Order payment History (Payment Journal)
                                [
                                ledgerJournalTable,
                                ledgerJournalTrans,
                                rCashJournalTable,
                                custPaymJournalTable,
                                voucher,
                                rCashVoucher,
                                custPaymVoucher
                                ]
                                = RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentCapture(
                                        channelRecId,
                                        SalesTable,
                                        custOrderInfo,
                                        paymentInfo,
                                        LedgerJournalTable,
                                        rCashJournalTable,
                                        custPaymJournalTable,
                                        voucher,
                                        rCashVoucher,
                                        custPaymVoucher,
                                        isRCash,
                                        isReturnOrder,
                                        CreditCardOperation::AuthorizeAndCapture,
                                        null,
                                        advanceInvoiceContract);
                                break;
                        }
                    }
                }
            }
        }

        // In case payment journal is successfully created, account for any rounding differences and post the journal
        if (ledgerJournalTable)
        {
            // Create payment journal line to account for any penny differences between invoiced and paid amounts.
            RetailTransactionPaymentsHelper::createRoundingDifferencePaymentJournalLineForStore(SalesTable, LedgerJournalTable, custOrderInfo);

            // Call pre post payment journal delegation.
            RetailTransactionServiceOrders::prePostPaymentJournal(SalesTable, LedgerJournalTable, custOrderInfo);

            // Post the journal after all the journal transaction are updated
            if (countryRegion_W)
            {
                RetailTransactionPaymentsHelper::postLedgerJournalTable_RU(rCashJournalTable);
                RetailTransactionPaymentsHelper::postLedgerJournalTable_RU(custPaymJournalTable);
            }
            else
            {
                RetailTransactionPaymentsHelper::postPaymentJournalForStore(LedgerJournalTable, custOrderInfo);
            }

            if(!isCommercePaymentsOrder)
            {
                /// Save pre-payments in RetailPrepaymentTrans table
                RetailTransactionPaymentsHelper::savePrepaymentsForSalesOrder(salesTable);
            }

            // Prepare Payment Settlements for invoicing process, Adding all prepayments and payments into specTrans
            // While processing advance invoices, settlement should be postponed
            if (!advanceInvoiceContract)
            {
                RetailTransactionServiceOrders::prepareRetailSettlements(salesTable, maxInt());
            }
        }

        if (RetailSharedParameters::find().EnableOmniChannelPayments)
        {
            // Try re-authorize remaining balance
            RetailTransactionPaymentsHelper::adjustCallCenterPayments(
                salesTable,
                isReturnOrder,
                existingDeclinedPayments,
                newPayments,
                isCommercePaymentsOrder);
        }

        ttscommit;

        timer.Stop();
        eventSource.EventWritePaymentsCreateOrUpdateRetailOrderPaymentsCallCompleted(
            salesTable.RecId,
            isCommercePaymentsOrder,
            timer.ElapsedMilliseconds,
            payments.get_Count());
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsCustomerOrderWithExchange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the customer order contains exchange (return items).
    /// </summary>
    /// <param name = "_custOrderInfo">The customer order input to be validated.</param>
    /// <returns>True if customer order contains exchange, false otherwise.</returns>
    private static boolean IsCustomerOrderWithExchange(CustomerOrderInfo _custOrderInfo)
    {
        boolean containsExchange = false;

        System.Object prop = ReflectionHelper::getObjectProperty(_custOrderInfo, 'IsCustomerOrderWithExchange');

        if (prop != null)
        {
            containsExchange = prop;
        }

        return containsExchange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerOrderNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer order from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// DataContract of customer order info.
    /// </param>
    /// <param name="reuseInventoryReservation">
    /// Determines if we can reuse the existing inventory reservation.
    /// </param>
    /// <param name="validateOrderLine">
    /// Indicate whether order line validation required.
    /// </param>
    /// <param name="preventDuplicates">
    /// Indicates whether we need to find duplicates for the sales order.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    ///</returns>
    public static container createCustomerOrderNew(CustomerOrderInfo custOrderInfo, boolean reuseInventoryReservation, boolean validateOrderLine = true, boolean preventDuplicates = true)
    {
        int fromLine;
        SalesTable salesTable;
        boolean success = false;
        str error;
        RetailChannelRecId channelRecId = str2Int64(custOrderInfo.ChannelRecordId);
        boolean isCustomerOrderWithExchange = RetailTransactionServiceOrders::IsCustomerOrderWithExchange(custOrderInfo);

        //<GEEU>
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        boolean isAdvanceInvoice = countryRegion_W && (RetailParameters::find().UseAdvanceInvoice_W && RetailTransactionServiceAdvanceInvoice_W::isCustomerOrderTransaction(custOrderInfo));
        AdvanceInvoiceContract_W advanceInvoiceContract;
        CustInvoiceJour custInvoiceJour;
        //</GEEU>

        container validationResult = RetailCommercePaymentsFeatureHelper::validateCustomerOrderVersion(custOrderInfo);
        boolean validationResultSuccessful = conPeek(validationResult, 1);

        if (!validationResultSuccessful)
        {
            error = conPeek(validationResult, 2);
            return [validationResultSuccessful, error, custOrderInfo.Id];
        }

        ItemInfoCollection items = custOrderInfo.Items;
        if (items.get_Count() == 0)
        {
            eventSource.EventWriteOrdersCreateCustomerOrderNoSaleslineError(funcName());
            return [false, "@Retail:WithoutSalesline", ''];
        }
        else if (isCustomerOrderWithExchange)
        {
            System.Object prop = ReflectionHelper::getObjectProperty(custOrderInfo, fieldStr(RetailParameters, AllowExchangeOnReturnOrders));

            if (prop == null)
            {
                // indicating that AllowExchangeOnReturnOrders flag does not exist.
                error = "@Ret_HF_237604:CannotCreateOrderWithExchangeWithNoExchangeFlag";
                eventSource.EventWriteOrdersCreateCustomerOrderNoExchangeFlagError(funcName());
            }
            else
            {
                RetailParameters retailParameters = RetailParameters::find();
                boolean allowExchange = prop;

                if (!retailParameters.AllowExchangeOnReturnOrders)
                {
                    // tell customer that customer order that contains returned products cannot be created when 'Process return orders as sales orders' is disabled.
                    error = "@Ret_HF_237604:CannotCreateOrderWithExchangeWithExchangeFlagFalse";
                    eventSource.EventWriteOrdersCreateCustomerOrderFalseExchangeFlagError(funcName());
                }
                else if (!allowExchange)
                {
                    // mismatch value (server value is true while input value is false)
                    error = strFmt("@Ret_HF_237604:MismatchAllowExchangeOnReturnOrdersFlag", retailParameters.AllowExchangeOnReturnOrders == NoYes::Yes, allowExchange);
                    eventSource.EventWriteOrdersCreateCustomerOrderMismatchAllowExchangeOnReturnOrdersFlagError(funcName(), retailParameters.AllowExchangeOnReturnOrders == NoYes::Yes, allowExchange);
                }
            }

            if (error != '')
            {
                return [false, error, ''];
            }
        }

        try
        {
            fromLine = Global::infologLine();

            //Checking if any duplicate/previous sales orders created already.
            if (preventDuplicates)
            {
                salesTable = RetailTransactionService::findDuplicateSalesOrder(custOrderInfo);
            }

            if (salesTable)
            {
                eventSource.EventWriteOrdersCreateCustomerOrderAlreadyExistError(funcName(), salesTable.RecId);
                return [true, '', salesTable.SalesId];
            }

            using(var telemetry = RetailInstrumentationSegment::construct(classStr(RetailTransactionServiceOrders), funcName()))
            {
                ttsbegin;

                //create sales order
                salesTable.clear();
                salesTable.SalesId = RetailTransactionServiceOrders::getNextSalesId(custOrderInfo);
                salesTable.initValue(SalesType::Sales);
                custOrderInfo.Id = SalesTable.SalesId;

                // Void any existing credit card authorization linked to this order left behiind from previous retry
                RetailTransactionPaymentsHelper::voidAllSalesOrderAuthorizations(salesTable, true);

                Map taxAdjustmentsMap = new Map(Types::String, Types::Container);

                RetailTransactionServiceOrders::createOrUpdateRetailOrderHeader(salesTable, custOrderInfo, true, taxAdjustmentsMap);

                RetailTransactionServiceOrders::beforeCreatingRetailOrderLines(salesTable, custOrderInfo);

                // create sales lines
                using (RetailKitAssemblyOrderContext context = RetailKitAssemblyOrderContext::construct())
                {
                    if (custOrderInfo.StatementId != '')
                    {
                        // Since the statement id is set, this order must be from statement posting.
                        context.parmIsCashAndCarry(NoYes::Yes);
                        if (RetailStatementFeatureControl::isAutomaticallyPostSalesLineKitOrderEnabled())
                        {
                            eventSource.EventWriteOrdersCreateCustomerOrderPostKitOrder(funcName(), salesTable.RecId);

                            context.parmTransDate(str2Date(custOrderInfo.BusinessDateString, 321));
                            context.parmShouldAutomaticallyPostSalesLineKitOrder(true);
                        }
                    }
                    else
                    {
                        // Since the statement id isn't set, this must be a regular customer order.
                        context.parmIsCashAndCarry(NoYes::No);
                    }

                    RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesTable, custOrderInfo, false, isCustomerOrderWithExchange, null, taxAdjustmentsMap, reuseInventoryReservation);
                }

                RetailTransactionServiceOrders::updateRetailOrderHeader_MX(salesTable, custOrderInfo);

                // If cart has return or carry out lines, we add tax adjustments for the header charges
                boolean hasReturnLines = RetailTransactionServiceOrders::hasReturnLines(custOrderInfo);
                boolean hasCarryOutLines = RetailTransactionServiceOrders::hasCarryOutLines(custOrderInfo);

                // creation of charge codes
                RetailTransactionServiceOrders::createMarkupTrans(custOrderInfo.Charges, salesTable, salesTable.CurrencyCode, custOrderInfo.StoreId, custOrderInfo, taxAdjustmentsMap, hasReturnLines, hasCarryOutLines);

                // insert the tax adjustments
                TaxCalculationType taxCalculationType = ReflectionHelper::getObjectProperty(custOrderInfo, PropertyTaxCalculationType);
                if (taxCalculationType == TaxCalculationType::GTE)
                {
                    RetailTransactionServiceOrders::insertTaxMeasureAdjustments(taxAdjustmentsMap);
                }
                else
                {
                    RetailTransactionServiceOrders::insertTaxAdjustments(taxAdjustmentsMap);
                }

                if (custOrderInfo.AutoPickOrder)
                {
                    RetailTransactionServiceOrders::createPickingList(salesTable.SalesId, '', channelRecId);
                }

                // Update SalesTable record before adding payments.
                // After running extension code, it is advised to reread the table buffer, as it may be stale.
                if (salesTable.orig() != salesTable)
                {
                    salesTable.update();
                    salesTable.reread();
                }

                PaymentInfoCollection depositPaymentsForCustomerOrderExchange;

                // If payment contains deposit (for ship or pick up) and invoice (for return items),
                // remove the deposit payments input and let HQ invoice carry out and returned products with invoice payments first.
                // Store the deposit payments to be used after invoicing carry out and returned products.
                if (RetailTransactionServiceOrders::IsCustomerOrderWithExchange(custOrderInfo) && RetailTransactionServiceOrders::containsDepositAndInvoicePayments(custOrderInfo.Payments))
                {
                    depositPaymentsForCustomerOrderExchange = RetailTransactionServiceOrders::removeDepositPaymentType(custOrderInfo);
                }

                if (custOrderInfo.StoreId && RetailStoreTable::findRecId(channelRecId).IsCallCenter)
                {
                    // creation of call center payment
                    RetailTransactionServiceOrders::createCallCenterOrderPayment(salesTable, custOrderInfo, false);
                }
                else
                {
                    // creation of prepayment journal
                    if (isAdvanceInvoice)
                    {
                        advanceInvoiceContract = new AdvanceInvoiceContract_W();
                        RetailTransactionServiceOrders::createOrUpdateRetailOrderPayments(
                        RetailCreateOrUpdatePaymentsParameters::initializeRetailCreateOrUpdatePaymentsParameters(
                            salesTable,
                            custOrderInfo,
                            false,
                            advanceInvoiceContract));
                        RetailTransactionServiceOrders::prepareRetailSettlements(salesTable, maxInt());
                    }
                    else
                    {
                        RetailTransactionServiceOrders::createOrUpdateRetailOrderPayments(
                        RetailCreateOrUpdatePaymentsParameters::initializeRetailCreateOrUpdatePaymentsParameters(
                            salesTable,
                            custOrderInfo,
                            false));
                    }
                }

                RetailTransactionServiceOrders::updateSalesOrdersByAffiliations(salesTable, custOrderInfo);

                // Check and update sales order's Estimate.
                // During Order payment creation, a new tts connection is opened and updates salesTable with credit card info.
                // If we don't reread() the record, we get an update conflict error.
                salesTable.reread();

                if (RetailPaymentsSkipCreditLimitCheckToggle::instance().isEnabled())
                {
                    // Credit limit verification should not happen in statement post/orders.
                    if (custOrderInfo.StatementId == '')
                    {
                        SalesTotals salesTotals = SalesTotals::construct(salesTable, SalesUpdate::All);

                        // A check against credit limit is needed when the payments on the order do not cover the order totals.
                        if (RetailTransactionServiceOrders::isCheckAgainstCreditLimitRequired(custOrderInfo, salesTotals))
                        {
                            RetailTransactionServiceOrders::checkCreditLimit(salesTable, salesTotals);
                        }
                    }
                }
                else
                {
                    RetailTransactionServiceOrders::checkCreditLimit(salesTable);
                }

                salesTable.update();

                if (custOrderInfo.StatementId == '')
                {
                    using (RetailTransactionServiceInvoiceContext context = RetailTransactionServiceOrders::createRetailTransactionServiceInvoiceContext(custOrderInfo))
                    {
                        RetailCustomerOrderCarryoutParameters parameters = new RetailCustomerOrderCarryoutParameters();
                        parameters.isCustomerOrderWithExchange = isCustomerOrderWithExchange;
                        parameters.salesTable = salesTable;
                        parameters.custOrderInfo = custOrderInfo;
                        parameters.invoiceNow = true;

                        RetailTransactionServiceOrders::postInvoiceForReturnedCarryOutItems(parameters);
                    }
                }

                if (advanceInvoiceContract)
                {
                    advanceInvoiceContract.parmCarryOutInvoiceAmount(custInvoiceJour.InvoiceAmount);
                    advanceInvoiceContract.parmSalesTable(SalesTable);
                    advanceInvoiceContract.initFromCustomerOrderInfo(custOrderInfo);

                    RetailTransactionServiceAdvanceInvoice_W::createCustAdvanceInvoiceByContract(advanceInvoiceContract);
                }

                // If collection of deposit payments exists, then we have not insert these payments to HQ yet.
                // Add the payments to the CustomerOrderInfo instance and execute createRetailOrderPayment.
                if (depositPaymentsForCustomerOrderExchange)
                {
                    PaymentInfoCollection paymentCollection = custOrderInfo.Payments;
                    paymentCollection.Clear();

                    for (int i = 0; i < depositPaymentsForCustomerOrderExchange.Count; i++)
                    {
                        PaymentInfo depositPayment = depositPaymentsForCustomerOrderExchange.get_Item(i) as PaymentInfo;
                        paymentCollection.Add(depositPayment);
                    }

                    RetailTransactionServiceOrders::createRetailOrderPayment(salesTable, custOrderInfo, false);
                }

                RetailTransactionServiceOrders::updateSalesId(custOrderInfo);

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
                {
                    RetailCustomerOrderLine_W::createOrUpdateLines(custOrderInfo);
                }

                // Re-check if any duplicate/previous sales orders created already.
                SalesTable salesTableDups;
                if (preventDuplicates)
                {
                    salesTableDups = RetailTransactionService::findDuplicateSalesOrder(custOrderInfo);
                }

                RetailCustomerOrderHeaderParameters args = RetailCustomerOrderHeaderParameters::construct();
                args.custOrderInfo = custOrderInfo;
                args.orderHeader = salesTable;
                args.orderHeaderExt = salesTable.retailSalesTable();
                args.mcrSalesTable = salesTable.mcrSalesTable();
                args.createNew = true;
                RetailCreateCustomerOrderExtensions::retailOrderCreated(args);

                RetailTransactionServiceOrders::setCreatedOrderSynchronizationStatus(salesTable, custOrderInfo);

                if (salesTableDups)
                {
                    ttsabort;
                    salesTable = salesTableDups;
                    eventSource.EventWriteOrdersCreateCustomerOrderDuplicatedOrder(funcName(), salesTable.RecId);
                }
                else
                {
                    ttscommit;
                    eventSource.EventWriteOrdersCreateCustomerOrderOrderCreated(funcName(), salesTable.RecId);
                }
            }

            error = '';
            success = true;
        }

        catch(Exception::UpdateConflictNotRecovered)
        {
            error = "@Retail:CreateCustomerOrder_UpdateConflictNotRecovered";
            eventSource.EventWriteOrdersCreateCustomerOrderError(funcName());
            success = false;
        }

        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCreateCustomerOrderError(funcName());
            success = false;
        }

        if (success)
        {
            RetailTransactionServiceSalesAgreement::cancelOrderBySalesIdWhenSalesAgreementValidationFails(salesTable);
        }
        else if (RetailCreateCustomerOrderNoSalesIdWhenFailedFlight::instance().isEnabled())
        {
            salesTable.SalesId = '';
        }

        return [success, error, salesTable.SalesId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCheckAgainstCreditLimitRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a check against credit limit is required on the customer order.
    /// A credit limit check is required when the order total is not covered by the payments,
    /// excluding on account as they require a credit limit check and should not count as
    /// covering the order's total.
    /// </summary>
    /// <param name = "_customerOrderInfo">The customer order information data contract object.</param>
    /// <param name = "_salesTotals">The sales total object.</param>
    /// <returns>true if a credit limit check is required; otherwise, false.</returns>
    public static boolean isCheckAgainstCreditLimitRequired(CustomerOrderInfo _customerOrderInfo, SalesTotals _salesTotals)
    {
        PaymentInfoCollection paymentInfoCollection = _customerOrderInfo.Payments;
        AmountCur depositAmount = 0;
        AmountCur authorizedAmount = 0;

        boolean includeAllPayments = RetailPaymentsCustomerAccountPaymentBalanceToggle::instance().isDisabled();

        for (int payment = 0; payment < paymentInfoCollection.get_Count(); payment++)
        {
            PaymentInfo paymentInfo = paymentInfoCollection.get_Item(payment) as PaymentInfo;

            // Should exclude customer on account payments as they require a credit limit check.
            boolean includePayment = includeAllPayments ||
                RetailStoreTenderTypeTable::find(str2Int64(_customerOrderInfo.ChannelRecordId), paymentInfo.PaymentType).function != RetailTenderFunction::Customer;

            if (includePayment)
            {
                if (paymentInfo.Amount > 0)
                {
                    depositAmount += paymentInfo.Amount;
                }
                else if (paymentInfo.AuthorizedAmount > 0)
                {
                    authorizedAmount += paymentInfo.AuthorizedAmount;
                }
            }
        }

        return decRound(_salesTotals.totalAmount(), 0) != decRound(depositAmount + authorizedAmount, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditLimit</Name>
				<Source><![CDATA[
    private static void checkCreditLimit(SalesTable _salesTable, SalesTotals _salesTotals = null)
    {
        if (!RetailConfigurationParameters::IsCreditLimitValidationInChannelEnabled())
        {
            return;
        }

        boolean creditLimitCheck = SalesTableType::checkAgainstCreditLimit(_salesTable, _salesTotals);

        if (!creditLimitCheck && CustParameters::find().CreditLineError == CreditLineErrorType::Error)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesOrdersByAffiliations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs affiliations and updates the sales id of sales orders.
    /// </summary>
    /// <param name = "_salesTable">
    ///     Sales table buffer.
    /// </param>
    /// <param name = "_custOrderInfo">
    ///     Customer order information table buffer.
    /// </param>
    protected static void updateSalesOrdersByAffiliations(SalesTable _salesTable, CustomerOrderInfo _custOrderInfo)
    {
        // Affiliations
        RetailSalesAffiliation::SetAffiliatonsAndLoyaltyTiers(_salesTable.SalesId, _custOrderInfo.Affiliations);
        for (int i = 0; i < _custOrderInfo.Affiliations.get_Count(); i++)
        {
            AffiliationInfo affiliationInfo = _custOrderInfo.Affiliations.get_Item(i) as AffiliationInfo;
            ReasonCodeLineInfoCollection reasonCodeLines = ReflectionHelper::getObjectProperty(affiliationInfo, ReasonCodeLinesParamName) as ReasonCodeLineInfoCollection;
            if (reasonCodeLines != null)
            {
                RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(_salesTable.RecId, affiliationInfo.AffiliationRecordId, reasonCodeLines, RetailInfoCodeLineRelatedTableType::Sales);
            }
        }

        if (_custOrderInfo.TransactionId)
        {
            RetailLoyaltyCardRewardPointTrans::UpdateLoyaltyPaymentEntriesWithSalesId(_custOrderInfo.TransactionId, _salesTable.SalesId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer order from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// DataContract of customer order info.
    /// </param>
    /// <param name="validateOrderLine">
    /// Indicate whether order line validation required.
    /// </param>
    /// <param name="preventDuplicates">
    /// Indicates whether we need to find duplicates for the sales order.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerOrder(CustomerOrderInfo custOrderInfo, boolean validateOrderLine = true, boolean preventDuplicates = true)
    {
        return RetailTransactionServiceOrders::createCustomerOrderNew(custOrderInfo, false, validateOrderLine, preventDuplicates);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOnlineCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an online customer order from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// DataContract of customer order info.
    /// </param>
    /// <param name="validateOrderLine">
    /// Indicate whether order line validation required.
    /// </param>
    /// <param name="preventDuplicates">
    /// Indicates whether we need to find duplicates for the sales order.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    /// <remarks>
    /// This method is used to create online orders and does not rely on the order synchronizer.
    /// The order synchronizer will not create a duplicate order, instead it will mark the <c>RetailTransactionTable</c> record with the created sales id.
    /// </remarks>
    public static container createOnlineCustomerOrder(CustomerOrderInfo custOrderInfo, boolean validateOrderLine = true, boolean preventDuplicates = true)
    {
        container createdOrder = RetailTransactionServiceOrders::createCustomerOrder(custOrderInfo, validateOrderLine, preventDuplicates);

        boolean isSuccess = conPeek(createdOrder, 1);

        if (isSuccess)
        {
            // Update RetailTransactionOrderStatus table with the last InventTransId for the sales order.
            // Retail server product availability APIs depend on this.
            SalesId createdSalesId = conPeek(createdOrder, 3);
            RefRecId lastInventTrans = RetailInventTransHelper::getLastInventTransForSalesOrder(createdSalesId);

            RetailTransactionOrderStatus::setOrderStatus(str2Int64(custOrderInfo.ChannelRecordId),
                                                         custOrderInfo.StoreId,
                                                         custOrderInfo.TerminalId,
                                                         custOrderInfo.TransactionId,
                                                         RetailTransactionOrderStatusType::PendingSynchronization,
                                                         '', // No error details.
                                                         createdSalesId,
                                                         lastInventTrans);
        }

        return createdOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info having the header, line details and charges associated with the quote to be created.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation created.
    /// </returns>
    public static container createCustomerQuote(CustomerOrderInfo custOrderInfo)
    {
        int fromLine;
        SalesQuotationTable salesQuotationTable;
        boolean success = false;
        str error;

        ItemInfoCollection items = custOrderInfo.Items;
        if (items.get_Count() == 0)
        {
            eventSource.EventWriteOrdersCreateCustomerQuoteNoSaleslineError(funcName());
            return [false, "@Retail:WithoutSalesline", ''];
        }

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;
            NumberSeq numberSeq = NumberSeq::newGetNum(SalesParameters::numRefSalesQuotationId(), true);
            salesQuotationTable.clear();
            salesQuotationTable.initValue();
            salesQuotationTable.QuotationId =  numberSeq.num();
            salesQuotationTable.QuotationType = QuotationType::Sales;
            custOrderInfo.Id  = salesQuotationTable.QuotationId;

            RetailTransactionServiceOrders::createOrUpdateRetailOrderHeader(salesQuotationTable, custOrderInfo, true);

            //Creation of sales quotation lines
            RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesQuotationTable, custOrderInfo);

            //creation of charge code
            RetailTransactionServiceOrders::createMarkupTrans(custOrderInfo.Charges, salesQuotationTable, salesQuotationTable.CurrencyCode, custOrderInfo.StoreId, custOrderInfo);

            // Affiliations
            RetailTransactionServiceOrders::updateSalesQuotationByAffiliations(salesQuotationTable, custOrderInfo.Affiliations);

            numberSeq.used();
            success = true;
            ttscommit;
            eventSource.EventWriteOrdersCreateCustomerQuoteCreated(funcName(), salesQuotationTable.RecId);
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCreateCustomerQuoteError(funcName());
            success = false;
        }
        return [success, error, salesQuotationTable.QuotationId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer return order from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info having the header, line details and charges, payments associated with the retrn order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerReturnOrder(CustomerOrderInfo custOrderInfo)
    {
        int fromLine;
        SalesTable salesTable;
        boolean success = false;
        str error;

        // In case this a retry, we look for a duplicate Sales Order.  If it exists, then the previous call succeeded and we can exit early.
        salesTable = RetailTransactionService::findDuplicateSalesOrder(custOrderInfo);
        if (salesTable)
        {
            return [true, '', salesTable.SalesId];
        }

        System.Object prop = ReflectionHelper::getObjectProperty(custOrderInfo, fieldStr(RetailParameters, AllowExchangeOnReturnOrders));

        // Only validate if the property object is not null to support backward compatibility.
        if (prop != null)
        {
            boolean allowExchange = prop;
            RetailParameters retailParameters = RetailParameters::find();

            if (retailParameters.AllowExchangeOnReturnOrders)
            {
                // tell customer that customer order return cannot be created when 'Process return orders as sales orders' is enabled.
                error = "@Ret_HF_237604:CannotCreateReturnOrderWithExchangeFlagTrue";
                eventSource.EventWriteOrdersCreateCustomerReturnAllowExchangeOnReturnOrdersOrderFlagError(funcName());
            }
            else if (allowExchange)
            {
                // mismatch value (server value is false while input value is true)
                error = strFmt("@Ret_HF_237604:MismatchAllowExchangeOnReturnOrdersFlag", retailParameters.AllowExchangeOnReturnOrders == NoYes::Yes, allowExchange);
                eventSource.EventWriteOrdersCreateCustomerReturnOrderMismatchAllowExchangeOnReturnOrdersFlagError(funcName(), retailParameters.AllowExchangeOnReturnOrders == NoYes::Yes, allowExchange);
            }

            if (error != '')
            {
                return [false, error, ''];
            }
        }

        try
        {
            fromLine = Global::infologLine();

            using(var telemetry = RetailInstrumentationSegment::construct(classStr(RetailTransactionServiceOrders), funcName()))
            {
                ttsbegin;
                NumberSeq numberSeq = NumberSeq::newGetNum(SalesParameters::numRefSalesId());
                boolean countryRegion_W  = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
                Map taxAdjustmentsMap = new Map(Types::String, Types::Container);

                //create sales order
                salesTable.clear();
                salesTable.initValue(SalesType::ReturnItem);
                salesTable.SalesId = numberSeq.num();
                SalesIdBase origSalesId = custOrderInfo.Id;
                custOrderInfo.Id = SalesTable.SalesId;    // Use the new Id instead of the original order Id.
                salesTable.ReturnStatus = ReturnStatusHeader::Created;
                salesTable.ReturnReasonCodeId = custOrderInfo.ReturnReasonCodeId;

                RetailTransactionServiceOrders::createOrUpdateRetailOrderHeader(salesTable, custOrderInfo, true, taxAdjustmentsMap);

                // creation of returned items.
                RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesTable, custOrderInfo, false, false, null, taxAdjustmentsMap);

                RetailTransactionServiceOrders::updateRetailOrderHeader_MX(salesTable, custOrderInfo);

                //creation of charge codes.
                RetailTransactionServiceOrders::createMarkupTrans(custOrderInfo.Charges, salesTable, salesTable.CurrencyCode, custOrderInfo.StoreId, custOrderInfo, taxAdjustmentsMap, true);

                // Update GST transaction Id
                RetailTransactionServiceOrders::populateGSTTransactionId(salesTable, custOrderInfo);

                // Insert the tax adjustments
                boolean isGteTaxCalculationType = (custOrderInfo.TaxCalculationType == enum2int(TaxCalculationType::GTE));
                if (isGteTaxCalculationType)
                {
                    RetailTransactionServiceOrders::insertTaxMeasureAdjustments(taxAdjustmentsMap);
                }
                else
                {
                    RetailTransactionServiceOrders::insertTaxAdjustments(taxAdjustmentsMap);
                }

                // Update packing slip for the return order
                SalesFormLetter salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);
                salesFormLetter.reArrangeNow(false);
                salesFormLetter.update(salesTable,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),SalesUpdate::All, AccountOrder::None,false,false,false);

                // Add payments before doing invoice on returned products.
                extendedParameters.parmCreateRetailOrderPayment_OrigSalesId(origSalesId);
                RetailTransactionServiceOrders::createRetailOrderPayment(salesTable, custOrderInfo, true);

                // Reset the OrigSalesId parameter so that it's not set incorrectly for another code path that might call recordRefund without setting the parameter.
                extendedParameters.parmCreateRetailOrderPayment_OrigSalesId('');

                var taxCalculationBehaviorController = RetailTaxCalculationBehaviorCustomerOrderInfoController::construct(custOrderInfo);

                using (RetailTransactionServiceInvoiceContext context = RetailTransactionServiceOrders::createRetailTransactionServiceInvoiceContext(custOrderInfo))
                {
                    TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);

                    // Create invoice for the sales order
                    if (countryRegion_W)
                    {
                        RetailTransactionServiceOrders::postSalesInvoiceForStatement_RU(salesTable, SalesUpdate::All, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), taxCalculationBehaviorController);
                    }
                    else
                    {
                        // Set the Italy-specific reason code for sales order, if necessary.
                        if (RetailChronologicalInvoicePostingReasonCodeSetter::isEnabled())
                        {
                            RetailChronologicalInvoicePostingReasonCodeSetter reasonCodeSetter =
                                RetailChronologicalInvoicePostingReasonCodeSetter::constuct(salesTable, businessDate);

                            reasonCodeSetter.setSalesReasonCode();
                        }

                        salesFormLetter = SalesFormLetter::construct(DocumentStatus::Invoice);
                        taxCalculationBehaviorController.configureInvoicingToAllowLineLevelTaxAdjusments(salesFormLetter);
                        salesFormLetter.reArrangeNow(false);
                        salesFormLetter.update(salesTable, businessDate, SalesUpdate::All, AccountOrder::None,false,false);
                    }
                }

                // Affiliations
                RetailSalesAffiliation::SetAffiliatonsAndLoyaltyTiers(salesTable.SalesId, custOrderInfo.Affiliations);

                if (custOrderInfo.TransactionId)
                {
                    RetailLoyaltyCardRewardPointTrans::UpdateLoyaltyPaymentEntriesWithSalesId(custOrderInfo.TransactionId, salesTable.SalesId);
                }

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
                {
                    RetailCustomerOrderLine_W::createOrUpdateLines(custOrderInfo);
                }

                error = '';
                success = true;
                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            if ((appl.ttsLevel() == 0)
            && (xSession::currentRetryCount() < #RetryNum))
            {
                retry;
            }
            else
            {
                throw Exception::Deadlock;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCreateCustomerReturnOrderError(funcName());
            success = false;
        }

        return [success, error, salesTable.SalesId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDiscountLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create Retail Sales Discount Line records for the given sales line xml fragment
    /// </summary>
    /// <param name="_xml">
    /// An XmlElement for an "Item" node in a Customer Order xml document.
    /// </param>
    /// <param name="_orderLine">
    ///  The associated Sales Line record.
    /// </param>
    /// <param name="_forQuote">
    /// True to create discount lines for a quote, false to create discount lines for a sales order.
    /// </param>
    /// <remarks>
    /// Parses and inserts Retail Sales Discount Line records for the given Item/SalesLine entity.
    /// </remarks>
    private static void createDiscountLines(DiscountInfoCollection discounts, RetailOrderLineMap _orderLine, boolean _forQuote = false)
    {
        if (discounts.get_Count() > 0 && _orderLine.inventTransId)
        {
            for (int i = 0 ; i < discounts.get_Count(); i++)
            {
                DiscountInfo discountInfo = discounts.get_Item(i) as DiscountInfo;
                if (_forQuote)
                {
                    RetailSalesQuotationDiscountLine quoteDiscountLineTable = RetailTransactionServiceOrders::createRetailSalesQuotationDiscountLine(discountInfo, _orderLine);
                    quoteDiscountLineTable.insert();
                }
                else
                {
                    RetailSalesDiscountLine salesDiscountLineTable = RetailTransactionServiceOrders::createRetailSalesDiscountLine(discountInfo, _orderLine);
                    salesDiscountLineTable.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRetailSalesQuotationDiscountLine</Name>
				<Source><![CDATA[
    internal protected static RetailSalesQuotationDiscountLine createRetailSalesQuotationDiscountLine(DiscountInfo _discountInfo, RetailOrderLineMap _orderLine)
    {
        RetailSalesQuotationDiscountLine quoteDiscountLineTable;
        quoteDiscountLineTable.clear();
        quoteDiscountLineTable.InventTransId = _orderLine.InventTransId;
        quoteDiscountLineTable.Amount = _discountInfo.Amount;
        quoteDiscountLineTable.DiscountOriginType = _discountInfo.DiscountOriginType;
        quoteDiscountLineTable.CustomerDiscountType = _discountInfo.CustomerDiscountType;
        quoteDiscountLineTable.ManualDiscountType = _discountInfo.ManualDiscountType;
        quoteDiscountLineTable.DiscountCode = _discountInfo.DiscountCode;
        quoteDiscountLineTable.PeriodicDiscountOfferId = _discountInfo.PeriodicDiscountOfferId;
        quoteDiscountLineTable.DealPrice = _discountInfo.DealPrice;
        quoteDiscountLineTable.DiscountAmount = _discountInfo.DiscountAmount;
        quoteDiscountLineTable.Percentage = _discountInfo.Percentage;
        quoteDiscountLineTable.BundleId = _discountInfo.BundleId;
        return quoteDiscountLineTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRetailSalesDiscountLine</Name>
				<Source><![CDATA[
    internal protected static RetailSalesDiscountLine createRetailSalesDiscountLine(DiscountInfo _discountInfo, RetailOrderLineMap _orderLine)
    {
        RetailSalesDiscountLine salesDiscountLineTable;
        salesDiscountLineTable.clear();
        salesDiscountLineTable.InventTransId = _orderLine.InventTransId;
        salesDiscountLineTable.Amount = _discountInfo.Amount;
        salesDiscountLineTable.DiscountOriginType = _discountInfo.DiscountOriginType;
        salesDiscountLineTable.CustomerDiscountType = _discountInfo.CustomerDiscountType;
        salesDiscountLineTable.ManualDiscountType = _discountInfo.ManualDiscountType;
        salesDiscountLineTable.DiscountCode = _discountInfo.DiscountCode;
        salesDiscountLineTable.PeriodicDiscountOfferId = _discountInfo.PeriodicDiscountOfferId;
        salesDiscountLineTable.DealPrice = _discountInfo.DealPrice;
        salesDiscountLineTable.DiscountAmount = _discountInfo.DiscountAmount;
        salesDiscountLineTable.Percentage = _discountInfo.Percentage;
        salesDiscountLineTable.BundleId = _discountInfo.BundleId;
        return salesDiscountLineTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceLines</Name>
				<Source><![CDATA[
    private static void createPriceLines(PriceInfoCollection _prices, RetailOrderLineMap _orderLine, boolean _forQuote = false)
    {
        if (_prices.get_Count() > 0 && _orderLine.InventTransId)
        {
            ttsbegin;

            PriceDiscAmount basePrice, agreementPrice, price;

            for (int i = 0; i < _prices.get_Count(); i++)
            {
                PriceInfo priceInfo = _prices.get_Item(i) as PriceInfo;
                price = RetailTransactionServiceOrders::createPriceLine(priceInfo, _orderLine, _forQuote);
                basePrice = priceInfo.PriceType == enum2int(PriceLineType::BasePriceLine) ? price : basePrice;
                agreementPrice =  priceInfo.PriceType == enum2int(PriceLineType::TradeAgreementPriceLine) ? price : agreementPrice;
            }

            if (agreementPrice)
            {
                basePrice = basePrice > 0 ? basePrice : InventTableModule::find(_orderLine.ItemId, ModuleInventPurchSales::Sales).Price;
                RetailTransactionServiceOrders::createGUPFlexibleMargin(_forQuote, _orderLine.inventTransId, basePrice, agreementPrice);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceLine</Name>
				<Source><![CDATA[
    internal protected static PriceDiscAmount createPriceLine(PriceInfo _priceInfo, RetailOrderLineMap _orderLine, boolean _forQuote)
    {
        if (_priceInfo.PriceType == enum2int(PriceLineType::PriceAdjustmentPriceLine))
        {
            RetailPeriodicDiscount  periodicDiscount;
            RetailDiscountLineOffer discountLineOffer;

            select firstonly UnitOfMeasure, LineNum, Name, discountMethod, discAmount, discPct, offerPrice, RecId from discountLineOffer
                where discountLineOffer.RecId == _priceInfo.RecordId
                join RecId, OfferId from periodicDiscount
                where periodicDiscount.OfferId == discountLineOffer.OfferId;

            if (discountLineOffer.RecId)
            {
                if (_forQuote)
                {
                    RetailSalesQuotationPriceAdjustmentLine adjustmentLine;

                    select firstonly forupdate RecId from adjustmentLine
                        where adjustmentLine.InventTransId == _orderLine.inventTransId
                           && adjustmentLine.OfferId == periodicDiscount.OfferId
                           && adjustmentLine.LineNum == discountLineOffer.LineNum;

                    adjustmentLine.InventTransId = _orderLine.inventTransId;
                    adjustmentLine.OfferId = periodicDiscount.OfferId;
                    adjustmentLine.LineNum = discountLineOffer.LineNum;
                    adjustmentLine.Name = discountLineOffer.Name;
                    adjustmentLine.Amount = RetailTransactionServiceOrders::getAdjustmentAmount(_priceInfo, discountLineOffer, _forQuote);
                    adjustmentLine.DiscountMethod = discountLineOffer.discountMethod;
                    adjustmentLine.RetailPeriodicDiscountLineRefRecId = _priceInfo.RecordId;

                    if (adjustmentLine.RecId)
                    {
                        adjustmentLine.doUpdate();
                    }
                    else
                    {
                        adjustmentLine.doInsert();
                    }
                }
                else
                {
                    RetailSalesPriceAdjustmentLine adjustmentLine;

                    select firstonly forupdate RecId from adjustmentLine
                        where adjustmentLine.InventTransId == _orderLine.inventTransId
                           && adjustmentLine.OfferId == periodicDiscount.OfferId
                           && adjustmentLine.LineNum == discountLineOffer.LineNum;

                    adjustmentLine.InventTransId = _orderLine.inventTransId;
                    adjustmentLine.OfferId = periodicDiscount.OfferId;
                    adjustmentLine.LineNum = discountLineOffer.LineNum;
                    adjustmentLine.Name = discountLineOffer.Name;
                    adjustmentLine.Amount = RetailTransactionServiceOrders::getAdjustmentAmount(_priceInfo, discountLineOffer, _forQuote);
                    adjustmentLine.DiscountMethod = discountLineOffer.discountMethod;
                    adjustmentLine.RetailPeriodicDiscountLineRefRecId = _priceInfo.RecordId;

                    if (adjustmentLine.RecId)
                    {
                        adjustmentLine.doUpdate();
                    }
                    else
                    {
                        adjustmentLine.doInsert();
                    }
                }

                RetailTransactionServiceOrders::createGUPPriceAdjustmentLine(_priceInfo, _orderLine, _forQuote, periodicDiscount, discountLineOffer);
            }
        }

        return _priceInfo.Value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentAmount</Name>
				<Source><![CDATA[
    internal protected static DiscAmount getAdjustmentAmount(PriceInfo _priceInfo, RetailDiscountLineOffer _discountLineOffer, boolean _forQuote = false)
    {
        switch (_discountLineOffer.discountMethod)
        {
            case RetailDiscountOfferLineDiscMethodBase::AmountOff:
                return _discountLineOffer.discAmount;
            case RetailDiscountOfferLineDiscMethodBase::PercentOff:
                return _discountLineOffer.discPct;
            case RetailDiscountOfferLineDiscMethodBase::Price:
                return _discountLineOffer.offerPrice;
        }

        return _priceInfo.Value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGUPFlexibleMargin</Name>
				<Source><![CDATA[
    internal protected static void createGUPFlexibleMargin(
        boolean _forQuote,
        InventTransId _inventTransId,
        PriceDiscAmount _basePrice,
        PriceDiscAmount _agreementPrice)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGUPPriceAdjustmentLine</Name>
				<Source><![CDATA[
    internal protected static void createGUPPriceAdjustmentLine(
        PriceInfo _priceInfo,
        RetailOrderLineMap _orderLine,
        boolean _forQuote,
        RetailPeriodicDiscount _periodicDiscount,
        RetailDiscountLineOffer _discountLineOffer)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PackingSlip for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    /// [Obsolete] This parameter won't be supported in new releases of the product and is still here for compatibility purposes only.
    /// </param>
    /// <param name="_retailChannelRecId">
    /// Channel for which to create the packing list. Default to 0.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PackingSlip creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPackingSlip(SalesId _salesId, InventLocationId _inventLocationId = '', RetailChannelRecId _retailChannelRecId = 0)
    {
        SalesLine       salesLine;
        boolean         hasActiveInSalesProcess;
        SalesTable      salesTable;
        InventLocationId inventLocationId;
        RetailStoreTable retailStoreTable;
        str             error;
        int             fromLine;
        container       printSuccess = [true,''];

        salesTable = SalesTable::find(_salesId);

        select InventLocationIdForCustomerOrder, InventLocation from retailStoreTable
            where retailStoreTable.RecId == _retailChannelRecId;

        if (RetailUseStorePrimaryWarehouseForPickingPackingToggle::instance().isEnabled())
        {
            inventLocationId = retailStoreTable.InventLocation;
        }
        else
        {
            inventLocationId = retailStoreTable.InventLocationIdForCustomerOrder;
        }

        if (salesTable)
        {
            fromLine = Global::infologLine();

            // Check if there are any Active in Sales process Serial Number lines
            while select ItemId, DataAreaId from salesLine
                where salesLine.SalesId == salesTable.SalesId
            {
                if (EcoResTrackingDimensionGroupItem::isItemActiveInSalesProcess(salesLine.dataAreaId, salesLine.ItemId))
                {
                    hasActiveInSalesProcess = true;
                    break;
                }
            }

            try
            {
                if (RetailOrderManager::ProcessOrderDelivery(_salesId, inventLocationId, DocumentStatus::PackingSlip))
                {
                    printSuccess = [true, ''];
                    eventSource.EventWriteOrdersCreatePackingSlipCreatedSuccessful(funcName(), salesTable.RecId);
                }
                else
                {
                    if (hasActiveInSalesProcess)
                    {
                        printSuccess = [false, strFmt("@RET490396", _salesId), #SerialItemsActiveInSalesProcess];
                    }
                    else
                    {
                        printSuccess = [false, strFmt("@RET490396", _salesId)];
                    }
                    eventSource.EventWriteOrdersCreatePackingSlipNotCreatedNoDeliverNowQuantities(funcName(), salesTable.RecId);
                }
            }
            catch(Exception::Error)
            {
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteOrdersCreatePackingSlipError(funcName());

                if (hasActiveInSalesProcess)
                {
                    printSuccess = [false, error, #SerialItemsActiveInSalesProcess];
                }
                else
                {
                    printSuccess = [false, error];
                }
            }
        }
        else
        {
            printSuccess = [false, strFmt("@RET4513", _salesId)];
            eventSource.EventWriteOrdersCreatePackingSlipOrderNotFoundWarning(funcName());
        }

        return printSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PickingList for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    /// [Obsolete] This parameter won't be supported in new releases of the product and is still here for compatibility purposes only.
    /// </param>
    /// <param name="_retailchannelId">
    /// Channel where picking list is being created. Default to 0.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PickingList creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPickingList(SalesId _salesId, InventLocationId _inventLocationId = '', RetailChannelRecId _retailChannelRecId = 0)
    {
        SalesTable          salesTable;
        SalesFormLetter     salesFormLetter;
        SalesLine           salesLine;
        RetailSalesLine     retailSalesLine;
        RetailStoreTable    retailStoreTable;
        RetailChannelTable  retailChannelTable;
        int                 fromLine;
        str                 error;
        container           printSuccess = [false, ''];
        boolean             hasQuantityToPick = false;
        SalesQty            qtyToDeliver;
        InventDim           inventDim;

        /*
        <?xml version="1.0" encoding="utf-16" ?>
        - <PickAndPackOrder xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ChannelRecordId>5637144592</ChannelRecordId>
        <SalesId>012536</SalesId>
        <SalesLineParameters />
        </PickAndPackOrder>
        */

        salesTable = SalesTable::find(_salesId);

        if (salesTable)
        {
            fromLine = Global::infologLine();

            select inventLocation, InventLocationIdForCustomerOrder from retailStoreTable
                where retailStoreTable.RecId == _retailChannelRecId;

            try
            {
                ttsbegin;
                while select forupdate * from salesLine
                    where salesLine.SalesId == _salesId
                    join inventDimId, InventLocationId from inventDim
                    where salesLine.InventDimId == inventDim.inventDimId
                {
                    boolean flightIsEnabled = RetailUseStorePrimaryWarehouseForPickingPackingToggle::instance().isEnabled();

                    if ((retailStoreTable.inventLocation == inventDim.InventLocationId && flightIsEnabled) ||
                        (retailStoreTable.InventLocationIdForCustomerOrder == inventDim.InventLocationId && !flightIsEnabled))
                    {
                        // Get remaining quantity less any that are on active picklists or on completed picklists.
                        qtyToDeliver = salesLine.RemainInventPhysical - salesLine.qtyOnPickNotReserved() - salesLine.pickedInTotalInventUnit();

                        if (abs(qtyToDeliver) > 0)
                        {
                            hasQuantityToPick = true;

                            salesLine.SalesDeliverNow = salesLine.unitConvertInvent2Sales(qtyToDeliver);
                            salesLine.InventDeliverNow = qtyToDeliver;
                            salesLine.doUpdate();
                        }
                    }
                }

                // If all remaining quantity is covered by active/completed picklists then do not attempt to pick anything.
                if (hasQuantityToPick)
                {
                    salesFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
                    salesFormLetter.reArrangeNow(false);
                    salesFormLetter.update(salesTable, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), SalesUpdate::DeliverNow, AccountOrder::None, false, false, false);

                    printSuccess = [true, ''];
                    eventSource.EventWriteOrdersCreatePickingListCreatedSuccessful(funcName(), salesTable.RecId);
                }
                else
                {
                    printSuccess = [false, strFmt("@RET490396", _salesId)];
                    eventSource.EventWriteOrdersCreatePickingListNotCreatedNoDeliverNowQuantities(funcName(), salesTable.RecId);
                }
                ttscommit;
            }
            catch(Exception::Error)
            {
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteOrdersCreatePickingListError(funcName());
                return [false, error];
            }
        }
        else
        {
            printSuccess = [false, strFmt("@RET4513",_salesId)];
            eventSource.EventWriteOrdersCreatePickingListOrderNotFoundWarning(funcName());
        }

        return printSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickListForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates picking list for the given items.
    /// </summary>
    /// <param name="paramList">
    /// XML string having the items and pickup quantity details.
    /// </param>
    /// <returns>
    /// A container having the status of Pick list creation.
    /// </returns>
    public static container createPickListForCustomerOrder(container paramList)
    {
        str             custOrderXmlStr,error = '';
        SalesQty        qty,pickUpQty;
        SalesTable      salesTable;
        SalesLine       salesLine;
        SalesId         salesId;
        XmlDocument     custOrderXml;
        XmlElement      xmlRoot;
        XmlElement      xmlRecord;
        XmlNodeList     xmlRecordList;
        ItemId          itemId;
        SalesFormLetter salesFormLetter;
        boolean         success = false;
        Counter         infologline    = infolog.num();
        int             i;
        int             fromLine;

        custOrderXmlStr = conPeek(paramList, 1);
        custOrderXml    = new XmlDocument();
        custOrderXml.loadXml(custOrderXmlStr);

        try
        {
            fromLine = Global::infologLine();

            custOrderXmlStr = conPeek(paramList, 1);
            custOrderXml   = new XmlDocument();
            custOrderXml.loadXml(custOrderXmlStr);
            xmlRoot = custOrderXml.documentElement().getNamedElement('SalesId');
            salesId = xmlRoot.text();
            xmlRoot = custOrderXml.documentElement().getNamedElement('Items');
            xmlRecordList = xmlRoot.childNodes();

            if (xmlRecordList)
            {
                for (i=0; i < xmlRecordList.length(); i++)
                {
                    xmlRecord = xmlRecordList.item(i);
                    itemId = xmlRecord.getAttribute(fieldStr(SalesLine, ItemId));
                    qty = str2num(xmlRecord.getAttribute('Quantity'));
                    pickUpQty = str2num(xmlRecord.getAttribute('PickUpQty'));
                    if (pickUpQty <= qty)
                    {
                        select forupdate salesLine
                            where salesLine.SalesId == salesId
                                && salesLine.ItemId == itemId;
                        salesLine.SalesDeliverNow = pickUpQty;
                        salesLine.update();
                    }
                }
                salesTable = SalesTable::find(salesId);
                salesFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
                salesFormLetter.reArrangeNow(false);
                salesFormLetter.update(salesTable,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),SalesUpdate::DeliverNow, AccountOrder::None,false,false,false);
            }
            success = true;
            eventSource.EventWriteOrdersCreatePickListForCustomerOrderCreatedSuccessful(funcName());
        }

        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCreatePickListForCustomerOrderError(funcName());
            success = false;
        }

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingListForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create picking list for sales line on order.
    /// </summary>
    /// <param name = "pickingListXmlStr">XML string having the items and pickup quantity details.</param>
    /// <returns>A container having the status and picking list id.</returns>
    public static container createPickingListForOrder(str pickingListXmlStr)
    {
        XmlDocument pickingListXml;
        XmlElement  xmlRoot;
        XmlElement  xmlRecord;
        XmlNodeList xmlRecordList;

        SalesId salesId;
        RetailChannelRecId retailChannelRecId;
        SalesTable salesTable;
        SalesLine salesLine;
        RetailStoreTable retailStoreTable;
        InventDim inventDim;
        SalesFormLetter salesFormLetter;
        SalesQty pickingListQty ;
        SalesQty qtyToDeliver, absQtyToDeliver;
        LineNum salesLineNumber;

        WMSPickingRoute         route;
        WMSPickingRouteLink     routeLink;

        str error = '';
        str pickingRouteIDCreated = '';
        boolean success = false;
        boolean hasQuantityToPick = false;
        int i;
        int fromLine;
        container output = [false, ''];

        pickingListXml    = new XmlDocument();
        pickingListXml.loadXml(pickingListXmlStr);

        try
        {
            fromLine = Global::infologLine();

            xmlRoot = pickingListXml.documentElement().getNamedElement('SalesId');
            salesId = xmlRoot.text();

            xmlRoot = pickingListXml.documentElement().getNamedElement('ChannelRecordId');
            retailChannelRecId = str2Int64(xmlRoot.text());

            xmlRoot = pickingListXml.documentElement().getNamedElement('SalesLineParameters');
            xmlRecordList = xmlRoot.childNodes();

            salesTable = SalesTable::find(salesId);

            select inventLocation, InventLocationIdForCustomerOrder
                    from retailStoreTable where retailStoreTable.RecId == retailChannelRecId;

            if (salesTable)
            {
                if (xmlRecordList && xmlRecordList.length() > 0)
                {
                    ttsbegin;

                    for (i = 0; i < xmlRecordList.length(); i++)
                    {
                        xmlRecord = xmlRecordList.item(i);
                        salesLineNumber = str2Num(xmlRecord.getAttribute('LineNumber'));
                        pickingListQty  = str2Num(xmlRecord.getAttribute('Quantity'));

                        select forupdate salesLine
                            join inventDimId, InventLocationId from inventDim
                            where salesLine.SalesId == salesId
                                && salesLine.LineNum == salesLineNumber
                                && salesLine.InventDimId == inventDim.inventDimId;

                        // Check if store should be allowed to create picking list.
                        if (retailStoreTable.inventLocation == inventDim.InventLocationId ||
                            retailStoreTable.InventLocationIdForCustomerOrder == inventDim.InventLocationId)
                        {
                            // Get remaining quantity less any that are on active picklists or on completed picklists.
                            qtyToDeliver = salesLine.RemainInventPhysical - salesLine.qtyOnPickNotReserved() - salesLine.pickedInTotalInventUnit();
                            absQtyToDeliver = abs(qtyToDeliver);

                            if (absQtyToDeliver > 0 && pickingListQty <= absQtyToDeliver)
                            {
                                hasQuantityToPick = true;
                                salesLine.SalesDeliverNow = salesLine.unitConvertInvent2Sales(pickingListQty);
                                salesLine.InventDeliverNow = pickingListQty;
                                salesLine.update();
                            }
                        }
                    }

                    if (hasQuantityToPick)
                    {
                        salesFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
                        salesFormLetter.reArrangeNow(false);
                        salesFormLetter.update(salesTable, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), SalesUpdate::DeliverNow, AccountOrder::None, false, false, false);

                        success = true;
                        eventSource.EventWriteOrdersCreatePickingListForOrderCreatedSuccessful(funcName(), salesTable.RecId);
                    }
                    else
                    {
                        success = false;
                        error = strFmt("@RET490396", salesId);
                        eventSource.EventWriteOrdersCreatePickingListForOrderNotCreatedNoDeliverNowQuantities(funcName(), salesTable.RecId);
                    }

                    ttscommit;
                }
                else
                {
                    // Create picking list for all the lines available at channel.
                    output = RetailTransactionServiceOrders::createPickingList(salesId, '', retailChannelRecId);
                    success = conPeek(output, 1);
                    error = conpeek(output, 2);
                }
            }
            else
            {
                eventSource.EventWriteOrdersCreatePickingListForOrderOrderNotFoundWarning(funcName());
                success = false;
                error = strFmt("@RET4513", salesId);
            }


            // Gets the latest picking route id for order.
            if (success)
            {
                select firstonly pickingRouteID, ActivationDateTime from route
                        order by route.ActivationDateTime desc
                    join PickingRouteId, ActivationDateTime, OrigInventTransRefId from routeLink
                        where   route.pickingRouteID == routeLink.PickingRouteId
                        && route.ActivationDateTime == routeLink.ActivationDateTime
                        && routeLink.OrigInventTransRefId == salesId;

                pickingRouteIDCreated = route.pickingRouteID;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersCreatePickingListForOrderError(funcName());
            return [false, error];
        }

        return [success, error, pickingRouteIDCreated];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get channel appropriate details for a sales order
    /// </summary>
    /// <param name="salesId">
    /// Sales Id of the sales order to retrieve
    /// </param>
    /// <param name="channelId">
    /// The channel id where the sales order originated
    /// </param>
    /// <param name="channelRefId">
    /// The channel reference id of the sales order to retrieve
    /// </param>
    /// <returns>
    /// container: [succees, errormessage, xml]
    /// </returns>
    /// <remarks>
    /// success = True if the sales order was retrieved successfully, false otherwise
    /// errormessage = empty if success == True, otherwise an error message
    /// xml = xml document describing the sales order
    /// </remarks>
    public static container getChannelSalesOrderDetail(SalesId salesId, RefRecId channelId, RetailOrderChannelReferenceId channelRefId = '')
    {
        #OCCRetryCount

        container salesOrder = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        SalesTable              soTable;
        RetailSalesTable        rsoTable;
        SalesLine               soLine;
        RetailSalesLine         rsoLine;
        RetailTransactionOrderStatus rtosTable;
        InventDim               inventDim;
        Counter                 pCounter = 0;
        str                     xmlString = '';
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;
        XmlElement              xmlCharge;
        XmlElement              xmlAddress;
        SalesTotals             salesTotals;
        AmountCur               totalAmount;
        AmountCur               totalTaxAmount;
        AmountCur               totalDiscount;
        AmountCur               totalChargeAmount;

        RetailSalesTableInstanceValue   retailSalesTableInstanceValue;
        EcoResAttribute                 ecoResAttribute;
        EcoResAttributeValue            ecoResAttributeValue;
        EcoResTextValue                 ecoResTextValue;

        MarkupTrans             markupTrans;
        LogisticsPostalAddress  deliveryAddress;

        try
        {
            ttsbegin;
            if (salesId && channelRefId)
            {
                select soTable where soTable.SalesType == SalesType::Sales
                    && soTable.SalesId == salesId
                join ChannelReferenceId, RetailChannel from rsoTable where soTable.RecId == rsoTable.SalesTable
                    && rsoTable.RetailChannel == channelId
                    && rsoTable.ChannelReferenceId == channelRefId
                outer join TransactionId from rtosTable where soTable.SalesId == rtosTable.SalesId;
            }
            else if (salesId)
            {
                select soTable where soTable.SalesId == salesId
                    && soTable.SalesType      == SalesType::Sales
                    outer join ChannelReferenceId, RetailChannel from rsoTable where soTable.RecId == rsoTable.SalesTable
                    outer join TransactionId from rtosTable where soTable.SalesId == rtosTable.SalesId;
            }
            else
            {
                select soTable
                    where soTable.SalesType == SalesType::Sales
                    join ChannelReferenceId, RetailChannel from rsoTable
                        where soTable.RecId == rsoTable.SalesTable
                           && rsoTable.RetailChannel == channelId
                           && rsoTable.ChannelReferenceId == channelRefId
                    outer join TransactionId from rtosTable
                        where soTable.SalesId == rtosTable.SalesId;
            }

            if (soTable)
            {
                xmlDoc = XmlDocument::newBlank();

                xmlRoot = xmlDoc.createElement(tableStr(SalesTable));

                xmlRoot.setAttribute('RecId', int642str(soTable.RecId));
                xmlRoot.setAttribute('SalesId', soTable.SalesId);
                xmlRoot.setAttribute('SalesName', soTable.SalesName);
                xmlRoot.setAttribute('CustAccount', soTable.CustAccount);
                xmlRoot.setAttribute('ChannelReferenceId', rsoTable.ChannelReferenceId);
                xmlRoot.setAttribute('ChannelId', int642str(rsoTable.RetailChannel));
                xmlRoot.setAttribute('TransactionId', rtosTable.TransactionId);

                xmlRoot.setAttribute('SalesStatus', int2str(enum2int(soTable.SalesStatus)));
                xmlRoot.setAttribute('DocumentStatus', int2str(enum2int(soTable.DocumentStatus)));
                xmlRoot.setAttribute('DlvMode', soTable.DlvMode);
                xmlRoot.setAttribute('AddressRecId', int642str(soTable.DeliveryPostalAddress));
                xmlRoot.setAttribute('DeliveryName', soTable.DeliveryName);
                xmlRoot.setAttribute('InventSiteId', soTable.InventSiteId);
                xmlRoot.setAttribute('InventLocationId', soTable.InventLocationId);

                xmlRoot.setAttribute('CreatedDateTime', RetailTransactionServiceUtilities::utcDateTimeToString(soTable.CreatedDateTime));
                xmlRoot.setAttribute('ReceiptDateRequested', RetailTransactionServiceUtilities::dateToString(soTable.ReceiptDateRequested));

                SalesOrderTotals orderTotals;
                if (FeatureStateProvider::isFeatureEnabled(RetailEnableSalesOrderTotalsFeature::instance()))
                {
                    orderTotals = SalesOrderTotals::find(soTable.SalesId);
                }
        
                if (orderTotals)
                {
                    totalAmount       = orderTotals.OrderTotalAmount;
                    totalTaxAmount    = orderTotals.OrderTotalTaxAmount;
                    totalDiscount     = orderTotals.OrderTotalDiscountAmount;
                    totalChargeAmount = orderTotals.OrderTotalChargesAmount;
                }
                else
                {
                    // totalAmount is the sales order balance due amount + previously invoiced amounts
                    salesTotals     = SalesTotals::construct(soTable, SalesUpdate::All);
                    salesTotals.calc();
                    totalAmount     = salesTotals.totalAmount() + soTable.amountInvoiced();
                    totalTaxAmount  = salesTotals.totalTaxAmount();
                    totalDiscount   = salesTotals.totalLineDisc();
                    totalChargeAmount = salesTotals.totalMarkup();
                }

                xmlRoot.setAttribute('TotalAmount', num2str(totalAmount, 5, 3, 1, 0));
                xmlRoot.setAttribute('TotalTaxAmount', num2str(totalTaxAmount, 5, 3, 1, 0));
                xmlRoot.setAttribute('TotalDiscount', num2str(totalDiscount, 5, 3, 1, 0));
                xmlRoot.setAttribute('TotalCharges', num2str(totalChargeAmount, 5, 3, 1, 0));

                // Get delivery address
                deliveryAddress = LogisticsPostalAddress::findRecId(soTable.DeliveryPostalAddress);
                if (deliveryAddress)
                {
                    xmlAddress = xmlDoc.createElement(tableStr(LogisticsPostalAddress));
                    xmlAddress.setAttribute('RecId', int642str(deliveryAddress.RecId));
                    xmlAddress.setAttribute('Location', int642str(deliveryAddress.Location));
                    xmlAddress.setAttribute('Address', deliveryAddress.Address);
                    xmlAddress.setAttribute('BuildingCompliment', deliveryAddress.BuildingCompliment);
                    xmlAddress.setAttribute('PostBox', deliveryAddress.PostBox);
                    xmlAddress.setAttribute('County', deliveryAddress.County);
                    xmlAddress.setAttribute('City', deliveryAddress.City);
                    xmlAddress.setAttribute('DistrictName', deliveryAddress.DistrictName);
                    xmlAddress.setAttribute('Street', deliveryAddress.Street);
                    xmlAddress.setAttribute('StreetNumber', deliveryAddress.StreetNumber);
                    xmlAddress.setAttribute('State', deliveryAddress.State);
                    xmlAddress.setAttribute('ZipCode', deliveryAddress.ZipCode);
                    xmlAddress.setAttribute('CountryRegionId', deliveryAddress.CountryRegionId);
                    xmlRoot.appendChild(xmlAddress);
                }

                while select * from soLine
                    join * from inventDim where soLine.SalesId == soTable.SalesId
                        && inventDim.InventDimId == soLine.InventDimId
                    outer join rsoLine where rsoLine.SalesLine == soLine.RecId
                {
                    xmlRecord = xmlDoc.createElement(tableStr(SalesLine));

                    xmlRecord.setAttribute('RecId', int642str(soLine.RecId));
                    xmlRecord.setAttribute('ItemId', soLine.ItemId);
                    xmlRecord.setAttribute('InventDimId', soLine.InventDimId);
                    xmlRecord.setAttribute('SalesQty', num2str(soLine.SalesQty, 0, 2, 1, 0));
                    xmlRecord.setAttribute('SalesDeliverNow', num2str(soLine.SalesDeliverNow, 0, 2, 1, 0));

                    xmlRecord.setAttribute('SalesPrice', num2str(soLine.SalesPrice, 5, 3, 1, 0));
                    xmlRecord.setAttribute(TaxGroupStr, soLine.TaxGroup);
                    xmlRecord.setAttribute(TaxItemGroupStr, soLine.TaxItemGroup);
                    xmlRecord.setAttribute('LineAmount', num2str(soLine.LineAmount, 5, 3, 1, 0));
                    xmlRecord.setAttribute('LineAmountExclTax', num2str(soLine.lineAmountExclTax(), 5, 3, 1, 0));
                    xmlRecord.setAttribute('LineAmountDisc', num2str(soLine.LineDisc, 5, 3, 1, 0));

                    xmlRecord.setAttribute('DlvMode', soLine.DlvMode);
                    xmlRecord.setAttribute('AddressRecId', int642str(soLine.DeliveryPostalAddress));
                    xmlRecord.setAttribute('DeliveryName', soLine.DeliveryName);

                    xmlRecord.setAttribute('InventBatchId', inventDim.InventBatchId);
                    xmlRecord.setAttribute('WmsLocationId', inventDim.wmsLocationId);
                    xmlRecord.setAttribute('WmsPalletId', '');
                    xmlRecord.setAttribute('InventSiteId', inventDim.InventSiteId);
                    xmlRecord.setAttribute('InventLocationId', inventDim.InventLocationId);
                    xmlRecord.setAttribute('ConfigId', inventDim.ConfigId);
                    xmlRecord.setAttribute('InventSizeId', inventDim.InventSizeId);
                    xmlRecord.setAttribute('InventColorId', inventDim.InventColorId);
                    xmlRecord.setAttribute('InventStyleId', inventDim.InventStyleId);
                    xmlRecord.setAttribute('InventVersionId', inventDim.InventVersionId);
                    xmlRecord.setAttribute('InventSerialId', inventDim.InventSerialId);

                    if (rsoLine)
                    {
                        xmlRecord.setAttribute('ListingId', rsoLine.ListingId);
                    }

                    // Get delivery address
                    deliveryAddress = LogisticsPostalAddress::findRecId(soLine.DeliveryPostalAddress);
                    if (deliveryAddress)
                    {
                        xmlAddress = xmlDoc.createElement(tableStr(LogisticsPostalAddress));
                        xmlAddress.setAttribute('RecId', int642str(deliveryAddress.RecId));
                        xmlAddress.setAttribute('Location', int642str(deliveryAddress.Location));
                        xmlAddress.setAttribute('Address', deliveryAddress.Address);
                        xmlAddress.setAttribute('BuildingCompliment', deliveryAddress.BuildingCompliment);
                        xmlAddress.setAttribute('PostBox', deliveryAddress.PostBox);
                        xmlAddress.setAttribute('County', deliveryAddress.County);
                        xmlAddress.setAttribute('City', deliveryAddress.City);
                        xmlAddress.setAttribute('DistrictName', deliveryAddress.DistrictName);
                        xmlAddress.setAttribute('Street', deliveryAddress.Street);
                        xmlAddress.setAttribute('StreetNumber', deliveryAddress.StreetNumber);
                        xmlAddress.setAttribute('State', deliveryAddress.State);
                        xmlAddress.setAttribute('ZipCode', deliveryAddress.ZipCode);
                        xmlAddress.setAttribute('CountryRegionId', deliveryAddress.CountryRegionId);
                        xmlRecord.appendChild(xmlAddress);
                    }

                    //Add line level charges
                    while select * from markupTrans
                        where markupTrans.TransTableId == soLine.TableId
                        && markupTrans.TransRecId == soLine.RecId
                    {
                        xmlCharge = xmlDoc.createElement(tableStr(MarkupTrans));
                        xmlCharge.setAttribute('MarkupCode', markupTrans.MarkupCode);
                        xmlCharge.setAttribute('Value', num2str(markupTrans.Value, 5, 3, 1, 0));
                        xmlCharge.setAttribute('CurrencyCode', markupTrans.CurrencyCode);
                        xmlCharge.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
                        xmlCharge.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);
                        xmlCharge.setAttribute('TaxAmount', num2str(markupTrans.TaxAmount, 5, 3, 1, 0));
                        xmlCharge.setAttribute('ModuleType', int2str(enum2int(markupTrans.ModuleType)));
                        xmlCharge.setAttribute('CalculatedAmount', num2str(markupTrans.CalculatedAmount, 5, 3, 1, 0));
                        xmlCharge.setAttribute('MarkupCategory', int2str(enum2int(markupTrans.MarkupCategory)));
                        xmlRecord.appendChild(xmlCharge);
                    }

                    RetailGetChannelSalesOrderDetailLineParameters lineParameters = RetailGetChannelSalesOrderDetailLineParameters::construct();
                    lineParameters.xmlDoc = xmlDoc;
                    lineParameters.xmlRoot = xmlRoot;
                    lineParameters.xmlRecord = xmlRecord;
                    lineParameters.salesLine = soLine;

                    RetailCustomerOrderExtensions::getChannelSalesOrderDetailPreAppendLine(lineParameters);

                    //Add the completed line
                    xmlRoot.appendChild(xmlRecord);
                }

                //Add header level charges
                while select * from markupTrans
                    where markupTrans.TransTableId == soTable.TableId
                    && markupTrans.TransRecId == soTable.RecId
                {
                    xmlCharge = xmlDoc.createElement(tableStr(MarkupTrans));
                    xmlCharge.setAttribute('MarkupCode', markupTrans.MarkupCode);
                    xmlCharge.setAttribute('Value', num2str(markupTrans.Value, 5, 3, 1, 0));
                    xmlCharge.setAttribute('CurrencyCode', markupTrans.CurrencyCode);
                    xmlCharge.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
                    xmlCharge.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);
                    xmlCharge.setAttribute('TaxAmount', num2str(markupTrans.TaxAmount, 5, 3, 1, 0));
                    xmlCharge.setAttribute('ModuleType', int2str(enum2int(markupTrans.ModuleType)));
                    xmlCharge.setAttribute('CalculatedAmount', num2str(markupTrans.CalculatedAmount, 5, 3, 1, 0));
                    xmlCharge.setAttribute('MarkupCategory', int2str(enum2int(markupTrans.MarkupCategory)));
                    xmlRoot.appendChild(xmlCharge);
                }

                //Add attributes
                retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(soTable.SalesId, soTable.DataAreaId);
                // if this sales order has any attributes
                if ( retailSalesTableInstanceValue)
                {
                    //Get all attributes (Name and Text value) for this sales order
                    while select * from ecoResAttributeValue where ecoResAttributeValue.InstanceValue == retailSalesTableInstanceValue.RecId
                        join Name from ecoResAttribute where ecoResAttribute.RecId == ecoResAttributeValue.Attribute
                            join TextValue from ecoResTextValue where ecoResTextValue.RecId == ecoResAttributeValue.Value
                    {
                        xmlRecord = xmlDoc.createElement(tableStr(EcoResTextValue));
                        xmlRecord.setAttribute('Name', ecoResAttribute.Name);
                        xmlRecord.setAttribute('TextValue', ecoResTextValue.TextValue);
                        xmlRoot.appendChild(xmlRecord);
                    }
                }

                xmlDoc.appendChild(xmlRoot);
                xmlString = xmlDoc.toString();
            }

            salesOrder = [true, '', xmlString];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            salesOrder = [false, "@RET2382"];
        }
        catch
        {
            salesOrder = [false, "@RET2382"];
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer history summary and sales orders
    /// </summary>
    /// <param name="_customerId">
    /// CustAccount id for the customer
    /// </param>
    /// <param name="_historyType">
    /// How much history to return
    /// </param>
    /// <returns>
    /// XML document containing history summary and list of sales orders
    /// </returns>
    /// <remarks>
    /// Returns a summary of history activity and list of sales orders for the configured period (30, 60, 90 days)
    /// </remarks>
    public static container getCustomerHistory(CustAccount _customerId, RetailCustomerHistoryType _historyType = RetailCustomerHistoryType::Days30)
    {
        SalesTable          salesTable;
        SalesLine           salesLine;
        InventDim           inventDim;
        CustTable           custTable;
        RetailSalesTable    retailSalesTable;

        str                 error = '';
        boolean             success = false;
        XmlDocument         xmldoc;
        XmlElement          xmlRoot, xmlRecord, xmlItems, xmlHeaderInfo;
        int                 fromLine;
        RetailStoreTable    retailStoreTable;
        RetailStoreId       storeId = '';

        str                 storeName;
        int64               visitCount;
        AmountCur           totalAmount;

        int                 historyDays;
        utcDateTime         fromDate;

        try
        {
            fromLine = Global::infologLine();

            xmldoc =  XmlDocument::newBlank();
            custTable = custTable::find(_customerId);

            if (custTable)
            {
                // Init number of history days to consider
                switch (_historyType)
                {
                    case RetailCustomerHistoryType::Days90:
                        historyDays = -90;
                        break;
                    case RetailCustomerHistoryType::Days60:
                        historyDays = -60;
                        break;
                    default:
                        historyDays = -30;
                        break;
                }
                fromDate = DateTimeUtil::addDays(DateTimeUtil::utcNow(), historyDays);

                xmlRoot = xmldoc.createElement('CustomerHistory');

                //Get the sales order header info
                xmlHeaderInfo = xmldoc.createElement('CustomerAccount');
                xmlHeaderInfo.innerText(custTable.AccountNum);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('DateCreated');
                xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::utcDateTimeToString(custTable.createdDateTime));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Order summary info

                //Last visit date/store
                select firstOnly *
                    from salesTable
                    order by createdDateTime desc
                    where salesTable.CustAccount == _customerId;

                xmlHeaderInfo = xmldoc.createElement('LastVisitDate');
                xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::utcDateTimeToString(salesTable.createdDateTime));
                xmlRoot.appendChild(xmlHeaderInfo);

                retailSalesTable = salesTable.retailSalesTable();
                if (retailSalesTable)
                {
                    storeName = RetailChannelTable::findByRecId(salesTable.retailSalesTable().RetailChannel).name();
                }
                xmlHeaderInfo = xmldoc.createElement('LastVisitStore');
                xmlHeaderInfo.innerText(storeName);
                xmlRoot.appendChild(xmlHeaderInfo);

                // Total visits
                select count(RecId)
                    from salesTable where salesTable.CustAccount == _customerId;

                visitCount = salesTable.RecId;
                xmlHeaderInfo = xmldoc.createElement('TotalVisitsCount');
                xmlHeaderInfo.innerText(int642str(visitCount));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Totals (sum of ALL items for this customer)
                select sum(LineAmount)
                    from salesLine
                    where salesLine.CustAccount == _customerId;

                totalAmount = 0.00;
                if (salesLine)
                {
                    totalAmount = salesLine.LineAmount;
                }
                xmlHeaderInfo = xmldoc.createElement('TotalSalesAmount');
                xmlHeaderInfo.innerText(num2str(totalAmount,5,3,1,0));
                xmlRoot.appendChild(xmlHeaderInfo);

                //Get the info of items
                xmlItems = xmldoc.createElement('Items');
                while select
                        SalesId,
                        createdDateTime,
                        ItemId,
                        SalesPrice,
                        SalesQty,
                        SalesStatus,
                        SalesUnit,
                        LineDisc,
                        LineAmount
                    from salesLine
                    order by createdDateTime desc
                    where (salesLine.CustAccount == _customerId) && (salesLine.createdDateTime >= fromDate)
                    join
                        InventLocationId
                    from inventDim where salesLine.InventDimId == inventDim.InventDimId
                {
                    xmlRecord = xmldoc.createElement('Item');

                    xmlRecord.setAttribute('SalesId', salesLine.SalesId);
                    xmlRecord.setAttribute('Status', int2str(enum2int(salesLine.SalesStatus)));
                    xmlRecord.setAttribute('DateCreated', RetailTransactionServiceUtilities::utcDateTimeToString(salesLine.createdDateTime));

                    xmlRecord.setAttribute('RecId', int642str(salesLine.RecId));
                    xmlRecord.setAttribute('ItemId', salesLine.ItemId);
                    xmlRecord.setAttribute('Price', num2str(salesLine.SalesPrice,5,3,1,0));
                    xmlRecord.setAttribute('Quantity',num2str(salesLine.SalesQty,5,1,1,0));
                    xmlRecord.setAttribute('NetAmount',num2str(salesLine.LineAmount,5,3,1,0));

                    select firstonly * from retailStoreTable
                        where retailStoreTable.InventLocation == inventDim.InventLocationId
                           && retailStoreTable.inventLocationDataAreaId == curExt();
                    storeId = '';
                    if (retailStoreTable)
                    {
                        storeId = retailStoreTable.name();
                    }
                    xmlRecord.setAttribute('StoreName', storeId);

                    RetailGetCustomerHistoryLineParameters lineParameters = RetailGetCustomerHistoryLineParameters::construct();
                    lineParameters.xmlDoc = xmlDoc;
                    lineParameters.xmlRoot = xmlRoot;
                    lineParameters.xmlItems = xmlItems;
                    lineParameters.xmlRecord = xmlRecord;
                    lineParameters.salesLine = salesLine;

                    RetailCustomerOrderExtensions::getCustomerHistoryPreAppendLine(lineParameters);

                    xmlItems.appendChild(xmlRecord);
                }

                xmlRoot.appendChild(xmlItems);
                xmldoc.appendChild(xmlRoot);
                success = true;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order for the given Id.
    /// </summary>
    /// <param name="_salesId">
    /// Value of the SalesId for which order needs to be fetched.
    /// </param>
    /// <param name="includeOnlineOrders">
    /// whether or not to include online orders in the search
    /// </param>
    /// <returns>
    /// A container having the order details in a XML string.
    /// </returns>
    public static container getCustomerOrder(SalesId _salesId, boolean includeOnlineOrders = false)
    {
        SalesTable          salesTable;
        SalesLine           salesLine;
        RetailSalesLine     retailSalesLine;
        InventDim           inventDim;
        MarkupTrans         markupTrans;
        RetailStaffTable    retailStaffTable;
        RetailLoyaltyCard   retailLoyaltyCard;
        str                 error = '';
        boolean             success = false;
        Counter             infologline    = infolog.num();
        XmlDocument         xmldoc;
        XmlElement          xmlRoot,xmlRecord,xmlItem,xmlCharges,xmlHeaderInfo, xmlLineCharges, xmlLineRecord, xmlCoupon, xmlHeaderInfoCodes, xmlLineInfoCodes, xmlNotes;
        int                 fromLine;
        InventTransIdSum    inventTransIdSum;
        RetailStoreTable    retailStoreTable;
        RetailStoreId       storeId = '';
        RetailStoreId       fulfillmentStoreId = '';
        DirPartyTable       dirPartyTable;
        HcmWorker           hcmWorker;
        str                 salespersonStaffId = '';
        RetailSalesTable    retailSalesTable;
        int i, length;
        container           discountCodes;
        boolean             countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        boolean             hasLoyaltyPayment;
        UnitOfMeasure       unitOfMeasure;
        PriceUnit           priceUnit;
        InventDimCombination inventDimCombination;
        CustTable            custTable;
        container           coupons;
        SalesOrderedQty     salesLineOrderedQty;

        try
        {
            fromLine = Global::infologLine();
            xmldoc =  XmlDocument::newBlank();

            // Find a Sales Order via SalesId directly
            salesTable = SalesTable::find(_salesId);

            if (!salesTable)
            {
                // If not found and if required, try find a matching Online Order
                if (includeOnlineOrders)
                {
                    select firstonly * from salesTable
                        exists join retailSalesTable
                            where   retailSalesTable.ChannelReferenceId == _salesId
                                &&  retailSalesTable.SalesTable == SalesTable.RecId;

                    if (salesTable)
                    {
                        _salesId = salesTable.SalesId;
                    }
                }
            }

            if (salesTable)
            {
                xmlRoot = xmldoc.createElement(CustomerOrderElement);

                //Get the sales order header info
                xmlHeaderInfo = xmldoc.createElement('CustomerAccount');
                xmlHeaderInfo.innerText(salesTable.CustAccount);
                xmlRoot.appendChild(xmlHeaderInfo);

                //Get customer record id
                custTable = CustTable::find(salesTable.CustAccount);
                xmlHeaderInfo = xmldoc.createElement('CustomerRecordId');
                xmlHeaderInfo.innerText(int642str(custTable.Party));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Id');
                xmlHeaderInfo.innerText(salesTable.SalesId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('AddressRecord');
                xmlHeaderInfo.innerText(int642str(salesTable.DeliveryPostalAddress));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('InventLocationId');
                xmlHeaderInfo.innerText(salesTable.InventLocationId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('InventSiteId');
                xmlHeaderInfo.innerText(salesTable.InventSiteId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Comment');
                xmlHeaderInfo.innerText(salesTable.CustomerRef);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CustomerRequisition');
                xmlHeaderInfo.innerText(salesTable.PurchOrderFormNum);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Status');
                xmlHeaderInfo.innerText(int2str(enum2int(salesTable.SalesStatus)));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('DocumentStatus');
                xmlHeaderInfo.innerText(int2str(enum2int(salesTable.DocumentStatus)));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CreationDate');
                xmlHeaderInfo.innerText(DateTimeUtil::toStr(salesTable.CreatedDateTime)); //Formatted as yyyy-MM-ddTHH:mm:ss
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('LanguageId');
                xmlHeaderInfo.innerText(salesTable.LanguageId);
                xmlRoot.appendChild(xmlHeaderInfo);

                retailSalesTable = salesTable.retailSalesTable();

                // Add discountCodes
                // DiscountCodes property is obsolete. We are setting discount codes here for N-1 compatibility.
                discountCodes = retailSalesTable.DiscountCodes;
                length = conLen(discountCodes);
                for (i = 1; i <= length; i++)
                {
                    xmlHeaderInfo = xmldoc.createElement(#DiscountCodes);
                    xmlHeaderInfo.innerText(conPeek(discountCodes, i));
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Add coupons.
                coupons = retailSalesTable.Coupons;
                length = conLen(Coupons);
                xmlHeaderInfo = xmldoc.createElement(#Coupons);
                for (i = 1; i <= length; i = i + 3)
                {
                    xmlCoupon = xmldoc.createElement(#Coupon);
                    xmlCoupon.setAttribute(#CodeId, conPeek(coupons, i));
                    xmlCoupon.setAttribute(CodeStr, conPeek(coupons, i + 1));
                    xmlCoupon.setAttribute(#DiscountOfferId, conPeek(coupons, i + 2));
                    xmlHeaderInfo.appendChild(xmlCoupon);
                }

                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountAmount);
                xmlHeaderInfo.innerText(RetailTransactionServiceOrders::amountToStr(retailSalesTable.TotalManualDiscountAmount));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountPercentage);
                xmlHeaderInfo.innerText(RetailTransactionServiceOrders::percentToStr(retailSalesTable.TotalManualDiscountPercentage));
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('ChannelReferenceId');
                xmlHeaderInfo.innerText(retailSalesTable.ChannelReferenceId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('InitialReceiptId');
                xmlHeaderInfo.innerText(retailSalesTable.InitialReceiptId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('Email');
                xmlHeaderInfo.innerText(salesTable.Email);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CommissionSalesGroup');
                xmlHeaderInfo.innerText(salesTable.SalesGroup);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(TaxOverrideCodeElement);
                xmlHeaderInfo.innerText(retailSalesTable.TaxOverrideCode);
                xmlRoot.appendChild(xmlHeaderInfo);

                select firstonly StaffId from retailStaffTable
                    join hcmWorker where retailStaffTable.StaffId == hcmWorker.PersonnelNumber
                                        && hcmWorker.RecId == salesTable.WorkerSalesResponsible;
                if (retailStaffTable)
                {
                    salespersonStaffId = retailStaffTable.StaffId;
                }
                else if (salesTable.WorkerSalesResponsible)
                {
                    salespersonStaffId = int642str(salesTable.WorkerSalesResponsible);
                    select firstonly Name from dirPartyTable
                        join RecId from hcmWorker where
                        hcmWorker.RecId == salesTable.WorkerSalesResponsible && hcmWorker.Person == dirPartyTable.RecId;
                    if (dirPartyTable)
                    {
                        xmlHeaderInfo = xmldoc.createElement('SalespersonName');
                        xmlHeaderInfo.innerText(dirPartyTable.Name);
                        xmlRoot.appendChild(xmlHeaderInfo);
                    }
                }

                if (salespersonStaffId != '')
                {
                    xmlHeaderInfo = xmldoc.createElement('SalespersonStaffId');
                    xmlHeaderInfo.innerText(salespersonStaffId);
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                DirPartyRecId customerParty = CustTable::find(salesTable.custAccount).Party;
                LogisticsPostalAddress headerDeliveryAddress = LogisticsPostalAddress::findRecId(salesTable.DeliveryPostalAddress);
                if (headerDeliveryAddress)
                {
                    str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(headerDeliveryAddress, salesTable.DeliveryName);
                    xmlRoot.appendChild(RetailTransactionServiceTransactions::fillSalesOrderAddress(headerDeliveryAddress, deliveryName, customerParty, xmlDoc, 'ShippingAddress'));
                }

                // Get store number assume one warehouse per store
                select firstonly StoreNumber from retailStoreTable
                    where retailStoreTable.InventLocation == salesTable.InventLocationId
                       && retailStoreTable.inventLocationDataAreaId == curExt();

                if (retailStoreTable)
                {
                    storeId = retailStoreTable.StoreNumber;
                }

                xmlHeaderInfo = xmldoc.createElement('StoreId');
                xmlHeaderInfo.innerText(storeId);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement(IsTaxExemptedForPriceInclusive);
                xmlHeaderInfo.innerText(retailSalesTable.IsTaxExemptedForPriceInclusive ? TrueStr : FalseStr);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('IsTaxIncludedInPrice');
                xmlHeaderInfo.innerText(salesTable.InclTax == NoYes::Yes ? TrueStr : FalseStr);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('CurrencyCode');
                xmlHeaderInfo.innerText(salesTable.CurrencyCode);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('DeliveryMode');
                xmlHeaderInfo.innerText(salesTable.DlvMode);
                xmlRoot.appendChild(xmlHeaderInfo);

                xmlHeaderInfo = xmldoc.createElement('RequestedDeliveryDate');
                xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::dateToString(salesTable.ShippingDateRequested));
                xmlRoot.appendChild(xmlHeaderInfo);

                if (salesTable.ShippingDateConfirmed)
                {
                    xmlHeaderInfo = xmldoc.createElement('ConfirmedShipDate');
                    xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::dateToString(salesTable.ShippingDateConfirmed));
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Sets PrepaymentAmountOverridden property.
                RetailTransactionServiceOrders::setHeaderDepositOverridenXml(xmldoc, xmlRoot, salesTable);

                // Loyalty
                if  (salesTable.retailSalesTable().RetailLoyaltyCard)
                {
                    select firstOnly CardNumber from retailLoyaltycard
                        where retailLoyaltycard.RecId == salesTable.retailSalesTable().RetailLoyaltyCard;

                    xmlHeaderInfo = xmldoc.createElement('LoyaltyCardId');
                    xmlHeaderInfo.innerText(retailLoyaltycard.CardNumber);
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                hasLoyaltyPayment = RetailLoyaltyCardRewardPointTrans::IsSalesOrderPaidByLoyalty(salesTable.SalesId, salesTable.dataAreaId);
                xmlHeaderInfo = xmldoc.createElement('HasLoyaltyPayment');
                xmlHeaderInfo.innerText(hasLoyaltyPayment ? TrueStr : FalseStr);
                xmlRoot.appendChild(xmlHeaderInfo);

                // DataAreaId
                xmlHeaderInfo = xmldoc.createElement('DataAreaId');
                xmlHeaderInfo.innerText(salesTable.DataAreaId);
                xmlRoot.appendChild(xmlHeaderInfo);

                // Affiliations
                xmlHeaderInfo = RetailSalesAffiliation::getSalesAffiliatonXML(xmldoc, salesTable.SalesId);
                if (xmlHeaderInfo)
                {
                    xmlRoot.appendChild(xmlHeaderInfo);
                }

                // Previously invoiced amount
                xmlHeaderInfo = xmldoc.createElement('PreviouslyInvoicedAmount');
                xmlHeaderInfo.innerText(num2str(salesTable.amountInvoiced(),5,3,1,0));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Sales Agreement Id
                xmlHeaderInfo = xmldoc.createElement('SalesAgreementRecordId');
                xmlHeaderInfo.innerText(int642str(salesTable.MatchingAgreement));
                xmlRoot.appendChild(xmlHeaderInfo);

                // Get Customer order Header retail attributes
                RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRoot, _salesId, salesTable.DataAreaId);

                boolean allowPartialOrderEditingFeatureEnabled = RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement();

                // Version 1 was for above properties QuantityRemained and QuantityShipped so clients can tell if they should be expected in the RTS response.
                // Version 2 additionally specifies the addition of quantityNotProcessed and QuantityPhysicallyReserved.
                ItemInfoContractVersion itemInfoVersion = ItemInfoContractVersion::V1;
                if (allowPartialOrderEditingFeatureEnabled)
                {
                    // V1 of the feature exposure maps to V2 of the item info version.
                    itemInfoVersion = ItemInfoContractVersion::V2;
                }

                //Get the info of items
                xmlItem = xmldoc.createElement('Items');
                while select
                        SalesId,
                        ItemId,
                        SalesPrice,
                        priceUnit,
                        SalesQty,
                        SalesStatus,
                        SalesUnit,
                        LineDisc,
                        LinePercent,
                        LineAmount,
                        TaxGroup,
                        TaxItemGroup,
                        SalesMarkup,
                        DlvMode,
                        DeliveryPostalAddress,
                        ShippingDateRequested,
                        ShippingDateConfirmed,
                        RetailVariantId,
                        StockedProduct,
                        InventTransId,
                        RemainSalesPhysical,
                        RemainSalesFinancial,
                        CustomerRef,
                        InventDimId,
                        LineNum,
                        SalesGroup,
                        DataAreaId,
                        DeliveryName,
                        MatchingAgreementLine,
                        AgreementSkipAutoLink
                    from salesLine
                    where salesLine.SalesId == _salesId
                    outer join QuantityPicked, QuantityPacked, QuantityNotProcessed, QuantityPhysicallyReserved, QuantityInvoiced, QuantityColumnsVersion, Catalog, SalesLine from retailSalesLine
                        where salesLine.RecId == retailSalesLine.SalesLine
                    join InventLocationId, InventSerialId, InventBatchId, InventColorId, InventSizeId, InventStyleId, InventVersionId, ConfigId, wmsLocationId from inventDim
                    where salesLine.InventDimId == inventDim.InventDimId
                {
                    if (PdsCatchWeightItem::exist(salesLine.ItemId))
                    {
                        eventSource.EventWriteOrdersGetCustomerOrderWithCatchWeightItemNotSupported(salesLine.RecId, salesLine.ItemId);
                    }

                    if (SalesLine.SalesStatus == SalesStatus::Canceled)
                    {
                        if (RetailDoNotDisplayCanceledSalesLineInPosFeature::IsEnabled())
                        {
                            continue;
                        }
                        else
                        {
                            salesLineOrderedQty = 0;
                        }
                    }
                    else
                    {
                        salesLineOrderedQty = salesLine.SalesQty;
                    }

                    xmlRecord = xmldoc.createElement('Item');

                    xmlRecord.setAttribute('RecId', int642str(salesLine.RecId));

                    inventDimCombination = InventDimCombination::findVariantId(salesLine.RetailVariantId);
                    xmlRecord.setAttribute('InventDimensionId', inventDimCombination.InventDimId);

                    xmlRecord.setAttribute('ItemId', salesLine.ItemId);

                    xmlRecord.setAttribute(lineNumberColumn, RetailTransactionServiceUtilities::lineNumToString(salesLine.LineNum));

                    xmlRecord.setAttribute('LineVersion', ItemInfoContractVersionHelper::ToIntString(itemInfoVersion));

                    priceUnit = salesLine.PriceUnit;
                    if (!priceUnit)
                    {
                        priceUnit = 1;
                    }

                    xmlRecord.setAttribute('Price', RetailTransactionServiceOrders::formatWithAllDecimals(salesLine.SalesPrice/priceUnit));
                    unitOfMeasure = UnitOfMeasure::findBySymbol(salesLine.SalesUnit);

                    int numberOfDecimals;
                    if (unitOfMeasure.RecId)
                    {
                        numberOfDecimals = unitOfMeasure.DecimalPrecision;
                    }
                    else
                    {
                        numberOfDecimals = 3;
                    }

                    // Original ordered quantity
                    xmlRecord.setAttribute('Quantity', num2str(salesLineOrderedQty,5,numberOfDecimals,1,0));

                    RetailSalesLineQuantitiesCalculator qtyCalculator = RetailSalesLineQuantitiesCalculator::construct(salesLine);

                    xmlRecord.setAttribute('QuantityCanceled', num2str(qtyCalculator.quantityCanceled(), 5, numberOfDecimals, 1, 0));

                    // These values (QuantityPicked, QuantityPickedWarehouse, QuantityPacked) have been made obsolete, in favor of the LineQuantityDetails populated below,
                    // which additionally includes QuantityNotProcessed, QuantityPhysicallyReserved, and QuantityInvoiced.
                    // These obsolete values are still populated to provide backward compatibility.
                    // This QuantityPicked means the quantity of items has been picked up by customer.
                    XmlRecord.setAttribute('QuantityPicked',num2str(qtyCalculator.quantityPickedUp(),5,numberOfDecimals,1,0));

                    // This value means the quantity of items has been picked from the warehouse during the fulfillment process.
                    xmlRecord.setAttribute('QuantityPickedWarehouse',num2Str(retailSalesLine.QuantityPicked,5,numberOfDecimals,1,0));

                    xmlRecord.setAttribute('QuantityPacked',num2Str(retailSalesLine.QuantityPacked,5,numberOfDecimals,1,0));

                    // Quantity that is still available for pickup in the stores
                    xmlRecord.setAttribute('QuantityRemained', num2str(qtyCalculator.quantityRemaining(),5,numberOfDecimals,1,0));

                    // Quantities that were already picked in the HQ, are showed as "shipped" in MPOS,
                    // as they won't be available for pick-up anymore.
                    xmlRecord.setAttribute('QuantityShipped', num2str(salesLine.deliveredInTotal(),5,numberOfDecimals,1,0));

                    xmlRecord.setAttribute('Status', int2str(enum2int(salesLine.SalesStatus)));

                    xmlRecord.setAttribute('Unit', salesLine.SalesUnit);
                    xmlRecord.setAttribute('Discount',num2str(salesLine.LineDisc,5,3,1,0));
                    xmlRecord.setAttribute('DiscountPercent',num2str(salesLine.LinePercent,5,3,1,0));
                    xmlRecord.setAttribute('NetAmount',num2str(salesLine.LineAmount,5,3,1,0));
                    xmlRecord.setAttribute(TaxGroupStr, salesLine.TaxGroup);
                    xmlRecord.setAttribute(TaxItemGroupStr, salesLine.TaxItemGroup);
                    xmlRecord.setAttribute('SalesMarkup', num2str(salesLine.SalesMarkup,5,3,1,0));
                    xmlRecord.setAttribute('InventLocationId', inventDim.InventLocationId);
                    xmlRecord.setAttribute('DeliveryMode', salesLine.DlvMode);
                    xmlRecord.setAttribute('AddressRecord', int642str(salesLine.DeliveryPostalAddress));
                    xmlRecord.setAttribute('RequestedDeliveryDate', RetailTransactionServiceUtilities::dateToString(salesLine.ShippingDateRequested));
                    if (salesLine.ShippingDateConfirmed)
                    {
                        xmlRecord.setAttribute('ConfirmedShipDate', RetailTransactionServiceUtilities::dateToString(salesLine.ShippingDateConfirmed));
                    }

                    xmlRecord.setAttribute('VariantId', salesLine.RetailVariantId);
                    xmlRecord.setAttribute('Comment', salesLine.CustomerRef);
                    xmlRecord.setAttribute('CommissionSalesGroup', salesLine.SalesGroup);

                    // Add details from retail sales line
                    RetailTransactionServiceOrders::getRetailSalesLine(xmlRecord, salesLine);

                    if(!salesLine.RetailVariantId)
                    {
                        // Get InventDim values.
                        RetailTransactionService::getInventDimValues(salesLine.ItemId, inventDim, xmlRecord);
                    }

                    InventDim serialIdOnlyInventDim = inventDim;
                    InventTable inventTable = InventTable::find(salesLine.ItemId);
                    if (inventTable && inventTable.isSalesProcessSerialActive())
                    {
                        InventTransOrigin inventTransOrigin;
                        InventTrackingRegisterTrans inventTrackingRegisterTrans;
                        select firstonly InventSerialId from serialIdOnlyInventDim
                            exists join inventTrackingRegisterTrans
                                where inventTrackingRegisterTrans.InventDimId == serialIdOnlyInventDim.inventDimId
                            exists join inventTransOrigin
                                where inventTransOrigin.RecId == inventTrackingRegisterTrans.InventTransOrigin
                                && inventTransOrigin.InventTransId == salesLine.InventTransId;
                    }

                    xmlRecord.setAttribute('SerialId', serialIdOnlyInventDim.InventSerialId);
                    xmlRecord.setAttribute('BatchId', inventDim.InventBatchId);

                    xmlRecord.setAttribute('WmsLocationId', inventDim.wMSLocationId);

                    //This catalogrecid is being used in ItemInfo as column name Catalog.
                    xmlRecord.setAttribute(CatalogRecId, int642str(retailSalesLine.Catalog));

                    // set sales agreement related property.
                    XmlRecord.setAttribute('SalesAgreementLineRecordId', int642Str(salesLine.MatchingAgreementLine));
                    xmlRecord.setAttribute('IsSalesAgreementSkipped', int2str(enum2int(salesLine.AgreementSkipAutoLink)));

                    if (ItemInfoContractVersionHelper::Includes(itemInfoVersion, ItemInfoContractVersion::V2))
                    {
                        // Version 2 introduces a run-once task to populate new values -- so we must check if this has happened already.
                        if (retailSalesLine.stockedInventoryQuantitiesNeverUpdated(salesLine))
                        {
                            RetailTransactionServiceFulfillment::updateFulfillmentStatus(salesLine.RecId);
                            retailSalesLine.reread();
                            eventSource.EventWriteRetailSalesLineUpdateQuantitiesOnDemand(retailSalesLine.RecId);
                        }

                        UnitOfMeasureSymbol inventUnitOfMeasure = salesLine.inventTable().inventUnitId();

                        // Version 2 and up will populate the LineQuantityDetails type.
                        RetailTransactionServiceOrders::setLineLevelQuantities(xmldoc, xmlRecord, retailSalesLine, inventUnitOfMeasure, numberOfDecimals);
                    }

                    //Get the line-level charge info

                    // 1. Include invoiced charge lines
                    if (allowPartialOrderEditingFeatureEnabled && retailSalesLine.QuantityInvoiced > 0)
                    {
                        CustInvoiceTrans custInvoiceTrans;

                        while select RecId from custInvoiceTrans
                            where custInvoiceTrans.InventTransId == salesLine.InventTransId
                        {
                            RetailTransactionServiceOrders::setLineLevelCharges(xmldoc, xmlRecord, custInvoiceTrans.RecId, 0, custInvoiceTrans.SalesId, true);
                        }
                    }

                    // 2. Include non-invoiced charge lines
                    RetailTransactionServiceOrders::setLineLevelCharges(xmldoc, xmlRecord, salesLine.RecId, salesLine.TableId);

                    if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
                    {
                        //Get line level price info
                        RetailTransactionServiceOrders::addPriceLineXml(xmlDoc, xmlRecord, salesLine, false);

                    }

                    //Get line level discount info
                    RetailTransactionServiceOrders::addDiscountLineXml(xmlDoc, xmlRecord, salesLine.salesPurchLineInterface(), false);

                    //Get customer order retail line level attributes
                    RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRecord, _salesId, salesLine.DataAreaId, salesLine.LineNum);

                    // get line-level info codes
                    xmlLineInfoCodes = RetailTransactionServiceOrders::setSalesLineInfocodeLines(xmldoc, salesTable.RecId, salesLine.RecId, RetailInfoCodeLineRelatedTableType::Sales);
                    xmlRecord.appendChild(xmlLineInfoCodes);

                    RetailGetCustomerOrderLineParameters lineParameters = RetailGetCustomerOrderLineParameters::construct();
                    lineParameters.xmlDoc = xmlDoc;
                    lineParameters.xmlRoot = xmlRoot;
                    lineParameters.xmlItem = xmlItem;
                    lineParameters.xmlRecord = xmlRecord;
                    lineParameters.salesLine = salesLine;

                    RetailCustomerOrderExtensions::getCustomerOrderPreAppendLine(lineParameters);

                    // Get line-level delivery address info
                    LogisticsPostalAddress deliveryAddress = LogisticsPostalAddress::findRecId(salesLine.DeliveryPostalAddress);

                    if (deliveryAddress)
                    {
                        str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, salesLine.DeliveryName);
                        xmlRecord.appendChild(RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, customerParty, xmlDoc, 'Address'));
                    }

                    // Get Warrantied Relation Information.
                    RetailTransactionServiceWarranty::appendWarrantiedRelationToItemInfo(xmldoc, xmlRecord, salesLine);

                    if (RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement())
                    {
                        xmlRecord.setAttribute('DetailedLineStatusValue', int2Str(enum2int(RetailDetailedOrderInfoHelper::getDetailedLineStatus(salesLine))));
                    }

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        XmlElement xmlCollection = RetailTransactionServiceOrders::fillSalesLineExtensionProprties_IN(xmldoc, salesLine);

                        xmlRecord.appendChild(xmlCollection);
                    }

                    xmlItem.appendChild(xmlRecord);
                }

                //Get header-level info of charges
                xmlCharges = RetailTransactionServiceOrders::setHeaderCharges(xmldoc, salesTable.RecId, salesTable.TableId);

                // get header-level info codes
                xmlHeaderInfoCodes = RetailTransactionServiceOrders::setHeaderInfocodeLines(xmldoc, salesTable.RecId, RetailInfoCodeLineRelatedTableType::Sales);

                // Add Notes
                xmlNotes = RetailTransactionServiceOrders::setNotes(xmlDoc, salesTable.RecId, salesTable.TableId, salesTable.DataAreaId);

                //
                // Add payment history (and authorizations for Omni channel payments only)
                //
                RetailTransactionServiceOrders::AddPaymentInformationXml(xmlRoot, salesTable);

                //
                // Compose all the pieces.
                //
                xmlRoot.appendChild(xmlItem);
                xmlRoot.appendChild(xmlCharges);
                xmlRoot.appendChild(xmlHeaderInfoCodes);
                xmlRoot.appendChild(xmlNotes);

                RetailGetCustomerOrderHeaderParameters headerParameters = RetailGetCustomerOrderHeaderParameters::construct();
                headerParameters.xmlDoc = xmlDoc;
                headerParameters.xmlRoot = xmlRoot;
                headerParameters.xmlItem = xmlItem;
                headerParameters.salesTable = salesTable;

                RetailCustomerOrderExtensions::getCustomerOrderPreAppendHeader(headerParameters);

                xmldoc.appendChild(xmlRoot);
                success = true;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineExtensionProprties_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills extension properties for sales line in scope of India localization.
    /// </summary>
    /// <param name = "_xmlDoc">The xml document.</param>
    /// <param name = "_salesLine">The sales line.</param>
    /// <returns>The xml element with extension properties.</returns>
    private static XmlElement fillSalesLineExtensionProprties_IN(XmlDocument _xmlDoc, SalesLine _salesLine)
    {
        XmlElement xmlRecord, xmlSubRecord, xmlRoot, xmlContainer;
        RetailTransactionFiscalTransExtendedData fiscalTransExtendedData;

        xmlContainer = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyExtensionProperties);

        SalesTable salesTable = _salesLine.salesTable();
        RetailSalesTable retailSalesTable = salesTable.retailSalesTable();
        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(retailSalesTable.RetailChannel);

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() &&
            FeatureStateProvider::isFeatureEnabled(RetailGSTInvoiceAddressTaxCalculationFeature_IN::instance()) && retailChannelTable &&
            (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore ||
             retailChannelTable.ChannelType == RetailChannelType::OnlineStore))
        {
            TransTaxInformation salesLineTransTaxInfo = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_salesLine);
            LogisticsPostalAddress logisticsPostalAddress = LogisticsPostalAddress::findByLocation(salesLineTransTaxInfo.CustomerLocation);

            if (logisticsPostalAddress)
            {
                RetailTransactionAdditionalAddressTransContract contract = new RetailTransactionAdditionalAddressTransContract();

                contract.initFromLogisticsPostalAddress(logisticsPostalAddress);

                xmlRoot = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyCommerceProperty);

                xmlRecord = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyKey);
                xmlRecord.innerText(RetailTransactionServiceOrders::InvoiceAddressIndiaPropertyName);
                xmlRoot.appendChild(xmlRecord);

                xmlRecord = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyValue);
                xmlSubRecord = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyStringValue);
                xmlSubRecord.innerText(contract.serialize());
                xmlRecord.appendChild(xmlSubRecord);
                xmlRoot.appendChild(xmlRecord);

                xmlContainer.appendChild(xmlRoot);
            }
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineExtensionProprtiesForInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills extension properties for sales line in scope of India localization.
    /// </summary>
    /// <param name = "_xmlDoc">The xml document.</param>
    /// <param name = "_salesLine">The sales line.</param>
    /// <param name = "_propertyType">The type of extension property.</param>
    /// <returns>The xml element with extension properties.</returns>
    private static XmlElement fillSalesLineExtensionProprtiesForInvoice_IN(XmlDocument _xmlDoc, SalesLine _salesLine, str _propertyType = RetailTransactionServiceOrders::SimplePropertyType)
    {
        XmlElement xmlRoot, xmlContainer;
        RetailTransactionFiscalTransExtendedData fiscalTransExtendedData;

        xmlContainer = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyExtensionProperties);

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TransTaxInformation salesLineTransTaxInfo = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_salesLine);

            HSNCodeTable_IN hsnCodeTable_IN = HSNCodeTable_IN::find(salesLineTransTaxInfo.HSNCodeTable);
            HSNCode_IN hsnCode = hsnCodeTable_IN ? hsnCodeTable_IN.Code : '';

            xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                _xmlDoc,
                RetailTransactionServiceOrders::HSNCodePropertyName,
                hsnCode,
                RetailTransactionServiceOrders::PropertyStringValue,
                _propertyType);
            xmlContainer.appendChild(xmlRoot);

            ServiceAccountingCodeTable_IN serviceAccountingCodeTable_IN = ServiceAccountingCodeTable_IN::find(salesLineTransTaxInfo.ServiceAccountingCodeTable);
            SAC_IN sacCode = serviceAccountingCodeTable_IN ? serviceAccountingCodeTable_IN.SAC : '';

            xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                _xmlDoc,
                RetailTransactionServiceOrders::ServiceAccountingCodePropertyName,
                sacCode,
                RetailTransactionServiceOrders::PropertyStringValue,
                _propertyType);
            xmlContainer.appendChild(xmlRoot);

            xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                _xmlDoc,
                RetailTransactionServiceOrders::NonGSTPropertyName,
                salesLineTransTaxInfo.NonGST == NoYes::Yes ? TrueStr : FalseStr,
                RetailTransactionServiceOrders::PropertyBooleanValue,
                _propertyType);
            xmlContainer.appendChild(xmlRoot);

            xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                _xmlDoc,
                RetailTransactionServiceOrders::IsExemptPropertyName,
                salesLineTransTaxInfo.Exempt == NoYes::Yes ? TrueStr : FalseStr,
                RetailTransactionServiceOrders::PropertyBooleanValue,
                _propertyType);
            xmlContainer.appendChild(xmlRoot);

            TaxRateType taxRateType = TaxRateType::find(salesLineTransTaxInfo.TaxRateType);
            TaxRateTypeName taxRateTypeName = taxRateType ? taxRateType.Name : '';

            xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                _xmlDoc,
                RetailTransactionServiceOrders::TaxRateTypePropertyName,
                taxRateTypeName,
                RetailTransactionServiceOrders::PropertyStringValue,
                _propertyType);
            xmlContainer.appendChild(xmlRoot);

            RetailSalesLine retailSalesLine = _salesLine.retailSalesLine();

            if (retailSalesLine.FulfillmentStoreId)
            {
                xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                    _xmlDoc,
                    RetailTransactionServiceOrders::FulfillmentStoreIdPropertyName,
                    retailSalesLine.FulfillmentStoreId,
                    RetailTransactionServiceOrders::PropertyStringValue,
                    _propertyType);
                xmlContainer.appendChild(xmlRoot);
            }

            SalesTable salesTable = _salesLine.salesTable();
            RetailSalesTable retailSalesTable = salesTable.retailSalesTable();
            RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(retailSalesTable.RetailChannel);

            if (FeatureStateProvider::isFeatureEnabled(RetailGSTInvoiceAddressTaxCalculationFeature_IN::instance()) && retailChannelTable &&
                (retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore ||
                 retailChannelTable.ChannelType == RetailChannelType::OnlineStore))
            {
                LogisticsPostalAddress logisticsPostalAddress = LogisticsPostalAddress::findByLocation(salesLineTransTaxInfo.CustomerLocation);

                if (logisticsPostalAddress)
                {
                    RetailTransactionAdditionalAddressTransContract contract = new RetailTransactionAdditionalAddressTransContract();

                    contract.initFromLogisticsPostalAddress(logisticsPostalAddress);

                    xmlRoot = RetailTransactionServiceOrders::createExtensionProperty(
                        _xmlDoc,
                        RetailTransactionServiceOrders::InvoiceAddressIndiaPropertyName,
                        contract.serialize(),
                        RetailTransactionServiceOrders::PropertyStringValue,
                        _propertyType);
                    xmlContainer.appendChild(xmlRoot);
                }
            }
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExtensionProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and fills an extension property.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document.</param>
    /// <param name = "_propertyKey">The extension property key name.</param>
    /// <param name = "_propertyValue">The extension property value.</param>
    /// <param name = "_propertyType">The extension property value type.</param>
    /// <returns>The XML element with extension property.</returns>
    private static XmlElement createExtensionProperty(
        XmlDocument _xmlDoc, 
        str _propertyKey, 
        str _propertyValue, 
        str _basePropertyType, 
        str _propertyType = RetailTransactionServiceOrders::SimplePropertyType)
    {
        XmlElement xmlRoot;

        if (_propertyType == RetailTransactionServiceOrders::CommercePropertyType)
        {
            xmlRoot = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyCommerceProperty);

            XmlElement xmlRecord = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyKey);
            xmlRecord.innerText(_propertyKey);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement(RetailTransactionServiceOrders::PropertyValue);
            XmlElement xmlSubRecord = _xmlDoc.createElement(_basePropertyType);
            xmlSubRecord.innerText(_propertyValue);
            xmlRecord.appendChild(xmlSubRecord);
            xmlRoot.appendChild(xmlRecord);
        }
        else
        {
            xmlRoot = _xmlDoc.createElement(_propertyKey);
            xmlRoot.innerText(_propertyValue);
        }
        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order details for the given customer.
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name="_startDate">
    /// The starting date to return orders (default is DateTimeUtil::minValue).
    /// </param>
    /// <param name="_endDate">
    /// The starting date to return orders (default is today's date).
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <param name="_includeQuotes">
    /// Whether or not quotes should be included in the results (default is False, quotes are not included).
    /// </param>
    /// <returns>
    /// A container having the customer order details for the given customer.
    /// </returns>
    public static container getCustomerOrderList(CustAccount _custAccount, str _startDate = '', str _endDate = '', int _resultsMaxCount = 100, boolean _includeQuotes = false)
    {
        SalesTable          salesTable;
        SalesQuotationTable salesQuotationTable;

        container           results = [true,''];
        utcDateTime         startDate = DateTimeUtil::minValue();
        utcDateTime         endDate = DateTimeUtil::maxValue();
        int ptr;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();

            if (_startDate)
            {
                startDate =  DateTimeUtil::parse(_startDate);
            }

            if (_endDate)
            {
                endDate = DateTimeUtil::parse(_endDate);
            }
        }
        catch
        {
            results = [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine)];
            return results;
        }

        // Always include sales orders
        QueryRun queryRun = new QueryRun(RetailTransactionServiceOrders::buildCustomerOrderListQuery(_custAccount, startDate, endDate));
        while (queryRun.next())
        {
            salesTable = queryRun.get(tableNum(salesTable));
            if (ptr < _resultsMaxCount)
            {
                results = conIns(results, conLen(results)+1, RetailTransactionService::getSalesOrder(salesTable.SalesId));
                ptr++;
            }
            else
            {
                break;
            }
        }

        // Only include quotes if they were specifically requested
        if (_includeQuotes)
        {
            QueryRun queryRunSQ = new QueryRun(RetailTransactionServiceOrders::buildSalesQuotationTableListQuery(_custAccount, startDate, endDate));
            while (queryRunSQ.next())
            {
                salesQuotationTable = queryRunSQ.get(tableNum(SalesQuotationTable));
                if (ptr < _resultsMaxCount)
                {
                    results = conIns(results, conLen(results)+1, RetailTransactionServiceOrders::getQuotationOrder(salesQuotationTable.QuotationId));
                    ptr++;
                }
                else
                {
                    break;
                }
            }
        }

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrdersForPackSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer orders for pack slip creation
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account
    /// </param>
    /// <returns>
    /// list of customer orders
    /// </returns>
    /// <remarks>
    /// Retrieves a list of all customer orders for the given customer which are available for packslip creation.
    /// </remarks>
    public static container getCustomerOrdersForPackSlip(CustAccount _custAccount)
    {
        SalesTable          salesTable;

        container           salesOrder = [true,''];
        ;

        if (_custAccount)
        {
            while select SalesType, CustAccount, SalesStatus, SalesId from salesTable
            where salesTable.SalesType == SalesType::Sales
            && salesTable.CustAccount == _custAccount
            && (salesTable.SalesStatus == SalesStatus::None ||
                salesTable.SalesStatus == SalesStatus::Backorder ||
                salesTable.SalesStatus == SalesStatus::Delivered)

            salesOrder = conIns(salesOrder,conLen(salesOrder)+1,RetailTransactionService::getSalesOrder(salesTable.SalesId));
        }

        else
        {
            while select SalesType,SalesStatus, SalesId from salesTable
            where salesTable.SalesType == SalesType::Sales
                && (salesTable.SalesStatus == SalesStatus::None ||
                    salesTable.SalesStatus == SalesStatus::Backorder ||
                    salesTable.SalesStatus == SalesStatus::Delivered)

            salesOrder = conIns(salesOrder,conLen(salesOrder)+1,RetailTransactionService::getSalesOrder(salesTable.SalesId));
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quotation for the given Quotation Id.
    /// </summary>
    /// <param name="_quotationId">
    /// Value of the QuotationId for which quote needs to be fetched.
    /// </param>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getCustomerQuote(QuotationIdBase _quotationId)
    {
        SalesQuotationTable quotationTable;
        SalesQuotationLine  quotationLine;
        InventDim           inventDim;
        RetailStoreTable    retailStoreTable;
        MarkupTrans         markupTrans;
        DirPartyTable       dirPartyTable;
        HcmWorker           hcmWorker;
        RetailStaffTable    retailStaffTable;
        RetailSalesQuotationTable retailQuotation;
        RetailSalesQuotationLine retailQuotationLine;
        container discountCodes;
        str                 salespersonStaffId = '';
        str                 error = '';
        boolean             success = false;
        Counter             infologline    = infolog.num();
        XmlDocument         xmldoc;
        XmlElement          xmlRoot,xmlRecord,xmlItem,xmlCharges,xmlHeaderInfo,xmlLineCharges, xmlLineRecord, xmlCoupon, xmlLineInfoCodes, xmlHeaderInfoCodes;
        int                 fromLine;
        int i, length;
        RetailSalesQuotationTable retailQuotationTable;
        RetailLoyaltyCard   retailLoyaltyCard;
        InventDimCombination inventDimCombination;
        RetailStoreId       storeId = '';
        RetailStoreId       fulfillmentStoreId = '';
        CustTable           custTable;
        container           coupons;

        try
        {
            fromLine = Global::infologLine();

            quotationTable = SalesQuotationTable::find(_quotationId);
            xmldoc =  XmlDocument::newBlank();
            xmlRoot = xmldoc.createElement(CustomerOrderElement);

            //Get the sales quote header info
            xmlHeaderInfo = xmldoc.createElement('Id');
            xmlHeaderInfo.innerText(quotationTable.QuotationId);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('OrderType');
            xmlHeaderInfo.innerText('Quote');
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('CustomerAccount');
            xmlHeaderInfo.innerText(quotationTable.CustAccount);
            xmlRoot.appendChild(xmlHeaderInfo);

            //Get customer record id
            custTable = CustTable::find(quotationTable.CustAccount);
            xmlHeaderInfo = xmldoc.createElement('CustomerRecordId');
            xmlHeaderInfo.innerText(int642str(custTable.Party));
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('AddressRecord');
            xmlHeaderInfo.innerText(int642str(quotationTable.DeliveryPostalAddress));
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('InventLocationId');
            xmlHeaderInfo.innerText(quotationTable.InventLocationId);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('InventSiteId');
            xmlHeaderInfo.innerText(quotationTable.InventSiteId);
            xmlRoot.appendChild(xmlHeaderInfo);

            retailQuotation = RetailSalesQuotationTable::find(_quotationId);

            xmlHeaderInfo = xmldoc.createElement(IsTaxExemptedForPriceInclusive);
            xmlHeaderInfo.innerText(retailQuotation.IsTaxExemptedForPriceInclusive ? TrueStr : FalseStr);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('IsTaxIncludedInPrice');
            xmlHeaderInfo.innerText(quotationTable.InclTax == NoYes::Yes ? TrueStr : FalseStr);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('CurrencyCode');
            xmlHeaderInfo.innerText(quotationTable.CurrencyCode);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('DeliveryMode');
            xmlHeaderInfo.innerText(quotationTable.DlvMode);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('Comment');
            xmlHeaderInfo.innerText(quotationTable.CustomerRef);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('CustomerRequisition');
            xmlHeaderInfo.innerText(quotationTable.CustPurchaseOrder);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('RequestedDeliveryDate');
            xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::dateToString(quotationTable.ShippingDateRequested));
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('ExpiryDate');
            xmlHeaderInfo.innerText(RetailTransactionServiceUtilities::dateToString(quotationTable.QuotationExpiryDate));
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('Email');
            xmlHeaderInfo.innerText(quotationTable.Email);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('CommissionSalesGroup');
            xmlHeaderInfo.innerText(quotationTable.SalesGroup);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement('InitialReceiptId');
            xmlHeaderInfo.innerText(retailQuotation.InitialReceiptId);
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement(TaxOverrideCodeElement);
            xmlHeaderInfo.innerText(retailQuotation.TaxOverrideCode);
            xmlRoot.appendChild(xmlHeaderInfo);

            // Add discountCodes
            // DiscountCodes property is obsolete. We are setting discount codes here for N-1 compatibility.
            discountCodes = retailQuotation.DiscountCodes;
            length = conLen(discountCodes);
            for (i = 1; i <= length; i++)
            {
                xmlHeaderInfo = xmldoc.createElement(#DiscountCodes);
                xmlHeaderInfo.innerText(conPeek(discountCodes, i));
                xmlRoot.appendChild(xmlHeaderInfo);
            }

            xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountAmount);
            xmlHeaderInfo.innerText(RetailTransactionServiceOrders::amountToStr(retailQuotation.TotalManualDiscountAmount));
            xmlRoot.appendChild(xmlHeaderInfo);

            xmlHeaderInfo = xmldoc.createElement(#TotalManualDiscountPercentage);
            xmlHeaderInfo.innerText(RetailTransactionServiceOrders::percentToStr(retailQuotation.TotalManualDiscountPercentage));
            xmlRoot.appendChild(xmlHeaderInfo);

            //Sales person
            select firstonly StaffId from retailStaffTable
                join hcmWorker where retailStaffTable.StaffId == hcmWorker.PersonnelNumber
                                        && hcmWorker.RecId == quotationTable.WorkerSalesResponsible;
            if (retailStaffTable)
            {
                salespersonStaffId = retailStaffTable.StaffId;
            }
            else if (quotationTable.WorkerSalesResponsible)
            {
                salespersonStaffId = int642str(quotationTable.WorkerSalesResponsible);
                select firstonly Name from dirPartyTable
                    join RecId from hcmWorker where
                    hcmWorker.RecId == quotationTable.WorkerSalesResponsible && hcmWorker.Person == dirPartyTable.RecId;
                if (dirPartyTable)
                {
                    xmlHeaderInfo = xmldoc.createElement('SalespersonName');
                    xmlHeaderInfo.innerText(dirPartyTable.Name);
                    xmlRoot.appendChild(xmlHeaderInfo);
                }
            }

            if (salespersonStaffId != '')
            {
                xmlHeaderInfo = xmldoc.createElement('SalespersonStaffId');
                xmlHeaderInfo.innerText(salespersonStaffId);
                xmlRoot.appendChild(xmlHeaderInfo);
            }

            LogisticsPostalAddress headerDeliveryAddress = LogisticsPostalAddress::findRecId(quotationTable.DeliveryPostalAddress);
            if (headerDeliveryAddress)
            {
                str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(headerDeliveryAddress, quotationTable.DeliveryName);
                xmlRoot.appendChild(RetailTransactionServiceTransactions::fillSalesOrderAddress(headerDeliveryAddress, deliveryName, custTable.Party, xmlDoc, 'ShippingAddress'));
            }

            // Get store number assume one warehouse per store
            select firstonly StoreNumber from retailStoreTable
                where retailStoreTable.InventLocation == quotationTable.InventLocationId
                   && retailStoreTable.inventLocationDataAreaId == curExt();

            if (retailStoreTable)
            {
                storeId = retailStoreTable.StoreNumber;
            }

            xmlHeaderInfo = xmldoc.createElement('StoreId');
            xmlHeaderInfo.innerText(storeId);
            xmlRoot.appendChild(xmlHeaderInfo);

            // Get Quote Header retail attributes
            RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRoot, _quotationId, quotationTable.DataAreaId);

            xmlItem = xmldoc.createElement('Items');
            //Get the info of items
            while select
                InventTransId,
                QuotationId,
                ItemId,
                SalesPrice,
                SalesQty,
                SalesUnit,
                LineDisc,
                LinePercent,
                LineAmount,
                LineNum,
                TaxGroup,
                TaxItemGroup,
                SalesMarkup,
                DlvMode,
                DeliveryPostalAddress,
                DeliveryName,
                DataAreaId,
                ShippingDateRequested,
                RetailVariantId,
                CustomerRef,
                SalesGroup
            from quotationLine
                where quotationLine.QuotationId == _quotationId
                join InventLocationId, InventSerialId, InventBatchId, InventColorId, InventSizeId, InventStyleId, InventVersionId, ConfigId from inventDim
                    where quotationLine.InventDimId == inventDim.InventDimId
                outer join retailQuotationLine
                    where retailQuotationLine.SalesQuotationLine == quotationLine.RecId
            {
                xmlRecord = xmldoc.createElement('Item');
                xmlRecord.setAttribute('ItemId', quotationLine.ItemId);
                xmlRecord.setAttribute('LineNumber', RetailTransactionServiceUtilities::lineNumToString(quotationLine.LineNum));
                xmlRecord.setAttribute('Price', num2str(quotationLine.SalesPrice,5,3,1,0));

                UnitOfMeasure unitOfMeasure = UnitOfMeasure::findBySymbol(quotationLine.SalesUnit);

                int numberOfDecimals;
                if (unitOfMeasure.RecId)
                {
                    numberOfDecimals = unitOfMeasure.DecimalPrecision;
                }
                else
                {
                    numberOfDecimals = 3;
                }

                xmlRecord.setAttribute('Quantity',num2str(quotationLine.SalesQty,5,numberOfDecimals,1,0));
                xmlRecord.setAttribute('Unit', quotationLine.SalesUnit);
                xmlRecord.setAttribute('Discount',num2str(quotationLine.LineDisc,5,3,1,0));
                xmlRecord.setAttribute('DiscountPercent',num2str(quotationLine.LinePercent,5,3,1,0));
                xmlRecord.setAttribute('NetAmount',num2str(quotationLine.LineAmount,5,3,1,0));
                xmlRecord.setAttribute(TaxGroupStr, quotationLine.TaxGroup);
                xmlRecord.setAttribute(TaxItemGroupStr, quotationLine.TaxItemGroup);
                xmlRecord.setAttribute('SalesMarkup', num2str(quotationLine.SalesMarkup,5,3,1,0));
                xmlRecord.setAttribute('DeliveryMode', quotationLine.DlvMode);
                xmlRecord.setAttribute('AddressRecord', int642str(quotationLine.DeliveryPostalAddress));
                xmlRecord.setAttribute('VariantId', quotationLine.RetailVariantId);
                xmlRecord.setAttribute('Comment', quotationLine.CustomerRef);
                xmlRecord.setAttribute('CommissionSalesGroup', quotationLine.SalesGroup);
                xmlRecord.setAttribute('InventLocationId', inventDim.InventLocationId);
                xmlRecord.setAttribute('SerialId', inventDim.InventSerialId);
                xmlRecord.setAttribute('BatchId', inventDim.InventBatchId);
                xmlRecord.setAttribute('RequestedDeliveryDate', RetailTransactionServiceUtilities::dateToString(quotationLine.ShippingDateRequested));

                inventDimCombination = InventDimCombination::findVariantId(quotationLine.RetailVariantId);
                xmlRecord.setAttribute('InventDimensionId', inventDimCombination.InventDimId);
                //This catalogrecid is being used in ItemInfo as column name Catalog.
                xmlRecord.setAttribute(CatalogRecId, int642str(retailQuotationLine.Catalog));

                if (retailQuotationLine.IsPriceOverridden == NoYes::Yes)
                {
                    xmlRecord.setAttribute(#IsPriceOverridden, '1');
                }
                else
                {
                    xmlRecord.setAttribute(#IsPriceOverridden, '0');
                }

                if (retailQuotationLine.IsPriceKeyedIn == NoYes::Yes)
                {
                    xmlRecord.setAttribute(IsPriceKeyedIn, '1');
                }
                else
                {
                    xmlRecord.setAttribute(IsPriceKeyedIn, '0');
                }

                xmlRecord.setAttribute(#LineDscAmount, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.LineDscAmount));
                xmlRecord.setAttribute(LinePercentageDiscountStr, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.LinePercentageDiscount));
                xmlRecord.setAttribute(#OriginalPrice, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.OriginalPrice));
                xmlRecord.setAttribute(#PeriodicDiscount, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.PeriodicDiscount));
                xmlRecord.setAttribute(#PeriodicPercentageDiscount, RetailTransactionServiceOrders::percentToStr(retailQuotationLine.PeriodicPercentageDiscount));
                xmlRecord.setAttribute(#LineManualDiscountAmount, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.LineManualDiscountAmount));
                xmlRecord.setAttribute(#LineManualDiscountPercentage, RetailTransactionServiceOrders::percentToStr(retailQuotationLine.LineManualDiscountPercentage));

                xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.TaxExemptPriceInclusiveOriginalPrice));
                xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.TaxExemptPriceInclusiveReductionAmount));

                xmlRecord.setAttribute(#TotalDiscount, RetailTransactionServiceOrders::amountToStr(retailQuotationLine.TotalDiscount));
                xmlRecord.setAttribute(#TotalPctDiscount, RetailTransactionServiceOrders::percentToStr(retailQuotationLine.TotalPctDiscount));

                select firstonly StoreNumber from retailStoreTable
                    where retailStoreTable.InventLocation == inventDim.InventLocationId
                       && retailStoreTable.inventLocationDataAreaId == inventDim.DataAreaId;
                if (retailStoreTable)
                {
                    fulfillmentStoreId = retailStoreTable.StoreNumber;
                }

                xmlRecord.setAttribute('FulfillmentStoreId', fulfillmentStoreId);

                if (!quotationLine.RetailVariantId)
                {
                    // Get InventDim values.
                    RetailTransactionService::getInventDimValues(quotationLine.ItemId, inventDim, xmlRecord);
                }

                //Get the line-level charge info
                RetailTransactionServiceOrders::setLineLevelCharges(xmldoc, xmlRecord, quotationLine.RecId, quotationLine.TableId);

                if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
                {
                    //Get line level price info
                    RetailTransactionServiceOrders::addPriceLineXml(xmlDoc, xmlRecord, quotationLine, true);
                }

                //Get line level discount info
                RetailTransactionServiceOrders::addDiscountLineXml(xmlDoc, xmlRecord, quotationLine.salesPurchLineInterface(), true);

                //Get customer order retail line level attributes
                RetailTransactionServiceOrders::getRetailAttributes(xmldoc, xmlRecord, _quotationId, quotationLine.DataAreaId, quotationLine.LineNum);

                // Get reason code line info
                xmlLineInfoCodes = RetailTransactionServiceOrders::setSalesLineInfocodeLines(xmldoc, quotationTable.RecId, quotationLine.RecId, RetailInfoCodeLineRelatedTableType::Quote);
                xmlRecord.appendChild(xmlLineInfoCodes);

                // Get line-level delivery address info
                LogisticsPostalAddress deliveryAddress = LogisticsPostalAddress::findRecId(quotationLine.DeliveryPostalAddress);

                if (deliveryAddress)
                {
                    str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, quotationLine.DeliveryName);
                    xmlRecord.appendChild(RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, custTable.Party, xmlDoc, 'Address'));
                }

                // Get Warrantied Relation Information.
                RetailTransactionServiceWarranty::appendWarrantiedRelationToItemInfo(xmldoc, xmlRecord, quotationLine);

                RetailCustomerQuoteLineParameters lineParameters = RetailCustomerQuoteLineParameters::construct();
                lineParameters.xmlCustomerQuoteDoc = xmlDoc;
                lineParameters.xmlCustomerOrder = xmlRoot;
                lineParameters.xmlItemsInfo = xmlItem;
                lineParameters.xmlItemRecord = xmlRecord;
                lineParameters.salesQuotationLine = quotationLine;

                RetailCustomerQuoteExtensions::processLineBeforeAppend(lineParameters);

                xmlItem.appendChild(xmlRecord);
            }

            //Get the info of charges
            xmlCharges = RetailTransactionServiceOrders::setHeaderCharges(xmldoc, quotationTable.RecId, quotationTable.TableId, true);

            xmlRoot.appendChild(xmlItem);
            xmlRoot.appendChild(xmlCharges);

            // Get header-level info codes
            xmlHeaderInfoCodes = RetailTransactionServiceOrders::setHeaderInfocodeLines(xmldoc, quotationTable.RecId, RetailInfoCodeLineRelatedTableType::Quote);

            xmlRoot.appendChild(xmlHeaderInfoCodes);

            // Add Notes
            xmlRoot.appendChild(RetailTransactionServiceOrders::setNotes(xmlDoc, quotationTable.RecId, quotationTable.TableId, quotationTable.DataAreaId));

            RetailCustomerQuoteHeaderParameters headerParameters = RetailCustomerQuoteHeaderParameters::construct();
            headerParameters.xmlCustomerQuoteDoc = xmlDoc;
            headerParameters.xmlCustomerOrder = xmlRoot;
            headerParameters.xmlItemsInfo = xmlItem;
            headerParameters.salesQuotationTable = quotationTable;

            RetailCustomerQuoteExtensions::processHeaderBeforeAppend(headerParameters);

            xmldoc.appendChild(xmlRoot);

            // Loyalty
            select firstOnly CardNumber from retailLoyaltyCard
            exists join retailQuotationTable
                where retailQuotationTable.RetailLoyaltyCard == retailLoyaltyCard.RecId
                    && retailQuotationTable.SalesQuotationTable == quotationTable.RecId;

            if  (retailLoyaltyCard.CardNumber)
            {
                xmlHeaderInfo = xmldoc.createElement('LoyaltyCardId');
                xmlHeaderInfo.innerText(retailLoyaltycard.CardNumber);
                xmlRoot.appendChild(xmlHeaderInfo);
            }

            // Affiliations
            RetailSalesQuotationAffiliation::AppendAffiliatonsAndLoyaltyTiersToXML(quotationTable.QuotationId, xmldoc, xmlRoot);

            success = true;
        }

        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPackingSlips</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of Packingslip journals for the given location.
    /// </summary>
    /// <param name="_storeId">
    /// Unique identification value of the Inventory location.
    /// </param>
    /// <returns>
    /// A container having the packing slip details in XML string.
    /// </returns>
    public static container getPackingSlips(InventLocationId _storeId)
    {
        container packingSlips = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        CustPackingSlipJour     packingSlipJour;
        CustPackingSlipTrans    packingSlipTrans;
        InventDim               inventDim;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.custPackingSlips('PackingSlips');

        if (_storeId)
        {
            try
            {
                ttsbegin;
                xmlDoc = XmlDocument::newBlank();

                xmlRoot = xmlDoc.createElement(#custPackingSlips);

                while select RefNum, SalesType, PackingSlipId, RecId, SalesId, DeliveryDate from packingSlipJour
                    where (packingSlipJour.RefNum == RefNum::SalesOrder)
                        && (packingSlipJour.SalesType == SalesType::Sales)

                {
                    select firstonly PackingSlipId, InventDimId from packingSlipTrans
                        join InventLocationId, InventDimId from inventDim
                            where   packingSlipTrans.PackingSlipId == packingSlipJour.PackingSlipId
                                &&  packingSlipTrans.InventDimId == inventDim.InventDimId
                                &&  inventDim.InventLocationId == _storeId;

                    if (packingSlipTrans)
                    {
                        xmlRecord = xmlDoc.createElement(tableStr(CustPackingSlipJour));

                        xmlRecord.setAttribute(fieldStr(CustPackingSlipJour, RecId), int642str(packingSlipJour.RecId));
                        xmlRecord.setAttribute(fieldStr(CustPackingSlipJour, PackingSlipId), packingSlipJour.PackingSlipId);
                        xmlRecord.setAttribute(fieldStr(CustPackingSlipJour, SalesId), packingSlipJour.SalesId);
                        xmlRecord.setAttribute(fieldStr(CustPackingSlipJour, DeliveryDate),
                            RetailTransactionServiceUtilities::dateToString(packingSlipJour.DeliveryDate));

                        xmlRoot.appendChild(xmlRecord);
                    }
                }

                xmlDoc.appendChild(xmlRoot);

                packingSlips = [true, '', xmlDoc.toString()];

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                pCounter++;
                if (pCounter <= 10)
                    retry;

                packingSlips = [false, "@RET2382", ''];
            }
            catch
            {
                packingSlips = [false, "@RET2382", ''];
            }
        }

        return packingSlips;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a picking list
    /// </summary>
    /// <param name="pickingId">
    /// A pickingId
    /// </param>
    /// <param name="_inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a picking list
    /// </returns>
    /// <remarks>
    /// The picking list status is still atctive
    /// </remarks>
    public static container getPickingList(WMSPickingRouteID pickingId, InventLocationId _inventLocationId)
    {
        #OCCRetryCount

        container pickingListContainer = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        WMSPickingRoute         pickingRoute;
        WMSOrderTrans           pickingLine;
        InventDim               inventDim;
        InventTable             inventTable;
        SalesTable              salesTable;
        SalesLine               salesLine;
        EcoResProductTranslation productTranslation;
        DlvMode                 dlvMode;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        LanguageId languageId = CompanyInfo::languageId();

        #define.UpdatedInAx('UpdatedInAx')
        #define.Message('Message')
        #define.FalseStr('false')


        try
        {
            ttsbegin;
            xmlDoc = XmlDocument::newBlank();

            select firstonly1  pickingRoute where pickingRoute.PickingRouteID == pickingId
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Cancelled)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Complete)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Picked);

            if (pickingRoute)
            {
                Map productMap = new Map(Types::String, Types::Int64);
                xmlRoot = xmlDoc.createElement(tableStr(WMSPickingRoute));

                xmlRoot.setAttribute(fieldStr(WMSPickingRoute, PickingRouteID), pickingId);
                xmlRoot.setAttribute(fieldStr(WMSPickingRoute, RecId), int642str(pickingRoute.RecId));

                select firstonly DlvMode from salesTable
                    where salesTable.SalesId == pickingRoute.TransRefId
                    join Txt from dlvMode
                    where dlvMode.Code == salesTable.DlvMode;

                xmlRoot.setAttribute(fieldStr(SalesTable,DlvMode), dlvMode.Txt);

                while select RouteId, RecId, ItemId, InventDimId, Qty, DataAreaId from pickingLine
                        where pickingLine.RouteId == pickingId
                        && pickingLine.ExpeditionStatus != WMSExpeditionStatus::Picked
                        && pickingLine.ExpeditionStatus != WMSExpeditionStatus::Cancelled
                    join * from inventDim where pickingLine.InventDimId == inventDim.InventDimId
                                          && inventDim.InventLocationId == _inventLocationId
                    join ItemId, Product from inventTable where inventTable.ItemId == pickingLine.ItemId
                    outer join Name, Product, LanguageId from productTranslation
                        where productTranslation.Product == inventTable.Product
                           && productTranslation.LanguageId == languageId
                    outer join DlvMode from salesLine
                        where pickingLine.InventTransId == salesLine.InventTransId
                    join Txt from dlvMode
                        where dlvMode.Code == salesLine.DlvMode
                {
                    xmlRecord = xmlDoc.createElement(tableStr(WMSOrderTrans));

                    xmlRecord.setAttribute(fieldStr(WMSOrderTrans, RecId), int642str(pickingLine.RecId));
                    xmlRecord.setAttribute(fieldStr(WMSOrderTrans, ItemId), pickingLine.ItemId);
                    xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), productTranslation.Name);
                    xmlRecord.setAttribute(fieldStr(WMSOrderTrans, InventDimId), pickingLine.InventDimId);
                    xmlRecord.setAttribute(fieldStr(WMSOrderTrans, Qty), num2str(pickingLine.Qty, 0, 2, 1, 0));

                    RecId productRecId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(
                        productMap, pickingLine.ItemId, pickingLine.DataAreaId, inventDim.InventColorId, inventDim.ConfigId,
                        inventDim.InventSizeId, inventDim.InventStyleId, inventDim.InventVersionId);

                    if (productRecId != 0)
                    {
                        xmlRecord.setAttribute(productRecordIdAttribute, int642Str(productRecId));
                    }

                    xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), inventDim.InventBatchId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), inventDim.wmsLocationId);
                    xmlRecord.setAttribute('WmsPalletId', '');
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), inventDim.InventSiteId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), inventDim.InventLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, ConfigId), inventDim.ConfigId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSizeId), inventDim.InventSizeId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventColorId), inventDim.InventColorId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStyleId), inventDim.InventStyleId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventVersionId), inventDim.InventVersionId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventDim.InventSerialId);
                    xmlRecord.setAttribute(fieldStr(WMSOrderTrans, DataAreaId), pickingLine.DataAreaId);
                    xmlRecord.setAttribute(fieldStr(SalesLine, DlvMode), dlvMode.Txt);

                    xmlRecord.setAttribute(GuidStr, guid2str(newGuid()));
                    xmlRecord.setAttribute(#UpdatedInAx, FalseStr);
                    xmlRecord.setAttribute(#Message, '');

                    xmlRoot.appendChild(xmlRecord);
                }

                xmlDoc.appendChild(xmlRoot);
            }

            pickingListContainer = [true, '', xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            pickingListContainer = [false, "@RET2382"];
        }
        catch
        {
            pickingListContainer = [false, "@RET2382"];
        }

        return pickingListContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of picking lists for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing a list of picking list in XML format
    /// </returns>
    /// <remarks>
    /// These picking lists are for a specific store
    /// </remarks>
    public static container getPickingLists(InventLocationId inventLocationId)
    {
        #OCCRetryCount

        container openPickingLists = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        WMSPickingRoute         pickingRoute;
        InventDim               inventDim;
        WMSOrderTrans           wmsOrderTrans;
        SalesTable              salesTable;
        DlvMode                 dlvMode;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.WmsPickingRoutes('WMSPickingRoutes');

        try
        {
            ttsbegin;
            xmlDoc = XmlDocument::newBlank();

            xmlRoot = xmlDoc.createElement(#WmsPickingRoutes);

            while select ShipmentType, ExpeditionStatus, RecId, PickingRouteID, Customer, InventLocationId, TransType, DlvDate, DlvModeId, TransRefId
                from pickingRoute
                where (pickingRoute.ShipmentType == WMSShipmentType::OrderPick)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Cancelled)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Complete)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Picked)
                exists join wmsOrderTrans
                where wmsOrderTrans.RouteId == pickingRoute.PickingRouteID
                exists join inventDim
                where wmsOrderTrans.InventDimId == inventDim.InventDimId
                    && inventDim.InventLocationId == inventLocationId
            {
                xmlRecord = xmlDoc.createElement(tableStr(WMSPickingRoute));

                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, RecId), int642str(pickingRoute.RecId));
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, PickingRouteId), pickingRoute.PickingRouteID);
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, Customer), pickingRoute.Customer);
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, InventLocationId), pickingRoute.InventLocationId);
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, TransType), enum2str(pickingRoute.TransType));
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, DlvDate),
                        RetailTransactionServiceUtilities::dateToString(pickingRoute.DlvDate));

                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, ExpeditionStatus), enum2str(pickingRoute.expeditionStatus));

                // DldModeId on WMSPickingRoute gets defaulted to a non-blank value in cases of mixed-delivery
                // but we want to return blank in those cases, so always get the delivery-mode from Sales header.

                select firstonly DlvMode
                    from salesTable
                    where salesTable.SalesId == pickingRoute.TransRefId
                    join Txt from dlvMode
                    where dlvMode.Code == salesTable.DlvMode;

                xmlRecord.setAttribute(fieldStr(SalesTable,DlvMode), dlvMode.Txt);

                xmlRoot.appendChild(xmlRecord);
            }

            xmlDoc.appendChild(xmlRoot);

            openPickingLists = [true, '', xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            openPickingLists = [false, "@RET2382", ''];
        }
        catch
        {
            openPickingLists = [false, "@RET2382", ''];
        }

        return openPickingLists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetPickingListsForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all the open picking lists for the order.
    /// </summary>
    /// <param name = "_salesId">The sales order identifier.</param>
    /// <returns>The picking list for the specified order.</returns>
    public static container GetPickingListsForOrder(SalesId _salesId)
    {
        const str WMSPickingRoutes = 'WMSPickingRoutes';

        // Error codes to return.
        const str PickingListNotFoundErrorCode = '1';
        const str SalesOrderNotFoundErrorCode = '2';
        const str ExceptionThrownErrorCode = '3';

        WMSPickingRoute pickingRoute;
        SalesTable salesTable;
        boolean isPickingListExists = false;

        XmlDocument xmlDoc;
        XmlElement  xmlRoot;
        XmlElement  xmlRecord;

        container openPickingLists = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        /* Sample of XML returned.
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>
            <WMSPickingRoutes>
            <WMSPickingRoute PickingRouteId=\"00016\" DlvDate=\"2016-05-20\" />
            <WMSPickingRoute PickingRouteId=\"00017\" DlvDate=\"2016-05-20\" /></WMSPickingRoutes>"
        */

        try
        {
            xmlDoc = XmlDocument::newBlank();
            xmlRoot = xmlDoc.createElement(WMSPickingRoutes);

            // Get open picking lists for the order.
            while select RecId, PickingRouteID, DlvDate from pickingRoute
                    where pickingRoute.TransRefId == _salesId
                        && (pickingRoute.ShipmentType == WMSShipmentType::OrderPick)
                        && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Cancelled)
                        && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Complete)
                        && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Picked)
            {
                xmlRecord = xmlDoc.createElement(tableStr(WMSPickingRoute));
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, PickingRouteId), pickingRoute.PickingRouteID);
                xmlRecord.setAttribute(fieldStr(WMSPickingRoute, DlvDate),
                    RetailTransactionServiceUtilities::dateToString(pickingRoute.DlvDate));

                xmlRoot.appendChild(xmlRecord);

                isPickingListExists = true;
            }

            xmlDoc.appendChild(xmlRoot);

            if (isPickingListExists)
            {
                openPickingLists = [true, '', xmlDoc.toString()];
            }
            else
            {
                // Check if sales order exists.
                salesTable = SalesTable::find(_salesId);

                if (salesTable)
                {
                    openPickingLists = [false, "@Retail:SalesOrderPickingListDoesNotExists", PickingListNotFoundErrorCode];
                    eventSource.EventWriteOrdersGetPickingListsForOrderPickinglistNotFoundWarning(funcName(), salesTable.RecId);
                }
                else
                {
                    openPickingLists = [false, "@Retail:SalesOrderDoesNotExists", SalesOrderNotFoundErrorCode];
                    eventSource.EventWriteOrdersGetPickingListsForOrderOrderNotFoundWarning(funcName());
                }
            }
        }
        catch
        {
            openPickingLists = [false, "@RET2382", ExceptionThrownErrorCode];
            eventSource.EventWriteOrdersGetPickingListsForOrderError(funcName());
        }

        return openPickingLists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuotationOrder</Name>
				<Source><![CDATA[
    private static container getQuotationOrder(QuotationId _quotationId)
    {
        SalesQuotationTable          salesQuotationTable;
        CustTable           custTable;
        container           salesQuotationOrder = [false,'','','','','','','','', 0, false, '', 0, 0, 0, 0, '', '', '', '', ''];

        AmountCur           salesPayed;
        ;

        select salesQuotationTable
        where salesQuotationTable.QuotationId        == _quotationId
                    && salesQuotationTable.QuotationType      == QuotationType::Sales
                    && (salesQuotationTable.QuotationStatus == SalesQuotationStatus::Created ||
                         salesQuotationTable.QuotationStatus == SalesQuotationStatus::Approved ||
                         salesQuotationTable.QuotationStatus == SalesQuotationStatus::Submitted);

        if (salesQuotationTable)
        {
            custTable       = CustTable::find(salesQuotationTable.CustAccount);
        }
        salesPayed = RetailPrePaymentTrans::paymentsMade(_quotationId);

        salesQuotationOrder = [true,                                                                                   //0 -result
                                    '',                                                                                     //1 -comment
                                    salesQuotationTable  ? salesQuotationTable.QuotationId                          : '',   //2 -QuotationId
                                    0,                                                                                      //3 - (prepay amount)
                                    0,                                                                                      //4 - (balance)
                                    salesQuotationTable  ? salesQuotationTable.invoiceAmount()                      : 0,    //5 -Total quotation line amount
                                    salesQuotationTable  ? salesQuotationTable.CustAccount                          : '',   //6 -Customer Id on Quotation order
                                    custTable            ? custTable.name()                                         : '',   //7 -Customer name on Quotation order
                                    salesQuotationTable  ? DateTimeUtil::toStr(salesQuotationTable.CreatedDateTime) : '',   //8 -Date of Quotation order creation
                                    enum2str(salesQuotationTable.QuotationType),                                            //9 -Quote type
                                    enum2str(salesQuotationTable.QuotationStatus),                                          //10-Quote status
                                    salesQuotationTable  ? enum2int(salesQuotationTable.QuotationStatus)            : 0,    //11-Quotation status
                                    false,                                                                                  //12-false = quotation (true = sales order)
                                    salesQuotationTable        ? salesQuotationTable.DlvMode                        : '',   //13-Delivery mode
                                    salesQuotationTable        ? enum2int(salesQuotationTable.QuotationStatus)      : 0,    //14-sales status
                                    0,                                                                                      //15-TaxAmount
                                    0,                                                                                      //16-DiscountAmount
                                    0,                                                                                      //17-ChargeAmount
                                    salesQuotationTable        ? salesQuotationTable.InventLocationId               : '',   //18-LocationId
                                    salesQuotationTable        ? salesQuotationTable.InventSiteId                   : '',   //19-SiteId
                                    '',                                                                                     //20-Channel Ref Id.
                                    '',                                                                                     //21-TransactionId
                                    salesQuotationTable        ? salesQuotationTable.Email                          : ''    //22-Email
                                ];

        return salesQuotationOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailSalesLine</Name>
				<Source><![CDATA[
    private static void getRetailSalesLine(XmlElement xmlRecord, SalesLine _salesLine)
    {
        RetailSalesLine retailSalesLine = retailSalesLine::findBySalesLine(_salesLine.RecId);

        DiscAmount lineDiscount;
        if (_salesLine.LineDisc && !retailSalesLine.PeriodicDiscount && !retailSalesLine.LineDscAmount && !retailSalesLine.TotalDiscount)
        {
            lineDiscount = _salesLine.LineDisc * _salesLine.SalesQty;
        }
        else
        {
            lineDiscount = retailSalesLine.LineDscAmount;
        }

        // For non Retail order (Orders from AX by a non call center user), use salesLine.LinePercent, otherwise, use retailSalesLine.LinePercentageDiscount
        SalesLinePercent linePercentDiscount;
        if (_salesLine.LinePercent && !retailSalesLine.PeriodicDiscount && !retailSalesLine.LinePercentageDiscount && !retailSalesLine.TotalDiscount)
        {
            linePercentDiscount = _salesLine.LinePercent;
        }
        else
        {
            linePercentDiscount = retailSalesLine.LinePercentageDiscount;
        }

        if (retailSalesLine.IsPriceOverridden == NoYes::Yes)
        {
            xmlRecord.setAttribute(#IsPriceOverridden, '1');
        }
        else
        {
            xmlRecord.setAttribute(#IsPriceOverridden, '0');
        }

        if (retailSalesLine.IsPriceKeyedIn == NoYes::Yes)
        {
            xmlRecord.setAttribute(IsPriceKeyedIn, '1');
        }
        else
        {
            xmlRecord.setAttribute(IsPriceKeyedIn, '0');
        }

        xmlRecord.setAttribute(#LineDscAmount, RetailTransactionServiceOrders::amountToStr(lineDiscount));
        xmlRecord.setAttribute(LinePercentageDiscountStr, RetailTransactionServiceOrders::amountToStr(linePercentDiscount));
        xmlRecord.setAttribute(#OriginalPrice, RetailTransactionServiceOrders::amountToStr(RetailSalesLine.OriginalPrice));
        xmlRecord.setAttribute(#PeriodicDiscount, RetailTransactionServiceOrders::amountToStr(retailSalesLine.PeriodicDiscount));
        xmlRecord.setAttribute(#PeriodicPercentageDiscount, RetailTransactionServiceOrders::percentToStr(retailSalesLine.PeriodicPercentageDiscount));
        xmlRecord.setAttribute(TenderDiscount, RetailTransactionServiceOrders::amountToStr(retailSalesLine.TenderDiscount));
        xmlRecord.setAttribute(TenderDiscountPercentage, RetailTransactionServiceOrders::percentToStr(retailSalesLine.TenderDiscountPercentage));
        xmlRecord.setAttribute(#LineManualDiscountAmount, RetailTransactionServiceOrders::amountToStr(retailSalesLine.LineManualDiscountAmount));
        xmlRecord.setAttribute(#LineManualDiscountPercentage, RetailTransactionServiceOrders::percentToStr(retailSalesLine.LineManualDiscountPercentage));

        xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(retailSalesLine.TaxExemptPriceInclusiveOriginalPrice));
        xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(retailSalesLine.TaxExemptPriceInclusiveReductionAmount));

        xmlRecord.setAttribute(#TotalDiscount, RetailTransactionServiceOrders::amountToStr(retailSalesLine.TotalDiscount));
        xmlRecord.setAttribute(#TotalPctDiscount, RetailTransactionServiceOrders::percentToStr(retailSalesLine.TotalPctDiscount));

        if (retailSalesLine && retailSalesLine.FulfillmentStoreId != '')
        {
            xmlRecord.setAttribute(#FulfillmentStoreId, retailSalesLine.FulfillmentStoreId);
        }
        else
        {
            // If the order is not a retail order find fulFillment store id.
            xmlRecord.setAttribute(#FulfillmentStoreId,_salesLine.mcrGetFulfillmentStore());
        }

        if (retailSalesLine.PickupEndTime > 0)
        {
            // Formatted as yyyy-MM-ddTHH:mm:ss
            xmlRecord.setAttribute(PickupTimeslotStartDateTime, DateTimeUtil::toStr(DateTimeUtil::newDateTime(_salesLine.ShippingDateRequested, retailSalesLine.PickupStartTime)));
            xmlRecord.setAttribute(PickupTimeslotEndDateTime, DateTimeUtil::toStr(DateTimeUtil::newDateTime(_salesLine.ShippingDateRequested, retailSalesLine.PickupEndTime)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnReasonCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reason codes.
    /// </summary>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getReturnReasonCodes()
    {
        ReturnReasonCode returnReasonCode;
        str                 error = '';
        boolean             success = false;
        Counter             infologline    = infolog.num();
        XmlDocument         xmldoc;
        XmlElement          xmlRoot,xmlRecord;
        int                 fromLine;

        try
        {
            fromLine = Global::infologLine();

            xmldoc =  XmlDocument::newBlank();
            xmlRoot = xmldoc.createElement('ArrayOfReturnReasonCode');

            while select ReasonCodeId, Description
            from returnReasonCode
            order by Description
            {
                xmlRecord = xmldoc.createElement('ReturnReasonCode');
                xmlRecord.setAttribute('ReasonCodeId', returnReasonCode.ReasonCodeId);
                xmlRecord.setAttribute('Description', returnReasonCode.Description);

                xmlRoot.appendChild(xmlRecord);
            }

            xmldoc.appendChild(xmlRoot);
            success = true;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoiceDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales invoice for a non-cash-and-carry sales order.
    /// </summary>
    /// <param name="invoiceId">
    /// An invoiceId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales invoice in XML format
    /// </returns>
    /// <remarks>
    /// If the invoice is for a cash and carry retail order, this API will return empty result.
    /// </remarks>
    public static container getSalesInvoiceDetail(InvoiceId invoiceId)
    {
        #OCCRetryCount

        container salesInvoice = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        CustInvoiceJour         custInvoiceJour;
        CustInvoiceTrans        custInvoiceTrans;
        SalesTable              salesTable;
        SalesLine               salesLine;
        InventDim               inventDim;
        InventTable             inventTable;
        EcoResProductTranslation productTranslation;
        RetailSalesTable        retailSalesTable;
        RetailLoyaltyCard       loyaltyCard;
        CustTrans               custTrans;
        InventDimCombination    inventDimCombination;
        Counter                 pCounter = 0;
        InventTrackingRegisterTrans inventTrackingRegisterTrans;
        InventTrackingRegisterTransView inventTrackingRegisterTransView;
        InventBatchSerialId     inventSerialId = '';

        Percent factorForEffectiveAmount = 1;

        XmlDocument             xmlDoc;
        XmlElement              xmlRoot, xmlRecord, xmlCharges;

        boolean useAdvancedAutoCharges = RetailParameters::IsRetailAutoChargesEnabledAndInUse();
        RetailParameters retailParameters = RetailParameters::find();

        try
        {
            xmlDoc = XmlDocument::newBlank();

            select firstonly1 RecId, SalesId, SalesType, InvoiceId, InvoiceDate, CurrencyCode, InvoiceAmount,
                InvoiceAccount, InvoicingName, DeliveryPostalAddress, DlvMode, CreatedDateTime, InclTax,
                OrderAccount, SalesBalance, SumMarkup, SumTax, SumLineDisc, EndDisc, LanguageId from custInvoiceJour
                where custInvoiceJour.InvoiceId == invoiceId
            join RecId from salesTable
                where salesTable.SalesId == custInvoiceJour.SalesId
            outer join TotalManualDiscountAmount, TotalManualDiscountPercentage, IsTaxExemptedForPriceInclusive, RetailChannel, StatementId from retailSalesTable
                where retailSalesTable.SalesTable == salesTable.RecId
            outer join CardNumber from loyaltyCard
                where loyaltyCard.RecId == retailSalesTable.RetailLoyaltyCard
            outer join Closed, DueDate, SettleAmountCur from custTrans
                where custTrans.invoice == custInvoiceJour.InvoiceId
                && custTrans.AccountNum == custInvoiceJour.InvoiceAccount
                && custTrans.TransDate == custInvoiceJour.InvoiceDate
                && custTrans.Voucher == custInvoiceJour.LedgerVoucher;

            LanguageId languageId = RetailTransactionServiceOrders::getInvoiceLanguageId(retailSalesTable.RetailChannel, custInvoiceJour.LanguageId);

            if (custInvoiceJour)
            {
                if (retailSalesTable.StatementId != '')
                {
                    return [true, '', xmlDoc.toString()];
                }

                xmlRoot = RetailTransactionServiceOrders::populateInvoiceOrderHeader(xmlDoc, custInvoiceJour, salesTable, retailSalesTable, loyaltyCard, custTrans);

                while select RecId, InvoiceId, ItemId, SalesUnit, Name, InventDimId, InventTransId, Qty, SalesPrice,
                    DiscPercent, DiscAmount, LineAmount, LineAmountTax, TaxGroup, TaxItemGroup,
                    DeliveryPostalAddress, MCRDlvMode, DlvDate, SalesId, LineNum, InvoiceDate
                from custInvoiceTrans
                        where custInvoiceTrans.InvoiceId == invoiceId
                            && custInvoiceTrans.Qty > 0
                    join inventDim where inventDim.InventDimId == custInvoiceTrans.InventDimId
                    join ItemId, Product from inventTable where inventTable.ItemId == custInvoiceTrans.ItemId
                    outer join salesLine
                        where salesLine.inventTransId == custInvoiceTrans.inventTransId
                    outer join Name, Product, LanguageId from productTranslation
                        where productTranslation.Product == inventTable.Product
                            && productTranslation.LanguageId == languageId
                {
                    RetailTransactionServiceOrders::populateInvoiceOrderLine(xmlDoc, xmlRoot, custInvoiceTrans, productTranslation, salesLine, inventDim);
                }

                // Add  Historical payment elements to the invoice order xml document.
                // For returns, consider original prepayments as regular payments, as they don't apply for return orders..
                RetailTransactionServiceOrders::AddPaymentInformationXml(xmlRoot, SalesTable::find(custInvoiceJour.SalesId), retailParameters.AllowExchangeOnReturnOrders);
                xmlDoc.appendChild(xmlRoot);
            }

            salesInvoice = [true, '', xmlDoc.toString()];

        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            salesInvoice = [false, "@RET2382", ''];
        }
        catch
        {
            salesInvoice = [false, "@RET2382", ''];
        }

        return salesInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoicesBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of sales invoices for a sales order
    /// </summary>
    /// <param name="_salesId">
    /// A salesId
    /// </param>
    /// <returns>
    /// A container object containing the list of sales invoices in XML format
    /// </returns>
    /// <remarks>
    /// This is to get a list of sales invoices
    /// </remarks>
    public static container getSalesInvoicesBySalesId(SalesId _salesId)
    {
        #OCCRetryCount

        container custInvoiceJourList = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        CustInvoiceJour         custInvoiceJour;
        CustInvoiceTrans        custInvoiceTrans;

        Counter                 pCounter = 0;

        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.CustInvoiceJours('CustInvoiceJours');

        try
        {
            ttsbegin;
            xmlDoc = XmlDocument::newBlank();

            xmlRoot = xmlDoc.createElement(#CustInvoiceJours);

            while select RecId, SalesId, SalesType, InvoiceId, InvoiceDate, CurrencyCode, InvoiceAmount,
                InvoiceAccount, InvoicingName from custInvoiceJour group by RecId, SalesId, SalesType, InvoiceId, InvoiceDate, CurrencyCode, InvoiceAmount,
                InvoiceAccount, InvoicingName
                exists join custInvoiceTrans
                where custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
                && custInvoiceTrans.OrigSalesId == _salesId
                && custInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                && custInvoiceTrans.numberSequenceGroup == custInvoiceJour.numberSequenceGroup
            {
                xmlRecord = xmlDoc.createElement(tableStr(CustInvoiceJour));

                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, RecId), int642str(custInvoiceJour.RecId));
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, InvoiceId), custInvoiceJour.InvoiceId);
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, SalesId), custInvoiceJour.SalesId);
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, SalesType), int2str(enum2int(custInvoiceJour.SalesType)));
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, InvoiceDate),
                    RetailTransactionServiceUtilities::dateToString(custInvoiceJour.InvoiceDate));

                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, CurrencyCode), custInvoiceJour.CurrencyCode);
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, InvoiceAmount), num2str(custInvoiceJour.InvoiceAmount,5,3,1,0));
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, InvoiceAccount), custInvoiceJour.InvoiceAccount);
                xmlRecord.setAttribute(fieldStr(CustInvoiceJour, InvoicingName), custInvoiceJour.InvoicingName);

                xmlRoot.appendChild(xmlRecord);
            }

            xmlDoc.appendChild(xmlRoot);

            custInvoiceJourList = [true, '', xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            custInvoiceJourList = [false, "@RET2382"];
        }
        catch
        {
            custInvoiceJourList = [false, "@RET2382"];
        }

        return custInvoiceJourList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales order
    /// </summary>
    /// <param name="salesId">
    /// A salesId
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales order in XML format
    /// </returns>
    /// <remarks>
    /// This is to get open sales order
    /// </remarks>
    public static container getSalesOrderDetail(SalesId salesId, InventLocationId storeId)
    {
        #OCCRetryCount

        container salesOrder = [false, '', '']; // Status, ErrorMsg, XmlResultSet

        SalesTable              soTable;
        SalesLine               soLine;
        InventDim               inventDim;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.UpdatedInAx('UpdatedInAx')
        #define.Message('Message')
        #define.FalseStr('false')


        try
        {
            ttsbegin;
            xmlDoc = XmlDocument::newBlank();

            QueryRun queryRun = new QueryRun(RetailTransactionServiceOrders::buildSalesOrderListQuery(salesId));
            queryRun.next();
            soTable = queryRun.get(tableNum(salesTable));

            if (soTable)
            {
                xmlRoot = xmlDoc.createElement(tableStr(SalesTable));

                xmlRoot.setAttribute(fieldStr(SalesTable, SalesId), salesId);
                xmlRoot.setAttribute(fieldStr(SalesTable, RecId), int642str(soTable.RecId));
                xmlRoot.setAttribute(fieldStr(SalesTable, SalesName), soTable.SalesName);
                xmlRoot.setAttribute(fieldStr(SalesTable, CustAccount), soTable.CustAccount);

                while select RecId, ItemId, InventDimId, SalesQty, SalesDeliverNow, SalesGroup from soLine
                        join * from inventDim
                            where soLine.SalesId == salesId
                                && inventDim.InventDimId == soLine.InventDimId
                {
                    xmlRecord = xmlDoc.createElement(tableStr(SalesLine));

                    xmlRecord.setAttribute(fieldStr(SalesLine, RecId), int642str(soLine.RecId));
                    xmlRecord.setAttribute(fieldStr(SalesLine, ItemId), soLine.ItemId);
                    xmlRecord.setAttribute(fieldStr(SalesLine, InventDimId), soLine.InventDimId);
                    xmlRecord.setAttribute(fieldStr(SalesLine, SalesQty), num2str(soLine.SalesQty, 0, 2, 1, 0));
                    xmlRecord.setAttribute(fieldStr(SalesLine, SalesDeliverNow), num2str(soLine.SalesDeliverNow, 0, 2, 1, 0));
                    xmlRecord.setAttribute(fieldStr(SalesLine, SalesGroup), soLine.SalesGroup);

                    xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), inventDim.InventBatchId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), inventDim.wmsLocationId);
                    xmlRecord.setAttribute('WmsPalletId', '');
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), inventDim.InventSiteId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), inventDim.InventLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, ConfigId), inventDim.ConfigId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSizeId), inventDim.InventSizeId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventColorId), inventDim.InventColorId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStyleId), inventDim.InventStyleId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventVersionId), inventDim.InventVersionId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventDim.InventSerialId);

                    xmlRecord.setAttribute(GuidStr, guid2str(newGuid()));
                    xmlRecord.setAttribute(#UpdatedInAx, FalseStr);
                    xmlRecord.setAttribute(#Message, '');

                    xmlRoot.appendChild(xmlRecord);
                }

                xmlDoc.appendChild(xmlRoot);
            }

            salesOrder = [true, '', xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                    retry;

            salesOrder = [false, "@RET2382"];
        }
        catch
        {
            salesOrder = [false, "@RET2382"];
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the shipping information of delivered sales orders.
    /// </summary>
    /// <param name="salesOrderId">
    /// Sales id of the shipments to get.
    /// </param>
    /// <param name="shipmentId">
    /// Packing slip id of the shipments to get.
    /// </param>
    /// <returns>
    /// A <c>container</c> with success status, error message and xml result of data returned by the query.
    /// </returns>
    /// <remarks>
    /// Method runs the <c>RetailGetShipmentInfo</c> query and forms the xml result of the data.
    /// </remarks>
    public static container getShipments(str salesOrderId = '', str shipmentId = '')
    {
        str                     error = '';
        boolean                 success = false;
        int                      fromLine;
        XmlDocument             xmldoc =  XmlDocument::newBlank();
        XmlElement              xmlRoot, xmlPackingSlipColl;
        #define.GetShipmentsResponse('GetShipmentResponse')

        try
        {
            fromLine = Global::infologLine();

            xmlRoot = xmldoc.createElement(#GetShipmentsResponse);

            xmlPackingSlipColl = RetailTransactionServiceOrders::fillOrderShipments(xmldoc, salesOrderId, shipmentId);
            xmlRoot.appendChild(xmlPackingSlipColl);
            xmldoc.appendChild(xmlRoot);
            success = true;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderShipmentHistory</Name>
				<Source><![CDATA[
    /* Template of the XML doc that is created. */
    /*
        "
     <?xml version="1.0" encoding="utf-8"?>
    <GetShipmentResponse>
        <Shipments>
            <Shipment>
                <ShipmentId>PS-101700</ShipmentId>
                <SalesOrderId>SO-101268</SalesOrderId>
                <DeliveryMode>06</DeliveryMode>
                <TermsOfDelivery>FOB_DS</TermsOfDelivery>
                <ShippingWeight>1.000</ShippingWeight>
                <WeightUnit></WeightUnit>
                <TrackingNumber>PartialOrderTracking</TrackingNumber>
                <ShipDate>2012-07-24</ShipDate>
                <DeliveryAddress>
                    <ThreeLetterISORegionName>USA</ThreeLetterISORegionName>
                    <ZipCode>78001</ZipCode>
                    <State>TX</State>
                    <County>LA SALLE</County>
                    <City>Artesia Wells</City>
                    <DistrictName></DistrictName>
                    <Street>123 White Road</Street>
                    <StreetNumber></StreetNumber>
                </DeliveryAddress>
                <ShipmentLines>
                    <ShipmentLine>
                        <ShipmentLineId>1.000</ShipmentLineId>
                        <ItemId>0001</ItemId>
                        <Description>Youth Accessory Combo Set Youth Accessory Combo Set</Description>
                        <InventDimId>00000451_069</InventDimId>
                        <OrderedQuantity>1.000</OrderedQuantity>
                        <DeliveredQuantity>1.000</DeliveredQuantity>
                        <RemainingQuantity>0.000</RemainingQuantity>
                    </ShipmentLine>
                    <ShipmentLine>
                        <ShipmentLineId>2.000</ShipmentLineId>
                        <ItemId>0002</ItemId>
                        <Description>Adult Helmet Accessory Combo Set Adult Helmet Accessory Combo Set</Description>
                        <InventDimId>00000451_069</InventDimId>
                        <OrderedQuantity>2.000</OrderedQuantity>
                        <DeliveredQuantity>1.000</DeliveredQuantity>
                        <RemainingQuantity>1.000</RemainingQuantity>
                    </ShipmentLine>
                </ShipmentLines>
            </Shipment>
            <Shipment>
                <ShipmentId>PS-101701</ShipmentId>
                <SalesOrderId>SO-101268</SalesOrderId>
                <DeliveryMode>06</DeliveryMode>
                <TermsOfDelivery>FOB_DS</TermsOfDelivery>
                <ShippingWeight>2.000</ShippingWeight>
                <WeightUnit></WeightUnit>
                <TrackingNumber>2ndpartofOrder</TrackingNumber>
                <ShipDate>2012-07-24</ShipDate>
                <DeliveryAddress>
                    <ThreeLetterISORegionName>USA</ThreeLetterISORegionName>
                    <ZipCode>78001</ZipCode>
                    <State>TX</State>
                    <County>LA SALLE</County>
                    <City>Artesia Wells</City>
                    <DistrictName></DistrictName>
                    <Street>123 White Road</Street>
                    <StreetNumber></StreetNumber>
                </DeliveryAddress>
                <ShipmentLines>
                    <ShipmentLine>
                        <ShipmentLineId>2.00</ShipmentLineId>
                        <ItemId>0002</ItemIdXX>
                        <Description>Adult Helmet Accessory Combo Set Adult Helmet Accessory Combo Set</Description>
                        <InventDimId>00000451_069</InventDimId>
                        <OrderedQuantity>1.000</OrderedQuantity>
                        <DeliveredQuantity>1.000</DeliveredQuantity>
                        <RemainingQuantity>0.000</RemainingQuantity>
                    </ShipmentLine>
                </ShipmentLines>
            </Shipment>
        </Shipments>
    </GetShipmentResponse>"
       */

    /// <summary>
    /// Get the history of all transactions and orders for a given customer.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders.
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getCustomerOrderShipmentHistory(str _xmlArgumentString = '')
    {
        str                 error = '';
        boolean             success = false;
        int                 fromLine;
        XmlDocument         xmldoc =  XmlDocument::newBlank('utf-16LE');
        XmlElement          xmlRoot, xmlOrderShipmentsList;

        XmlElement          argsRoot;
        int64               resultsStartingPosition = 1;
        int64               resultsMaxCount = 10;
        int64               resultsCount = 0;
        CreatedDateTime     startDateTime, endDateTime;
        boolean             skipRecords = false;

        // Parse the arguments
        XmlDocument argsXml   = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        CustAccount custAccount = RetailTransactionServiceOrders::getArg('CustomerAccountNumber', argsRoot);

        // Customer is required. If customer does not exist, return error
        CustTable custTable = CustTable::find(custAccount);
        if (RetailSearchOrderReturnInvalidCustomerFlight::instance().isEnabled() && !custTable)
        {
            return [false, strFmt("@SYS119849", custAccount)];
        }

        str fetchNextPage = RetailTransactionServiceOrders::getArg('FetchNextPage', argsRoot);
        if (fetchNextPage == '' || fetchNextPage != 'True')
        {
            // old fashion way, left here for legacy support:
            // get records in the time interval from a given date up to Now
            startDateTime = str2Datetime(RetailTransactionServiceOrders::getArg('StartDateTime', argsRoot), 213);
            endDateTime = DateTimeUtil::utcNow();
        }
        else
        {
            // New way of fetching data: skip a given number of records
            // and return up to maximum number of records from all the history
            skipRecords = true;
            startDateTime = DateTimeUtil::minValue();
            endDateTime = DateTimeUtil::utcNow();
        }

        // Get paging details
        [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

        try
        {
            fromLine = Global::infologLine();

            xmlOrderShipmentsList = RetailTransactionServiceOrders::getArrayOfOrderShipmentsXmlRoot(xmldoc);

            // get the basic query
            // inner join RetailSalesTable on st.SalesId == rst.SalesTable
            RetailOrderHistoryQuery q = new RetailOrderHistoryQuery(custAccount, startDateTime, endDateTime);

            // Set paging and run the query
            if (skipRecords)
            {
                q.addPageRange(resultsStartingPosition, resultsMaxCount);
            }

            while (q.moveNext())
            {
                // Skip if we have already reached max count
                if (resultsCount >= resultsMaxCount)
                {
                    break;
                }

                int historySource;
                int64 orderRecId;

                [historySource, orderRecId] = q.get();

                if (RetailTransactionServiceOrders::processOrderHistoryRecord(historySource, orderRecId, xmldoc, xmlOrderShipmentsList))
                {
                    resultsCount++;
                }
            }

            xmldoc.appendChild(xmlOrderShipmentsList);
            success = true;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBusinessPartnerOrderHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all transactions and orders for a given business partner.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders.
    ///     <ArrayOfOrderShipments>
    ///         <OrderShipments />
    ///     </ArrayOfOrderShipments>
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <BusinessPartnerId>"1234"</BusinessPartnerId>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    internal static container getBusinessPartnerOrderHistory(str _xmlArgumentString = '')
    {
        str                     error = '';
        boolean                 success = false;
        int                     fromLine;
        XmlDocument             xmldoc =  XmlDocument::newBlank('utf-16LE');
        XmlElement              xmlRoot, xmlOrderShipmentsList;

        XmlElement          argsRoot;
        int                 resultsStartingPosition = 1;
        int                 resultsMaxCount = 100;
        int                 resultsCount;

        // Parse the arguments
        XmlDocument argsXml   = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        CustHierarchyId businessPartnerId = RetailTransactionServiceOrders::getArg('BusinessPartnerId', argsRoot);
        CreatedDateTime startDateTime = str2Datetime(RetailTransactionServiceOrders::getArg('StartDateTime', argsRoot), 213);

        // Get paging details
        [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

        try
        {
            fromLine = Global::infologLine();

            xmlOrderShipmentsList = RetailTransactionServiceOrders::getArrayOfOrderShipmentsXmlRoot(xmldoc);

            // get the basic query
            // inner join RetailSalesTable on st.SalesId == rst.SalesTable
            Query q = new Query();

            //Add filters/ranges
            QueryBuildDataSource qbds = q.addDataSource(tableNum(RetailBusinessPartnerOrderHistoryView));
            qbds.addRange(fieldNum(RetailBusinessPartnerOrderHistoryView, BusinessPartnerId)).value(businessPartnerId); //View.CustHierarchyId == businessPartnerId
            qbds.addRange(fieldNum(RetailBusinessPartnerOrderHistoryView, OrderDateTime)).value(strFmt('>%1',
                startDateTime == DateTimeUtil::minValue() ? SysQuery::value(startDateTime) : SysQuery::value(DateTimeUtil::addDays(startDateTime, -1))));
            qbds.addSortField(fieldNum(RetailBusinessPartnerOrderHistoryView, OrderDateTime), SortOrder::Descending); // Newest order first

            // Set paging and run the query
            QueryRun qr = new QueryRun(q);
            while (qr.next())
            {
                // Skip if we have already reached max count
                if (resultsCount >= resultsMaxCount)
                {
                    break;
                }

                RetailBusinessPartnerOrderHistoryView orderHistoryView = qr.get(tableNum(RetailBusinessPartnerOrderHistoryView));

                RetailTransactionServiceOrders::processOrderHistoryRecord(orderHistoryView.HistorySource, orderHistoryView.OrderRecId, xmldoc, xmlOrderShipmentsList);

                resultsCount++;
            }

            xmldoc.appendChild(xmlOrderShipmentsList);
            success = true;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmldoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getArg</Name>
				<Source><![CDATA[
    private static str getArg(str argName, XmlElement argsRoot)
    {
        XmlElement xmlElement = argsRoot.getNamedElement(argName);
        if (xmlElement != null)
        {
            return xmlElement.text();
        }
        else
        {
            return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getArrayOfOrderShipmentsXmlRoot</Name>
				<Source><![CDATA[
    private static XmlElement getArrayOfOrderShipmentsXmlRoot(XmlDocument _doc)
    {
        XmlElement xmlElement = _doc.createElement('ArrayOfOrderShipments');
        xmlElement.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.DataModel');
            return xmlElement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether we should process the order.
    /// We always process retail orders.
    /// We only process non-retail orders if customer sets commerce parameter configuration.
    /// </summary>
    /// <param name = "rst">The retail sales table record associated with the order.</param>
    /// <returns>true if we should process, otherwise false.</returns>
    private static boolean shouldProcessOrder(RetailSalesTable rst)
    {
        return rst.RetailOrder || RetailParameters::find().DisplayNonRetailOrdersInEcommerceOrderHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOrderHistoryRecord</Name>
				<Source><![CDATA[
    private static boolean processOrderHistoryRecord(int _historySource, RecId _orderRecId, XmlDocument _xmldoc, XmlElement _xmlOrderShipmentsList)
    {
        const str xmlKeyElementOrderShipments = 'OrderShipments';
        XmlElement xmlOrderShipmentsNode;
        SalesTable salesTable;
        RetailTransactionTable transactionTable;
        RetailSalesTable rsTable;
        boolean result = false;

        switch (_historySource)
        {
            case tableNum(RetailTransactionTable):

                //if Transaction
                select firstonly TransactionId, Channel, Store, Terminal, DataAreaId, ChannelReferenceId, createdDateTime, Currency, CustAccount, DlvMode, GrossAmount, InventLocationId, ReceiptId, ReceiptDateRequested, salesOrderId, RecId
                            from transactionTable
                            where transactionTable.recid == _orderRecId;

                if (transactionTable.salesOrderId != '')
                {
                    // Order is already created for the transaction.
                    salesTable = SalesTable::find(transactionTable.salesOrderId);

                    // Did not use RetailSalesTable::findSalesTable just for minimum columns and better IO perf.
                    select firstonly ChannelReferenceId, RetailChannel, RetailOrder
                        from rsTable
                        where rsTable.SalesTable == salesTable.RecId;
                }

                if (salesTable && rsTable)
                {
                    if (RetailTransactionServiceOrders::shouldProcessOrder(rsTable)) {
                        // Generate xml for sales order
                        xmlOrderShipmentsNode = RetailTransactionServiceOrders::fillSalesOrderSummaryAndShipments(salesTable, rsTable, _xmldoc, xmlKeyElementOrderShipments);
                        _xmlOrderShipmentsList.appendChild(xmlOrderShipmentsNode);
                        result = true;
                    }
                }
                else
                {
                    // Generate xml for sales order transactions which is not yet synced to SalesOrder table
                    xmlOrderShipmentsNode = RetailTransactionServiceOrders::fillTransactionSummaryAndShipments(transactionTable, _xmldoc, xmlKeyElementOrderShipments);
                    _xmlOrderShipmentsList.appendChild(xmlOrderShipmentsNode);
                    result = true;
                }
                
                break;

            case tableNum(SalesTable):

                salesTable = salesTable::findRecId(_orderRecId);
                rsTable = RetailSalesTable::findSalesTable(salesTable);

                RetailTransactionOrderStatus orderStatus;

                // Find order status for current salesId to determine the status.
                // If the status is PendingSynchronization, the order was created in real time and p-job + sync orders hasn't been run yet
                // As a result we will not return the tender lines in the sales order summary
                select orderStatus
                            where orderStatus.SalesId == salesTable.SalesId
                            && orderStatus.Status == RetailTransactionOrderStatusType::PendingSynchronization;

                // Skip sales orders that have order status Pending Synchronization
                // The channel API will retrieve this transaction from the channel DB in this case
                if (!orderStatus && RetailTransactionServiceOrders::shouldProcessOrder(rsTable))
                {
                    // Generate xml for sales order
                    xmlOrderShipmentsNode = RetailTransactionServiceOrders::fillSalesOrderSummaryAndShipments(salesTable, rsTable, _xmldoc, xmlKeyElementOrderShipments);
                    _xmlOrderShipmentsList.appendChild(xmlOrderShipmentsNode);
                    result = true;
                }

                break;

            case tableNum(SalesQuotationTable):
            default:
                // Do nothing.
                break;
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOrderShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the shipping information of delivered sales orders.
    /// </summary>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="salesOrderId">
    /// Sales id of the shipments to get.
    /// </param>
    /// <param name="shipmentId">
    /// Packing slip id of the shipments to get.
    /// </param>
    /// <returns>
    /// A <c>container</c> with success status, error message and xml result of data returned by the query.
    /// </returns>
    /// <remarks>
    /// Method runs the <c>RetailGetShipmentInfo</c> query and forms the xml result of the data.
    /// </remarks>
    [Hookable(false), Wrappable(false)]
    internal static XmlElement fillOrderShipments(XmlDocument xmlDoc, str salesOrderId = '', str shipmentId = '')
    {
        str                     error = '';
        Query                   query = new Query(queryStr(RetailGetShipmentInfo));
        QueryRun                queryRun;
        CustPackingSlipJour     loc_CustPackingSlipJour;
        XmlElement              xmlPackingSlipColl, xmlPackingSlip, xmlPackingSlipLineColl, xmlPackingSlipLine;
        str                     currentPackingSlipId;

        // ShipmentLine xml keys:
        const str xmlKeyPackingSlipLines = 'ShipmentLines';
        const str xmlKeyPackingSlipLine = 'ShipmentLine';
        const str xmlKeyDeliveredQuantity = 'DeliveredQuantity';
        const str xmlKeyDescription = 'Description';
        const str xmlKeyInventDimId = 'InventDimId';
        const str xmlKeyItemId = 'ItemId';
        const str xmlKeyOrderedQuantity = 'OrderedQuantity';
        const str xmlKeyRemainingQuantity = 'RemainingQuantity';
        const str xmlKeyPackingSlipLineId = 'ShipmentLineId';

        // Shipment xml keys:
        const str xmlKeyPackingSlips = 'Shipments';
        const str xmlKeyPackingSlip = 'Shipment';
        const str xmlKeyDeliveryAddress = 'DeliveryAddress';
        const str xmlKeyDeliveryMode = 'DeliveryMode';
        const str xmlKeySalesOrderId = 'SalesId';
        const str xmlKeyShipCarrierId = 'ShipCarrierId';
        const str xmlKeyShipDate = 'ShipDate';
        const str xmlKeyPackingSlipId = 'ShipmentId';
        const str xmlKeyShippingWeight = 'ShippingWeight';
        const str xmlKeyTermsOfDelivery = 'TermsOfDelivery';
        const str xmlKeyTrackingNumber = 'TrackingNumber';
        const str xmlKeyTrackingUrl = 'TrackingUrl';
        const str xmlKeyWeightUnit = 'WeightUnit';
        const str xmlKeyInventoryTransactionId = 'InventoryTransactionId';

        void addNewTextNodeToParent(str _childNodeName, str _childNodeInnerText, XmlElement _parentNode)
        {
            XmlElement _xmlElement;

            _xmlElement = xmldoc.createElement(_childNodeName);
            _xmlElement.innerText(_childNodeInnerText);
            _parentNode.appendChild(_xmlElement);
        }

        // Get node that has line specific packing slip information.
        XmlElement getPackingSlipLinesNode(str _packingSlipId)
        {
            XmlElement _xmlPackingSlipLinesNode, _xmlPackingSlipLine;
            CustPackingSlipTrans custPackingSlipTrans;

            _xmlPackingSlipLinesNode = xmldoc.createElement(xmlKeyPackingSlipLines);

            while select PackingSlipId, Qty, Name, InventDimId, ItemId, Ordered, Remain, LineNum, InventTransId from custPackingSlipTrans
                where custPackingSlipTrans.PackingSlipId == _packingSlipId
            {
                _xmlPackingSlipLine = xmldoc.createElement(xmlKeyPackingSlipLine);

                addNewTextNodeToParent(xmlKeyDeliveredQuantity, num2str(custPackingSlipTrans.Qty,5,3,1,0), _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyDescription, custPackingSlipTrans.Name, _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyInventDimId, custPackingSlipTrans.InventDimId, _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyInventoryTransactionId, custPackingSlipTrans.InventTransId, _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyItemId, custPackingSlipTrans.ItemId, _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyOrderedQuantity, num2str(custPackingSlipTrans.Ordered,5,3,1,0), _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyRemainingQuantity, num2str(custPackingSlipTrans.Remain,5,3,1,0), _xmlPackingSlipLine);
                addNewTextNodeToParent(xmlKeyPackingSlipLineId, RetailTransactionServiceUtilities::lineNumToString(custPackingSlipTrans.LineNum), _xmlPackingSlipLine);

                _xmlPackingSlipLinesNode.appendChild(_xmlPackingSlipLine);
            }

            return _xmlPackingSlipLinesNode;
        }

        // Get node that contains information common across all packing slip lines.
        XmlElement getPackingSlipNode()
        {
            XmlElement            _xmlPackingSlip, _xmlAddress, _xmlshipDate;
            str                   _packingSlipId, trackingNum, trackingUrl, packageWeight, weightUnit;
            CustPackingSlipJour  _custPackingSlipJour = queryRun.get(tableNum(CustPackingSlipJour));
            SalesPackingSlipTrackingInformation _salesPackingSlipTrackingInformation;
            ShipCarrierStaging   _shipCarrierStaging;
            ShipCarrierPackage   _shipCarrierPackage;
            ShipCarrierTracking  _shipCarrierTracking;
            LogisticsPostalAddress _logisticsPostalAddress;

            _xmlPackingSlip = xmldoc.createElement(xmlKeyPackingSlip);
            _packingSlipId = _custPackingSlipJour.PackingSlipId;

            // Tracking number and tracking URL.
            // Look for information in SalesPackingSlipTrackingInformation, ShipCarrierTracking and ShipCarrierPackage tables in order.

            select firstOnly RecId, TrackingNumber, TrackingURL
                from _salesPackingSlipTrackingInformation
                where _salesPackingSlipTrackingInformation.PackingSlipId == _packingSlipId;

            select firstOnly Recid, TrackingNumber, Weight, WeightText
                        from _shipCarrierStaging
                        where _shipCarrierStaging.PackingSlipId == _packingSlipId;

            if (_salesPackingSlipTrackingInformation.RecId)
            {
                trackingNum = _salesPackingSlipTrackingInformation.TrackingNumber;
                trackingUrl = _salesPackingSlipTrackingInformation.TrackingURL;
            }
            else
            {
                select firstOnly RecId, TrackingNumber, URL
                    from _shipCarrierTracking
                    where _shipCarrierTracking.PackingSlipId == _packingSlipId;

                if (_shipCarrierTracking.RecId)
                {
                    trackingNum = _shipCarrierTracking.TrackingNumber;
                    trackingUrl = _shipCarrierTracking.URL;
                }
                else
                {
                    trackingNum = _shipCarrierStaging.TrackingNumber;
                }
            }

            // Weight and weight Unit.
            // Look for information in ShipCarrierPackage, ShipCarrierTracking and CustPackingSlipJour tables in order.

            select firstOnly RecId, Weight, UnitId
                from _shipCarrierPackage
                where _shipCarrierPackage.PackingSlipId == _packingSlipId;

            if (_shipCarrierPackage.RecId)
            {
                packageWeight = num2str(_shipCarrierPackage.Weight,5,3,1,0);
                weightUnit = _shipCarrierPackage.UnitId;
            }
            else if (_shipCarrierStaging.RecId)
            {
                packageWeight = num2str(_shipCarrierStaging.Weight,5,3,1,0);
                weightUnit = _shipCarrierStaging.WeightText;
            }
            else
            {
                packageWeight = num2str(_custPackingSlipJour.Weight,5,3,1,0);
            }

            // ShipDate node.
            _xmlshipDate = xmlDoc.createElement(xmlKeyShipDate);
            if (_custPackingSlipJour.DeliveryDate)
            {
                _xmlshipDate.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
                _xmlshipDate.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_custPackingSlipJour.deliveryDateTime()));
            }

            // DeliveryAddress node.
            DirPartyRecId _customerParty = CustTable::find(_custPackingSlipJour.OrderAccount).Party;
            _logisticsPostalAddress = LogisticsPostalAddress::findRecId(_custPackingSlipJour.DeliveryPostalAddress);
            _xmlAddress = RetailTransactionServiceTransactions::fillSalesOrderAddress(_logisticsPostalAddress, _custPackingSlipJour.DeliveryName, _customerParty, xmlDoc, xmlKeyDeliveryAddress);

            // Packing slip lines (ShipmentLines) node.
            xmlPackingSlipLineColl = getPackingSlipLinesNode(_custPackingSlipJour.PackingSlipId);

            // Populate packing slip fields to xml.
            _xmlPackingSlip.appendChild(_xmlAddress);
            addNewTextNodeToParent(xmlKeyDeliveryMode, _custPackingSlipJour.DlvMode, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeySalesOrderId, _custPackingSlipJour.SalesId, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeyShipCarrierId, _custPackingSlipJour.ShipCarrierId, _xmlPackingSlip);
            _xmlPackingSlip.appendChild(_xmlshipDate);
            addNewTextNodeToParent(xmlKeyPackingSlipId, _custPackingSlipJour.PackingSlipId, _xmlPackingSlip);
            _xmlPackingSlip.appendChild(xmlPackingSlipLineColl);
            addNewTextNodeToParent(xmlKeyShippingWeight, packageWeight, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeyTermsOfDelivery, _custPackingSlipJour.DlvTerm, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeyTrackingNumber, trackingNum, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeyTrackingUrl, trackingUrl, _xmlPackingSlip);
            addNewTextNodeToParent(xmlKeyWeightUnit, weightUnit, _xmlPackingSlip);

            return _xmlPackingSlip;
        }

        if (salesOrderId == '' && shipmentId == '')
        {
            error = 'At least one of SaleOrderId or PackingSlipId must be specified.';
            throw error(error);
        }

        if (salesOrderId != '')
        {
            // Add salesOrderId to where clause.
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(CustPackingSlipJour)),
                                fieldNum(CustPackingSlipJour, SalesId)).value(queryValue(salesOrderId));
        }

        if (shipmentId != '')
        {
            // Add packingSlipId to where clause.
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(CustPackingSlipJour)),
                                    fieldNum(CustPackingSlipJour, PackingSlipId)).value(queryValue(shipmentId));
        }

        queryRun = new QueryRun(query);

        // Initialize
        xmlPackingSlipColl = xmldoc.createElement(xmlKeyPackingSlips);

        while (queryRun.next())
        {
            loc_CustPackingSlipJour = queryRun.get(tableNum(CustPackingSlipJour));

            if (loc_CustPackingSlipJour.RecId)
            {
                xmlPackingSlip = getPackingSlipNode();
                xmlPackingSlipColl.appendChild(xmlPackingSlip);
            }
        }

        return xmlPackingSlipColl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesOrderSummaryAndShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the xml string of some properties of a Sales Order, as well as shipments.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c> table.
    /// </param>
    /// <param name="_rsoTable">
    /// Table buffer of <c>RetailSalesTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of OrderShipments.
    /// * Members must be in order of the OrderShipments DataContract
    /// Example, inside the given <_elementName> node:
    ///      <SalesId />
    ///      <CreatedDateTime />
    ///      <CurrencyCode />
    ///      <CustomerId />
    ///      <DeliveryMode />
    ///      <GrossAmount />
    ///      <InventoryLocationId />
    ///      <RequestedDeliveryDate />
    ///      <SalesLines />
    ///      <Shipments />
    ///      <TotalAmount />
    ///      <TaxAmount />
    ///      <Status />
    /// </returns>
    private static XmlElement fillSalesOrderSummaryAndShipments(SalesTable _salesTable,
                                                    RetailSalesTable _rsoTable,
                                                    XmlDocument xmlDoc,
                                                    str _elementName)
    {
        AmountCur totalAmount, totalTaxAmount;

        // The customer has to enable SalesTotalsCalculateBatch batch job so we get current totals fetched, instead of calculated.
        SalesOrderTotals orderTotals;
        if (FeatureStateProvider::isFeatureEnabled(RetailEnableSalesOrderTotalsFeature::instance()))
        {
            orderTotals = SalesOrderTotals::find(_salesTable.SalesId);
        }
        
        if (orderTotals)
        {
            totalAmount = orderTotals.OrderTotalAmount;
            totalTaxAmount = orderTotals.OrderTotalTaxAmount;
        }
        else
        {
            SalesTotals salesTotals = SalesTotals::construct(_salesTable, SalesUpdate::All);
            salesTotals.calc();

            // totalAmount is the sales order balance due amount + previously invoiced amounts
            totalAmount = salesTotals.totalAmount() + _salesTable.amountInvoiced();

            // totalTaxAmount is the sales order tax amount + any previously invoiced tax amounts. Same applies to charges and discounts.
            totalTaxAmount = salesTotals.totalTaxAmount() + _salesTable.taxAmountInvoiced();
        }

        XmlElement xmlRoot = xmlDoc.createElement(_elementName);

        XmlElement xmlRecord = xmlDoc.createElement(ChannelIdStr);
        xmlRecord.innerText(int642str(_rsoTable.RetailChannel));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(ChannelReferenceIdStr);
        xmlRecord.innerText(_rsoTable.ChannelReferenceId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CreatedDateTimeStr);
        if (_salesTable.createdDateTime)
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_salesTable.CreatedDateTime));
        }
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CurrencyCodeStr);
        xmlRecord.innerText(_salesTable.CurrencyCode);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CustomerIdStr);
        xmlRecord.innerText(_salesTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(DeliveryModeStr);
        xmlRecord.innerText(_salesTable.DlvMode);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(GrossAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(InventoryLocationIdStr);
        xmlRecord.innerText(_salesTable.InventLocationId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(RequestedDeliveryDateStr);
        if (_salesTable.ReceiptDateRequested)
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_salesTable.ReceiptDateRequested, _rsoTable.RetailChannel));
        }
        else
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::schemaInstanceNSKey, RetailTransactionServiceTransactions::schemaInstanceNSUrl);
            xmlRecord.setAttribute2("nil", RetailTransactionServiceTransactions::schemaInstanceNSUrl, "true");
        }
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(SalesIdStr);
        xmlRecord.innerText(_salesTable.SalesId);
        xmlRoot.appendChild(xmlRecord);

        // fill sales lines.
        SalesLine soLine;
        RetailSalesLine rsoLine;
        InventDim inventDim;
        XmlElement xmlContainer = xmlDoc.createElement(SalesLinesStr);
        while select * from soLine
            join inventDim where soLine.SalesId == _salesTable.SalesId
                && inventDim.InventDimId == soLine.InventDimId
            outer join rsoLine where rsoLine.SalesLine == soLine.RecId
        {
            xmlRecord = RetailTransactionServiceTransactions::fillSalesLineDetails(_salesTable, _rsoTable, soLine, rsoLine, inventDim, xmlDoc, false);
            xmlContainer.appendChild(xmlRecord);
        }
        xmlRoot.appendChild(xmlContainer);

        // fill shipments.
        xmlContainer = RetailTransactionServiceOrders::fillOrderShipments(xmlDoc, _salesTable.SalesId);
        xmlRoot.appendChild(xmlContainer);

        xmlRecord = xmlDoc.createElement(StatusStr);
        xmlRecord.innerText(int2str(enum2int(_salesTable.SalesStatus)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TaxAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalTaxAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TotalAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TransactionIdStr);
        // Get the most recent Transaction associated with this order (if one exists)
        RetailTransactionTable retailTransactionTable;
        select firstOnly1 TransactionId
            from retailTransactionTable
            order by retailTransactionTable.transDate desc, retailTransactionTable.transTime desc
            where retailTransactionTable.salesOrderId == _salesTable.SalesId;
        if (retailTransactionTable)
        {
            xmlRecord.innerText(retailTransactionTable.TransactionId);
        }
        xmlRoot.appendChild(xmlRecord);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTransactionSummaryAndShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the xml string of some properties of a Sales transaction, as well as shipments.
    /// </summary>
    /// <param name = "_rtTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of OrderShipments.
    /// * Members must be in order of the OrderShipments DataContract
    /// Example, inside the given <_elementName> node:
    ///      <SalesId />
    ///      <CreatedDateTime />
    ///      <CurrencyCode />
    ///      <CustomerId />
    ///      <DeliveryMode />
    ///      <GrossAmount />
    ///      <InventoryLocationId />
    ///      <RequestedDeliveryDate />
    ///      <SalesLines />
    ///      <Shipments />
    ///      <TotalAmount />
    ///      <TaxAmount />
    ///      <Status />
    /// </returns>
    private static XmlElement fillTransactionSummaryAndShipments(
        RetailTransactionTable _rtTable,
        XmlDocument xmlDoc,
        str _elementName)
    {
        // Get additional summary values
        RetailTransactionTaxTrans taxTable;
        select sum(Amount) from taxTable
            where _rtTable.TransactionId == taxTable.TransactionId
                && _rtTable.Channel == taxTable.Channel
                && _rtTable.Store == taxTable.StoreId
                && _rtTable.Terminal == taxTable.TerminalId
                && _rtTable.DataAreaId == taxTable.DataAreaId;

        XmlElement xmlRoot = xmlDoc.createElement(_elementName);

        XmlElement xmlRecord = xmlDoc.createElement(ChannelIdStr);
        xmlRecord.innerText(int642str(_rtTable.Channel));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(ChannelReferenceIdStr);
        xmlRecord.innerText(_rtTable.ChannelReferenceId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CreatedDateTimeStr);
        if (_rtTable.createdDateTime)
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_rtTable.CreatedDateTime));
        }
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CurrencyCodeStr);
        xmlRecord.innerText(_rtTable.Currency);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(CustomerIdStr);
        xmlRecord.innerText(_rtTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(DeliveryModeStr);
        xmlRecord.innerText(_rtTable.DlvMode);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(GrossAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(_rtTable.GrossAmount * -1));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(InventoryLocationIdStr);
        xmlRecord.innerText(_rtTable.InventLocationId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(ReceiptIdStr);
        xmlRecord.innerText(_rtTable.ReceiptId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(RequestedDeliveryDateStr);
        if (_rtTable.ReceiptDateRequested)
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_rtTable.ReceiptDateRequested, _rtTable.Channel));
        }
        else
        {
            xmlRecord.setAttribute(RetailTransactionServiceTransactions::schemaInstanceNSKey, RetailTransactionServiceTransactions::schemaInstanceNSUrl);
            xmlRecord.setAttribute2("nil", RetailTransactionServiceTransactions::schemaInstanceNSUrl, "true");
        }
        xmlRoot.appendChild(xmlRecord);

        // fill sales lines.
        RetailTransactionSalesTrans retailTransactionSalesTrans;
        XmlElement xmlContainer = xmlDoc.createElement(SalesLinesStr);
        while select * from retailTransactionSalesTrans order by TransDate desc
            where _rtTable.TransactionId == retailTransactionSalesTrans.TransactionId
                && _rtTable.Channel == retailTransactionSalesTrans.Channel
                && _rtTable.Store == retailTransactionSalesTrans.Store
                && _rtTable.Terminal == retailTransactionSalesTrans.Terminalid
                && _rtTable.DataAreaId == retailTransactionSalesTrans.DataAreaId
        {
            // Add the sales lines from the transactionSalesTable in order by TransDate (ideally they should have the same TransDate but sort to be safe).
            xmlContainer.appendChild(RetailTransactionServiceTransactions::fillSalesTransDetailsWithoutAttributesDiscountTax(retailTransactionSalesTrans, xmlDoc));
        }
        xmlRoot.appendChild(xmlContainer);

        // no need to fill shipments because sales order ID is not created yet.
        xmlRecord = xmlDoc.createElement(SalesIdStr);
        xmlRecord.innerText(_rtTable.salesOrderId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(StatusStr);
        xmlRecord.innerText(int2str(enum2int(SalesStatus::None)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TaxAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(taxTable.Amount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TotalAmountStr);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(_rtTable.GrossAmount * -1));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TransactionIdStr);
        xmlRecord.innerText(_rtTable.TransactionId);
        xmlRoot.appendChild(xmlRecord);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxGroup_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets retail order line tax group.
    /// </summary>
    /// <param name="_qty">
    /// Sales line quantity.
    /// </param>
    /// <param name="_custAccount">
    /// Sales order customer account ID.
    /// </param>
    /// <param name="_storeId">
    /// Retail store ID.
    /// </param>
    /// <param name="_defaultTaxGroup">
    /// Default sales line tax group.
    /// </param>
    /// <returns>
    /// Retail order line tax group.
    /// </returns>
    /// <remarks>
    /// Default tax group is returned in case quantity is positive or return tax group is undefined.
    /// </remarks>
    public static TaxGroup getTaxGroup_W(SalesQty _qty, CustAccount _custAccount, RetailStoreId _storeId, TaxGroup _defaultTaxGroup)
    {
        RetailStoreTable storeTable;
        TaxGroup         returnTaxGroup;

        if(!SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
        {
            return _defaultTaxGroup;
        }

        if (RetailParameters::find().UseRetailReturnTaxGroup_W && _qty < 0)
        {
            storeTable = RetailStoreTable::find(_storeId);

            returnTaxGroup =
                _custAccount == storeTable.DefaultCustAccount ?
                    storeTable.ReturnTaxGroup_W               :
                    RetailCustTable::find(_custAccount).ReturnTaxGroup_W;
        }

        return returnTaxGroup ? returnTaxGroup : _defaultTaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnReasonCodePolicyLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the return location policy line related to the reason code and return policy.
    /// </summary>
    /// <param name = "_returnReasonCodeId">Reason code for returning the item.</param>
    /// <param name = "_returnPolicy">Return policy RecId.</param>
    /// <returns>Returns the <c>RetailReturnReasonCodePolicyLine</c> based on reason code and return policy.</returns>
    public static RetailReturnReasonCodePolicyLine getReturnReasonCodePolicyLine(ReturnReasonCodeId _returnReasonCodeId, RefRecId _returnPolicy)
    {
        RetailReturnReasonCodePolicyLine retailReturnReasonCodePolicyLine;
        RefRecId storeId;
        RetailTransactionServiceOrdersContext context = RetailTransactionServiceOrdersContext::current();

        if (context != null && context.parmChannelRecordId())
        {
            storeId = context.parmChannelRecordId();
        }

        select firstonly retailReturnReasonCodePolicyLine
                where retailReturnReasonCodePolicyLine.ReasonCodeId == _returnReasonCodeId
                && retailReturnReasonCodePolicyLine.Policy == _returnPolicy
                && (retailReturnReasonCodePolicyLine.RetailStoreTable == storeId || !storeId);

        return retailReturnReasonCodePolicyLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailAttrForLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the attributes of the legal entity based on category and company.
    /// </summary>
    /// <param name = "_category">Category of the product.</param>
    /// <param name = "_dataArea">Legal entity of the transaction.</param>
    /// <returns>Returns <c>RetailAttributesLegalEntityLookup</c> based on category and company.</returns>
    public static RetailAttributesLegalEntityLookup getRetailAttrForLegalEntity(EcoResCategoryId _category, DataAreaId _dataArea)
    {
        RetailAttributesLegalEntityLookup retailAttributesLegalEntityLookup;
        CompanyInfo                       companyInfo;

        select ReturnPolicy from retailAttributesLegalEntityLookup
            where  retailAttributesLegalEntityLookup.Category == _category
        exists join companyInfo
            where   companyInfo.RecId       == retailAttributesLegalEntityLookup.LegalEntity
                &&  companyInfo.DataArea    == _dataArea;

        return retailAttributesLegalEntityLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventDimForReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the product dimensions for return order based on the return reason codes.
    /// Besides that, if the product should be blocked, then the blocked quantity is updated in the SalesLine.
    /// </summary>
    /// <param name = "_orderLine">SalesLine record related to the return transaction.</param>
    /// <param name = "_salesTransInventDim">Product dimensions of the customer order.</param>
    /// <param name = "_itemId">Item id of the product.</param>
    /// <param name = "_returnReasonCodeId">Reason code for returning the item.</param>
    /// <param name = "_dataArea">Legal entity of the transaction.</param>
    public static void updateInventDimForReturnOrder(SalesLine _orderLine, InventDim _salesTransInventDim, ReturnReasonCodeId _returnReasonCodeId)
    {
        // Selects the category of the item
        EcoResCategoryId ecoResCategoryId = EcoResProductCategory::findRetailCategoryByItem(_orderLine.ItemId);

        // Selects the product category setup based on the current company.
        RetailAttributesLegalEntityLookup retailAttributesLegalEntityLookup = RetailTransactionServiceOrders::getRetailAttrForLegalEntity(ecoResCategoryId, _orderLine.DataAreaId);

        // Selects warehouse and location based on the return policy done under product category setup.
        RetailReturnReasonCodePolicyLine retailReturnReasonCodePolicyLine = RetailTransactionServiceOrders::getReturnReasonCodePolicyLine(_returnReasonCodeId, retailAttributesLegalEntityLookup.ReturnPolicy);

        if (retailReturnReasonCodePolicyLine.RecId != 0)
        {
            // Update the inventory dimensions(warehouse, Location) on the return order line
            _salesTransInventDim.InventLocationId = retailReturnReasonCodePolicyLine.InventLocationId;
            _salesTransInventDim.wMSLocationId = retailReturnReasonCodePolicyLine.WMSLocationId;
            _salesTransInventDim.InventSiteId = InventLocation::find(_salesTransInventDim.InventLocationId).InventSiteId;

            // If the return location is LP controlled and item is whs enabled, we need to ensure the valid lp location combination.
            if (WHSInventEnabled::exist(_orderLine.ItemId) && _salesTransInventDim.wmsLocation().isWHSEnabled())
            {
                _salesTransInventDim = RetailTransferOrderHandler::ensureValidLPAndLocationCombination(_salesTransInventDim);
            }

            _orderLine.InventDimId = InventDim::findOrCreate(_salesTransInventDim).InventDimId;

            if (retailReturnReasonCodePolicyLine.BlockItem)
            {
                _orderLine.RetailBlockQty = -_orderLine.SalesQty;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkupTrans_IN</Name>
				<Source><![CDATA[
    private static void initMarkupTrans_IN(MarkupTrans _markupTrans, RetailStoreId _storeId, ChargeInfo _chargeInfo, XmlElement _xmlChargeRecord = null)
    {
        HSNCode_IN                  hsnCode;
        NoYesId                     exempt;
        NonGST_IN                   nonGST;
        ServiceAccountingCode_IN    serviceAccountingCode;
        ITCCategory_IN              itcCategory;
        ServiceCategory_IN          serviceCategory;
        TaxRateTypeName             taxRateType;

        RetailTransactionServiceOrders::setTaxInformationForMarkupTrans_IN(_markupTrans, _storeId);

        if (_markupTrans.TransTableId != tableNum(SalesTable)
            && _markupTrans.TransTableId != tableNum(SalesQuotationTable))
        {
            if (_chargeInfo != null)
            {
                PropertyInfo extensionPropertiesInfo = _chargeInfo.GetType().GetProperty(RetailTransactionServiceOrders::PropertyExtensionProperties);

                if (extensionPropertiesInfo)
                {
                    CLRObject extensionPropertyCollection = System.Activator::CreateInstance(extensionPropertiesInfo.PropertyType);

                    extensionPropertyCollection = extensionPropertiesInfo.GetValue(_chargeInfo);

                    for (int i = 0; i < extensionPropertyCollection.get_Count(); i++)
                    {
                        CLRObject commerceProperty =  extensionPropertyCollection.get_Item(i);
                        CLRObject commercePropertyValue;

                        switch (commerceProperty.get_Key())
                        {
                            case RetailTransactionServiceOrders::HSNCodePropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                hsnCode = commercePropertyValue.get_StringValue();
                                break;
                            case RetailTransactionServiceOrders::ServiceAccountingCodePropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                serviceAccountingCode = commercePropertyValue.get_StringValue();
                                break;
                            case RetailTransactionServiceOrders::IsExemptPropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                exempt = commercePropertyValue.get_BooleanValue();
                                break;
                            case RetailTransactionServiceOrders::NonGSTPropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                nonGST = commercePropertyValue.get_BooleanValue();
                                break;
                            case RetailTransactionServiceOrders::ITCCategoryPropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                itcCategory = commercePropertyValue.get_IntegerValue();
                                break;
                            case RetailTransactionServiceOrders::ServiceCategoryPropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                serviceCategory = commercePropertyValue.get_IntegerValue();
                                break;
                            case RetailTransactionServiceOrders::TaxRateTypePropertyName:
                                commercePropertyValue = commerceProperty.get_Value();
                                taxRateType = commercePropertyValue.get_StringValue();
                                break;
                        }
                    }
                }
            }
            else
            {
                hsnCode                 = _xmlChargeRecord.getAttribute('HSNCode');
                serviceAccountingCode   = _xmlChargeRecord.getAttribute('ServiceAccountingCode');
                exempt                  = _xmlChargeRecord.getAttribute('Exempt') == TrueStr ? NoYes::Yes : NoYes::No;
                nonGST                  = _xmlChargeRecord.getAttribute('NonGST') == TrueStr ? NoYes::Yes : NoYes::No;
                itcCategory             = str2int(_xmlChargeRecord.getAttribute('ITCCategory'));
                serviceCategory         = str2int(_xmlChargeRecord.getAttribute('ServiceCategory'));
                taxRateType             = _xmlChargeRecord.getAttribute('TaxRateType');
            }

            TransTaxInformation markupTransTaxInfo;

            markupTransTaxInfo = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_markupTrans, true);
            ttsbegin;
            markupTransTaxInfo.HSNCodeTable                  = HSNCodeTable_IN::findByCode(hsnCode);
            markupTransTaxInfo.ServiceAccountingCodeTable    = ServiceAccountingCodeTable_IN::findByServiceAccountingCode(serviceAccountingCode);
            markupTransTaxInfo.Exempt                        = exempt;
            markupTransTaxInfo.NonGST                        = nonGST;
            markupTransTaxInfo.ITCCategory                   = itcCategory;
            markupTransTaxInfo.ServiceCategory               = serviceCategory;
            markupTransTaxInfo.TaxRateType                   = TaxRateType::findByName(taxRateType).RecId;
            markupTransTaxInfo.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>SalesLine_IN</c> table extension data specific for retail.
    /// </summary>
    /// <param name = "_salesLine">Sales line.</param>
    /// <param name = "_salesTable">Sales table.</param>
    /// <param name = "_retailChannelTable">Retail channel table.</param>
    /// <param name = "_itemInfo">Item information.</param>
    /// <param name = "_xmlSalesLineRecord">Sales line xml element.</param>
    private static void initSalesLine_IN(SalesLine _salesLine, SalesTable _salesTable, RetailChannelTable _retailChannelTable, ItemInfo _itemInfo, XmlElement _xmlSalesLineRecord = null)
    {
        HSNCode_IN                  hsnCode;
        NoYesId                     exempt;
        NonGST_IN                   nonGST;
        ServiceAccountingCode_IN    serviceAccountingCode;
        SalesQty                    qty;
        TaxRateTypeName             taxRateType;
        RetailStoreTable            retailStoreTable, retailStoreTableReturnFulfillment;
        SalesTaxFormTypesRecId_IN   salesTaxFormTypeRecId;
        RetailTransactionAdditionalAddressTransContract retailTransactionAdditionalAddressTransContract;

        retailStoreTable = RetailStoreTable::findRecId(_retailChannelTable.RecId);

        _salesLine.initFromRetailChannelTable_IN(_retailChannelTable);

        SalesLine_IN salesLineIN = _salesLine.salesLine_IN();
        salesLineIN.selectForUpdate(true);
        salesLineIN.AssessableValueTransactionCurrency = _salesLine.calcLineAmount();
        salesLineIN.write();
        _salesLine.packSalesLine_IN(salesLineIN);

        if (_itemInfo)
        {
            qty = _itemInfo.Quantity;

            PropertyInfo extensionPropertiesInfo = _itemInfo.GetType().GetProperty(RetailTransactionServiceOrders::PropertyExtensionProperties);

            if (extensionPropertiesInfo)
            {
                CLRObject extensionPropertyCollection = System.Activator::CreateInstance(extensionPropertiesInfo.PropertyType);

                extensionPropertyCollection = extensionPropertiesInfo.GetValue(_itemInfo);

                for (int i = 0; i < extensionPropertyCollection.get_Count(); i++)
                {
                    CLRObject commerceProperty =  extensionPropertyCollection.get_Item(i);
                    CLRObject commercePropertyValue;

                    switch (commerceProperty.get_Key())
                    {
                        case RetailTransactionServiceOrders::HSNCodePropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            hsnCode = commercePropertyValue.get_StringValue();
                            break;
                        case RetailTransactionServiceOrders::ServiceAccountingCodePropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            serviceAccountingCode = commercePropertyValue.get_StringValue();
                            break;
                        case RetailTransactionServiceOrders::NonGSTPropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            nonGst = commercePropertyValue.get_BooleanValue();
                            break;
                        case RetailTransactionServiceOrders::IsExemptPropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            exempt = commercePropertyValue.get_BooleanValue();
                            break;
                        case RetailTransactionServiceOrders::TaxRateTypePropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            taxRateType = commercePropertyValue.get_StringValue();
                            break;
                        case RetailTransactionServiceOrders::InvoiceAddressIndiaPropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            retailTransactionAdditionalAddressTransContract = RetailTransactionAdditionalAddressTransContract::deserialize(commercePropertyValue.get_StringValue());
                            break;
                        case RetailTransactionServiceOrders::FulfillmentStoreIdPropertyName:
                            commercePropertyValue = commerceProperty.get_Value();
                            retailStoreTableReturnFulfillment = RetailStoreTable::find(commercePropertyValue.get_StringValue());
                            break;
                    }
                }
            }
        }
        else
        {
            hsnCode = _xmlSalesLineRecord.getAttribute('HSNCode');
            serviceAccountingCode = _xmlSalesLineRecord.getAttribute('ServiceAccountingCode');
            exempt = _xmlSalesLineRecord.getAttribute('Exempt') == TrueStr ? NoYes::Yes : NoYes::No;
            nonGST = _xmlSalesLineRecord.getAttribute('NonGST') == TrueStr ? NoYes::Yes : NoYes::No;
            taxRateType = _xmlSalesLineRecord.getAttribute('TaxRateType');
            qty = str2num(_xmlSalesLineRecord.getAttribute('Quantity'));
        }

        if (retailStoreTable)
        {
            RetailStoreTable_IN storeTableIN = RetailStoreTable_IN::findByRetailStoreTable(retailStoreTable.RecId);
            salesTaxFormTypeRecId = storeTableIN.SalesTaxFormTypes;
        }

        InventLocationId logisticsLocationId;

        if (retailStoreTableReturnFulfillment && _salesTable.SalesType == SalesType::ReturnItem)
        {
            logisticsLocationId = retailStoreTableReturnFulfillment.inventLocation;
        }
        else
        {
            RetailStoreTable retailStoreTableFulfillment = RetailStoreTable::find(_itemInfo.FulfillmentStoreId);
            logisticsLocationId = retailStoreTableFulfillment.inventLocation;
        }

        if (!logisticsLocationId)
        {
            logisticsLocationId = _retailChannelTable.inventLocation;
        }

        LogisticsLocationRecId logisticsLocationRecId = InventLocation::getDefaultLogisticsLocation_IN(logisticsLocationId, LogisticsLocationRoleType::Delivery).RecId;
        TaxInformationRecId_IN taxInformationRecId = TaxInformation_IN::findDefaultbyLocation(logisticsLocationRecId).RecId;

        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_salesLine, true);
        ttsbegin;
        transTaxInformation.HSNCodeTable = HSNCodeTable_IN::findByCode(hsnCode);
        transTaxInformation.ServiceAccountingCodeTable = ServiceAccountingCodeTable_IN::findByServiceAccountingCode(serviceAccountingCode);
        transTaxInformation.Exempt = exempt;
        transTaxInformation.NonGST = nonGST;
        transTaxInformation.TaxRateType = TaxRateType::findByName(taxRateType).RecId;
        transTaxInformation.CompanyLocation = logisticsLocationRecId;
        transTaxInformation.TaxInformation = taxInformationRecId;
        transTaxInformation.SalesTaxFormTypes = salesTaxFormTypeRecId;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            RetailTransactionServiceOrders::setCustomerTaxInformation(transTaxInformation, _salesTable,_salesLine, _retailChannelTable, retailTransactionAdditionalAddressTransContract);
        }

        if (_itemInfo.RecId && qty > 0)
        {
            RetailTransactionSalesTrans rboSaleLines;
            RetailStoreTable storeTable;

            // For return order, takes the price inclusive flag from the original tax transaction.
            if (rboSaleLines.transactionTable().TaxCalculationType == TaxCalculationType::GTE)
            {
                RetailTransactionTaxTransGTE transTaxTransGTE;

                // GTE tax trans.
                select firstOnly IsIncludedInPrice from transTaxTransGTE
                    exists join rboSaleLines
                    where rboSaleLines.RecId == _itemInfo.RecId
                        && transTaxTransGTE.Channel == rboSaleLines.Channel
                        && transTaxTransGTE.TransactionId == rboSaleLines.returnTransactionId
                        && transTaxTransGTE.StoreId == rboSaleLines.returnStore
                        && transTaxTransGTE.TerminalId == rboSaleLines.returnTerminalId
                        && transTaxTransGTE.SaleLineNum == rboSaleLines.returnLineNum
                    exists join storeTable
                    where storeTable.StoreNumber == rboSaleLines.returnStore
                        && transTaxTransGTE.Channel == storeTable.RecId;

                if (transTaxTransGTE.rowCount() > 0)
                {
                    transTaxInformation.InclTax = transTaxTransGTE.IsIncludedInPrice;
                }
            }
            else
            {
                RetailTransactionTaxTrans transTaxTrans;

                // GTE tax trans.
                select firstOnly IsIncludedInPrice from transTaxTrans
                    exists join rboSaleLines
                    where rboSaleLines.RecId == _itemInfo.RecId
                        && transTaxTrans.Channel == rboSaleLines.Channel
                        && transTaxTrans.TransactionId == rboSaleLines.returnTransactionId
                        && transTaxTrans.StoreId == rboSaleLines.returnStore
                        && transTaxTrans.TerminalId == rboSaleLines.returnTerminalId
                        && transTaxTrans.SaleLineNum == rboSaleLines.returnLineNum
                    exists join storeTable
                    where storeTable.StoreNumber == rboSaleLines.returnStore
                        && transTaxTrans.Channel == storeTable.RecId;

                if (transTaxTrans.rowCount() > 0)
                {
                    transTaxInformation.InclTax = transTaxTrans.IsIncludedInPrice;
                }
            }
        }

        transTaxInformation.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerTaxInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set customer tax information for line tax information.
    /// </summary>
    /// <param name = "_transTaxInformation">Transaction tax information.</param>
    /// <param name = "_salesTable">Sales table.</param>
    /// <param name = "_salesLine">Sales line.</param>
    /// <param name = "_retailStoreTable">Retail store table.</param>
    /// <param name = "_retailTransactionAdditionalAddressTransContract">Retail aditional address contract.</param>
    private static void setCustomerTaxInformation(TransTaxInformation _transTaxInformation, SalesTable _salesTable, SalesLine _salesLine, RetailChannelTable _retailStoreTable, RetailTransactionAdditionalAddressTransContract _retailTransactionAdditionalAddressTransContract)
    {
        if (FeatureStateProvider::isFeatureEnabled(RetailGSTInvoiceAddressTaxCalculationFeature_IN::instance()) && _retailTransactionAdditionalAddressTransContract)
        {
            RetailTransactionServiceOrders::setCustomerTaxInformationInvoiceAddress(_transTaxInformation, _salesTable, _retailTransactionAdditionalAddressTransContract);
        }
        else
        {
            RetailTransactionServiceOrders::setCustomerTaxInformationShippingAddress(_transTaxInformation, _salesTable, _salesLine, _retailStoreTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerTaxInformationShippingAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set customer tax information for line tax information based on shipping address.
    /// </summary>
    /// <param name = "_transTaxInformation">Transaction tax information.</param>
    /// <param name = "_salesTable">Sales table.</param>
    /// <param name = "_salesLine">Sales line.</param>
    /// <param name = "_retailStoreTable">Retail store table.</param>
    private static void setCustomerTaxInformationShippingAddress(TransTaxInformation _transTaxInformation, SalesTable _salesTable, SalesLine _salesLine, RetailChannelTable _retailStoreTable)
    {
        boolean isLegalEntity;
        LogisticsLocationRecId primaryCustomerLocation;
        TaxInformationRefRecId_IN primaryCustomerTaxInformation;
        boolean isCustomerOrder;
        boolean isPickupLine;
        RetailSalesTable retailSalesTable = _salesTable.retailSalesTable();
        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(retailSalesTable.RetailChannel);
        boolean isOnlineStore = retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore ||
                           retailChannelTable.ChannelType == RetailChannelType::OnlineStore;

        if (_salesTable.CustAccount)
        {
            boolean isRetailStoreDefaultCustomer = _salesTable.CustAccount == _retailStoreTable.DefaultCustAccount;
            boolean isOnlineStoreDefaultCustomer = _salesTable.CustAccount == retailChannelTable.DefaultCustAccount;

            if ((!isRetailStoreDefaultCustomer && !isOnlineStore) || (!isOnlineStoreDefaultCustomer && isOnlineStore))
            {
                CustTable custTable = CustTable::find(_salesTable.CustAccount);
                RetailOrderHeaderExtensionMap orderHeaderExt = _salesTable.RetailOrderHeaderMap::getRetailExtension();
                isCustomerOrder = !orderHeaderExt.StatementId;

                if (isCustomerOrder)
                {
                    isPickupLine = _salesLine.DlvMode && RetailDlvMode::isPickupDeliveryMode(_salesLine.DlvMode);
                    RetailParameters retailParamsTable = RetailParameters::find();
                    boolean isCarryOutLine =  retailParamsTable.CarryOutDeliveryModeCode && _salesLine.DlvMode == retailParamsTable.CarryOutDeliveryModeCode;

                    if (!isPickupLine)
                    {
                        //For customer order shipment first try to get customer tax information from line delivery address
                        primaryCustomerLocation = LogisticsPostalAddress::getLocation(_salesLine.DeliveryPostalAddress);
                        primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;

                        if (!primaryCustomerTaxInformation)
                        {
                            //If sales line delivery address does not contain tax information then try to get it from customer default delivery location
                            LogisticsLocationDefault custDefaultLocations = LogisticsLocationDefault::construct(custTable);
                            if (custDefaultLocations.defaultExistsByType(LogisticsLocationRoleType::Delivery))
                            {
                                primaryCustomerLocation = custDefaultLocations.getDefaultLocationByType(LogisticsLocationRoleType::Delivery).RecId;
                                primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;
                            }
                        }

                    }

                    if(!FeatureStateProvider::isFeatureEnabled(RetailG11NUsingCustomerAddressToDetermineGSTFeature_IN::instance()))
                    {
                        if(RetailCustomerLocationIsStoreLocationForPickUp_INFlight::instance().isEnabled()
                        && (isPickupLine || isCarryOutLine) && !isOnlineStore)
                        {
                            //if customer order is pickup or carry out, customer address should be stores's address.
                            primaryCustomerLocation = _transTaxInformation.CompanyLocation;
                            primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;
                        }
                    }

                }

                if (!primaryCustomerTaxInformation)
                {
                    //if no tax information found for delivery addresses try to get it from customer primary address.
                    DirPartyLocation dirPartyLocation = DirPartyLocation::findPrimaryPartyLocation(custTable.Party);
                    primaryCustomerLocation = LogisticsLocation::find(dirPartyLocation.Location).RecId;
                    primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;
                }

            }
            else if (isOnlineStoreDefaultCustomer && isOnlineStore)
            {
                //For customer order shipment first try to get customer tax information from line delivery address
                primaryCustomerLocation = LogisticsPostalAddress::getLocation(_salesLine.DeliveryPostalAddress);
                primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;
            }
        }

        if (RetailPreventRedefinitionCustomerLocationWithoutTaxInformation_INFlight::instance().isEnabled())
        {
            isPickupLine = _salesLine.DlvMode && RetailDlvMode::isPickupDeliveryMode(_salesLine.DlvMode);
            RetailOrderHeaderExtensionMap orderHeaderExt = _salesTable.RetailOrderHeaderMap::getRetailExtension();
            isCustomerOrder = !orderHeaderExt.StatementId;

            if (!primaryCustomerTaxInformation && !isOnlineStore && (!isCustomerOrder || isPickupLine))
            {
                // Customer location should be equal to store location for customers without tax information or store customer.
                primaryCustomerLocation = _transTaxInformation.CompanyLocation;
            }
            else if (!primaryCustomerLocation)
            {
                // Customer location should be equal to store location when primaryCustomerLocation is empty
                primaryCustomerLocation = _transTaxInformation.CompanyLocation;
            }
        }
        else
        {
            if (!primaryCustomerTaxInformation && !isOnlineStore)
            {
                // Customer location should be equal to store location for customers without tax information or store customer.
                primaryCustomerLocation = _transTaxInformation.CompanyLocation;
            }
            else if (!primaryCustomerLocation && isOnlineStore)
            {
                // Customer location should be equal to store location for customers without tax information or store customer.
                primaryCustomerLocation = _transTaxInformation.CompanyLocation;
            }
        }

        _transTaxInformation.CustomerTaxInformation = primaryCustomerTaxInformation;
        _transTaxInformation.CustomerLocation = primaryCustomerLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerTaxInformationInvoiceAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set customer tax information for line tax information based on invoice address.
    /// </summary>
    /// <param name = "_transTaxInformation">Transaction tax information.</param>
    /// <param name = "_salesTable">Sales table.</param>
    /// <param name = "_retailTransactionAdditionalAddressTransContract">Retail aditional address.</param>
    private static void setCustomerTaxInformationInvoiceAddress(TransTaxInformation _transTaxInformation, SalesTable _salesTable, RetailTransactionAdditionalAddressTransContract _retailTransactionAdditionalAddressTransContract)
    {
        container roleContainer = [LogisticsLocationRole::findBytype(LogisticsLocationRoleType::OneTime).RecId];
        LogisticsPostalAddressRecId logisticsPostalAddressRecId = _retailTransactionAdditionalAddressTransContract.parmPostalAddressRecordId();

        if (!logisticsPostalAddressRecId)
        {
            logisticsPostalAddressRecId = RetailTransactionServiceOrders::createAddress(
                    _salesTable.InvoiceAccount,
                    _retailTransactionAdditionalAddressTransContract.parmDeliveryName(),
                    _retailTransactionAdditionalAddressTransContract.parmStreetNumber(),
                    _retailTransactionAdditionalAddressTransContract.parmStreet(),
                    _retailTransactionAdditionalAddressTransContract.parmCity(),
                    _retailTransactionAdditionalAddressTransContract.parmDistrictName(),
                    _retailTransactionAdditionalAddressTransContract.parmCounty(),
                    _retailTransactionAdditionalAddressTransContract.parmState(),
                    _retailTransactionAdditionalAddressTransContract.parmZipCode(),
                    _retailTransactionAdditionalAddressTransContract.parmCountryRegionId(),
                    _retailTransactionAdditionalAddressTransContract.parmPhone(),
                    _retailTransactionAdditionalAddressTransContract.parmEmail(),
                    _retailTransactionAdditionalAddressTransContract.parmBuildingCompliment(),
                    roleContainer,
                    true,
                    _retailTransactionAdditionalAddressTransContract.parmAttentionToAddressLine());
        }

        LogisticsPostalAddress logisticsPostalAddress = LogisticsPostalAddress::findRecId(logisticsPostalAddressRecId);

        LogisticsLocationRecId primaryCustomerLocation = logisticsPostalAddress.Location;
        TaxInformationRefRecId_IN primaryCustomerTaxInformation = TaxInformation_IN::findDefaultbyLocation(primaryCustomerLocation).RecId;

        _transTaxInformation.CustomerTaxInformation = primaryCustomerTaxInformation;
        _transTaxInformation.CustomerLocation = primaryCustomerLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates packing slip for the customer order.
    /// </summary>
    /// <param name="_salesId">
    /// Identification of the sales order.
    /// </param>
    /// <returns>
    /// A Container with the status of pack slip creation.
    /// </returns>
    public static container packingSlipForCustomerOrder(SalesId _salesId)
    {
        container          printSuccess = [true,''];
        SalesTable         salesTable;
        SalesFormLetter salesFormLetter;

        salesTable = SalesTable::find(_salesId);
        if (salesTable)
        {
            salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);
            salesFormLetter.reArrangeNow(false);
            salesFormLetter.update(salesTable,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),SalesUpdate::DeliverNow, AccountOrder::None,false,false,false);
            eventSource.EventWriteOrdersPackingSlipForCustomerOrderCreatedSuccessful(funcName(), salesTable.RecId);
        }
        else
        {
            printSuccess = [false,strFmt("@RET4513",_salesId)];
            eventSource.EventWriteOrdersPackingSlipForCustomerOrderNotFoundError(funcName());
        }

        return printSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentToStr</Name>
				<Source><![CDATA[
    private static str percentToStr(Percent _percent)
    {
        return num2str(_percent,5,2,1,0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAttributesForChargeElement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets attributes for the Charge Element in the Sales Invoice for Line and Header Charges
    /// </summary>
    /// <param name = "_xmlRecord">XML record to populate.</param>
    /// <param name = "_markupTable">Mark up table with information of the charge.</param>
    /// <param name = "_markupTrans">Mark up trans with inforamtion of the charge.</param>
    /// <param name = "_amountChargesRefunded">Amount already refunded for the specific charge.</param>
    /// <param name = "_includeTaxGroup">Include tax group or not.</param>
    private static void setAttributesForChargeElement(
        XmlElement _xmlRecord,
        MarkupTable _markupTable,
        MarkUpTrans _markupTrans,
        real _amountChargesRefunded,
        boolean _includeTaxGroup)
    {
        real amountCharges = _markupTrans.Value;

        if (RetailOrdersFeatureControl::allowNegativeAutoChargesOnRetunOrderFeatureEnabled())
        {
            real newAmountCharges = amountCharges < 0 ? amountCharges + abs(_amountChargesRefunded) : amountCharges - abs(_amountChargesRefunded);

            if (sign(amountCharges) != sign(newAmountCharges))
            {
                newAmountCharges = 0;
            }
            amountCharges = newAmountCharges;
        }
        else
        {
            amountCharges = amountCharges - abs(_amountChargesRefunded);

            if (amountCharges < 0)
            {
                amountCharges = 0;
            }
        }

        if (_markupTable.VendType == MarkupType::CustVend)
        {
            _xmlRecord.setAttribute(AmountStr,num2str(-_markupTrans.Value,5,3,1,0));
            _xmlRecord.setAttribute(AmountRefundedStr,num2str(-_amountChargesRefunded,5,3,1,0));
            _xmlRecord.setAttribute(AmountLeftToRefundStr,num2str(-amountCharges,5,3,1,0));
        }
        else
        {
            _xmlRecord.setAttribute(AmountStr,num2str(_markupTrans.Value,5,3,1,0));
            _xmlRecord.setAttribute(AmountRefundedStr,num2str(_amountChargesRefunded,5,3,1,0));
            _xmlRecord.setAttribute(AmountLeftToRefundStr,num2str(amountCharges,5,3,1,0));
        }

        _xmlRecord.setAttribute(CodeStr, _markupTrans.MarkupCode);
        _xmlRecord.setAttribute(CurrencyCodeStr, _markupTrans.CurrencyCode);
        _xmlRecord.setAttribute(ModuleTypeStr, int2Str(enum2int(_markupTrans.ModuleType)));
        _xmlRecord.setAttribute(ModuleTypeValueStr, int2Str(enum2int(_markupTrans.ModuleType)));

        var chargeType = RetailTransactionServiceOrders::getChargeType(_markupTrans);
        _xmlRecord.setAttribute(ChargeTypeStr, enum2Str(chargeType));
        _xmlRecord.setAttribute(DescriptionStr, _markupTrans.Txt);
        _xmlRecord.setAttribute(MarkupAutoTableRecIdStr, int642Str(_markupTrans.MarkupAutoTableRecId));
        _xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(_markupTrans.TaxExemptPriceInclusiveOriginalPrice));
        _xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(_markupTrans.TaxExemptPriceInclusiveReductionAmount));

        if (_includeTaxGroup)
        {
            _xmlRecord.setAttribute(TaxGroupStr, _markupTrans.TaxGroup);
            _xmlRecord.setAttribute(TaxItemGroupStr, _markupTrans.TaxItemGroup);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && _markupTrans.TransTableId != tableNum(CustInvoiceJour))
        {
            TransTaxInformation markupTransTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_markupTrans);
            HSNCodeTable_IN hsnCodeTable_IN = HSNCodeTable_IN::find(markupTransTaxInformation.HSNCodeTable);
            ServiceAccountingCodeTable_IN serviceAccountingCodeTable_IN = ServiceAccountingCodeTable_IN::find(markupTransTaxInformation.ServiceAccountingCodeTable);

            _xmlRecord.setAttribute('HSNCode', hsnCodeTable_IN.Code);
            _xmlRecord.setAttribute('ServiceAccountingCode', serviceAccountingCodeTable_IN.SAC);
            _xmlRecord.setAttribute('Exempt', int2str(markupTransTaxInformation.Exempt));
            _xmlRecord.setAttribute('ITCCategory', int2str(markupTransTaxInformation.ITCCategory));
            _xmlRecord.setAttribute('ServiceCategory', int2str(markupTransTaxInformation.ServiceCategory));
        }

        _xmlRecord.setAttribute(CalculatedProratedAmountStr, RetailTransactionServiceOrders::amountToStr(_markupTrans.CalculatedProratedAmount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeaderAutoCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets header level auto charges aggregated by Business Key (MarkupCode, ModuleType, TaxGroup, TaxItemGroup)
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record.</param>
    /// <param name = "_transTableRecId">The transaction table record.</param>
    /// <param name = "_transSalesId">The transaction sales id.</param>
    /// <returns>New XmlElement that contains charges.</returns>
    private static XmlElement setHeaderAutoCharges(
        XmlDocument _xmlDoc,
        RecId _transRecId,
        RecId _transTableRecId,
        boolean _includeTaxGroup = true,
        SalesId _transSalesId = '')
    {
        InventTransOrigin inventTransOrigin;
        SalesLine salesLineReturn;
        CustInvoiceJour custInvoiceJour;
        MarkUpTrans returnedMarkupTrans;
        MarkupTrans markupTrans;
        MarkupTable markupTable;
        XmlElement xmlCharges, xmlRecord;
        real amountChargesRefunded = 0;

        xmlCharges = _xmldoc.createElement('Charges');
        // Selecting sum of charges in same business key (MarkupCode, ModuleType, TaxGroup, TaxItemGroup)
        while select TransRecId, TransTableId, sum(Value), sum(TaxExemptPriceInclusiveOriginalPrice), sum(TaxExemptPriceInclusiveReductionAmount), MarkupCode, ModuleType, TaxGroup, TaxItemGroup, CurrencyCode from markupTrans
            group by markupTrans.MarkupCode, markupTrans.ModuleType, markupTrans.TaxGroup, markupTrans.TaxItemGroup, markupTrans.CurrencyCode, markupTrans.CalculatedProratedAmount
            where markupTrans.TransRecId == _transRecId
                && markupTrans.TransTableId == _transTableRecId
            join VendType from markupTable
                where markupTable.MarkupCode == markupTrans.MarkupCode
                    && markupTable.ModuleType == markupTrans.ModuleType
                    && markupTable.Refundable == true
        {
            xmlRecord = _xmldoc.createElement('Charge');

            if (_transSalesId != '')
            {

                // Getting sum of how much has already been refunded (tax inclusive) for a business key in the salesid
                select sum(Value) from returnedMarkupTrans
                where returnedMarkupTrans.MarkupCode == markupTrans.MarkupCode
                    && returnedMarkupTrans.ModuleType == markupTrans.ModuleType
                    && returnedMarkupTrans.TaxGroup == markupTrans.TaxGroup
                    && returnedMarkupTrans.TaxItemGroup == markupTrans.TaxItemGroup
                exists join custInvoiceJour
                    where returnedMarkupTrans.TransRecId == custInvoiceJour.RecId
                    && returnedMarkupTrans.TransTableId == tableNum(CustInvoiceJour)
                exists join salesLineReturn
                    where custInvoiceJour.SalesId == salesLineReturn.Salesid
                exists join inventTransOrigin
                    where salesLineReturn.InventTransIdReturn == inventTransOrigin.InventTransId
                    && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    && inventTransOrigin.ReferenceId == _transSalesId;

                amountChargesRefunded = returnedMarkupTrans.Value;
            }

            RetailTransactionServiceOrders::setAttributesForChargeElement(xmlRecord, markupTable, markupTrans, amountChargesRefunded, _includeTaxGroup);
            RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, true);
            xmlCharges.appendChild(xmlRecord);
        }

        return xmlCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeaderCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets header level charges.
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record.</param>
    /// <param name = "_transTableRecId">The transaction table record.</param>
    /// <param name = "_transSalesId">The transaction sales id.</param>
    /// <returns>New XmlElement that contains charges.</returns>
    private static XmlElement setHeaderCharges(XmlDocument _xmlDoc, RecId _transRecId, RecId _transTableRecId, boolean _includeTaxGroup = true, SalesId _transSalesId = '')
    {
        MarkupTrans markupTrans;
        MarkupTable markupTable;
        MarkupCode shippingChargeCode = RetailParameters::find().ShippingChargeCode;
        CustInvoiceJour custInvoiceJour;
        XmlElement xmlCharges, xmlRecord;
        real amountChargesRefunded = 0;

        if (_transSalesId != '')
        {
            InventTransOrigin inventTransOrigin;
            SalesLine salesLineReturn;
            MarkUpTrans markUpTransCharges;

            // Getting sum of how much has already been refunded for a salesId
            select sum(calculatedAmount) from markupTransCharges
                exists join custInvoiceJour
                    where markupTransCharges.TransRecId == custInvoiceJour.RecId
                    && markupTransCharges.TransTableId == tableNum(custInvoiceJour)
                    && markupTransCharges.MarkupCategory == MarkupCategory::Fixed
                exists join salesLineReturn
                    where custInvoiceJour.SalesId == salesLineReturn.Salesid
                exists join inventTransOrigin
                    where salesLineReturn.InventTransIdReturn == inventTransOrigin.InventTransId
                    && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    && inventTransOrigin.ReferenceId == _transSalesId
                exists join CustType, VendType from markupTable
                    where markupTable.MarkupCode == markUpTransCharges.MarkupCode
                    && markupTable.ModuleType == markUpTransCharges.ModuleType
                    && !(markupTable.CustType == MarkupType::LedgerAccount
                        && markupTable.VendType == MarkupType::LedgerAccount);

            amountChargesRefunded = markupTransCharges.calculatedAmount;
        }

        xmlCharges = _xmldoc.createElement('Charges');
        while select * from markupTrans
            where markupTrans.TransRecId == _transRecId
                && ( _transTableRecId == 0 || markupTrans.TransTableId == _transTableRecId)
                && markupTrans.MarkupCategory == MarkupCategory::Fixed
            join CustType, VendType from markupTable
                where markupTable.MarkupCode == markupTrans.MarkupCode
                    && markupTable.ModuleType == markupTrans.ModuleType
                    && !(markupTable.CustType == MarkupType::LedgerAccount
                        && markupTable.VendType == MarkupType::LedgerAccount)
        {
            xmlRecord = _xmldoc.createElement('Charge');

            real amountCharges = markupTrans.Value;

            if (markupTrans.MarkupCode == shippingChargeCode)
            {
                amountCharges = amountCharges - abs(amountChargesRefunded);

                if (amountCharges < 0)
                {
                    amountCharges = 0;
                }
            }

            if (markupTable.VendType == MarkupType::CustVend)
            {
                xmlRecord.setAttribute(AmountStr,num2str(-amountCharges,5,3,1,0));
            }
            else
            {
                xmlRecord.setAttribute(AmountStr,num2str(amountCharges,5,3,1,0));
            }

            xmlRecord.setAttribute(CodeStr, markupTrans.MarkupCode);

            if (_includeTaxGroup)
            {
                xmlRecord.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
                xmlRecord.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);
            }

            var chargeType = RetailTransactionServiceOrders::getChargeType(markupTrans);
            xmlRecord.setAttribute(ChargeTypeStr, enum2Str(chargeType));
            xmlRecord.setAttribute(DescriptionStr, markupTrans.Txt);
            xmlRecord.setAttribute(MarkupAutoTableRecIdStr, int642Str(markupTrans.MarkupAutoTableRecId));
            xmlRecord.setAttribute(MarkupAutoLineRecIdStr, int642Str(markupTrans.MarkupAutoLineRecId));
            xmlRecord.setAttribute(IsOverriddenLineStr, int2Str(enum2Int(markupTrans.IsOverriddenLine)));
            xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveOriginalPrice));
            xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveReductionAmount));
            xmlRecord.setAttribute(ModuleTypeValueStr, int2Str(enum2int(markupTrans.ModuleType)));
            xmlRecord.setAttribute(CalculatedProratedAmountStr, RetailTransactionServiceOrders::amountToStr(markupTrans.CalculatedProratedAmount));

            RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, true);

            xmlCharges.appendChild(xmlRecord);
        }

        boolean allowPartialOrderEditingFeatureEnabled = RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement();
        boolean disablePopulateInvoicedHeaderAutoCharge = Global::isFlightEnabled("RetailChargeDoNotPopulateInvoicedHeaderAutoCharge");
        if (allowPartialOrderEditingFeatureEnabled && !disablePopulateInvoicedHeaderAutoCharge)
        {
            if (RetailChargeFilterCustInvoiceJourWhenPopulateInvoicedChargeFlight::instance().isEnabled())
            {
                while select * from markupTrans
                    where markupTrans.MCRSavedRecID == _transRecId
                        && ( _transTableRecId == 0 || markupTrans.MCRSavedTableID == _transTableRecId)
                        && markupTrans.TransTableId == tableNum(custInvoiceJour)
                        && markupTrans.MarkupCategory == MarkupCategory::Fixed
                    join CustType, VendType from markupTable
                        where markupTable.MarkupCode == markupTrans.MarkupCode
                            && markupTable.ModuleType == markupTrans.ModuleType
                            && !(markupTable.CustType == MarkupType::LedgerAccount
                            && markupTable.VendType == MarkupType::LedgerAccount)
                {
                    xmlRecord = _xmldoc.createElement('Charge');

                    real amountCharges = markupTrans.Value;

                    if (markupTrans.MarkupCode == shippingChargeCode)
                    {
                        // handle negative charges as 0.
                        if (amountCharges < 0)
                        {
                            amountCharges = 0;
                        }
                    }

                    if (markupTable.VendType == MarkupType::CustVend)
                    {
                        xmlRecord.setAttribute(AmountStr,num2str(-amountCharges,5,3,1,0));
                    }
                    else
                    {
                        xmlRecord.setAttribute(AmountStr,num2str(amountCharges,5,3,1,0));
                    }

                    xmlRecord.setAttribute(CodeStr, markupTrans.MarkupCode);

                    if (_includeTaxGroup)
                    {
                        xmlRecord.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
                        xmlRecord.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);
                    }

                    var chargeType = RetailTransactionServiceOrders::getChargeType(markupTrans);
                    xmlRecord.setAttribute(ChargeTypeStr, enum2Str(chargeType));
                    xmlRecord.setAttribute(DescriptionStr, markupTrans.Txt);
                    xmlRecord.setAttribute(MarkupAutoTableRecIdStr, int642Str(markupTrans.MarkupAutoTableRecId));
                    xmlRecord.setAttribute(MarkupAutoLineRecIdStr, int642Str(markupTrans.MarkupAutoLineRecId));
                    xmlRecord.setAttribute(IsOverriddenLineStr, int2Str(enum2Int(markupTrans.IsOverriddenLine)));
                    xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveOriginalPrice));
                    xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveReductionAmount));
                    xmlRecord.setAttribute(ModuleTypeValueStr, int2Str(enum2int(markupTrans.ModuleType)));
                    xmlRecord.setAttribute(CalculatedProratedAmountStr, RetailTransactionServiceOrders::amountToStr(markupTrans.CalculatedProratedAmount));

                    RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, true);
                    xmlRecord.setAttribute(IsInvoicedStr, enum2Str(true));

                    xmlCharges.appendChild(xmlRecord);
                }
            }
            else
            {
                while select * from markupTrans
                where markupTrans.MCRSavedRecID == _transRecId
                    && ( _transTableRecId == 0 || markupTrans.MCRSavedTableID == _transTableRecId)
                    && markupTrans.MarkupCategory == MarkupCategory::Fixed
                join CustType, VendType from markupTable
                    where markupTable.MarkupCode == markupTrans.MarkupCode
                        && markupTable.ModuleType == markupTrans.ModuleType
                        && !(markupTable.CustType == MarkupType::LedgerAccount
                        && markupTable.VendType == MarkupType::LedgerAccount)
                {
                    xmlRecord = _xmldoc.createElement('Charge');

                    real amountCharges = markupTrans.Value;

                    if (markupTrans.MarkupCode == shippingChargeCode)
                    {
                        // handle negative charges as 0.
                        if (amountCharges < 0)
                        {
                            amountCharges = 0;
                        }
                    }

                    if (markupTable.VendType == MarkupType::CustVend)
                    {
                        xmlRecord.setAttribute(AmountStr,num2str(-amountCharges,5,3,1,0));
                    }
                    else
                    {
                        xmlRecord.setAttribute(AmountStr,num2str(amountCharges,5,3,1,0));
                    }

                    xmlRecord.setAttribute(CodeStr, markupTrans.MarkupCode);

                    if (_includeTaxGroup)
                    {
                        xmlRecord.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
                        xmlRecord.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);
                    }

                    var chargeType = RetailTransactionServiceOrders::getChargeType(markupTrans);
                    xmlRecord.setAttribute(ChargeTypeStr, enum2Str(chargeType));
                    xmlRecord.setAttribute(DescriptionStr, markupTrans.Txt);
                    xmlRecord.setAttribute(MarkupAutoTableRecIdStr, int642Str(markupTrans.MarkupAutoTableRecId));
                    xmlRecord.setAttribute(MarkupAutoLineRecIdStr, int642Str(markupTrans.MarkupAutoLineRecId));
                    xmlRecord.setAttribute(IsOverriddenLineStr, int2Str(enum2Int(markupTrans.IsOverriddenLine)));
                    xmlRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveOriginalPrice));
                    xmlRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveReductionAmount));
                    xmlRecord.setAttribute(ModuleTypeValueStr, int2Str(enum2int(markupTrans.ModuleType)));
                    xmlRecord.setAttribute(CalculatedProratedAmountStr, RetailTransactionServiceOrders::amountToStr(markupTrans.CalculatedProratedAmount));

                    RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, true);
                    xmlRecord.setAttribute(IsInvoicedStr, enum2Str(true));

                    xmlCharges.appendChild(xmlRecord);
                }
            }
        }

        return xmlCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeaderDepositOverridenXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets header level PrepaymentAmountOverridden property.
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_parentElement">The parent element to be appended.</param>
    /// <param name = "_salesTable">The SalesTable record.</param>
    private static void setHeaderDepositOverridenXml(XmlDocument _xmlDoc, XmlElement _parentElement, SalesTable _salesTable)
    {
        RetailSalesTable retailSalesTable = _salesTable.retailSalesTable();

        XmlElement xmlNode = _xmldoc.createElement('PrepaymentAmountOverridden');

        if (retailSalesTable.RetailPrepaymentOverridden == NoYes::Yes)
        {
            xmlNode.innerText(TrueStr);
        }
        else
        {
            if (_salesTable.mcrIsCallCenter())
            {
                // If order completion is enabled, ALWAYS consider the deposit as overridden to prevent POS from auto-calculating it;
                // Otherwise, deposit can be calculated.
                RetailMCRChannelTable mcrChannelTable = RetailMCRChannelTable::findRecId(retailSalesTable.RetailChannel);
                xmlNode.innerText((mcrChannelTable && mcrChannelTable.mcrEnableOrderCompletion == NoYes::Yes) ? TrueStr : FalseStr);
            }
            else
            {
                xmlNode.innerText(FalseStr);
            }
        }

        _parentElement.appendChild(xmlNode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeaderInfocodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets header infocode lines.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record ID.</param>
    /// <returns>The XMLElement containing the infocode lines.</returns>
    private static XmlElement setHeaderInfocodeLines(XmlDocument _xmlDoc, RecId _transRecId, RetailInfoCodeLineRelatedTableType _tableType)
    {
        RetailInfocodeLineV2 infoCodeLineV2;

        XmlElement xmlReasonCodeLines = _xmlDoc.createElement('ReasonCodeLines');

        if (RetailInfoCodeLineTableV2Feature::isEnabled())
        {
            infoCodeLineV2 = RetailInfocodeLineV2::findAnyLine(_transRecId, _transRecId, _tableType, RetailInfocodeTransType::Header);
            if (infoCodeLineV2.RecId)
            {
                RetailTransactionServiceOrders::setInfoCodeLinesV2(_xmlDoc, xmlReasonCodeLines, _transRecId, _transRecId, RetailInfocodeTransType::Header, _tableType);
            }
            else
            {
                RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _transRecId, RetailInfocodeTransType::Header);
            }
        }
        else
        {
            RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _transRecId, RetailInfocodeTransType::Header);
        }

        return xmlReasonCodeLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesLineInfocodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the sales line infocode lines.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record ID.</param>
    /// <param name = "_parentRecId">The sales line record ID.</param>
    /// <returns>The XMLElement containing the sales line infocode lines.</returns>
    private static XmlElement setSalesLineInfocodeLines(XmlDocument _xmlDoc, RecId _transRecId, RecId _parentRecId, RetailInfoCodeLineRelatedTableType _tableType)
    {
        RetailInfocodeLineV2 infoCodeLineV2;

        XmlElement xmlReasonCodeLines = _xmlDoc.createElement('ReasonCodeLines');

        if (RetailInfoCodeLineTableV2Feature::isEnabled())
        {
            infoCodeLineV2 = RetailInfocodeLineV2::findAnyLine(_transRecId, _parentRecId, _tableType, RetailInfocodeTransType::Sales);
            if (infoCodeLineV2.RecId)
            {
                RetailTransactionServiceOrders::setInfoCodeLinesV2(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Sales, _tableType);
            }
            else
            {
                RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Sales);
            }
        }
        else
        {
            RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Sales);
        }

        return xmlReasonCodeLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTenderLineInfocodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the tender line infocode lines.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record ID.</param>
    /// <param name = "_parentRecId">The tender line record ID.</param>
    /// <returns>The XMLElement containing the sales line infocode lines.</returns>
    private static XmlElement setTenderLineInfocodeLines(XmlDocument _xmlDoc, RecId _transRecId, RecId _parentRecId, RetailInfoCodeLineRelatedTableType _tableType)
    {
        RetailInfocodeLineV2 infoCodeLineV2;

        XmlElement xmlReasonCodeLines = _xmlDoc.createElement('ReasonCodeLines');

        if (RetailInfoCodeLineTableV2Feature::isEnabled())
        {
            infoCodeLineV2 = RetailInfocodeLineV2::findAnyLine(_transRecId, _parentRecId, _tableType, RetailInfocodeTransType::Payment);
            if (infoCodeLineV2.RecId)
            {
                RetailTransactionServiceOrders::setInfoCodeLinesV2(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Payment, _tableType);
            }
            else
            {
                RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Payment);
            }
        }
        else
        {
            RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Payment);
        }

        return xmlReasonCodeLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAffiliationLineInfoCodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the info code lines on affiliations.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record ID to find affiliation reason codes for.</param>
    /// <returns>The xml containing the affiliation line info code lines.</returns>
    public static XmlElement setAffiliationLineInfoCodeLines(XmlDocument _xmlDoc, RecId _transRecId)
    {
        RetailInfocodeLine infoCodeLine;
        RefRecId affRecId;
        RetailTransactionServiceOrdersContext context = RetailTransactionServiceOrdersContext::current();
        if (context != null && context.parmAffiliationRecordId())
        {
            affRecId = context.parmAffiliationRecordId();
        }

        XmlElement xmlReasonCodeLines = _xmlDoc.createElement('ReasonCodeLines');

        if (RetailFilterInfoCodesByAffiliationFlight::instance().isEnabled())
        {
           while select SalesTable, Amount, InfocodeId, Information, InformationAmount,
              InputType, ItemTender, LineNum, Type, SourceCode, SourceCode2, SourceCode3,
              StatementCode, SubInfocodeId from infoCodeLine
                order by LineNum asc
                where infoCodeLine.SalesTable == _transRecId
                    && infoCodeLine.parentRecId == affRecId
                    && infoCodeLine.Type == RetailInfocodeTransType::Affiliation
          {
            xmlReasonCodeLines.appendChild(RetailTransactionServiceOrders::createReasonCodeLine(_xmlDoc, infoCodeLine));
          }
        }
        else{
             while select SalesTable, Amount, InfocodeId, Information, InformationAmount,
            InputType, ItemTender, LineNum, Type, SourceCode, SourceCode2, SourceCode3,
            StatementCode, SubInfocodeId from infoCodeLine
                order by LineNum asc
                where infoCodeLine.SalesTable == _transRecId
                    && infoCodeLine.Type == RetailInfocodeTransType::Affiliation
        {
            xmlReasonCodeLines.appendChild(RetailTransactionServiceOrders::createReasonCodeLine(_xmlDoc, infoCodeLine));
        }
    }

        return xmlReasonCodeLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAffiliationLineInfoCodeLinesV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the info code lines on affiliations.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "_transRecId">The transaction record ID to find affiliation reason codes for.</param>
    /// <param name = "_parentRecId">The tender line record ID.</param>
    /// <param name = "_tableType">The table type to find affiliation reason codes for.</param>
    /// <returns>The xml containing the affiliation line info code lines.</returns>
    public static XmlElement setAffiliationLineInfoCodeLinesV2(XmlDocument _xmlDoc, RecId _transRecId, RecId _parentRecId, RetailInfoCodeLineRelatedTableType _tableType)
    {
        RetailInfocodeLineV2 infoCodeLineV2;

        XmlElement xmlReasonCodeLines = _xmlDoc.createElement('ReasonCodeLines');

        if (RetailInfoCodeLineTableV2Feature::isEnabled())
        {
            infoCodeLineV2 = RetailInfocodeLineV2::findAnyLine(_transRecId, _parentRecId, _tableType, RetailInfocodeTransType::Affiliation);
            if (infoCodeLineV2.RecId)
            {
                RetailTransactionServiceOrders::setInfoCodeLinesV2(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Affiliation, _tableType);
            }
            else
            {
                RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Affiliation);
            }
        }
        else
        {
            RetailTransactionServiceOrders::setInfoCodeLines(_xmlDoc, xmlReasonCodeLines, _transRecId, _parentRecId, RetailInfocodeTransType::Affiliation);
        }

        return xmlReasonCodeLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInfoCodeLines</Name>
				<Source><![CDATA[
    private static void setInfoCodeLines(XmlDocument _xmlDoc, XmlElement _xmlReasonCodeLines, RecId _transRecId, RecId _parentRecId, RetailInfocodeTransType _transType)
    {
        RetailInfocodeLine infoCodeLine;

        while select SalesTable, Amount, InfocodeId, Information, InformationAmount,
            InputType, ItemTender, LineNum, Type, ParentRecId, SourceCode, SourceCode2, SourceCode3,
            StatementCode, SubInfocodeId from infoCodeLine
                order by LineNum asc
                where infoCodeLine.SalesTable == _transRecId
                    && infoCodeLine.ParentRecId == _parentRecId
                    && infoCodeLine.Type == _transType
        {
            _xmlReasonCodeLines.appendChild(RetailTransactionServiceOrders::createReasonCodeLine(_xmlDoc, infoCodeLine));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInfoCodeLinesV2</Name>
				<Source><![CDATA[
    private static void setInfoCodeLinesV2(XmlDocument _xmlDoc, XmlElement _xmlReasonCodeLines, RecId _transRecId, RecId _parentRecId, RetailInfocodeTransType _transType, RetailInfoCodeLineRelatedTableType _tableType)
    {
        RetailInfocodeLineV2 infoCodeLineV2;

        while select SalesTable, Amount, InfocodeId, Information, InformationAmount,
            InputType, ItemTender, LineNum, Type, ParentRecId, SourceCode, SourceCode2, SourceCode3,
            StatementCode, SubInfocodeId from infoCodeLineV2
                order by LineNum asc
                where infoCodeLineV2.SalesTable == _transRecId
                    && infoCodeLineV2.ParentRecId == _parentRecId
                    && infoCodeLineV2.Type == _transType
                    && infoCodeLineV2.TableType == _tableType
        {
            _xmlReasonCodeLines.appendChild(RetailTransactionServiceOrders::createReasonCodeLine(_xmlDoc, RetailInfocodeLineV2::convertToV1(infoCodeLineV2)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReasonCodeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an XMLElement containing an infocode line.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document to populate.</param>
    /// <param name = "infoCodeLine">The infocode line to be serialized into an XMLElement.</param>
    /// <returns>The XMLElement containing the infocode line.</returns>
    private static XmlElement createReasonCodeLine(XmlDocument _xmlDoc, RetailInfocodeLine infoCodeLine)
    {
        XmlElement xmlRecord = _xmldoc.createElement('ReasonCodeLine');
        xmlRecord.setAttribute('Amount', num2Str(infoCodeLine.Amount, 5, 4, 1, 0));
        xmlRecord.setAttribute('Information', infoCodeLine.Information);
        xmlRecord.setAttribute('InformationAmount', num2Str(infoCodeLine.InformationAmount, 5, 4, 1, 0));
        xmlRecord.setAttribute('InputTypeValue', int2Str(infoCodeLine.InputType));
        xmlRecord.setAttribute('ItemTender', infoCodeLine.ItemTender);
        xmlRecord.setAttribute('LineNum', RetailTransactionServiceUtilities::lineNumToString(infoCodeLine.LineNum));
        xmlRecord.setAttribute('LineTypeValue', int2Str(infoCodeLine.Type));
        xmlRecord.setAttribute('ReasonCodeId', infoCodeLine.InfocodeId);
        xmlRecord.setAttribute('SourceCode', infoCodeLine.SourceCode);
        xmlRecord.setAttribute('SourceCode2', infoCodeLine.SourceCode2);
        xmlRecord.setAttribute('SourceCode3', infoCodeLine.SourceCode3);
        xmlRecord.setAttribute('StatementCode', infoCodeLine.StatementCode);
        xmlRecord.setAttribute('SubReasonCodeId', infoCodeLine.SubInfocodeId);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineLevelAutoCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets line level auto charges aggregated by Business Key (MarkupCode, ModuleType, TaxGroup, TaxItemGroup).
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_xmlRecord">The xml record.</param>
    /// <param name = "_transRecId">The transaction record.</param>
    /// <param name = "_transTableRecId">The transaction table record.</param>
    private static void setLineLevelAutoCharges(
        XmlDocument _xmlDoc,
        XmlElement _xmlRecord,
        RecId _transRecId,
        RecId _transTableRecId,
        SalesId _transSalesId = '',
        LineNum _transLineNum = 0)
    {
        InventTransOrigin inventTransOrigin;
        SalesLine salesLineReturn;
        CustInvoiceTrans custInvoiceTrans;
        MarkUpTrans returnedMarkupTrans;
        MarkupTrans markupTrans;
        MarkupTable markupTable;
        XmlElement xmlLineCharges, xmlLineRecord;
        real amountChargesRefunded = 0;

        xmlLineCharges = _xmldoc.createElement('Charges');
        // Selecting sum of charges in same business key (MarkupCode, ModuleType, TaxGroup, TaxItemGroup)
        while select TransRecId, TransTableId, sum(Value), sum(TaxExemptPriceInclusiveOriginalPrice), sum(TaxExemptPriceInclusiveReductionAmount), MarkupCode, ModuleType, TaxGroup, TaxItemGroup, CurrencyCode, MarkupCategory from markupTrans
            group by markupTrans.MarkupCode, markupTrans.ModuleType, markupTrans.TaxGroup, markupTrans.TaxItemGroup, markupTrans.CurrencyCode, markupTrans.CalculatedProratedAmount
            where markupTrans.TransRecId == _transRecId
                && markupTrans.TransTableId == _transTableRecId
            join VendType from markupTable
                where markupTable.MarkupCode == markupTrans.MarkupCode
                    && markupTable.ModuleType == markupTrans.ModuleType
                    && markupTable.Refundable == true
        {
            xmlLineRecord = _xmldoc.createElement('Charge');

            if (_transSalesId != '')
            {
                // Getting sum of how much has already been refunded (tax inclusive) for a business key in a salesline
                select sum(Value) from returnedMarkupTrans
                    where returnedMarkupTrans.MarkupCode == markupTrans.MarkupCode
                    && returnedMarkupTrans.ModuleType == markupTrans.ModuleType
                    && returnedMarkupTrans.TaxGroup == markupTrans.TaxGroup
                    && returnedMarkupTrans.TaxItemGroup == markupTrans.TaxItemGroup
                exists join custInvoiceTrans
                    where custInvoiceTrans.LineNum == _transLineNum
                    && returnedMarkupTrans.TransRecId == custInvoiceTrans.RecId
                    && returnedMarkupTrans.TransTableId == tableNum(CustInvoiceTrans)
                exists join salesLineReturn
                    where custInvoiceTrans.SalesId == salesLineReturn.Salesid
                exists join inventTransOrigin
                    where salesLineReturn.InventTransIdReturn == inventTransOrigin.InventTransId
                    && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                    && inventTransOrigin.ReferenceId == _transSalesId;

                amountChargesRefunded = returnedMarkupTrans.Value;
            }

            RetailTransactionServiceOrders::setAttributesForChargeElement(xmlLineRecord, markupTable, markupTrans, amountChargesRefunded, true);
            RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlLineRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, false);

            xmlLineCharges.appendChild(xmlLineRecord);
        }

        _xmlRecord.appendChild(xmlLineCharges);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineLevelQuantities</Name>
				<Source><![CDATA[
    private static void setLineLevelQuantities(XmlDocument _xmlDoc, XmlElement _xmlRecord, RetailSalesLine _retailSalesLine, UnitOfMeasureSymbol _inventUnitOfMeasure, int _numberOfDecimals)
    {
        boolean isRetailFulfillmentQuantitiesInSalesUomFlightEnabled = RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled();
        XmlElement xmlLineQuantities = _xmldoc.createElement('InventoryQuantities');

        XmlElement unitOfMeasure = _xmlDoc.createElement('UnitOfMeasure');
        unitOfMeasure.innerText(_inventUnitOfMeasure);
        xmlLineQuantities.appendChild(unitOfMeasure);

        SalesLine soLine = SalesLine::findRecId(_retailSalesLine.SalesLine);

        XmlElement quantityNotProcessed = _xmlDoc.createElement('QuantityNotProcessed');

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            quantityNotProcessed.innerText(num2str(_retailSalesLine.getQuantityNotProcessedInSalesUnit(soLine), 5, _numberOfDecimals, 1, 0));
        }
        else
        {
            quantityNotProcessed.innerText(num2str(_retailSalesLine.QuantityNotProcessed, 5, _numberOfDecimals, 1, 0));
        }

        xmlLineQuantities.appendChild(quantityNotProcessed);

        XmlElement quantityReserved = _xmlDoc.createElement('QuantityReserved');

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            quantityReserved.innerText(num2str(_retailSalesLine.getQuantityPhysicallyReservedInSalesUnit(soLine), 5, _numberOfDecimals, 1, 0));
        }
        else
        {
            quantityReserved.innerText(num2str(_retailSalesLine.QuantityPhysicallyReserved, 5, _numberOfDecimals, 1, 0));
        }
        xmlLineQuantities.appendChild(quantityReserved);

        XmlElement quantityPicked = _xmlDoc.createElement('QuantityPicked');

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            quantityPicked.innerText(num2str(_retailSalesLine.getQuantityPickedInSalesUnit(soLine), 5, _numberOfDecimals, 1, 0));
        }
        else
        {
            quantityPicked.innerText(num2str(_retailSalesLine.QuantityPicked, 5, _numberOfDecimals, 1, 0));
        }
        xmlLineQuantities.appendChild(quantityPicked);

        XmlElement quantityPacked = _xmlDoc.createElement('QuantityPacked');

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            quantityPacked.innerText(num2str(_retailSalesLine.getQuantityPackedInSalesUnit(soLine), 5, _numberOfDecimals, 1, 0));
        }
        else
        {
            quantityPacked.innerText(num2str(_retailSalesLine.QuantityPacked,5,_numberOfDecimals,1,0));
        }
        xmlLineQuantities.appendChild(quantityPacked);

        XmlElement quantityInvoiced = _xmlDoc.createElement('QuantityInvoiced');

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            quantityInvoiced.innerText(num2str(_retailSalesLine.getQuantityInvoicedInSalesUnit(soLine), 5, _numberOfDecimals, 1, 0));
        }
        else
        {
            quantityInvoiced.innerText(num2str(_retailSalesLine.QuantityInvoiced, 5, _numberOfDecimals, 1, 0));
        }
        xmlLineQuantities.appendChild(quantityInvoiced);

        _xmlRecord.appendChild(xmlLineQuantities);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineLevelCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets line level charges.
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_xmlRecord">The xml record.</param>
    /// <param name = "_transRecId">The transaction record.</param>
    /// <param name = "_transTableRecId">The transaction table record.</param>
    /// <param name = "_transSalesId">The sales id.</param>
    /// <param name = "_isInvoiced">Indicates whether this charge line is already invoiced.</param>
    private static void setLineLevelCharges(XmlDocument _xmlDoc, XmlElement _xmlRecord, RecId _transRecId, RecId _transTableRecId, SalesId _transSalesId = '', boolean _isInvoiced = false)
    {
        MarkupTrans markupTrans;
        MarkupTable markupTable;
        XmlElement xmlLineCharges, xmlLineRecord;

        xmlLineCharges = _xmlRecord.getElementsByTagName('Charges').item(0);

        if (xmlLineCharges == null)
        {
            xmlLineCharges = _xmldoc.createElement('Charges');
        }

        while select * from markupTrans
            where markupTrans.TransRecId == _transRecId
                && ( _transTableRecId == 0 || markupTrans.TransTableId == _transTableRecId)
                && markupTrans.MarkupCategory == MarkupCategory::Fixed
            join CustType, VendType from markupTable
                where markupTable.MarkupCode == markupTrans.MarkupCode
                    && markupTable.ModuleType == markupTrans.ModuleType
                    && !(markupTable.CustType == MarkupType::LedgerAccount
                         && markupTable.VendType == MarkupType::LedgerAccount)
        {
            xmlLineRecord = _xmldoc.createElement('Charge');

            if (markupTable.VendType == MarkupType::CustVend)
            {
                xmlLineRecord.setAttribute(AmountStr,num2str(-markupTrans.Value,5,3,1,0));
            }
            else
            {
                xmlLineRecord.setAttribute(AmountStr,num2str(markupTrans.Value,5,3,1,0));
            }

            xmlLineRecord.setAttribute(CodeStr, markupTrans.MarkupCode);
            xmlLineRecord.setAttribute(TaxGroupStr, markupTrans.TaxGroup);
            xmlLineRecord.setAttribute(TaxItemGroupStr, markupTrans.TaxItemGroup);

            var chargeType = RetailTransactionServiceOrders::getChargeType(markupTrans);
            xmlLineRecord.setAttribute(ChargeTypeStr, enum2Str(chargeType));
            xmlLineRecord.setAttribute(DescriptionStr, markupTrans.Txt);
            xmlLineRecord.setAttribute(MarkupAutoTableRecIdStr, int642Str(markupTrans.MarkupAutoTableRecId));
            xmlLineRecord.setAttribute(MarkupAutoLineRecIdStr, int642Str(markupTrans.MarkupAutoLineRecId));
            xmlLineRecord.setAttribute(IsOverriddenLineStr, int2Str(enum2Int(markupTrans.IsOverriddenLine)));
            xmlLineRecord.setAttribute(TaxExemptPriceInclusiveOriginalPrice, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveOriginalPrice));
            xmlLineRecord.setAttribute(TaxExemptPriceInclusiveReductionAmount, RetailTransactionServiceOrders::amountToStr(markupTrans.TaxExemptPriceInclusiveReductionAmount));
            xmlLineRecord.setAttribute(ModuleTypeValueStr, int2Str(enum2int(markupTrans.ModuleType)));
            xmlLineRecord.setAttribute(CalculatedProratedAmountStr, RetailTransactionServiceOrders::amountToStr(markupTrans.CalculatedProratedAmount));

            RetailTransactionServiceOrders::addChargeTaxLineXml(_xmlDoc, xmlLineRecord, markupTrans, _transSalesId, _transRecId, _transTableRecId, false);

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                TransTaxInformation markupTransTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(markupTrans);
                HSNCodeTable_IN hsnCodeTable_IN = HSNCodeTable_IN::find(markupTransTaxInformation.HSNCodeTable);
                ServiceAccountingCodeTable_IN serviceAccountingCodeTable_IN = ServiceAccountingCodeTable_IN::find(markupTransTaxInformation.ServiceAccountingCodeTable);

                xmlLineRecord.setAttribute('HSNCode', hsnCodeTable_IN.Code);
                xmlLineRecord.setAttribute('ServiceAccountingCode', serviceAccountingCodeTable_IN.SAC);
                xmlLineRecord.setAttribute('Exempt', int2str(markupTransTaxInformation.Exempt));
                xmlLineRecord.setAttribute('ITCCategory', int2str(markupTransTaxInformation.ITCCategory));
                xmlLineRecord.setAttribute('ServiceCategory', int2str(markupTransTaxInformation.ServiceCategory));
            }

            xmlLineRecord.setAttribute("IsInvoiced", enum2Str(_isInvoiced));

            xmlLineCharges.appendChild(xmlLineRecord);
        }

        _xmlRecord.appendChild(xmlLineCharges);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of retail attributes.
    /// </summary>
    /// <param name = "_xmlDoc">XML document to populate.</param>
    /// <param name = "_parentElement">The parent element to be appended retail attribute elements.</param>
    /// <param name = "_salesId">The sales order identifier.</param>
    /// <param name="_dataAreaId">The data area identifier.</param>
    /// <param name = "_headerOrLineNum">The header or line number.</param>
    private static void getRetailAttributes(
        XmlDocument _xmlDoc,
        XmlElement _parentElement,
        SalesIdBase _salesId,
        DataAreaId _dataAreaId,
        HeaderOrLineNum _headerOrLineNum = 0)
    {
        RetailSalesTableInstanceValue retailSalesTableInstanceValue;
        EcoResAttributeValue ecoResAttributeValue;
        EcoResAttribute ecoResAttribute;
        EcoResTextValue ecoResTextValue;
        XmlElement parentAttributeElement, attributeElement;

        parentAttributeElement = _xmlDoc.createElement('AttributeValues');

        //Add attributes
        retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(_salesId, _dataAreaId, false, _headerOrLineNum);

        // if this sales order has any attributes
        if (retailSalesTableInstanceValue)
        {
            //Get all attributes (Name and Text value) for this sales order
            while select InstanceValue, Attribute, Value from ecoResAttributeValue
                where ecoResAttributeValue.InstanceValue == retailSalesTableInstanceValue.RecId
                && retailSalesTableInstanceValue.HeaderOrLineNum == _headerOrLineNum
                    join Name from ecoResAttribute where ecoResAttribute.RecId == ecoResAttributeValue.Attribute
                    join TextValue from ecoResTextValue where ecoResTextValue.RecId == ecoResAttributeValue.Value
            {
                attributeElement = _xmlDoc.createElement('AttributeValue');
                attributeElement.setAttribute('Name', ecoResAttribute.Name);
                attributeElement.setAttribute('LineNum', RetailTransactionServiceUtilities::lineNumToString(_headerOrLineNum));
                attributeElement.setAttribute('TextValue', ecoResTextValue.TextValue);
                parentAttributeElement.appendChild(attributeElement);
            }
        }

        _parentElement.appendChild(parentAttributeElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends <c>Note</c> information to the <paramref name="_xmlDoc"/>< with data from <c>DocuRef</c> table.
    /// </summary>
    /// <param name = "xmlDoc">The XML document.</param>
    /// <param name = "_recId">The retail order header record id.</param>
    /// <param name = "_tableId">The retail order header table id.</param>
    /// <param name = "_dataAreaId">The data area id.</param>
    /// <returns>The XMLElement containing the note.</returns>
    private static XmlElement setNotes(XmlDocument _xmlDoc, RefRecId _recId, TableId _tableId, DataAreaId _dataAreaId)
    {
        XmlElement xmlNotes = _xmlDoc.createElement('Notes');
        XmlElement xmlRecord;
        DocuRef docuRef;

        // Ideally this query should leverage DOCUREF table REFIDX.
        // PARTITION, REFCOMPANYID, REFTABLEID, REFRECID, CREATEDDATETIME, CREATEDBY
        while select RecId, Name, Notes, Restriction
            from docuRef
            order by DocuRef.CreatedDateTime desc
            where docuRef.TypeId == DocuType::typeNote()
                && docuRef.RefTableId == _tableId
                && docuRef.RefRecId == _recId
                && docuRef.RefCompanyId == _dataAreaId
        {
            // 'Note' XML maps to 'NoteInfo' CRT Entity.
            xmlRecord = _xmlDoc.createElement('Note');
            xmlRecord.setAttribute('Description', docuRef.Notes);
            xmlRecord.setAttribute('DocuRefRecId', int642Str(docuRef.RecId));
            xmlRecord.setAttribute('Restriction', enum2Symbol(enumNum(DocuRestriction), docuRef.Restriction));
            xmlRecord.setAttribute('Title', docuRef.Name);

            xmlNotes.appendChild(xmlRecord);
        }

        return xmlNotes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesInvoice_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <param name="_specQty">
    /// Quantity to update.
    /// </param>
    /// <parm name="_transDate">
    /// Sales order posting date.
    /// </parm>
    /// <returns>
    /// The Customer invoice journal record.
    /// </returns>
    public static CustInvoiceJour postSalesInvoice_RU(SalesTable     _salesTable,
                                                      SalesUpdate    _specQty,
                                                      TransDate      _transDate)
    {
        return RetailTransactionServiceOrders::postSalesInvoiceForStatement_RU(_salesTable, _specQty, _transDate, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesInvoiceForStatement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <param name="_specQty">
    /// Quantity to update.
    /// </param>
    /// <parm name="_transDate">
    /// Sales order posting date.
    /// </parm>
    /// <parm name="_taxCalculationBehaviorController">
    /// Tax calaulation behavior controller.
    /// </parm>
    /// <returns>
    /// The Customer invoice journal record.
    /// </returns>
    public static CustInvoiceJour postSalesInvoiceForStatement_RU(SalesTable     _salesTable,
                                                                  SalesUpdate    _specQty,
                                                                  TransDate      _transDate,
                                                                  RetailTaxCalculationBehaviorControllerBase _taxCalculationBehaviorController = null)
    {
        SalesFormLetter    salesFormLetter;
        LtDocNumberingCode docNumberingCode;
        CustInvoiceJour    custInvoiceJour;

        DocumentStatus documentStatus;
        if (RetailParameters::find().PostFacture_RU == NoYes::Yes)
        {
            documentStatus = DocumentStatus::Facture_RU;
        }
        else
        {
            documentStatus = DocumentStatus::Invoice;
        }

        salesFormLetter = SalesFormLetter::construct(documentStatus);

        if (_taxCalculationBehaviorController)
        {
            _taxCalculationBehaviorController.configureInvoicingToAllowLineLevelTaxAdjusments(salesFormLetter);
        }

        salesFormLetter.salesTable(_salesTable);
        salesFormLetter.initParmSalesTable(_salesTable);

        if (!_transDate)
        {
            _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        salesFormLetter.transDate(_transDate);
        salesFormLetter.specQty(_specQty);
        salesFormLetter.proforma(false);
        salesFormLetter.printFormLetter(false);
        salesFormLetter.printCODLabel(false);
        salesFormLetter.printShippingLabel(false);
        salesFormLetter.usePrintManagement(false);

        PlFiscalDocType defaultFiscalDocType_PL = RetailParameters::find().DefaultFiscalDocType_PL;

        salesFormLetter.fiscalDocType_PL(defaultFiscalDocType_PL);

        salesFormLetter.createParmUpdateFromParmUpdateRecord(
            SalesFormletterParmData::initSalesParmUpdateFormletter(salesFormLetter.documentStatus(),
                                                                   salesFormLetter.pack(),
                                                                   true,
                                                                   CustParameters::find().CreditError,
                                                                   InventParameters::find().StornoPhysicalPosting_RU));

        salesFormLetter.initParameters(salesFormLetter.salesParmUpdate(), Printout::Current);

        salesFormLetter.initLinesQuery();

        if (RetailParameters::find().UseDefaultTradeDates_W)
        {
            SalesParmTable::initDefaultTradeDates_W(salesFormLetter.salesParmUpdate());
        }

        salesFormLetter.parmSkipRunShipCarrier(true);
        salesFormLetter.reArrangeNow(false);
        salesFormLetter.run();

        if (RetailParameters::find().UseAdvanceInvoice_W)
        {
            select firstonly custInvoiceJour
                where custInvoiceJour.ParmId == salesFormLetter.parmId();
        }

        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Search for customer sales orders.
    /// </summary>
    /// <param name="_custTerm">
    /// The customer name search term.
    /// </param>
    /// <param name="_orderTerm">
    /// The order search term.
    /// </param>
    /// <param name="_fromDate">
    /// The date to search from.
    /// </param>
    /// <param name="_toDate">
    /// The date to search to.
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <returns>
    /// Container with the success, error and results.
    /// </returns>
    /// <remarks>
    /// Searches for sales orders using the given search terms/criteria
    /// </remarks>
    [SysObsolete('We only keep it for backward compatibility for customers using EPOS.', false, 26\08\2022)]
    public static container searchCustomerOrderList(str _custTerm, str _orderTerm, str _fromDate, str _toDate, int _resultsMaxCount = 100)
    {
        SalesTable          salesTable;
        SalesQuotationTable salesQuotationTable;
        RetailSalesTable    retailSalesTable;
        RetailTransactionTable retailTransactionTable;
        container           salesOrder = [true,''];
        int ptr;

        // Search terms
        utcdatetime         fromDate = DateTimeUtil::addYears(DateTimeUtil::utcNow(),-1);
        utcdatetime         toDate = DateTimeUtil::maxValue();
        CustAccount         searchCust = _custTerm;
        SalesName           searchName = _custTerm;
        Email               searchEmail = _custTerm;
        SalesId             searchId = _orderTerm;

        if (_fromDate)
        {
            fromDate = DateTimeUtil::parse(_fromDate);
        }
        if ( _toDate)
        {
            toDate = DateTimeUtil::addDays(DateTimeUtil::parse(_toDate), 1);
        }

        //Search for matches only in RetailSalesTable on the field ChannelReferenceId
        //Ideally this will return only one record based on an exact match on ChannelReferenceId.
        //To be consistent with the flexibility in the RetailSalesTable schema this allows for multiple matching records to exist
        if (searchId != '')
        {
            while select firstOnly100
            SalesType, CustAccount, SalesStatus, SalesId, DocumentStatus, SalesName, DeliveryName, Email, CustomerRef
            from salesTable
            order by salesTable.CreatedDateTime desc //Select the most recent 100 records from the returned set
            join channelreferenceid
            from retailSalesTable
            where (
                //Relation between SalesTable and RetailSalesTable
                (salesTable.RecId == retailSalesTable.SalesTable)
                //Order Search criteria
                && (retailsalesTable.ChannelReferenceId == searchId)
                //Customer search criteria
                && (
                    (searchCust != '' && (salesTable.CustAccount == searchCust))
                    || (searchName != '' && ((salesTable.SalesName like #Star + searchName + #Star) || (salesTable.DeliveryName like #Star + searchName + #Star)))
                    || (searchEmail != '' && (salesTable.Email like #Star + searchEmail + #Star))
                    || (searchCust == '')
                )
                //Results must lie within date range
                && (fromDate <= salesTable.createdDateTime) && (salesTable.createdDateTime < toDate)
                //Results contains only orders of type Sales
                && (salesTable.SalesType == SalesType::Sales)
                //Reuslts must not contain SalesStatus::Canceled
                && (
                    salesTable.SalesStatus == SalesStatus::None
                    || salesTable.SalesStatus == SalesStatus::Backorder
                    || salesTable.SalesStatus == SalesStatus::Delivered
                    || salesTable.SalesStatus == SalesStatus::Invoiced
                )
            )
            {
                if (ptr < _resultsMaxCount)
                {
                    salesOrder = conins(salesOrder, conlen(salesOrder) + 1, RetailTransactionService::getSalesOrder(salesTable.SalesId));
                    ptr++;
                }
                else
                {
                    break;
                }
            }
        }

        //Search for records in salesTable on customers/order number but do not consider the records that were already matched
        while select SalesType, CustAccount, SalesStatus, SalesId, DocumentStatus, SalesName, DeliveryName, Email
        from salesTable
        order by salesTable.CreatedDateTime desc
        where (searchId != '' && (salesTable.SalesId == searchId))
                ||(
                   searchId == ''
                   && (fromDate <= salesTable.CreatedDateTime) && (salesTable.CreatedDateTime < toDate)
                   && salesTable.SalesType == SalesType::Sales
                   && (
                       salesTable.SalesStatus == SalesStatus::None
                       || salesTable.SalesStatus == SalesStatus::Backorder
                       || salesTable.SalesStatus == SalesStatus::Delivered
                       || salesTable.SalesStatus == SalesStatus::Invoiced
                      )
                   // Ignore Inter-Company orders
                   && (salesTable.InterCompanyOrder == NoYes::No)
                   && (
                        (searchCust != '' && (salesTable.CustAccount like #Star + searchCust + #Star))
                        || (searchName != '' && ((salesTable.SalesName like #Star + searchName + #Star) || (salesTable.DeliveryName like #Star + searchName + #Star)))
                        || (searchEmail != '' && (salesTable.Email like #Star + searchEmail + #Star))
                        || (searchCust == '')
                      )
                )
                outer join channelreferenceid  from retailSalesTable where ((salesTable.RecId == retailSalesTable.SalesTable) && (searchId != '' && retailsalesTable.ChannelReferenceId == searchId))
                // Ignore any sales orders that came from posted non-CustomerOrder retail sales.
                notExists join RetailTransactionTable where ((RetailTransactionTable.salesOrderId == salesTable.SalesId) && (RetailTransactionTable.type != RetailTransactionType::CustomerOrder))
        {
            if (ptr < _resultsMaxCount)
            {
                //Do not consider records that were matched previously
                //If a record that matched the search query were present in RetailSalesTable, it need not be reconsidered because:
                // Added to salesOrder if it fell within date range
                // Not added to salesOrder as it did not fall in the date range/incorrect salesType/incorrect salesStatus
                if (retailSalesTable.channelreferenceid == '')
                {
                    salesOrder = conins(salesOrder, conlen(salesOrder) + 1, RetailTransactionService::getSalesOrder(salesTable.SalesId));
                    ptr++;
                }
            }
            else
            {
                break;
            }
        }

        while select QuotationType, CustAccount, QuotationId, QuotationStatus
        from salesQuotationTable
        order by salesQuotationTable.CreatedDateTime desc
        where (
                fromDate <= salesQuotationTable.createdDateTime
                && salesQuotationTable.createdDateTime < toDate
                && salesQuotationTable.QuotationType == QuotationType::Sales
                && (
                    salesQuotationTable.QuotationStatus == SalesQuotationStatus::Created
                    || salesQuotationTable.QuotationStatus == SalesQuotationStatus::Approved
                    || salesQuotationTable.QuotationStatus == SalesQuotationStatus::Submitted
                   )
                && (
                    (searchCust != '' && (salesQuotationTable.CustAccount like #Star + searchCust + #Star))
                    || (searchName != '' && (salesQuotationTable.QuotationName like #Star + searchName + #Star || salesQuotationTable.DeliveryName like #Star + searchName + #Star))
                    || (searchEmail != '' && (salesQuotationTable.Email like #Star + searchEmail +#Star))
                    || (searchCust == '')
                   )

                && (searchId == '' || salesQuotationTable.QuotationId == searchId)
            )
        {
            if (ptr < _resultsMaxCount)
            {
                salesOrder = conIns(salesOrder, conLen(salesOrder) + 1, RetailTransactionServiceOrders::getQuotationOrder(salesQuotationTable.QuotationId));
                ptr++;
            }
            else
            {
                break;
            }
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerOrderJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set LedgerJournalTrans properties based on the given tender type
    /// </summary>
    /// <param name="storeRecId">
    /// Store recid to lookup store
    /// </param>
    /// <param name="tenderTypeId">
    /// Retail Tender Type
    /// </param>
    /// <param name="ledgerJournalTrans">
    /// Journal to be updated
    /// </param>
    /// <param name="cardTypeId">
    /// Retail Tender Card Type. Default to empty.
    /// </param>
    /// <remarks>
    /// Updates the Journal based on the store and tender type.
    /// </remarks>
    public static void setCustomerOrderJournal(RecId storeRecId, RetailTenderTypeId tenderTypeId, LedgerJournalTrans ledgerJournalTrans, RetailCardTypeId cardTypeId = '')
    {
        RetailStoreTenderTypeTable      storeTenderTable;
        RetailStoreTenderTypeCardTable  storeTenderCardTable;
        boolean                         countryRegion_W  = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        RecId                           offsetAccount;

        storeTenderCardTable = RetailStoreTenderTypeCardTable::find(storeRecId, tenderTypeId, cardTypeId);
        storeTenderTable = RetailStoreTenderTypeTable::find(storeRecId, tenderTypeId);
        SalesTable salesTableForOrder = SalesTable::find(ledgerJournalTrans.SalesOrderId);

        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTableForOrder, funcName()))
        {
            // For Commerce Payments orders unify the order of the merge with statement posting.
            ledgerJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(storeTenderTable.DefaultDimension, ledgerJournalTrans.DefaultDimension);
        }
        else
        {
            ledgerJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ledgerJournalTrans.DefaultDimension,storeTenderTable.DefaultDimension);
        }

        if (RetailEodUseCustomerFinancialDimensionToPostDepositsToggle::instance().isEnabled())
        {
            ledgerJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(CustTable::find(salesTableForOrder.custAccount).DefaultDimension, ledgerJournalTrans.DefaultDimension);
        }

        if (storeTenderCardTable)
        {
            switch (storeTenderCardTable.AccountType)
            {
                case RetailLedgerBank::Bank:
                    ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Bank;
                    break;
                case RetailLedgerBank::Ledger:
                    ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                    break;
                case RetailLedgerBank::RCash:
                    // have to swap account and offset account for RCash lines
                    ledgerJournalTrans.OffsetAccountType     = ledgerJournalTrans.AccountType;
                    ledgerJournalTrans.OffsetLedgerDimension = ledgerJournalTrans.LedgerDimension;
                    ledgerJournalTrans.AccountType           = LedgerJournalACType::RCash;
                    break;
            }

            // Get offset account from Card Level Setup
            offsetAccount = storeTenderCardTable.LedgerDimension;
        }

        if (!storeTenderCardTable || (storeTenderCardTable && (offsetAccount == 0)))
        {
            // Card Level setup not found. trying to get from payment method level...

            if(storeTenderTable)
            {
                switch(storeTenderTable.AccountType)
                {
                    case RetailLedgerBank::Bank:
                        ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Bank;
                        break;
                    case RetailLedgerBank::Ledger:
                        ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                        break;
                    case RetailLedgerBank::RCash:
                        // have to swap account and offset account for RCash lines
                        ledgerJournalTrans.OffsetAccountType     = ledgerJournalTrans.AccountType;
                        ledgerJournalTrans.OffsetLedgerDimension = ledgerJournalTrans.LedgerDimension;
                        ledgerJournalTrans.AccountType           = LedgerJournalACType::RCash;
                        break;
                    default:
                        // do nothing
                        break;
                }

                // Get offset account from Payment Method level Setup
                offsetAccount = storeTenderTable.LedgerDimension;
            }
            else
            {
                throw error(strFmt("@SYS35030")); // the offset account must be specified
            }
        }

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::RCash)
        {
            ledgerJournalTrans.LedgerDimension        = offsetAccount;
            ledgerJournalTrans.OffsetDefaultDimension = ledgerJournalTrans.DefaultDimension;
        }
        else
        {
            if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(offsetAccount, ledgerJournalTrans.DefaultDimension);
            }
            else
            {
                ledgerJournalTrans.OffsetLedgerDimension        = offsetAccount;
                ledgerJournalTrans.OffsetDefaultDimension       = countryRegion_W ? ledgerJournalTrans.DefaultDimension : storeTenderTable.DefaultDimension;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInformationForMarkupTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets India tax information of charges transactions based on the set up on retail store.
    /// </summary>
    /// <param name="_markupTrans">
    /// The <c>MarkupTrans</c> to be used.
    /// </param>
    /// <param name="_storeId">
    /// The specific retail store Id.
    /// </param>
    private static void setTaxInformationForMarkupTrans_IN(MarkupTrans _markupTrans, RetailStoreId _storeId)
    {
        MarkupTrans_IN          markupTransIN;
        if (_markupTrans.RecId)
        {
            markupTransIN = _markupTrans.markupTrans_IN();
            markupTransIN.initValue();
            markupTransIN.CompanyLocation   = InventLocation::getDefaultLogisticsLocation_IN(RetailStoreTable::find(_storeId).inventLocation, LogisticsLocationRoleType::Delivery).RecId;
            markupTransIN.TaxInformation    = TaxInformation_IN::findDefaultbyLocation(markupTransIN.CompanyLocation).RecId;
            markupTransIN.SysExtensionSerializerExtensionMap::insertAfterBaseTable(_markupTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInformationForQuoteLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets India tax information sales quotation line based on the set up on retail store.
    /// </summary>
    /// <param name="_salesQuotationLine">
    /// The <c>SalesQuotationLine</c> to be updated.
    /// </param>
    /// <param name="_storeId">
    /// The specific retail store Id.
    /// </param>
    private static void setTaxInformationForQuoteLine_IN(SalesQuotationLine _salesQuotationLine, RetailStoreId _storeId)
    {
        SalesQuotationLineTaxExtensionIN    salesQuotationLineTaxExtensionIN;
        LogisticsLocationRecId              logisticsLocationRecId;
        TaxInformationRecId_IN              taxInformationRecId;
        RetailStoreTable                    storeTable;
        RetailStoreTable_IN                 storeTableIN;
        InventTableModule                   inventTableModule;
        PriceDisc_Price                     priceDiscPrice;
        TransTaxInformation                 transTaxInformation;

        if (_salesQuotationLine.RecId)
        {
            storeTable                  = RetailStoreTable::find(_storeId);
            storeTableIN                = RetailStoreTable_IN::findByRetailStoreTable(storeTable.RecId);
            logisticsLocationRecId      = InventLocation::getDefaultLogisticsLocation_IN(storeTable.inventLocation, LogisticsLocationRoleType::Delivery).RecId;
            taxInformationRecId         = TaxInformation_IN::findDefaultbyLocation(logisticsLocationRecId).RecId;
            inventTableModule           = InventTableModule::find(_salesQuotationLine.ItemId, ModuleInventPurchSales::Sales);
            transTaxInformation         = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_salesQuotationLine, true);

            _salesQuotationLine.selectForUpdate(true);
            transTaxInformation.selectForUpdate(true);
            transTaxInformation.CompanyLocation   = logisticsLocationRecId;
            transTaxInformation.SalesTaxFormTypes = storeTableIN.SalesTaxFormTypes;
            transTaxInformation.TaxInformation    = taxInformationRecId;
            TransTaxInformationHelper::initFromTaxInformation(transTaxInformation);
            transTaxInformation.update();

            priceDiscPrice = PriceDisc_Price::construct();
            priceDiscPrice.parmModuleType(ModuleInventPurchSales::Sales);
            priceDiscPrice.parmItemId(_salesQuotationLine.ItemId);
            priceDiscPrice.parmInventDim(_salesQuotationLine.inventDim());
            priceDiscPrice.parmUnitID(_salesQuotationLine.SalesUnit);
            priceDiscPrice.parmPriceDate(_salesQuotationLine.priceDate());
            priceDiscPrice.parmQty(_salesQuotationLine.SalesQty);
            priceDiscPrice.parmAccountNum(_salesQuotationLine.salesQuotationTable().CustAccount);
            priceDiscPrice.parmCurrencyCode(_salesQuotationLine.salesQuotationTable().CurrencyCode);
            priceDiscPrice.parmPriceGroupId(_salesQuotationLine.salesQuotationTable().PriceGroupId);

            salesQuotationLineTaxExtensionIN        = SalesQuotationLineTaxExtensionIN::findBysalesQuotationLine(_salesQuotationLine.RecId, true);
            if (!salesQuotationLineTaxExtensionIN)
            {
                salesQuotationLineTaxExtensionIN.SalesQuotationLine = _salesQuotationLine.RecId;
                salesQuotationLineTaxExtensionIN.MaximumRetailPrice = CurrencyExchangeHelper::curAmount(inventTableModule.MaximumRetailPrice_IN, _salesQuotationLine.CurrencyCode);
                salesQuotationLineTaxExtensionIN.insert();
            }
            else
            {
                salesQuotationLineTaxExtensionIN.MaximumRetailPrice = CurrencyExchangeHelper::curAmount(inventTableModule.MaximumRetailPrice_IN, _salesQuotationLine.CurrencyCode);
                salesQuotationLineTaxExtensionIN.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCustomerOrderCancellation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles prepayment and cancellation transactions.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order for which the settlement is to be done.
    /// </param>
    /// <param name="_vouchersToSettle">
    /// A list of voucher ids to be settle.
    /// </param>
    protected static void settleCustomerOrderCancellation(SalesTable _salesTable, List _vouchersToSettle)
    {
        CustTransOpen       custTransOpen;
        CustTrans           custTrans;
        boolean             countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        if (countryRegion_W && !_vouchersToSettle)
        {
            return;
        }

        SpecTransManager specTransManager = SpecTransManager::newFromSpec(_salesTable);

        ListEnumerator enumerator = _vouchersToSettle.getEnumerator();

        while (enumerator.moveNext())
        {
            Voucher voucher = enumerator.current();

            while select CurrencyCode from custTrans
                where   custTrans.Voucher       == voucher
                &&      custTrans.PaymReference == _salesTable.SalesId
                outer join custTransOpen
                    where custTransOpen.RefRecId == custTrans.RecId
            {
                specTransManager.insert(custTransOpen.company(),custTransOpen.TableId,custTransOpen.RecId,custTransOpen.AmountCur,custTrans.CurrencyCode);
            }
        }

        // settle marked transactions
        CustTransData custTransData = custTrans.transData();
        custTransData.updateOffsetVoucher(SettlementType::SelectedTransact, null, _salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settle a customer order
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info
    /// </param>
    /// <returns>
    /// container [success, error]
    /// </returns>
    /// <remarks>
    /// Settles a customer order after pickup
    /// </remarks>
    public static container settleCustomerOrder(CustomerOrderInfo custOrderInfo)
    {
        str error;
        CurrencyCode currencyCode = CompanyInfoHelper::standardCurrency();
        boolean success = false;
        boolean isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        int fromLine;

        container validationResult = RetailCommercePaymentsFeatureHelper::validateCustomerOrderVersion(custOrderInfo, SalesTable::find(custOrderInfo.Id));
        boolean validationResultSuccessful = conPeek(validationResult, 1);

        if (!validationResultSuccessful)
        {
            return validationResult;
        }

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;
            RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(str2Int64(custOrderInfo.ChannelRecordId));
            SalesTable salesTable = SalesTable::find(custOrderInfo.Id, true);
            salesTable.SettleVoucher = SettlementType::SelectedTransact;

            if (salesTable.SalesStatus == SalesStatus::Invoiced)
            {
                eventSource.EventWriteOrdersSettleCustomerOrderSuspendedInvoicedOrderMustBeVoidError(funcName());
                throw error('@Retail:SuspendedInvoicedOrderMustBeVoid');
            }

            salesTable.update();

            if (custOrderInfo.CurrencyCode)
            {
                currencyCode = custOrderInfo.CurrencyCode;
            }

            RefRecId loyaltyCardRecId = RetailLoyaltyCard::findByCardNumber(custOrderInfo.LoyaltyCardId).RecId;
            RetailSalesTable retailSalesTable = RetailSalesTable::find(salesTable.SalesId, true);
            if (retailSalesTable.RecId != 0 && retailSalesTable.RetailLoyaltyCard != loyaltyCardRecId)
            {
                retailSalesTable.RetailLoyaltyCard = loyaltyCardRecId;
                retailSalesTable.update();
            }

            RetailTransactionServiceOrders::updateRetailOrderHeader_MX(salesTable, custOrderInfo);

            RetailSalesAffiliation::SetAffiliatonsAndLoyaltyTiers(salesTable.SalesId, custOrderInfo.Affiliations);

            using (RetailTransactionServiceInvoiceContext context = RetailTransactionServiceOrders::createRetailTransactionServiceInvoiceContext(custOrderInfo))
            {
                RetailTransactionServiceOrders::createRetailOrderPayment(salesTable, custOrderInfo, false);
            }

            Map taxAdjustmentsMap = new Map(Types::String, Types::Container);

            // Check for GTE tax calculation type
            boolean isGteTaxCalculationType = (custOrderInfo.TaxCalculationType == enum2int(TaxCalculationType::GTE));

            // Delete any existing tax adjustments
            if (isGteTaxCalculationType)
            {
                RetailTransactionServiceOrders::deleteExistingGTETaxAdjustments(salesTable.RecId);
            }
            else
            {
                RetailTransactionServiceOrders::deleteExistingTaxAdjustments(custOrderInfo, salesTable.RecId);
            }


            boolean areCustomerOrderTaxAdjustmentsAllowed = RetailParameters::find().CustomerOrderTaxCalculationBehavior == RetailCustomerOrderTaxCalculationBehavior::DontRecalculate;

            if (areCustomerOrderTaxAdjustmentsAllowed)
            {
                // Add header charges tax adjustments.
                RetailTransactionServiceOrders::addMarkUpTransTaxAdjustments(salesTable, custOrderInfo.Charges, taxAdjustmentsMap, isGteTaxCalculationType);
            }

            //Invoicing the order
            ItemInfoCollection items = custOrderInfo.Items as ItemInfoCollection;

            for (int i = 0; i < items.get_Count(); i++)
            {
                ItemInfo itemInfo = items.get_Item(i) as ItemInfo;

                if (itemInfo.Quantity > 0)
                {
                    // Setting a proper value for inventDim
                    inventDim inventDim = RetailTransactionServiceOrders::createInventDim(itemInfo);

                    SalesLine salesLine;

                    select forupdate salesLine
                    where salesLine.RecId == itemInfo.RecId;

                    if (PdsCatchWeightItem::exist(salesLine.ItemId))
                    {
                        eventSource.EventWriteOrdersSettleCustomerOrderWithCatchWeightItemNotSupported(salesLine.RecId, salesLine.ItemId);
                    }

                    if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
                    {
                        InventTable inventTable = InventTable::find(salesLine.ItemId);

                        if (inventTable)
                        {
                            boolean isSalesProcessSerialActive = inventTable.isSalesProcessSerialActive();
                            boolean isItemSerialNumberActivated = inventTable.isItemSerialNumberActivated();

                            InventDim originalInventDim;
                            if (isSalesProcessSerialActive)
                            {
                                InventTransOrigin inventTransOrigin;
                                InventTrackingRegisterTrans inventTrackingRegisterTrans;
                                select inventSerialId from originalInventDim
                                join inventTrackingRegisterTrans
                                    where inventTrackingRegisterTrans.InventDimId == originalInventDim.inventDimId
                                join inventTransOrigin
                                    where inventTransOrigin.RecId == inventTrackingRegisterTrans.InventTransOrigin
                                        && inventTransOrigin.InventTransId == salesLine.InventTransId;
                            }
                            else if (isItemSerialNumberActivated)
                            {
                                originalInventDim = InventDim::find(salesLine.InventDimId);
                            }

                            if (originalInventDim && originalInventDim.inventSerialId != inventDim.inventSerialId)
                            {
                                RetailSalesLine retailSalesLine;
                                select FulfillmentStatus from retailSalesLine where retailSalesLine.SalesLine == salesLine.RecId;

                                if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Packed)
                                {
                                    throw error("@Retail:CannotUpdateSerialNumberOfLineOfPacked");
                                }

                                if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Picked && isItemSerialNumberActivated)
                                {
                                    throw error("@Retail:CannotUpdateSerialNumberOfLineOfPicked");
                                }
                            }
                        }
                    }

                    if (areCustomerOrderTaxAdjustmentsAllowed)
                    {
                        // Add line level tax adjustments
                        if (isGteTaxCalculationType)
                        {
                            RetailTransactionServiceOrders::CreateTaxMeasureAdjustments(tableNum(SalesTable), salesTable.RecId, tableNum(SalesLine), salesLine.RecId, itemInfo.TaxMeasures, taxAdjustmentsMap);
                        }
                        else
                        {
                            RetailTransactionServiceOrders::CreateTaxLines(tableNum(SalesLine), salesLine.RecId, itemInfo.Taxes, taxAdjustmentsMap);
                        }

                        // Add line level charge tax adjustments.
                        RetailTransactionServiceOrders::addMarkUpTransTaxAdjustments(salesLine, itemInfo.Charges, taxAdjustmentsMap, isGteTaxCalculationType, salesTable);
                    }

                    RetailTransactionServiceOrders::salesLineUpdateToSettleCustomerOrder(salesLine, inventDim, ItemInfo, retailChannelTable, salesTable);
                    salesLine.update();

                    InventMovement inventMovement = InventMovement::construct(salesLine, InventMovSubType::None, null);
                    if (inventMovement.mustRegisterTrackingDimension())
                    {
                        // Check if Inventory Tracking Register Trans for serial number exists. If it exists, update it.
                        boolean isInventTrackingRegistered = InventTrackingRegisterUpdate::newFromMovement(inventMovement).updateTrackingDimension(inventDim);

                        // Inventory Tracking Register Trans for serial number doesn't exist, create it
                        if (!isInventTrackingRegistered)
                        {
                            InventTrackingRegisterUpdate::newFromMovement(inventMovement).registerTrackingDimension(inventDim, inventMovement.transQty());
                        }
                    }

                    RetailKitAssemblyOrder::postSalesLineAssemblyOrder(salesLine);
                }
                else if (itemInfo.Quantity < 0)
                {
                    eventSource.EventWriteOrdersSettleCustomerOrderRetailOrderFulfillmentQuantityLessThanZeroError(funcName());
                    throw error("@Retail:RetailOrderFulfillmentQuantityLessThanZero");
                }
            }

            // Insert the tax adjustments
            if (areCustomerOrderTaxAdjustmentsAllowed)
            {
                if (isGteTaxCalculationType)
                {
                    RetailTransactionServiceOrders::insertTaxMeasureAdjustments(taxAdjustmentsMap);
                }
                else
                {
                    RetailTransactionServiceOrders::insertTaxAdjustments(taxAdjustmentsMap);
                }
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
            {
                RetailCustomerOrderLine_W::createOrUpdateLines(custOrderInfo);
            }

            //Update the Channel reference id
            if (custOrderInfo.ChannelReferenceId)
            {
                retailSalesTable = RetailSalesTable::find(salesTable.salesId, true);
                retailSalesTable.ChannelReferenceId = custOrderInfo.ChannelReferenceId;

                if (retailSalesTable.RecId != 0)
                {
                    retailSalesTable.update();
                }
            }

            // Update GST transaction Id
            RetailTransactionServiceOrders::populateGSTTransactionId(salesTable, custOrderInfo);

            if (RetailCreateCustomerOrderExtensions::skipInvoice())
            {
                // skip invoice.
                eventSource.EventWritesSkipInvoceNotification(funcName());
            }
            else
            {
                using (RetailTransactionServiceInvoiceContext context = RetailTransactionServiceOrders::createRetailTransactionServiceInvoiceContext(custOrderInfo))
                {
                    RetailTransactionServiceOrders::invoiceSalesOrder(salesTable, SalesUpdate::DeliverNow, custOrderInfo.PrepaymentAmountApplied);
                }

                CustInvoiceJour custInvoiceJour;
                select firstonly custInvoiceJour
                where custInvoiceJour.SalesId == salesTable.SalesId
                   && custInvoiceJour.InvoiceId
                   && custInvoiceJour.SalesType == SalesType::Sales;

                if (custInvoiceJour) //If invoice is present
                {
                    error = '';
                    success = true;
                }
                else
                {
                    throw error("@Retail:NoInvoiceFoundAfterSettleCustomerOrder");
                }
            }

            ttscommit;
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersSettleCustomerOrderError(funcName());
            success = false;
            return [success, error];
        }

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates the product dimension for the given line.
    /// </summary>
    /// <param name = "_itemInfo">
    /// The product information from the client.
    /// </param>
    /// <returns>
    /// The product dimension for the given line.
    /// </returns>
    [Wrappable(true)]
    protected final static InventDim createInventDim(ItemInfo _itemInfo)
    {
        InventDim inventDim = InventDim::findOrCreateInventDim(_itemInfo);

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to invoice the sales order.
    /// </summary>
    /// <param name = "salesTable">The <c>SalesTable</c> record buffer.</param>
    /// <param name = "salesupdate">The sales update parameter.</param>
    /// <param name = "PrepaymentAmountApplied">The amount to be apply for prepayment.</param>
    public static void invoiceSalesOrder(SalesTable salesTable,
                                                SalesUpdate salesupdate = SalesUpdate::All,
                                                Amount PrepaymentAmountApplied = 0)
    {
        RetailTransactionServiceInvoiceContext context = RetailTransactionServiceInvoiceContext::current();
        TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);

        // Prepare Settlements for invoicing process
        RetailTransactionServiceOrders::prepareRetailSettlements(salesTable, PrepaymentAmountApplied);

        // Initialize tax calculation behavior for tax adjustments
        var taxCalculationBehaviorController = RetailTaxCalculationBehaviorSalesTableController::construct(salesTable);

        // Generate Invoice (without CC info to avoid auto-charging CC)
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        if (countryRegion_W)
        {
            CustInvoiceJour custInvoiceJour_W = RetailTransactionServiceOrders::postSalesInvoiceForStatement_RU(salesTable, salesupdate, businessDate, taxCalculationBehaviorController);

            if (RetailParameters::find().UseAdvanceInvoice_W)
            {
                RetailTransactionServiceAdvanceInvoice_W::settleCustAdvanceInvoices(salesTable, custInvoiceJour_W, prepaymentAmountApplied);
            }
        }
        else
        {
            // Set the Italy-specific reason code for sales order, if necessary.
            if (RetailChronologicalInvoicePostingReasonCodeSetter::isEnabled())
            {
                RetailChronologicalInvoicePostingReasonCodeSetter reasonCodeSetter =
                    RetailChronologicalInvoicePostingReasonCodeSetter::constuct(salesTable, businessDate);

                reasonCodeSetter.setSalesReasonCode();
            }

            SalesFormLetter salesFormLetter = SalesFormLetter::construct(DocumentStatus::Invoice);
            salesFormLetter.reArrangeNow(false);
            taxCalculationBehaviorController.configureInvoicingToAllowLineLevelTaxAdjusments(salesFormLetter);
            salesFormLetter.update(salesTable, businessDate, salesupdate, AccountOrder::None, false, false);

            if (FeatureStateProvider::isFeatureEnabled(RetailEInvoiceFeature_SA::instance())
                && context.parmTransactionId())
            {
                CustInvoiceJour custInvoiceJournal = salesFormLetter.getOutputContract().parmJournal();
                RetailCustInvoiceJourTable retailCustInvoiceJournal = custInvoiceJournal.retailCustInvoiceJourTable();

                if (retailCustInvoiceJournal)
                {
                    retailCustInvoiceJournal.selectForUpdate(true);
                    retailCustInvoiceJournal.IsEInvocieGeneratedFromPOS_SA = true;
                    retailCustInvoiceJournal.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the customer order.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info having the details of order to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order updated.
    /// </returns>
    public static container updateCustomerOrder(CustomerOrderInfo custOrderInfo, boolean aggregate = false)
    {
        str                 error;
        boolean             success = false;
        int fromLine;
        SalesTable salesTable;
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        //<GEEU>
        boolean isAdvanceInvoice = countryRegion_W && (RetailParameters::find().UseAdvanceInvoice_W && RetailTransactionServiceAdvanceInvoice_W::isCustomerOrderTransaction(custOrderInfo));
        AdvanceInvoiceContract_W advanceInvoiceContract;
        CustInvoiceJour custInvoiceJour;
        //</GEEU>

        container validationResult = RetailCommercePaymentsFeatureHelper::validateCustomerOrderVersion(custOrderInfo, SalesTable::find(custOrderInfo.Id));
        boolean validationResultSuccessful = conPeek(validationResult, 1);

        if (!validationResultSuccessful)
        {
            error = conPeek(validationResult, 2);
            return [validationResultSuccessful, error, custOrderInfo.Id];
        }

        try
        {
            fromLine = Global::infologLine();

            salesTable = SalesTable::find(custOrderInfo.Id, true);

            if (!RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement() && salesTable.DocumentStatus == DocumentStatus::Invoice)
            {
                return [false, strFmt('@Retail:RetailUpdateInvoiceCustomerOrderError', salesTable.SalesId), salesTable.SalesId];
            }

            ttsbegin;

            custOrderInfo.QuotationId = '';

            RetailTransactionServiceOrders::createOrUpdateRetailOrderHeader(salesTable, custOrderInfo, /*createNew*/ false);

            // Remove discount lines on the SalesLine Level
            RetailSalesDiscountLine retailSalesDiscountLine;
            SalesLine salesLine;
            delete_from retailSalesDiscountLine
                exists join salesLine
                    where retailSalesDiscountLine.InventTransId == salesLine.InventTransId
                        && salesLine.SalesId == salesTable.SalesId;

            //update sales lines
            if (isAdvanceInvoice)
            {
                advanceInvoiceContract = new AdvanceInvoiceContract_W();
                RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesTable, custOrderInfo, /*_aggregate*/ false, /*_isCustomerOrderReturnWithExchange*/ false, advanceInvoiceContract);
            }
            else
            {
                RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesTable, custOrderInfo);
            }

            RetailTransactionServiceOrders::updateRetailOrderHeader_MX(salesTable, custOrderInfo);

            //creation of charge codes
            RetailTransactionServiceOrders::createMarkupTrans(custOrderInfo.Charges, salesTable, salesTable.CurrencyCode, custOrderInfo.StoreId, custOrderInfo);

            if (custOrderInfo.AutoPickOrder)
            {
                RetailChannelRecId retailChannelRecId = str2Int64(custOrderInfo.ChannelRecordId);
                RetailTransactionServiceOrders::createPickingList(salesTable.SalesId, '',  retailChannelRecId);
            }

            // creation of prepayment journal
            if (isAdvanceInvoice)
            {
                RetailTransactionServiceOrders::createOrUpdateRetailOrderPayments(
                        RetailCreateOrUpdatePaymentsParameters::initializeRetailCreateOrUpdatePaymentsParameters(
                            salesTable,
                            custOrderInfo,
                            false,
                            advanceInvoiceContract));
                advanceInvoiceContract.parmSalesTable(salesTable);
                advanceInvoiceContract.initFromCustomerOrderInfo(custOrderInfo);
                RetailTransactionServiceAdvanceInvoice_W::updateCustAdvanceInvoiceByContract(advanceInvoiceContract);
                RetailTransactionServiceOrders::prepareRetailSettlements(salesTable, maxInt());
            }
            else
            {
                RetailTransactionServiceOrders::createOrUpdateRetailOrderPayments(
                        RetailCreateOrUpdatePaymentsParameters::initializeRetailCreateOrUpdatePaymentsParameters(
                            salesTable,
                            custOrderInfo,
                            false));
            }

            // creation of call center payment
            //RetailTransactionServiceOrders::createCallCenterOrderPayment(salesTable, custOrderInfo, false);

            // Affiliations
            RetailSalesAffiliation::SetAffiliatonsAndLoyaltyTiers(salesTable.SalesId, custOrderInfo.Affiliations);
            RetailTransactionServiceOrders::createOrUpdateAffilitaionsReasonCodeLines(salesTable.RecId, custOrderInfo);

            // Post Invoice for "Carry Out" items
            RetailCustomerOrderCarryoutParameters parameters = new RetailCustomerOrderCarryoutParameters();
            parameters.invoiceNow = true;
            parameters.custOrderInfo = custOrderInfo;
            parameters.salesTable = salesTable;

            RetailTransactionServiceOrders::postInvoiceCarryoutLines(parameters);

            if (isAdvanceInvoice && !advanceInvoiceContract.parmNoFurtherProcessing())
            {
                advanceInvoiceContract.parmCarryOutInvoiceAmount(custInvoiceJour.InvoiceAmount);
                RetailTransactionServiceAdvanceInvoice_W::createCustAdvanceInvoiceByContract(advanceInvoiceContract);
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
            {
                RetailCustomerOrderLine_W::createOrUpdateLines(custOrderInfo);
            }

            error = '';
            success = true;
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'Deadlock', xSession::currentRetryCount(), #RetryNum, false);
                    throw Exception::Deadlock;
                }
                else
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'Deadlock', xSession::currentRetryCount(), #RetryNum, true);
                    retry;
                }
            }
            else
            {
                eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'Deadlock', xSession::currentRetryCount(), #RetryNum, false);
                throw Exception::Deadlock;
            }
        }
        catch (Exception::UpdateConflict)
        {
            // For UpdateConflict, try again from the top
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'UpdateConflict', xSession::currentRetryCount(), #RetryNum, false);
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'UpdateConflict', xSession::currentRetryCount(), #RetryNum, true);
                    retry;
                }
            }
            else
            {
                eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'UpdateConflict', xSession::currentRetryCount(), #RetryNum, false);
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            // For DuplicateKeyException, try again from the top
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'DuplicateKeyException', xSession::currentRetryCount(), #RetryNum, false);
                    throw Exception::DuplicateKeyExceptionNotRecovered;
                }
                else
                {
                    eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'DuplicateKeyException', xSession::currentRetryCount(), #RetryNum, true);
                    retry;
                }
            }
            else
            {
                eventSource.EventWriteUpdateCustomerOrderExceptionWithRetries(funcName(), 'DuplicateKeyException', xSession::currentRetryCount(), #RetryNum, false);
                throw Exception::DuplicateKeyException;
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersUpdateCustomerOrderError(funcName());
            success = false;
        }

        return [success, error, salesTable.SalesId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info having the header, line details and charges associated with the quote to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation updated.
    /// </returns>
    public static container updateCustomerQuote(CustomerOrderInfo custOrderInfo)
    {
        str                 error;
        boolean             success = false;
        Counter             infologline    = infolog.num();
        SalesQuotationTable salesQuotationTable;

        try
        {
            using(var telemetry = RetailInstrumentationSegment::construct(classStr(RetailTransactionServiceOrders), funcName()))
            {
                ttsbegin;

                // Keep backward compatibility functionality works (if QuotationId field is empty, search quotation by Id field)
                salesQuotationTable = SalesQuotationTable::find(custOrderInfo.QuotationId != '' ? custOrderInfo.QuotationId : custOrderInfo.Id, true);

                salesQuotationTable.QuotationType = QuotationType::Sales;
                RetailTransactionServiceOrders::createOrUpdateRetailOrderHeader(salesQuotationTable, custOrderInfo, false);

                //Creation of sales quotation lines
                RetailTransactionServiceOrders::createOrUpdateRetailOrderLines(salesQuotationTable, custOrderInfo);

                //creation of charge code
                RetailTransactionServiceOrders::createMarkupTrans(custOrderInfo.Charges, salesQuotationTable, salesQuotationTable.CurrencyCode, custOrderInfo.StoreId, custOrderInfo);

                // Affiliations
                RetailSalesQuotationAffiliation::SetAffiliatonsAndLoyaltyTiers(salesQuotationTable.QuotationId, custOrderInfo.Affiliations);

                success = true;
                ttscommit;
            }
        }
        catch(Exception::Error)
        {
            error = conPeek(conPeek(infolog.copy(infologline +1,infolog.num()),2),2);
            eventSource.EventWriteOrdersUpdateCustomerQuoteError(funcName());

            success = false;
        }
        return [success, error, salesQuotationTable.QuotationId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the picking list in Ax.
    /// </summary>
    /// <param name="xmlPickListStr">
    /// An XML string having the details of picking list.
    /// </param>
    /// <returns>
    /// A container having the status of updation.
    /// </returns>
    public static container updatePickingList(str xmlPickListStr)
    {
        container           resultContainer        = [false, '', ''];
        boolean          success;
        str              error = '';
        int              i;
        Qty              qty;
        RecId            lineRecId;
        XmlDocument      pickListXml;
        WMSPickingRouteID pickingId;
        XmlElement       xmlRoot;
        XmlElement       xmlRecord;
        XmlNodeList      xmlRecordList;
        WMSPickingRoute  pickingRoute;
        WMSOrderTrans    pickingLine;
        Counter          infologline    = infolog.num();
        InventDim        inventDim;
        HcmWorkerRecId   worker = DirPersonUserEx::findUserWorkerReference();
        WMSShipment      wmsShipment;
        int              fromLine;

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;
            pickListXml    = new XmlDocument();
            pickListXml.loadXml(xmlPickListStr);

            xmlRoot = pickListXml.getNamedElement('WMSPickingRoute');
            pickingId = xmlRoot.getAttribute('PickingRouteId');

            select forupdate pickingRoute where pickingRoute.PickingRouteID == pickingId
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Cancelled)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Complete)
                    && (pickingRoute.ExpeditionStatus != WMSExpeditionStatus::Picked);

            if (pickingRoute)
            {
                xmlRecordList = xmlRoot.childNodes();
                if (xmlRecordList)
                {
                    for (i=0; i < xmlRecordList.length(); i++)
                    {
                        xmlRecord = xmlRecordList.item(i);
                        qty = str2num(xmlRecord.getAttribute('Qty'));
                        lineRecId = str2int64(xmlRecord.getAttribute(fieldStr(WMSOrderTrans, RecId)));
                        select forupdate pickingLine
                            where pickingLine.RecId == lineRecId
                               && pickingLine.ExpeditionStatus != WMSExpeditionStatus::Picked
                               && pickingLine.ExpeditionStatus != WMSExpeditionStatus::Cancelled
                            join inventDim
                                where inventDim.InventDimId == pickingLine.InventDimId;

                        if (pickingLine)
                        {
                            if (qty == 0)
                            {
                                pickingLine.cancel(false);
                            }
                            else if (pickingLine.Qty > qty)
                            {
                                pickingLine.split(pickingLine.Qty - qty).cancel();
                                pickingLine.finishPickingLine('', inventDim, worker, 0,false,false);
                            }
                            else
                            {
                                pickingLine.finishPickingLine('', inventDim, worker, 0,false,false);
                            }
                        }

                        xmlRecord.setAttribute(#UpdatedInAx, TrueStr);
                        xmlRecord.setAttribute(#Message, '');
                    }
                }

                // SetStatus updates the route status based on the lines.
                pickingRoute.setStatus();
                pickingRoute.update();

                wmsShipment = pickingRoute.wmsShipment(true);
                wmsShipment.setStatus(NoYes::Yes, NoYes::No);
            }

            success = true;

            resultContainer = [success, '', pickListXml.toString()];

            ttscommit;
            eventSource.EventWriteOrdersUpdatePickingListUpdatedMessage(funcName(), pickingRoute.RecId);
        }

        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteOrdersUpdatePickingListError(funcName());
            success = false;

            resultContainer = [success, error, ''];
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateTaxOnJourLine_RU</Name>
				<Source><![CDATA[
    private static void allocateTaxOnJourLine_RU(XmlElement _xmlPayment, LedgerJournalTrans _ledgerJournalTrans)
    {
        XmlElement              xmlPrepaymentTaxLinesElement;
        XmlNodeList             xmlPrepaymentTaxLinesList;
        XmlElement              xmlPrepaymentTaxLine;

        int                     i, elementsCount;
        TaxCode                 taxCode;
        TaxRegulationAmountCur  amount;

        xmlPrepaymentTaxLinesElement = _xmlPayment.getNamedElement('PrepaymentTaxLines');
        if (xmlPrepaymentTaxLinesElement)
        {
            xmlPrepaymentTaxLinesList = xmlPrepaymentTaxLinesElement.childNodes();
            if (xmlPrepaymentTaxLinesList)
            {
                elementsCount = xmlPrepaymentTaxLinesList.length();
                for (i = 0; i < elementsCount; i++)
                {
                    xmlPrepaymentTaxLine = xmlPrepaymentTaxLinesList.item(i);
                    taxCode = xmlPrepaymentTaxLine.getAttribute(TaxCodeStr);
                    amount = str2num(xmlPrepaymentTaxLine.getAttribute(AmountStr));

                    if (!TaxUncommitted::existForTaxCodeAndDirection(tableNum(LedgerJournalTrans),_ledgerJournalTrans.RecId, taxCode, TaxDirection::OutgoingTax))
                    {
                        throw error(strFmt("@SYP4860496", taxCode));
                    }

                    TaxWorkRegulation::adjustTaxWorkRegulation(tableNum(LedgerJournalTrans), _ledgerJournalTrans.RecId, taxCode, TaxDirection::OutgoingTax, -amount);
                }
                if (elementsCount > 0)
                {
                    //_ledgerJournalTrans.update() is called to recalculate adjusted tax.
                    _ledgerJournalTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDlvModeFromLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the delivery mode from the order sale lines
    /// </summary>
    /// <param name="_orderXml">
    /// Order/Quote xml
    /// </param>
    /// <param name="_PickupDeliveryMode">
    /// The default pickup delivery mode.
    /// </param>
    /// <returns>
    /// Returns the last non-pickup delivery mode if present, otherwise returns the last delivery mode.
    /// </returns>
    private static DlvModeId getDlvModeFromLines(ItemInfoCollection _itemInfos)
    {
        XmlElement  xmlRoot;
        XmlElement  xmlRecord;
        XmlNodeList xmlRecordList;
        DlvModeId   deliveryMode, shippingDeliveryMode;
        int i;
        ItemInfo    itemInfo;
        int         cnt;

        cnt = _itemInfos.get_Count();
        DlvModeId carryOutDlvModeId = RetailParameters::find().CarryOutDeliveryModeCode;

        //iterate the sales lines to find the delivery modes
        if (cnt > 0)
        {
            for (i = 0; i < cnt; i++)
            {
                itemInfo = _itemInfos.get_Item(i) as ItemInfo;
                deliveryMode = itemInfo.DeliveryMode;

                //If we found a non-pickup deliverymode, then cache it.
                if (deliveryMode && !RetailDlvMode::isPickupDeliveryMode(deliveryMode) && deliveryMode != carryOutDlvModeId)
                {
                    shippingDeliveryMode = deliveryMode;
                }
            }
        }

        //Pick the delivery mode...
        if (shippingDeliveryMode)
        {
            //If there is a non-pickup delivery mode, we need to set that on the header to enable POS shipping workflows
            return shippingDeliveryMode;
        }
        else
        {
            //Otherwise, just use the last delivery mode from the lines
            return deliveryMode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeMCRSalesLineForNewSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the mcrSalesLine with data from itemInfo.
    /// </summary>
    /// <param name = "salesLine">The base sales line.</param>
    /// <param name = "itemInfo">Item info from client.</param>
    private static void writeMCRSalesLineForNewSalesLine(SalesLine salesLine, ItemInfo itemInfo)
    {
        MCRSalesLine mcrSalesLine = salesLine.mcrSalesLine();

        // set gift card related info
        if (itemInfo.Giftcard)
        {
            DlvModeId   deliveryModeCode = RetailParameters::find().ElectronicDeliveryModeCode;
            CustTable   customer = CustTable::find(salesLine.CustAccount);

            mcrSalesLine.GiftCardType = salesLine.DlvMode == deliveryModeCode ? MCRGiftCardType::Email :  MCRGiftCardType::Physical;
            mcrSalesLine.GiftCardBuyerEmail = customer.email();
            mcrSalesLine.GiftCardBuyerName =  customer.name();
            mcrSalesLine.GiftCardNumber = itemInfo.GiftcardNumber;

            if (mcrSalesLine.GiftCardType == MCRGiftCardType::Email)
            {
                mcrSalesLine.GiftCardRecipientEmail = itemInfo.GiftcardDeliveryEmail;
                mcrSalesLine.GiftCardRecipientName =  itemInfo.GiftcardDeliveryEmail;
                mcrSalesLine.GiftCardGiftMessage = itemInfo.GiftcardDeliveryMessage;
            }
            else
            {
                mcrSalesLine.GiftCardRecipientName =  customer.name();
            }
        }

        if (!RetailUpdateExpediteValueBasedOnModeOfDeliveryFlight::instance().isEnabled())
        {
            // Update lines expedite value as per delivery mode.
            if (itemInfo.DeliveryMode && RetailUpdateMCRSalesLineExpediteFlight::instance().isEnabled())
            {
                mcrSalesLine.Expedite = DlvMode::find(itemInfo.DeliveryMode).mcrExpedite;
            }
        }

        mcrSalesLine.SourceId = itemInfo.SourceId;
        mcrSalesLine.ContinuityScheduleId = itemInfo.ContinuityScheduleId;
        mcrSalesLine.CustInvoiceTransRecId = itemInfo.CustInvoiceTransId;
        mcrSalesLine.ExchangeInventRefTransId = itemInfo.ExchangeInventTransId;
        mcrSalesLine.InstallmentEligible = itemInfo.IsInstallmentEligible;
        mcrSalesLine.LineType = itemInfo.LineType;
        mcrSalesLine.UpSellOrigin = itemInfo.UpSellOrigin;
        mcrSalesLine.UpSellOriginRef = itemInfo.UpSellOriginOfferId;
        mcrSalesLine.ParentLotId = itemInfo.ParentInventTransId;

        salesLine.mcrPackMCRSalesLine(mcrSalesLine);
        mcrSalesLine.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateGSTTransactionId</Name>
				<Source><![CDATA[
    private static void populateGSTTransactionId(SalesTable _salesTable, CustomerOrderInfo _custOrderInfo)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && RetailParameters::find().UpdateGSTTransactionId_IN)
        {
            RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(str2Int64(_custOrderInfo.ChannelRecordId));

            if (_salesTable.CustAccount != retailChannelTable.DefaultCustAccount)
            {
                TaxTransactionId_IN gstTransactionId;
                var extensionPropertyCollection = _custOrderInfo.ExtensionProperties;

                // Gets the GST transaction Id from the extension property.
                for (int i = 0; i < extensionPropertyCollection.get_Count(); i++)
                {
                    CLRObject commerceProperty =  extensionPropertyCollection.get_Item(i);

                    if (commerceProperty && commerceProperty.get_Key() == fieldStr(RetailSalesTable, GSTTransactionId_IN))
                    {
                        CLRObject commercePropertyValue = commerceProperty.get_Value();

                        gstTransactionId = commercePropertyValue.get_StringValue();

                        break;
                    }
                }

                RetailSalesTable retailSalesTable = RetailSalesTable::find(_salesTable.SalesId, true);

                ttsbegin;
                // If the GST transaction Id cannot be gotten from the extension properties, then assign GST transaction Id with ChannelReferenceId.
                retailSalesTable.GSTTransactionId_IN = gstTransactionId == '' ? _custOrderInfo.ChannelReferenceId : gstTransactionId;

                if (retailSalesTable.GSTTransactionId_IN && retailSalesTable.RecId != 0)
                {
                    retailSalesTable.GSTTransactionIdFromPOS_IN = NoYes::Yes;
                    retailSalesTable.update();
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCustomerOrderListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying the list of
    /// customer orders from <c>SalesTable</c> using specified filter conditions.
    /// </summary>
    /// <param name = "_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name = "_startDate">
    /// The starting date to return orders (default is DateTimeUtil::minValue).
    /// </param>
    /// <param name = "_endDate">
    /// The starting date to return orders (default is today's date).
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying the list of customer orders using specified filter conditions.
    /// </returns>
    protected static Query buildCustomerOrderListQuery(CustAccount _custAccount, utcDateTime _startDate , utcDateTime _endDate)
    {
        Query salesTableQuery = new Query();

        QueryBuildDataSource salesTableQueryBuildDS = salesTableQuery.addDataSource(tableNum(SalesTable));

        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesType));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, CustAccount));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesStatus));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesId));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, DocumentStatus));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, CreatedDateTime));

        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, CreatedDateTime)).value(SysQuery::range(_startDate, _endDate));

        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::Sales));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, CustAccount)).value(queryValue(_custAccount));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::None)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Backorder)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Delivered)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Invoiced)));

        return salesTableQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesQuotationTableListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying  from
    /// <c>SalesQuotationTable</c> using the specified filter conditions.
    /// </summary>
    /// <param name = "_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name = "_startDate">
    /// The starting date to return orders (default is DateTimeUtil::minValue).
    /// </param>
    /// <param name = "_endDate">
    /// The starting date to return orders (default is today's date).
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying list of records from <c>SalesQuotationTable</c> using specified filter conditions.
    /// </returns>
    protected static Query buildSalesQuotationTableListQuery(CustAccount _custAccount, utcDateTime _startDate , utcDateTime _endDate)
    {
        Query salesQuotationTableQuery = new Query();

        QueryBuildDataSource salesQuotationTableBuildDS = salesQuotationTableQuery.addDataSource(tableNum(SalesQuotationTable));

        salesQuotationTableBuildDS.addSelectionField(fieldNum(SalesQuotationTable, QuotationType));
        salesQuotationTableBuildDS.addSelectionField(fieldNum(SalesQuotationTable, CustAccount));
        salesQuotationTableBuildDS.addSelectionField(fieldNum(SalesQuotationTable, QuotationId));
        salesQuotationTableBuildDS.addSelectionField(fieldNum(SalesQuotationTable, QuotationStatus));
        salesQuotationTableBuildDS.addSelectionField(fieldNum(SalesQuotationTable, CreatedDateTime));

        salesQuotationTableBuildDS.addRange(fieldNum(SalesQuotationTable, CreatedDateTime)).value(SysQuery::range(_startDate, _endDate));

        salesQuotationTableBuildDS.addRange(fieldNum(SalesQuotationTable, QuotationType)).value(queryValue(SalesType::Sales));
        salesQuotationTableBuildDS.addRange(fieldNum(SalesQuotationTable, CustAccount)).value(queryValue(_custAccount));
        salesQuotationTableBuildDS.addRange(fieldNum(SalesQuotationTable, QuotationStatus)).value(strFmt(
            '((%1.%2 == %3) || (%1.%4 == %5) || (%1.%6 == %7))',
            salesQuotationTableBuildDS.name(),
            fieldStr(SalesQuotationTable, QuotationStatus), queryValue(SalesQuotationStatus::Created),
            fieldStr(SalesQuotationTable, QuotationStatus), queryValue(SalesQuotationStatus::Approved),
            fieldStr(SalesQuotationTable, QuotationStatus), queryValue(SalesQuotationStatus::Submitted)));

        return salesQuotationTableQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesOrderListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying the list of
    /// sales orders from <c>SalesTable</c> using specified filter conditions.
    /// </summary>
    /// <param name = "_salesId">
    /// The sales order id.
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying the list of sales orders using specified filter conditions.
    /// </returns>
    protected static Query buildSalesOrderListQuery(SalesId _salesId)
    {
        Query salesQuery = new Query();

        QueryBuildDataSource salesTableBuildDS = salesQuery.addDataSource(tableNum(SalesTable));

        salesTableBuildDS.addRange(fieldNum(SalesTable, SalesId)).value(queryValue(_salesId));
        salesTableBuildDS.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::Sales));
        salesTableBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::None)));
        salesTableBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Backorder)));

        return salesQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeCreatingRetailOrderLines</Name>
				<Source><![CDATA[
    static delegate void beforeCreatingRetailOrderLines(SalesTable _salesTable, CustomerOrderInfo _customerOrderInfo)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePostPaymentJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to be called for pre post payment journal.
    /// </summary>
    /// <param name = "_salesTable">The sales order table</param>
    /// <param name = "_ledgerJournalTable">The Ledger Journal table</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    static delegate void prePostPaymentJournal(SalesTable _salesTable, LedgerJournalTable _ledgerJournalTable, CustomerOrderInfo _custOrderInfo)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetOrderListCountCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the getOrderListCount.
    /// </summary>
    /// <param name = "_channelId">The channel RecId of store.</param>
    /// <param name = "_argFulfillmentTypeValues">The fulfillment types.</param>
    /// <param name = "_qbds">The count order List query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerGetOrderListCountCustomDataSources(RetailChannelRecId _channelId, List _argFulfillmentTypeValues, QueryBuildDataSource _qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>markPrePaymentsForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add/Update all pre-payment unsettled amounts to specTrans, to be settled against next invoice
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> bufferr of the order to be processed.</param>
    /// <param name = "_maxAmountToMark">The maximum amount of prepayments to be settled. Default to maximum.</param>
    /// <param name = "_settleNow">Set true to Settle transactions now. Default to false.</param>
    /// <returns>The Prepayment marked amount for the sales Order.</returns>
    public static Amount markPrePaymentsForSettlement(SalesTable  _salesTable, boolean _settleNow = false, Amount _maxAmountToMark = maxInt())
    {
        CustTrans custTransForPrepayment;
        CustTransOpen custTransOpenForPrepayment;
        LedgerJournalTrans ledgerJournalTrans;
        RetailPrePaymentTrans prepaymentTrans;
        SpecTransManager specTransManagerForPrepayment = SpecTransManager::newFromSpec(_salesTable);
        Amount totalMarkedPrepayments = 0.00;
        Amount amountAvailableToSettle, transAmountSettled;

        RetailTransactionServiceInvoiceContext context = RetailTransactionServiceInvoiceContext::current();
        TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);

        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), businessDate);
        boolean isCommercePaymentOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        if (countryRegion_W)
        {
            // Delete all already marked transactions of the current sales table
            specTransManagerForPrepayment.deleteAll();
        }

        if(isCommercePaymentOrder)
        {
            eventSource.EventWritePaymentsMarkPrePaymentsForSettlementForCommerceEnabledOrders(_salesTable.RecId);

            while select CurrencyCode, AmountCur, SettleAmountCur from custTransForPrepayment
                    where custTransForPrepayment.PaymReference == _salesTable.SalesId
                join TableId, RecId from custTransOpenForPrepayment
                    where custTransOpenForPrepayment.RefRecId == custTransForPrepayment.recId
                exists join Prepayment from ledgerJournalTrans
                    where custTransForPrepayment.Voucher == ledgerJournalTrans.Voucher &&
                      LedgerJournalTrans.Prepayment == NoYes::Yes
            {
                // If transaction amount is greater than maximum amount available for settlement, mark transaction for settlement in SpecTrans
                amountAvailableToSettle = abs(_maxAmountToMark) - abs(totalMarkedPrepayments);
                if (amountAvailableToSettle > 0)
                {
                    transAmountSettled = RetailTransactionPaymentsHelper::upsertPrepaymentsForSettlement(custTransForPrepayment,
                         custTransOpenForPrepayment,
                         specTransManagerForPrepayment,
                         currencyExchangeHelper,
                         totalMarkedPrepayments,
                        _maxAmountToMark);
                    totalMarkedPrepayments += abs(transAmountSettled);
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            while select prepaymentTrans
                where prepaymentTrans.SalesId == _salesTable.salesId
                join CurrencyCode, AmountCur, SettleAmountCur from custTransForPrepayment
                    where prepaymentTrans.CustTransRecId == custTransForPrepayment.RecId
                join TableId, RecId from custTransOpenForPrepayment
                    where custTransOpenForPrepayment.RefRecId == custTransForPrepayment.recId
            {
                // If transaction amount is greater than maximum amount available for settlement, mark transaction for settlement in SpecTrans
                amountAvailableToSettle = abs(_maxAmountToMark) - abs(totalMarkedPrepayments);
                if (amountAvailableToSettle > 0)
                {
                    transAmountSettled = RetailTransactionPaymentsHelper::upsertPrepaymentsForSettlement(custTransForPrepayment,
                         custTransOpenForPrepayment,
                         specTransManagerForPrepayment,
                         currencyExchangeHelper,
                         totalMarkedPrepayments,
                        _maxAmountToMark);
                    totalMarkedPrepayments += abs(transAmountSettled);
                }
                else
                {
                    // No available amounts to settle anymore ( The marked transaction amount is higher than the available for settlerment).
                    break;
                }
            }
        }

        // If a prepayment is being applied to an Accounts receivable order, then make sure to set the Settlement type to 'Designated transactions'.
        boolean isRetailPaymentsDepositForCallCenterOrderFlightEnabled = FeatureStateProvider::isFeatureEnabled(
            RetailPaymentsDepositForCallCenterOrderFlight::instance());

        if (isRetailPaymentsDepositForCallCenterOrderFlightEnabled
            && RetailTransactionPaymentsHelper::isSettlementTypeUpdateRequired(_salesTable, totalMarkedPrepayments))
        {
            RetailTransactionPaymentsHelper::setSettlementType(_salesTable, SettlementType::SelectedTransact);
            _salesTable.reread();
        }

        if (_settleNow)
        {
            // settle marked transactions (prepayments, including change back)
            // This settlement will force any change-back or cash-back to be settled
            // against payments with open balances.
            CustTransData custTransData = custTransForPrepayment.transData();

            custTransData.parmDatePrinciple(SettleDatePrinc::SelectDate);
            custTransData.parmSelectedDate(businessDate);

            custTransData.updateOffsetVoucher(SettlementType::OpenTransact, null, _salesTable);
        }

        return totalMarkedPrepayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markPaymentsForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add/Update all payment unsettled amounts to specTrans, to be settled against next invoice.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> bufferr of the order to be processed.</param>
    /// <param name = "_settleNow">Set true to Settle transactions now. Default to false.</param>
    /// <param name = "_maxAmountToMark">The maximum amount of prepayments to be settled. Default to maximum.</param>
    /// <returns>The Payment marked amount for the sales Order.</returns>
    public static Amount markPaymentsForSettlement(SalesTable  _salesTable, boolean _settleNow = false, Amount _maxAmountToMark = maxInt())
    {
        CustTrans custTransForPayment;
        CustTransOpen custTransOpenForPayment;
        LedgerJournalTrans ledgerJournalTrans;
        SpecTransManager specTransManagerForPayment = SpecTransManager::newFromSpec(_salesTable);
        Amount totalMarkedPayments = 0.00;
        Amount transAmountInCompanyCur, amountAvailableToSettle, transAmountToSettle;

        RetailTransactionServiceInvoiceContext context = RetailTransactionServiceInvoiceContext::current();
        TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);

        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), businessDate);
        boolean isUseCompanyCurrencyToTotalizeSettlementAmount = RetailOrdersFeatureControl::isUseCompanyCurrencyToTotalizeSettlementAmount();

        while select CurrencyCode, RecId, AmountCur, SettleAmountCur from custTransForPayment
                where custTransForPayment.PaymReference == _salesTable.SalesId
            join TableId, RecId, AmountCur from custTransOpenForPayment
                where custTransOpenForPayment.RefRecId == custTransForPayment.RecId
            exists join Prepayment from ledgerJournalTrans
                where custTransForPayment.Voucher == ledgerJournalTrans.Voucher &&
                      LedgerJournalTrans.Prepayment == NoYes::No
        {
            // Convert transaction amount to company currency
            transAmountInCompanyCur = currencyExchangeHelper.calculateTransactionToAccounting(custTransForPayment.CurrencyCode, custTransForPayment.AmountCur - custTransForPayment.SettleAmountCur, false);

            // If transaction amount is greater than maximum amount available for settlement, mark transaction for settlement in SpecTrans
            amountAvailableToSettle = abs(_maxAmountToMark) - abs(totalMarkedPayments);
            if (amountAvailableToSettle > 0)
            {
                if (abs(transAmountInCompanyCur) > amountAvailableToSettle)
                {
                    transAmountToSettle = currencyExchangeHelper.calculateAccountingToTransaction(custTransForPayment.CurrencyCode, amountAvailableToSettle * (custTransForPayment.AmountCur > 0 ? 1 : -1), false);
                }
                else
                {
                    transAmountToSettle = currencyExchangeHelper.calculateAccountingToTransaction(custTransForPayment.CurrencyCode, transAmountInCompanyCur, false);
                }

                if (specTransManagerForPayment.exist(custTransOpenForPayment.company(), custTransOpenForPayment.TableId, custTransOpenForPayment.RecId))
                {
                    specTransManagerForPayment.updateSettleAmount(
                                custTransOpenForPayment.company(),
                                custTransOpenForPayment.TableId,
                                custTransOpenForPayment.RecId,
                                transAmountToSettle);
                }
                else
                {
                    specTransManagerForPayment.insert(
                                custTransOpenForPayment.company(),
                                custTransOpenForPayment.TableId,
                                custTransOpenForPayment.RecId,
                                transAmountToSettle,
                                custTransForPayment.CurrencyCode);
                }

                totalMarkedPayments += abs(isUseCompanyCurrencyToTotalizeSettlementAmount ? transAmountInCompanyCur : transAmountToSettle);
            }
            else
            {
                // No available amounts to settle anymore ( The marked transaction amount is higher than the available for settlerment).
                break;
            }
        }

        if (_settleNow)
        {
            // settle marked transactions (prepayments, including change back)
            // This settlement will force any change-back or cash-back to be settled
            // against payments with open balances.
            CustTransData custTransData = custTransForPayment.transData();

            custTransData.parmDatePrinciple(SettleDatePrinc::SelectDate);
            custTransData.parmSelectedDate(businessDate);

            custTransData.updateOffsetVoucher(SettlementType::OpenTransact, null, _salesTable);
        }

        return totalMarkedPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markInvoicesForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add/Update all Invoice unsettled amounts to specTrans, to be settled by current prepayments and payments.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> bufferr of the order to be processed.</param>
    /// <returns>The invoice marked amount for the sales Order.</returns>
    public static Amount markInvoicesForSettlement(SalesTable  _salesTable)
    {
        CustTrans custTransForInvoice;
        CustTransOpen custTransOpenForInvoice;
        CustInvoiceJour custInvoiceJour;
        SpecTransManager specTransManagerForInvoice = SpecTransManager::newFromSpec(_salesTable);
        Amount totalMarkedInvoices = 0.00;

        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        if (countryRegion_W)
        {
            // Delete all already marked transactions of the current sales table
            specTransManagerForInvoice.deleteAll();
        }

        // Mark the invoices with open balance for settlement by payments and prepayments.
        while select RecId, TableId, AmountCur, SettleAmountCur, CurrencyCode from custTransForInvoice
            join LedgerVoucher from custInvoiceJour
            where custInvoiceJour.SalesId == _salesTable.SalesId
                &&  custInvoiceJour.InvoiceAccount ==  _salesTable.InvoiceAccount
                &&  custTransForInvoice.Voucher == custInvoiceJour.LedgerVoucher
            join custTransOpenForInvoice
            where custTransOpenForInvoice.RefRecId == custTransForInvoice.RecId
        {
            if (specTransManagerForInvoice.exist(custTransOpenForInvoice.company(), custTransOpenForInvoice.TableId, custTransOpenForInvoice.RecId))
            {
                specTransManagerForInvoice.updateSettleAmount(
                            custTransOpenForInvoice.company(),
                            custTransOpenForInvoice.TableId,
                            custTransOpenForInvoice.RecId,
                            custTransForInvoice.AmountCur - custTransForInvoice.SettleAmountCur);
            }
            else
            {
                specTransManagerForInvoice.insert(
                            custTransOpenForInvoice.company(),
                            custTransOpenForInvoice.TableId,
                            custTransOpenForInvoice.RecId,
                            custTransForInvoice.AmountCur - custTransForInvoice.SettleAmountCur,
                            custTransForInvoice.CurrencyCode);
            }

            totalMarkedInvoices += abs(custTransForInvoice.AmountCur - custTransForInvoice.SettleAmountCur);
        }

        return totalMarkedInvoices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareRetailSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Execute Retail auto-settlement
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_availablePrepaymentAmount">The deposit amount available for settlement.</param>
    public static void prepareRetailSettlements(SalesTable _salesTable, Amount _availablePrepaymentAmount)
    {
        Amount totalMarkedInvoices, totalMarkedPrepayments, totalMarkedPayments, availableAmountToSettle;

        // Collapse Payments and change-backs, settling them with each other (Deposits & Check-out Payments from POS)
        // Then add the residual Open Balances back to specTrans
        // Parameter _settleNow = true will force a settlement
        RetailTransactionServiceOrders::markPrePaymentsForSettlement(_salesTable, true);
        RetailTransactionServiceOrders::markPaymentsForSettlement(_salesTable, true);

        // Mark all previous Invoices with Open balances for Settlement
        totalMarkedInvoices = RetailTransactionServiceOrders::markInvoicesForSettlement(_salesTable);

        // Mark prepayments for settlement (deposits with Open balances)
        totalMarkedPrepayments = RetailTransactionServiceOrders::markPrePaymentsForSettlement(_salesTable, false, _availablePrepaymentAmount + totalMarkedInvoices);

        // Mark prepayments for settlement (deposits with Open balances)
        totalMarkedPayments = RetailTransactionServiceOrders::markPaymentsForSettlement(_salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockOnAccountPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlock On account payments, removing invoices from SpecTrans with open balances up to the On account authorized amount.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> bufferr of the order to be processed.</param>
    public static void unlockOnAccountPayments(SalesTable _salesTable)
    {
        SpecTrans specTransForBalance;
        SalesTable salesTableForBalance;
        CustInvoiceJour custInvoiceJourForBalance;
        CustTrans custTransForBalance;
        CustTransOpen custTransOpenForBalance;
        MCRCustPaymTotals mcrCustPaymTotals;
        AmountMST currentOnAccountBalance = 0.00;
        CustTable custTable = CustTable::find(_salesTable.InvoiceAccount);

        if (CustTable)
        {
            // Create new Settlement specification for the Customer Table (AR Settlements) and Sales Table (Retail)
            SpecTransManager specTransManagerAR = SpecTransManager::newFromSpec(custTable, false);
            SpecTransManager specTransManagerRetail = SpecTransManager::newFromSpec(_salesTable, false);

            if (_salesTable.mcrIsCallCenter())
            {
                // Calculate On-account payment  Total amount for Call center orders
                mcrCustPaymTotals = MCRCustPaymTotals::construct(_salesTable.TableId, _salesTable.RecId);
                currentOnAccountBalance = abs(mcrCustPaymTotals.getTotalPaymAmount_OnAccount());
            }

            // Find all Open Balance invoices
            while select AmountMST, SettleAmountMST from custTransForBalance
                        join RecId from custInvoiceJourForBalance
                            where custTransForBalance.Invoice == custInvoiceJourForBalance.InvoiceId
                        join TableId, RecId, AmountMST from custTransOpenForBalance
                            where custTransForBalance.RecId ==  custTransOpenForBalance.RefRecId
                        join SalesId from salesTableForBalance
                            where salesTableForBalance.SalesId == custInvoiceJourForBalance.SalesId &&
                                salesTableForBalance.SalesId == _salesTable.SalesId
            {
                // For call center orders, we unlock up to the limit of the "On-account" payments linked to the order
                if (_salesTable.mcrIsCallCenter() && abs(custTransOpenForBalance.AmountMST) <= abs(currentOnAccountBalance))
                {
                    // If there is still available "On-account" balance, delete the Invoice from the specification
                    specTransManagerAR.delete(custTransOpenForBalance.company(), custTransOpenForBalance.TableId, custTransOpenForBalance.RecId);

                    // Decrease on-account available amount
                    currentOnAccountBalance -= abs(custTransOpenForBalance.AmountMST);
                }

                // For other types of Sales Orders, we always delete invoices with open balances from specTrans
                // These invoices must be manually paid later from the AR->Payment Journal
                specTransManagerRetail.delete(custTransOpenForBalance.company(), custTransOpenForBalance.TableId, custTransOpenForBalance.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the invoice lines.
    /// </summary>
    /// <param name = "_xmlCriteriaRequest">The criteria request.</param>
    /// <param name = "_defaultRootElement">The default root element.</param>
    /// <param name = "_resultDoc">The result document.</param>
    /// <returns>The list of invoice lines.</returns>
    /// <remarks>
    /// Only called if the Unified Returns Feature or Returns for Multiple Invoices are enabled
    /// </remarks>
    public static container getInvoiceLines(str _xmlCriteriaRequest, XmlDocument _resultDoc = null, XmlElement _defaultRootElement = null)
    {
        boolean success = false;
        str errorMessage = '';
        int infologLine;
        RefRecId channelRecId;

        try
        {
            if (_resultDoc == null)
            {
                _resultDoc = XmlDocument::newBlank();
            }

            infologLine = Global::infologLine();
            XmlDocument criteriaXmlDoc = new XmlDocument();
            criteriaXmlDoc.loadXml(_xmlCriteriaRequest);
            XmlElement rootElement = criteriaXmlDoc.documentElement();

            // Build query.
            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(tableNum(RetailInvoiceLinesView));

            // Add sort by field.
            qbds.addSortField(fieldNum(RetailInvoiceLinesView, SalesId), SortOrder::Descending);
            qbds.addSortField(fieldNum(RetailInvoiceLinesView, SalesLineRecId), SortOrder::Ascending);

            // Add record identifiers criteria
            XmlElement invoiceLineRecIdsElement = rootElement.getNamedElement(InvoiceLineIdsElementName);

            // Get paging details
            int startingPosition = 1;
            int maxResultCount = 0;

            if (invoiceLineRecIdsElement != null)
            {
                XmlNodeList invoiceLineRecIds =  invoiceLineRecIdsElement.childNodes();

                for (int i = 0; i < invoiceLineRecIds.length(); i++)
                {
                    XmlNode invoiceLineRecIdNode = invoiceLineRecIds.item(i);
                    str invoiceLineRecIdStr = invoiceLineRecIdNode.text();
                    qbds.addRange(fieldNum(RetailInvoiceLinesView, CustInvoiceTransRecId)).value(invoiceLineRecIdStr);
                }

                // If parameter contains invoice line record identifiers, get max result count would be the count of this list.
                startingPosition = 1;
                maxResultCount = invoiceLineRecIds.length();
            }

            // Add invoice identifiers criteria.
            XmlElement invoiceIdsElement = rootElement.getNamedElement('InvoiceIds');

            if (invoiceIdsElement != null)
            {
                XmlNodeList invoiceIds =  invoiceIdsElement.childNodes();

                for (int i = 0; i < invoiceIds.length(); i++)
                {
                    XmlNode invoiceIdNode = invoiceIds.item(i);
                    str invoiceId = invoiceIdNode.text();
                    qbds.addRange(fieldNum(RetailInvoiceLinesView, InvoiceId)).value(queryValue(invoiceId));
                }
            }

            // Add sales identifiers criteria.
            XmlElement salesIdsRootElement = rootElement.getNamedElement('SalesIds');

            if (salesIdsRootElement != null)
            {
                XmlNodeList salesIds =  salesIdsRootElement.childNodes();

                for (int i = 0; i < salesIds.length(); i++)
                {
                    XmlNode salesIdNode = salesIds.item(i);
                    str salesId = salesIdNode.text();
                    qbds.addRange(fieldNum(RetailInvoiceLinesView, SalesId)).value(salesId);
                }
            }

            if (invoiceIdsElement != null || salesIdsRootElement != null)
            {
                [startingPosition, maxResultCount] = RetailTransactionServiceTransactions::parsePagingInfo(criteriaXmlDoc);
            }

            XmlElement channelRootElement = rootElement.getNamedElement('ChannelRecId');

            if (channelRootElement != null)
            {
                XmlNodeList channelIds =  channelRootElement.childNodes();

                for (int i = 0; i < channelIds.length(); i++)
                {
                    XmlNode channelIdNode = channelIds.item(i);
                    str channelId = channelIdNode.text();
                    channelRecId = str2Int64(channelId);
                }
            }

            QueryRun qr = new QueryRun(query);
            qr.enablePositionPaging(true);
            qr.addPageRange(startingPosition, maxResultCount);

            // Initialize xml return result
            XmlElement resultRootElement = _defaultRootElement != null ?
                _defaultRootElement: _resultDoc.createElement('InvoiceLinesResult');

            int resultCounter = 0;

            boolean allowLinkedRefunds = true;
            str invoiceId = strMin();
            str salesIds[maxResultCount];

            while (qr.next())
            {
                // Counter reaches max result. Stop fetching data.
                if (resultCounter >= maxResultCount)
                {
                    break;
                }

                RetailInvoiceLinesView viewResult = qr.get(tableNum(RetailInvoiceLinesView));
                CustInvoiceTrans custInvoiceTransResult = CustInvoiceTrans::findRecId(viewResult.CustInvoiceTransRecId);
                LanguageId languageId = CompanyInfo::languageId();
                EcoResProductTranslation translationResult = EcoResProductTranslation::findByProductLanguage(viewResult.ProductId, languageId);
                SalesLine salesLineResult = SalesLine::findRecId(viewResult.SalesLineRecId);
                InventDim inventDimResult = InventDim::find(viewResult.InventDimId);

                RetailTransactionServiceOrders::populateInvoiceOrderLine(_resultDoc, resultRootElement,
                    custInvoiceTransResult, translationResult, salesLineResult, inventDimResult, channelRecId);

                //if first invoice order line
                if (invoiceId == strMin())
                {
                    invoiceId = custInvoiceTransResult.InvoiceId;
                }

                //if returning multiple invoices
                else if(custInvoiceTransResult.InvoiceId != invoiceId)
                {
                    allowLinkedRefunds = false;
                }

                resultCounter++;
                salesIds[resultCounter] = salesLineResult.SalesId;
            }

            //if single invoice, allow linked refunds
            if (allowLinkedRefunds)
            {
                for (int i = 1; i <= resultCounter; i++)
                {
                    RetailTransactionServiceOrders::AddPaymentInformationXML(resultRootElement, SalesTable::find(salesIds[i]));
                }
            }

            //if multiple invoices, no linked refunds
            else
            {
                eventSource.EventWritePaymentsLinkedRefundsNotAllowedForMultipleInvoices();
            }

            _resultDoc.appendChild(resultRootElement);
            success = true;
        }
        catch (Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            eventSource.EventWriteOrdersGetInvoiceLinesError(funcName());
        }

        container result = [success, errorMessage, _resultDoc.toString()];
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLinesForReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the invoice lines for returns.
    /// </summary>
    /// <param name = "_xmlCriteriaRequest">The criteria request.</param>
    /// <returns>The list of invoice lines and a consolidated header.</returns>
    public static container getInvoiceLinesForReturn(str _xmlCriteriaRequest)
    {
        boolean success = true;
        str errorMessage = '';
        int infologLine;
        str xmlResult;
        XmlDocument resultDoc = XmlDocument::newBlank();

        try
        {
            infologLine = Global::infologLine();
            XmlDocument criteriaXmlDoc = new XmlDocument();
            criteriaXmlDoc.loadXml(_xmlCriteriaRequest);
            XmlElement rootElement = criteriaXmlDoc.documentElement();
            List invoicedLineIdsList = new List(Types::Int64);

            XmlElement invoiceLineRecIdsElement = rootElement.getNamedElement(InvoiceLineIdsElementName);

            if (invoiceLineRecIdsElement != null)
            {
                XmlNodeList invoiceLineRecIds =  invoiceLineRecIdsElement.childNodes();

                for (int i = 0; i < invoiceLineRecIds.length(); i++)
                {
                    XmlNode invoiceLineRecIdNode = invoiceLineRecIds.item(i);
                    str invoiceLineRecIdStr = invoiceLineRecIdNode.text();
                    RefRecId invoiceLineRecId = str2Int64(invoiceLineRecIdStr);
                    invoicedLineIdsList.addEnd(invoiceLineRecId);
                }

                Map consolidatedHeaderMap = RetailTransactionServiceOrders::consolidateOrderHeader(resultDoc, invoicedLineIdsList);
                success = consolidatedHeaderMap.lookup(SuccessKey);
                errorMessage = consolidatedHeaderMap.lookup(ErrorMessageKey);

                if (success)
                {
                    // Get the invoiced sales lines only if consolidating order header was successful.
                    XmlElement headerRootElement = consolidatedHeaderMap.lookup(ElementKey);
                    container salesLinesResultContainer = RetailTransactionServiceOrders::getInvoiceLines(_xmlCriteriaRequest, resultDoc, headerRootElement);
                    success = conPeek(salesLinesResultContainer, 1);
                    errorMessage = conPeek(salesLinesResultContainer, 2);
                    xmlResult = conPeek(salesLinesResultContainer, 3);
                }
            }
        }
        catch (Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            eventSource.EventWriteOrdersGetInvoiceLinesForReturnError(funcName());
        }

        return [success, errorMessage, xmlResult];
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirm the sales order.
    /// </summary>
    /// <param name = "_confirmSalesOrderParametersJsonString">
    /// A JSON formatted string of the parameters to confirm the sales order.
    /// </param>
    /// <returns>
    /// A JSON formatted string with the confirmed sales order.
    /// </returns>
    /// <remarks>
    /// Input JSON example:
    ///     {
    ///         "SalesId": "S01"
    ///     }
    /// </remarks>
    public static container confirmSalesOrder(str _confirmSalesOrderParametersJsonString)
    {
        System.Exception ex;
        str salesId;

        try
        {
            var parameters = RetailTransactionServiceOrders::getConfirmSalesOrderParametersFromJson(_confirmSalesOrderParametersJsonString);
            salesId = parameters.SalesId;
            RetailTransactionServiceOrders::confirmSalesOrderInternal(salesId);
        }
        catch (ex)
        {
            // TODO from fangzhan to fangzhan: add logging. Tracked by bug 841817.
            // eventSource.EventWriteConfirmSalesOrderError(ex.ToString());
            return [false, ex.Message, ''];
        }

        // Return the confirmed sales order.
        SalesTable salesTable;
        RetailSalesTable retailSalesTable;
        CustTable custTable; // Empty table buffer
        RetailTransactionTable retailTransactionTable; // Empty table buffer.

        RetailTransactionResultListHelper listHelper = new RetailTransactionResultListHelper(RetailTransactionServiceResultFormat::Json);
        select firstonly salesTable
            where salesTable.SalesId == salesId
        outer join retailSalesTable
            where retailSalesTable.SalesTable == salesTable.RecId;

        listHelper.AddSalesOrder(salesTable, retailSalesTable, custTable, retailTransactionTable, /* _includeDetails */ true);

        return [true, '', listHelper.Serialize()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmSalesOrderInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Internal implementation to confirm the sales order.
    /// </summary>
    /// <param name = "_salesId">
    /// The sales identifier.
    /// </param>
    internal static void confirmSalesOrderInternal(SalesId _salesId)
    {
        ttsbegin;
        SalesTable salesTable = SalesTable::find(_salesId, true);

        SalesFormLetter salesFormLetter = SalesFormLetter::construct(DocumentStatus::Confirmation);
        salesFormLetter.reArrangeNow(false);
        salesFormLetter.update(salesTable, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), SalesUpdate::All, AccountOrder::None, false, false, false);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDepositPaymentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove the deposit payment from the payment collection and store them to different collection.
    /// </summary>
    /// <param name = "_customerOrderInfo">The CustomerOrderInfo instance.</param>
    /// <returns>A collection of deposit payments.</returns>
    private static PaymentInfoCollection removeDepositPaymentType(CustomerOrderInfo _customerOrderInfo)
    {
        PaymentInfoCollection originalPayments = _customerOrderInfo.Payments;
        PaymentInfoCollection depositPayments = new PaymentInfoCollection();

        for (int i = 0; i < originalPayments.Count; i++)
        {
            PaymentInfo payment = originalPayments.get_Item(i) as PaymentInfo;

            if (payment.Prepayment)
            {
                depositPayments.Add(payment);
            }
        }

        // Remove deposit payments from original payments list.
        for (int i = 0; i < depositPayments.Count; i++)
        {
            originalPayments.Remove(depositPayments.get_Item(i) as PaymentInfo);
        }

        return depositPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsDepositAndInvoicePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value whether the payments contains deposit and invoice payments.
    /// </summary>
    /// <param name = "payments">List of payments to be validated.</param>
    /// <returns>True if payment collection contains deposit and invoice, false otherwise.</returns>
    private static boolean containsDepositAndInvoicePayments(PaymentInfoCollection payments)
    {
        boolean containsDeposit = false;
        boolean containsInvoicePayments = false;

        for (int i = 0; i < payments.Count; i++)
        {
            if (containsDeposit && containsInvoicePayments)
            {
                break;
            }

            PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;

            if (paymentInfo.Prepayment)
            {
                containsDeposit = true;
            }
            else
            {
                containsInvoicePayments = true;
            }
        }

        return containsDeposit && containsInvoicePayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLineUpdateToSettleCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the SalesLine records.
    /// </summary>
    /// <param name = "_salesLine">
    /// The sales line information for the given line.
    /// </param>
    /// <param name = "_inventDim">
    /// The product dimension for the given line.
    /// </param>
    /// <param name = "_itemInfo">
    /// The  product information from the client.
    /// </param>
    /// <param name = "_retailChannelTable">
    /// The retailChannelTable contains the selected online store information.
    /// </param>
    /// <param name = "_salesTable">
    /// The given sales order information.
    /// </param>
    public static void salesLineUpdateToSettleCustomerOrder(SalesLine _salesLine, inventDim _inventDim, ItemInfo _itemInfo, RetailChannelTable _retailChannelTable, SalesTable _salesTable)
    {
        boolean isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        _salesLine.InventDimId = _inventDim.InventDimId;
        _salesLine.SalesDeliverNow = _itemInfo.Quantity;

        if (!RetailCustomerOrderNetamountFlight::instance().isEnabled())
        {
            _salesLine.LineAmount = _itemInfo.NetAmount;
        }

        _salesLine.SalesPrice = _itemInfo.Price;
        _salesLine.TaxGroup = _itemInfo.SalesTaxGroup;
        _salesLine.TaxItemGroup = _itemInfo.ItemTaxGroup;

        _salesLine.setInventDeliverNow();
        _salesLine.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_salesLine.DefaultDimension, _retailChannelTable.DefaultDimension);

        if (isIndia)
        {
            RetailTransactionServiceOrders::initSalesLine_IN(_salesLine, _salesTable, _retailChannelTable, _itemInfo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerJournalTransForCancellationCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the total cancellation charge for the customer order and
    /// excludes the uncommitted taxes if any from the refund amount.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_salesTable">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <param name = "_chargeCode">
    /// Markup code for which total needs to be calculated.
    /// </param>
    /// <param name = "_defaultCurrencyCode">
    /// It is the default currency code.</param>
    /// <param name = "_voucher">
    /// Customer payment voucher number.
    /// </param>
    /// <param name = "_taxGroup">
    /// Sales tax group.
    /// </param>
    /// <param name = "_taxItemGroup">
    /// Item sales tax group.
    /// </param>
    /// <param name = "_totalChargeCodeAmount">
    /// Total charge code amount.
    /// </param>
    /// <param name = "_storeId">
    /// Retail store id.
    /// </param>
    /// <returns>
    /// True if journal transaction is added for cancellation charge, otherwise false.
    /// </returns>
    public static boolean addLedgerJournalTransForCancellationCharge(
                             LedgerJournalTable _ledgerJournalTable,
                             SalesTable _salesTable,
                             MarkupCode  _chargeCode,
                             currencyCode _defaultCurrencyCode,
                             Voucher _voucher,
                             TaxGroup _taxGroup,
                             TaxItemGroup _taxItemGroup,
                             Amount _totalChargeCodeAmount,
                             RetailStoreId _storeId
                             )
    {
        MarkupTable         markupTable;
        TaxUncommitted      taxUncommitted;
        TaxTable            taxTable;
        TaxAmountCur        exclusiveTaxAmountCur = 0;
        LedgerJournalTrans  ledgerJournalTrans;
        boolean             postCancellationCharge;
        boolean             isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        //Insert the charge first, the uncommitted taxes are calculated on .Insert()
        markupTable = MarkupTable::find(MarkupModuleType::Cust, _chargeCode);

        ledgerJournalTrans = RetailTransactionPaymentsHelper::CreateLedgerJournalTransForPayment(_ledgerJournalTable, _salesTable, _defaultCurrencyCode, _voucher);
        ledgerJournalTrans.TaxGroup                 = _taxGroup;
        ledgerJournalTrans.TaxItemGroup             = _taxItemGroup;
        ledgerJournalTrans.AmountCurDebit           = CurrencyExchangeHelper::amount(_totalChargeCodeAmount, _defaultCurrencyCode);
        ledgerJournalTrans.DefaultDimension         = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ledgerJournalTrans.DefaultDimension,
                                                                                    CustTable::find(_salesTable.CustAccount).DefaultDimension);

        postCancellationCharge = true;

        // Payment of cancellation charge for the order %1
        ledgerJournalTrans.Txt                      = strFmt("@RET260962", _salesTable.SalesId);

        if (markupTable.VendType == MarkupType::LedgerAccount)
        {
            ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
            ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, ledgerJournalTrans.DefaultDimension);
        }
        else
        {
            eventSource.EventWriteOrdersaddLedgerJournalTransForCancellationChargeWarning(funcName(), markupTable.RecId);
            postCancellationCharge = false;
        }

        if (postCancellationCharge)
        {
            ledgerJournalTrans.insert();
        }

        if (isIndia)
        {
            RetailTransactionService::setTaxInformationForJournalLine_IN(ledgerJournalTrans, _storeId);
        }

        //After .Insert, read back the uncommitted exclusive taxes, as these need to be excluded from the refundAmount
        if (!_ledgerJournalTable.LedgerJournalInclTax)
        {
            select sum(SourceRegulateAmountCur) from taxUncommitted
                where taxUncommitted.SourceTableId == ledgerJournalTrans.TableId
                    && taxUncommitted.SourceRecId == ledgerJournalTrans.Recid
                exists join taxTable
                    where taxTable.TaxCode == taxUncommitted.TaxCode
                        && taxTable.TaxType_IN == TaxType_IN::None
                                ;
            exclusiveTaxAmountCur = TaxUncommitted.SourceRegulateAmountCur;
        }

        if (isIndia)
        {
            exclusiveTaxAmountCur += ledgerJournalTrans.getIndirectExclusiveTaxAmountCur_IN();
        }

        return postCancellationCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the next sales id from the number sequence.
    /// </summary>
    /// <param name = "custOrderInfo">The CustomerOrderInfo the salesOrder is being created fo.</param>
    /// <returns>
    /// The new sales id.
    /// </returns>
    [Replaceable(true)]
    public static SalesIdBase getNextSalesId(CustomerOrderInfo custOrderInfo)
    {
        NumberSequenceReference salesOrderNumberSeqRef = RetailParameters::numRefSalesOrderId();
        if (!salesOrderNumberSeqRef.NumberSequenceId)
        {
            salesOrderNumberSeqRef = SalesParameters::numRefSalesId();
        }

        NumberSeq numberSeq = NumberSeq::newGetNum(salesOrderNumberSeqRef);
        numberSeq.used();

        return numberSeq.num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInvoiceOrderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the invoice order header.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document.</param>
    /// <param name = "_custInvoiceJour">Current row on CustInvoiceJour table.</param>
    /// <param name = "_salesTable">Current row on SalesTable table.</param>
    /// <param name = "_retailSalesTable">Current row on RetailSalesTable table.</param>
    /// <param name = "_loyaltyCard">Current row on RetailLoyaltyCard table.</param>
    /// <param name = "_CustTrans">Current row on CustTrans table.</param>
    /// <returns>An XML element represents the invoiced order header.</returns>
    private static XmlElement populateInvoiceOrderHeader(XmlDocument _xmlDoc, CustInvoiceJour _custInvoiceJour, SalesTable _salesTable, RetailSalesTable _retailSalesTable, RetailLoyaltyCard _loyaltyCard, CustTrans _custTrans)
    {
        boolean useAdvancedAutoCharges = RetailParameters::IsRetailAutoChargesEnabledAndInUse();
        XmlElement xmlRoot = _xmlDoc.createElement(tableStr(CustInvoiceJour));

        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, RecId), int642str(_custInvoiceJour.RecId));
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, InvoiceId), _custInvoiceJour.InvoiceId);
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, SalesId), _custInvoiceJour.SalesId);
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, SalesType), int2str(enum2int(_custInvoiceJour.SalesType)));
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, InvoiceDate),
                    RetailTransactionServiceUtilities::dateToString(_custInvoiceJour.InvoiceDate));
        xmlRoot.setAttribute(fieldStr(CustTrans, DueDate), RetailTransactionServiceUtilities::dateToString(_custTrans.DueDate));

        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, CurrencyCode), _custInvoiceJour.CurrencyCode);

        xmlRoot.setAttribute(InvoiceSubtotalAttribute, num2str(_custInvoiceJour.SalesBalance,5,3,1,0));
        xmlRoot.setAttribute(TotalChargesAttribute, num2str(_custInvoiceJour.SumMarkup,5,3,1,0));
        xmlRoot.setAttribute(TotalTaxAmountAttribute, num2str(_custInvoiceJour.SumTax,5,3,1,0));
        xmlRoot.setAttribute(TotalLineDiscountAttribute, num2str(_custInvoiceJour.SumLineDisc,5,3,1,0));
        xmlRoot.setAttribute(TotalDiscountAttribute, num2str(_custInvoiceJour.EndDisc + _custInvoiceJour.SumLineDisc,5,3,1,0));
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, InvoiceAmount), num2str(_custInvoiceJour.InvoiceAmount,5,3,1,0));
        xmlRoot.setAttribute(AmountPaidAttribute, num2str(_custTrans.SettleAmountCur,5,3,1,0));
        xmlRoot.setAttribute(AmountBalanceAttribute, num2str(_custInvoiceJour.InvoiceAmount - _custTrans.SettleAmountCur,5,3,1,0));

        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, InvoiceAccount), _custInvoiceJour.InvoiceAccount);
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, InvoicingName), _custInvoiceJour.InvoicingName);
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, DeliveryPostalAddress), int642str(_custInvoiceJour.DeliveryPostalAddress));
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, DlvMode), _custInvoiceJour.DlvMode);

        // Formatted as yyyy-MM-ddTHH:mm:ss
        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, CreatedDateTime), DateTimeUtil::toStr(_custInvoiceJour.CreatedDateTime));

        xmlRoot.setAttribute(#TotalManualDiscountAmount, RetailTransactionServiceOrders::amountToStr(_retailSalesTable.TotalManualDiscountAmount));
        xmlRoot.setAttribute(#TotalManualDiscountPercentage, RetailTransactionServiceOrders::percentToStr(_retailSalesTable.TotalManualDiscountPercentage));
        xmlRoot.setAttribute(#LoyaltyCardId, _loyaltyCard.CardNumber);
        xmlRoot.setAttribute(#CommissionSalesGroup, _salesTable.SalesGroup);
        xmlRoot.setAttribute(IsTaxExemptedForPriceInclusive, _retailSalesTable.IsTaxExemptedForPriceInclusive ? TrueStr : FalseStr);
        xmlRoot.setAttribute(IsTaxIncludedInPrice, int2str(_custInvoiceJour.InclTax));

        xmlRoot.setAttribute(fieldStr(CustInvoiceJour, OrderAccount), _custInvoiceJour.OrderAccount);
        xmlRoot.setAttribute(OrderedByCustomerNameStr, CustTable::find(_custInvoiceJour.OrderAccount).name());

        XmlElement xmlCharges = useAdvancedAutoCharges ?
            RetailTransactionServiceOrders::setHeaderAutoCharges(_xmlDoc, _custInvoiceJour.RecId, tableNum(CustInvoiceJour), true, _custInvoiceJour.SalesId) :
            RetailTransactionServiceOrders::setHeaderCharges(_xmlDoc, _custInvoiceJour.RecId, 0, true, _custInvoiceJour.SalesId);

        RetailInvoicePaidStatus invoicePaidStatus =
            _custTrans.Closed != dateNull() ? RetailInvoicePaidStatus::Paid :
            (_custTrans.SettleAmountCur == 0 ? RetailInvoicePaidStatus::Unpaid : RetailInvoicePaidStatus::PartiallyPaid);
        xmlRoot.setAttribute(InvoicePaidStatusValueAttribute, int2Str(invoicePaidStatus));

        xmlRoot.setAttribute(ChannelIdStr, int642str(_retailSalesTable.RetailChannel));
        xmlRoot.setAttribute(fieldStr(RetailSalesTable, ChannelReferenceId), _retailSalesTable.ChannelReferenceId);

        xmlRoot.appendChild(xmlCharges);

        XmlElement xmlSalesAffiliation = RetailSalesAffiliation::getSalesAffiliatonXML(_xmlDoc, _custInvoiceJour.SalesId);
        if (xmlSalesAffiliation)
        {
            xmlRoot.appendChild(xmlSalesAffiliation);
        }

        xmlRoot.setAttribute('SalesAgreementRecordId', int642Str(_salesTable.MatchingAgreement));

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInvoiceOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the invoice line from sales order.
    /// </summary>
    /// <param name = "_xmlDoc">The XML document.</param>
    /// <param name = "_xmlRoot">The root element.</param>
    /// <param name = "_custInvoiceTrans">Current row in CustInvoiceTrans table.</param>
    /// <param name = "_productTranslation">Current row in EcoResProductTranslation table.</param>
    /// <param name = "_salesLine">Current row in SalesLine table.</param>
    /// <param name = "_inventDim">Current row in InventDim table.</param>
    /// <param name = "_channelRecId">Retail channel record id.</param>
    private static void populateInvoiceOrderLine(XmlDocument _xmlDoc, XmlElement _xmlRoot, CustInvoiceTrans _custInvoiceTrans,
        EcoResProductTranslation _productTranslation, SalesLine _salesLine, InventDim _inventDim, RefRecId _channelRecId = 0)
    {
        boolean useAdvancedAutoCharges = RetailParameters::IsRetailAutoChargesEnabledAndInUse();
        XmlElement xmlRecord = _xmlDoc.createElement(tableStr(CustInvoiceTrans));
        InventTrackingRegisterTrans inventTrackingRegisterTrans;
        InventTrackingRegisterTransView inventTrackingRegisterTransView;
        InventDimCombination inventDimCombination;
        Percent factorForEffectiveAmount = 1;

        str inventSerialId = '';

        xmlRecord = _xmlDoc.createElement(tableStr(CustInvoiceTrans));

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, RecId), int642str(_custInvoiceTrans.RecId));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, InvoiceId), _custInvoiceTrans.InvoiceId);
        xmlRecord.setAttribute(fieldStr(SalesLine, SalesId), _salesLine.SalesId);
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, ItemId), _custInvoiceTrans.ItemId);
        xmlRecord.setAttribute(fieldStr(SalesLine, BarCode), _salesLine.BarCode);
        xmlRecord.setAttribute(productRecordIdAttribute, int642str(InventTable::getDistinctProductRecId(_custInvoiceTrans.ItemId, _inventDim)));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, SalesUnit), _custInvoiceTrans.SalesUnit);

        if (_productTranslation.Name == null || _productTranslation.Name == '')
        {
            xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), _custInvoiceTrans.Name);
        }
        else
        {
            xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), _productTranslation.Name);
        }

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, Name), _custInvoiceTrans.Name);
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, InventDimId), _custInvoiceTrans.InventDimId);
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, InventTransId), _custInvoiceTrans.InventTransId);

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, MCRDlvMode), _custInvoiceTrans.MCRDlvMode);
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, DlvDate),
                        RetailTransactionServiceUtilities::dateToString(_custInvoiceTrans.DlvDate));

        if (useAdvancedAutoCharges)
        {
            RetailTransactionServiceOrders::setLineLevelAutoCharges(_xmlDoc, xmlRecord, _custInvoiceTrans.RecId, tableNum(CustInvoiceTrans), _custInvoiceTrans.SalesId, _custInvoiceTrans.LineNum);
        }
        else
        {
            RetailTransactionServiceOrders::setLineLevelCharges(_xmlDoc, xmlRecord, _custInvoiceTrans.RecId, 0, _custInvoiceTrans.SalesId);
        }

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, Qty), num2str(_custInvoiceTrans.Qty, 0, 2, 1, 0));

        SalesQty qtyReturnable =  RetailTransactionServiceOrders::getReturnableQuantityForInvoiceLine(_custInvoiceTrans, _salesLine);
        xmlRecord.setAttribute(QtyReturnableStr, num2str(qtyReturnable, 0, 2, 1, 0));

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, SalesPrice), num2str(_custInvoiceTrans.SalesPrice, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, DiscPercent), num2str(_custInvoiceTrans.DiscPercent, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, DiscAmount), num2str(_custInvoiceTrans.DiscAmount, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, LineAmount), num2str(_custInvoiceTrans.LineAmount, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, LineAmountTax), num2str(_custInvoiceTrans.LineAmountTax, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, SalesMarkup), num2str(_custInvoiceTrans.SalesMarkup, 0, 2, 1, 0));
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, LineNum), RetailTransactionServiceUtilities::lineNumToString(_custInvoiceTrans.LineNum));

        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, TaxGroup), _custInvoiceTrans.TaxGroup);
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, TaxItemGroup), _custInvoiceTrans.TaxItemGroup);

        xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), _inventDim.InventBatchId);
        xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), _inventDim.wmsLocationId);
        xmlRecord.setAttribute('WmsPalletId', '');
        xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), _inventDim.InventSiteId);
        xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), _inventDim.InventLocationId);

        if (_inventDim.InventSerialId != '')
        {
            xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), _inventDim.InventSerialId);
        }
        else
        {
            // Might be a serial number with active in sales process
            while select firstonly RecId, InventTransOrigin from inventTrackingRegisterTrans
                            where inventTrackingRegisterTrans.FinancialRefTableId == _custInvoiceTrans.TableId
                                && inventTrackingRegisterTrans.FinancialRefRecId == _custInvoiceTrans.RecId
                            join InventSerialId from inventTrackingRegisterTransView
                                where inventTrackingRegisterTransView.RecId == inventTrackingRegisterTrans.RecId
                                    && inventTrackingRegisterTransView.InventTransOrigin == inventTrackingRegisterTrans.InventTransOrigin
            {
                inventSerialId = inventTrackingRegisterTransView.InventSerialId;
            }

            xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventSerialId);
        }

        RetailTransactionService::getInventDimValues(_custInvoiceTrans.ItemId, _inventDim, xmlRecord);

        xmlRecord.setAttribute(GuidStr, guid2str(newGuid()));
        xmlRecord.setAttribute(#UpdatedInAx, FalseStr);
        xmlRecord.setAttribute(#Message, '');
        xmlRecord.setAttribute(fieldStr(CustInvoiceTrans, DeliveryPostalAddress), int642str(_custInvoiceTrans.DeliveryPostalAddress));
        xmlRecord.setAttribute(fieldStr(SalesLine, RetailVariantId), _salesLine.RetailVariantId);
        xmlRecord.setAttribute(#CommissionSalesGroup, _salesLine.SalesGroup);

        inventDimCombination = InventDimCombination::findVariantId(_salesLine.RetailVariantId);
        xmlRecord.setAttribute('InventDimensionId', inventDimCombination.InventDimId);

        // Add details from retail sales line
        RetailTransactionServiceOrders::getRetailSalesLine(xmlRecord, _salesLine);

        factorForEffectiveAmount = 1;
        if (_salesLine.SalesQty > _custInvoiceTrans.Qty && _salesLine.SalesQty > 0)
        {
            factorForEffectiveAmount = _custInvoiceTrans.Qty / _salesLine.SalesQty;
        }

        if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            //Get line level price info
            RetailTransactionServiceOrders::addPriceLineXml(_xmlDoc, xmlRecord, _salesLine, false);
        }

        //Get line level discount info
        RetailTransactionServiceOrders::addDiscountLineXml(_xmlDoc, xmlRecord, _salesLine.salesPurchLineInterface(), false, factorForEffectiveAmount);

        //Get line level tax info
        RetailTransactionServiceOrders::addTaxLineXml(_xmlDoc, xmlRecord, _custInvoiceTrans.InvoiceId, _salesLine.ItemId, _salesLine.SalesId, _custInvoiceTrans.LineNum, _custInvoiceTrans.InvoiceDate, _channelRecId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) &&
            FeatureStateProvider::isFeatureEnabled(RetailGSTCopyTaxInformationForReturnCustomerOrdersFeature_IN::instance()))
        {
            XmlElement xmlCollection = RetailTransactionServiceOrders::fillSalesLineExtensionProprtiesForInvoice_IN(_xmlDoc, _salesLine);

            xmlRecord.appendChild(xmlCollection);
        }

        // set sales agreement related property.
        if (_salesLine.MatchingAgreementLine != 0)
        {
            XmlRecord.setAttribute('SalesAgreementLineRecordId', int642Str(_salesLine.MatchingAgreementLine));
        }

        xmlRecord.setAttribute('IsSalesAgreementSkipped', int2str(enum2int(_salesLine.AgreementSkipAutoLink)));

        // Call extension point to add custom data to existing invoice line.
        RetailPopulateInvoiceOrderLineParameters lineParameters = RetailPopulateInvoiceOrderLineParameters::construct();
        lineParameters.invoiceLineXmlElement = xmlRecord;
        lineParameters.custInvoiceTrans = _custInvoiceTrans;
        lineParameters.salesLine = _salesLine;
        lineParameters.inventDim = _inventDim;

        RetailCustomerOrderExtensions::populateInvoiceOrderLinePostAppend(lineParameters);

        _xmlRoot.appendChild(xmlRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>consolidateOrderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Consolidates the order header.
    /// </summary>
    /// <param name = "_xmlDoc">The xml document.</param>
    /// <param name = "invoiceLineIds">The list of invoice line identifiers.</param>
    /// <returns>A container consists of boolean value whether order is successfully consolidated,
    /// the error message (if any), and the consolidated header result.</returns>
    private static Map consolidateOrderHeader(XmlDocument _xmlDoc, List invoiceLineIds)
    {
        boolean success = true;
        str errorMessage = '';
        XmlElement orderHeader;
        ListIterator invoiceLineIterator = new ListIterator(invoiceLineIds);
        Set salesIdSet = new Set(Types::String);
        RetailInvoiceLinesView retailInvoiceLinesView;

        SalesId salesId;
        AccountNum currentAccount;
        RefRecId loyaltyCardRecId;

        // Order headers cannot be consolidated when they have the following.
        // * Different customer identifier.
        // * Different loyalty card identifier.

        while (invoiceLineIterator.more() && errorMessage == '')
        {
            RecId invoiceLineRecId = invoiceLineIterator.value();

            select firstonly SalesId, CustInvoiceJourRecId, CustAccount, RetailLoyaltyCardRecId from retailInvoiceLinesView
                where retailInvoiceLinesView.CustInvoiceTransRecId == invoiceLineRecId;

            if (retailInvoiceLinesView)
            {
                if (salesIdSet.elements() == 0)
                {
                    // Set the properties of the first sales id as a comparison
                    // with the rest of the iterator.
                    currentAccount = retailInvoiceLinesView.CustAccount;
                    loyaltyCardRecId = retailInvoiceLinesView.RetailLoyaltyCardRecId;
                    salesId = retailInvoiceLinesView.SalesId;
                    salesIdSet.add(salesId);
                }
                else if (!salesIdSet.in(retailInvoiceLinesView.SalesId))
                {
                    // Found a CustInvoiceTrans record with SalesId that does not in the SalesId set.
                    // Add the SalesId set with this new SalesId.
                    salesIdSet.add(retailInvoiceLinesView.SalesId);

                    if (currentAccount != retailInvoiceLinesView.CustAccount)
                    {
                        // Set error message when customer identifier is different from the current ones.
                        errorMessage = strFmt("@Ret_266467:ConsolidateOrderCustomerErrorMessage", salesId, retailInvoiceLinesView.SalesId);
                    }
                    else if (loyaltyCardRecId != retailInvoiceLinesView.RetailLoyaltyCardRecId)
                    {
                        // Set error message when loyalty card identifier is different from the current ones.
                        errorMessage = strFmt("@Ret_266467:ConsolidateOrderLoyaltyIdErrorMessage", salesId, retailInvoiceLinesView.SalesId);
                    }
                }
            }
            else
            {
                // No row is found, means the input parameter CustInvoiceTrans RecId does not exists.
                str invoiceRecIdStr = int642Str(invoiceLineRecId);
                errorMessage = strFmt("@Ret_266467:InvoiceLineRecIdNotExists", invoiceRecIdStr);
            }

            invoiceLineIterator.next();
        }

        SalesTable salesTable;
        CustInvoiceJour custInvoiceJour;
        RetailSalesTable retailSalesTable;
        RetailLoyaltyCard retailLoyaltyCard;
        CustTrans custTrans;

        if (errorMessage != '')
        {
            success = false;
        }
        else if (salesIdSet.elements() > 1)
        {
            // Multiple SalesIds are found, consolidate the order header.
            // Set default row on CustInvoiceJour, SalesTable, and RetailSalesTable table.
            CustInvoiceJour defaultCustInvoiceJour;
            defaultCustInvoiceJour.InvoiceAccount = currentAccount;
            SalesTable defaultSalesTable;
            RetailSalesTable defaultRetailSalesTable;
            CustTrans defaultCustTrans;

            // For RetailLoyaltyCard table, since the row has been validated to have the same card number,
            // we can use the current row found on retailLoyaltyCard instance.
            select firstonly RecId, CardNumber from retailLoyaltyCard where retailLoyaltyCard.RecId == retailInvoiceLinesView.RetailLoyaltyCardRecId;
            orderHeader = RetailTransactionServiceOrders::populateInvoiceOrderHeader(_xmlDoc, defaultCustInvoiceJour, defaultSalesTable, defaultRetailSalesTable, retailLoyaltyCard, defaultCustTrans);
        }
        else if (salesIdSet.elements() == 1)
        {
            // We only deal with one SalesId, populate invoice order header with the current row found on
            // the last query row.
            custInvoiceJour = CustInvoiceJour::findRecId(retailInvoiceLinesView.CustInvoiceJourRecId);
            salesTable = SalesTable::find(retailInvoiceLinesView.SalesId);
            retailSalesTable = RetailSalesTable::findSalesTable(salesTable);
            retailLoyaltyCard = RetailLoyaltyCard::find(retailInvoiceLinesView.RetailLoyaltyCardRecId);
            custTrans = custTrans::findVoucherDate(custInvoiceJour.LedgerVoucher, custInvoiceJour.InvoiceDate);
            orderHeader = RetailTransactionServiceOrders::populateInvoiceOrderHeader(_xmlDoc, custInvoiceJour, salesTable, retailSalesTable, retailLoyaltyCard, custTrans);
        }

        Map mapResult = new Map(Types::String, Types::AnyType);
        mapResult.insert(SuccessKey, success);
        mapResult.insert(ErrorMessageKey, errorMessage);
        mapResult.insert(ElementKey, orderHeader);

        return mapResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChargeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a markup transaction, get its commerce ChargeType.
    /// </summary>
    /// <param name = "_markupTrans">The markup transaction.</param>
    /// <returns>The commerce ChargeType of the markup transaction.</returns>
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.ChargeType getChargeType(MarkupTrans _markupTrans)
    {
        var chargeType = Microsoft.Dynamics.Commerce.Runtime.DataModel.ChargeType::ManualCharge;
        if (_markupTrans.IsAutoCharge)
        {
            chargeType = Microsoft.Dynamics.Commerce.Runtime.DataModel.ChargeType::AutoCharge;
        }

        return chargeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    // Check if the channel reference Id is not empty before setting the sales Id.
    // When customer order is created for posting scenario, channel reference Id is empty
    // and this assignment should be skipped.
    /// </summary>
    private static void updateSalesId(CustomerOrderInfo custOrderInfo)
    {

        if (custOrderInfo.ChannelReferenceId != '')
        {
            RetailChannelTable retailchanneltable;
            RetailCouponUsage retailCouponUsage;
            RetailChannelRecId channelRecId = str2Int64(custOrderInfo.ChannelRecordId);

            select firstonly ChannelType, RetailChannelId from retailchanneltable
                    where retailchanneltable.RecId == channelRecId;

            // Check if the sales order is created for retailstorefront scenario.
            if (retailchanneltable.ChannelType == RetailChannelType::SharePointOnlineStore)
            {
                // When sales order is created for online scenario, receipt id is empty
                // and retailCouponUsage table should be updated based on the transactionId
                while select forupdate SalesId from retailCouponUsage
                    where retailCouponUsage.TransactionId == custOrderInfo.TransactionId
                {
                    retailCouponUsage.SalesId = custOrderInfo.Id;
                    retailCouponUsage.doUpdate();
                }
            }
            else
            {
                if (RetailPricingRetrieveCouponUsageByTransactionIdFlight::instance().isEnabled())
                {
                    // Update salesId in the coupon usage table based on the transactionId and retailChannelId.
                    while select forupdate SalesId from retailCouponUsage
                        where retailCouponUsage.TransactionId == custOrderInfo.TransactionId
                            && retailCouponUsage.RetailChannelId == retailchanneltable.RetailChannelId
                    {
                        retailCouponUsage.SalesId = custOrderInfo.Id;
                        retailCouponUsage.doUpdate();
                    }
                }
                else
                {
                    // Update salesId in the coupon usage table based on the receiptId.
                    while select forupdate SalesId from retailCouponUsage
                        where retailCouponUsage.ReceiptId == custOrderInfo.ChannelReferenceId
                    {
                        retailCouponUsage.SalesId = custOrderInfo.Id;
                        retailCouponUsage.doUpdate();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatWithAllDecimals</Name>
				<Source><![CDATA[
    /// <summary>
    // Removes trailing zeros from decimal using G29 format.
    /// </summary>
    private static Str formatWithAllDecimals(real _value)
    {
        real decimalString = str2Num(num2str(_value, 5, 16, 1, 0));
        return System.String::Format(CultureInfo::InvariantCulture, '{0:G29}', decimalString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoiceForReturnedCarryOutItems</Name>
				<Source><![CDATA[
    /// <summary>
    // Post Invoice for "Carry Out" items and for returned items for Customer Order Return with Exchange mode.
    /// </summary>
    /// <param name="_items">
    /// List of items.
    /// </param>
    /// <param name="_isCustomerOrderWithExchange">
    /// Is Customer Order With Exchange.
    /// </param>
    /// <param name="_salesTable">
    /// Sales Order which was created.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// Invoice which may be created.
    /// </param>
    /// <param name="_invoiceNow">
    /// True if carryout lines will be invoiced during order creation.
    /// </param>
    [Wrappable(true)]
    protected static void postInvoiceForReturnedCarryOutItems(RetailCustomerOrderCarryoutParameters _parameters)
    {
        if (!_parameters.invoiceNow)
        {
            return;
        }

        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        var taxCalculationBehaviorController = RetailTaxCalculationBehaviorSalesTableController::construct(_parameters.salesTable);

        ItemInfoCollection items = _parameters.custOrderInfo.Items;

        // NOTE: "Carry Out" items have SalesDeliverNow > 0. The strategy here is to run over the sales lines
        // and find at least 1 "Carry Out" item. If found, an invoice is generated for ALL "Carry Out" items.
        // Note the break after the post execution. A single post will invoice all items with SalesDeliverNow > 0

        for (int i = 0; i < items.get_Count(); i++)
        {
            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;
            if ((RetailParameters::find().CarryOutDeliveryModeCode != '' && itemInfo.DeliveryMode == RetailParameters::find().CarryOutDeliveryModeCode) ||
                (_parameters.isCustomerOrderWithExchange && itemInfo.Quantity < 0))
            {
                // Mark payments with Open balance for Settlement
                RetailTransactionServiceOrders::markPaymentsForSettlement(_parameters.salesTable);

                RetailTransactionServiceInvoiceContext context = RetailTransactionServiceInvoiceContext::current();
                TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);

                // Invoice carry out items
                if (countryRegion_W)
                {
                    RetailTransactionServiceOrders::postSalesInvoiceForStatement_RU(_parameters.salesTable,
                                                                                            SalesUpdate::DeliverNow,
                                                                                            DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone())),
                                                                                            taxCalculationBehaviorController);
                }
                else
                {
                    // Set the Italy-specific reason code for sales order, if necessary.
                    if (RetailChronologicalInvoicePostingReasonCodeSetter::isEnabled())
                    {
                        RetailChronologicalInvoicePostingReasonCodeSetter reasonCodeSetter =
                            RetailChronologicalInvoicePostingReasonCodeSetter::constuct(_parameters.salesTable, businessDate);

                        reasonCodeSetter.setSalesReasonCode();
                    }

                    SalesFormLetter formLetter = SalesFormLetter::construct(DocumentStatus::Invoice);
                    taxCalculationBehaviorController.configureInvoicingToAllowLineLevelTaxAdjusments(formLetter);
                    formLetter.update(_parameters.salesTable, businessDate, SalesUpdate::DeliverNow);

                    if (FeatureStateProvider::isFeatureEnabled(RetailEInvoiceFeature_SA::instance()))
                    {
                        CustInvoiceJour custInvoiceJournal = formLetter.getOutputContract().parmJournal();
                        RetailCustInvoiceJourTable retailCustInvoiceJournal = custInvoiceJournal.retailCustInvoiceJourTable();

                        if (retailCustInvoiceJournal)
                        {
                            retailCustInvoiceJournal.selectForUpdate(true);
                            retailCustInvoiceJournal.IsEInvocieGeneratedFromPOS_SA = true;
                            retailCustInvoiceJournal.update();
                        }
                    }
                }
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoiceCarryoutLines</Name>
				<Source><![CDATA[
    /// NOTE: "Carry Out" items have SalesDeliverNow > 0. The strategy here is to run over the sales lines
    // and find at least 1 "Carry Out" item NOT yet invoiced. If found, an invoice is generated for ALL "Carry Out" items.
    // Note the break after the post execution. A single post will invoice all items with SalesDeliverNow > 0
    [Wrappable(true)]
    protected static void postInvoiceCarryoutLines(RetailCustomerOrderCarryoutParameters _parameters)
    {
        if (!_parameters.invoiceNow)
        {
            return;
        }

        ItemInfoCollection items = _parameters.custOrderInfo.Items;

        for (int i = 0; i < items.get_Count(); i++)
        {
            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;
            SalesLine salesLine = SalesLine::findRecId(itemInfo.RecId, false);
            if ( RetailParameters::find().CarryOutDeliveryModeCode != '' &&
                     itemInfo.DeliveryMode == RetailParameters::find().CarryOutDeliveryModeCode &&
                     salesLine.canInvoiceOrderLineFromCurrentSalesStatus())
            {
                using (RetailTransactionServiceInvoiceContext context = RetailTransactionServiceOrders::createRetailTransactionServiceInvoiceContext(_parameters.custOrderInfo))
                {
                    TransDate businessDate = RetailTransactionServiceOrders::getNewInvoiceBusinessDate(context);
                    boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
                    if(countryRegion_W)
                    {
                        CustInvoiceJour custInvoiceJour = RetailTransactionServiceOrders::postSalesInvoice_RU(_parameters.salesTable,
                                                                                                  SalesUpdate::DeliverNow,
                                                                                                  DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone())));
                    }
                    else
                    {
                        // Set the Italy-specific reason code for sales order, if necessary.
                        if (RetailChronologicalInvoicePostingReasonCodeSetter::isEnabled())
                        {
                            RetailChronologicalInvoicePostingReasonCodeSetter reasonCodeSetter =
                                RetailChronologicalInvoicePostingReasonCodeSetter::constuct(_parameters.salesTable, businessDate);

                            reasonCodeSetter.setSalesReasonCode();
                        }

                        SalesFormLetter formLetter = SalesFormLetter::construct(DocumentStatus::Invoice);
                        formLetter.update(_parameters.salesTable, businessDate, SalesUpdate::DeliverNow);
                    }
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddressUsingParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="_addressParameters">Address parameters</param>
    /// <returns>Logistics postal address RecordId.</returns>
    [Wrappable(true)]
    public static LogisticsPostalAddressRecId createAddressUsingParameters(RetailTransactionServiceOrdersAddressParameters _addressParameters)
    {
        return RetailTransactionServiceOrders::createAddress(
            _addressParameters.custAccount,
            _addressParameters.custName,
            _addressParameters.streetNumber,
            _addressParameters.street,
            _addressParameters.city,
            _addressParameters.districtName,
            _addressParameters.county,
            _addressParameters.state,
            _addressParameters.zip,
            _addressParameters.country,
            _addressParameters.phone,
            _addressParameters.email,
            _addressParameters.buildingCompliment,
            _addressParameters.roleContainer,
            _addressParameters.associateAddressToCustomer,
            _addressParameters.attentionTo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="_custAccount">Customer account.</param>
    /// <param name="_custName">Customer name.</param>
    /// <param name="_streetNumber">StreetNumber.</param>
    /// <param name="_street">Street.</param>
    /// <param name="_city">City.</param>
    /// <param name="_districtName">District Name.</param>
    /// <param name="_county">County.</param>
    /// <param name="_state">State.</param>
    /// <param name="_zip">Zip.</param>
    /// <param name="_country">Country.</param>
    /// <param name="_phone">Phone.</param>
    /// <param name="_eMail">Email.</param>
    /// <param name="_roleContainer">Logistics location role type.</param>
    /// <param name="_isDefaultCustomer">Mark if customer is default customer of online channel.</param>
    /// <param name="_attentionTo">Attention To address line.</param>
    /// <returns>Logistics postal address RecordId.</returns>
    private static LogisticsPostalAddressRecId createAddress(CustAccount _custAccount,
                                                             CustName _custName,
                                                             LogisticsAddressStreetNumber _streetNumber,
                                                             AddressStreet _street,
                                                             AddressCity _city,
                                                             LogisticsAddressDistrictName _districtName,
                                                             AddressCountyId _county,
                                                             AddressStateId _state,
                                                             AddressZipCodeId _zip,
                                                             AddressCountryRegionId _country,
                                                             Phone _phone,
                                                             EMail _eMail,
                                                             LogisticsAddressBuildingCompliment _buildingCompliment,
                                                             container _roleContainer,
                                                             boolean _isDefaultCustomer = false,
                                                             LogisticsAttentionToAddressLine _attentionTo = '')
    {
        boolean validInsert = false;
        LogisticsPostalAddress postalAddress;
        CustTable custTable;
        DirPartyPostalAddressView addressView;
        LogisticsLocation location;
        LogisticsPostalAddressEntity postalAddressEntity;
        LogisticsPostalAddressView logisticsPostalAddressView;
        DirPartyLocationEntity partyLocationEntity;
        LogisticsPostalAddressRecId logisticsPostalAddressRecId;

        if (_street == "" && _city == "" && _zip == "" && _county == "" && _country == "" && _eMail == "" && _phone == "")
        {
            return logisticsPostalAddressRecId;
        }

        custTable = CustTable::find(_custAccount);

        if (custTable)
        {
            addressView.StreetNumber = _streetNumber;
            addressView.Street = _street;
            addressView.City = _city;
            addressView.ZipCode = _zip;
            addressView.State = _state;
            addressView.County = _county;
            addressView.CountryRegionId = _country;
            addressView.DistrictName = _districtName;
            addressView.IsPrimary = NoYes::No;
            addressView.Party = new CustomerEntity(custTable, DateTimeUtil::utcNow()).getPartyRecId();
            addressView.BuildingCompliment = _buildingCompliment;

            // Create LogisticsPostalAddress and LogisticsLocation
            postalAddressEntity = LogisticsPostalAddressEntity::construct();
            logisticsPostalAddressView.initFromPartyPostalAddressView(addressView);
            postalAddress = postalAddressEntity.createPostalAddress(logisticsPostalAddressView);

            // Do not create an address for the default customer.
            if (postalAddress.RecId > 0 && !_isDefaultCustomer)
            {
                partyLocationEntity = DirPartyLocationEntity::construct(addressView.Party);
                partyLocationEntity.parmLocation(postalAddress.Location);

                // Create party links
                DirPartyLocationContract partyLocationContract = new DirPartyLocationContract();
                partyLocationContract.parmIsPrimary(addressView.IsPrimary);
                partyLocationContract.parmIsPrivate(addressView.IsPrivate);
                partyLocationContract.parmRoleIds(_roleContainer);

                partyLocationEntity.createOrUpdatePartyLocation(partyLocationContract);

                // Set the Attention-To address line if it has been provided.
                if (_attentionTo)
                {
                    DirPartyLocation partyLocation = DirPartyLocation::findByPartyLocation(addressView.Party, postalAddress.Location, true);

                    if (partyLocation)
                    {
                        partyLocation.AttentionToAddressLine = _attentionTo;
                        partyLocation.update();
                    }
                }
            }

            select forUpdate RecId from location where location.RecId == postalAddress.Location;
            location.Description = _custName;
            location.update();

            logisticsPostalAddressRecId = postalAddress.RecId;

            // Create LogisticsElectronicAddresses
            if (_eMail != "")
            {
                RetailTransactionServiceOrders::CreateLogisticsElectronicAddress(location.RecId, LogisticsElectronicAddressMethodType::Email, _eMail);
            }

            if (_phone != "")
            {
                RetailTransactionServiceOrders::CreateLogisticsElectronicAddress(location.RecId, LogisticsElectronicAddressMethodType::Phone, _phone);
            }
        }

        return logisticsPostalAddressRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Electronic Address.
    /// </summary>
    /// <param name="parentLocationId">
    /// Parent Location Id.
    /// </param>
    /// <param name="methodType">
    /// Represents LogisticsElectronicAddressMethodType.
    /// </param>
    /// <param name="locator">
    /// The value of the LogisticsElectronicAddressLocator.
    /// </param>
    private static void CreateLogisticsElectronicAddress(int64 parentLocationId, LogisticsElectronicAddressMethodType methodType, LogisticsElectronicAddressLocator locator)
    {
        LogisticsLocation location;
        LogisticsElectronicAddress electronicAddress;
        location.initValue();
        location.ParentLocation = parentLocationId;
        location.IsPostalAddress = NoYes::No;
        location.insert();

        electronicAddress.initValue();
        electronicAddress.Type = methodType;
        electronicAddress.Location = location.RecId;
        electronicAddress.Locator = locator;
        electronicAddress.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateAffilitaionsReasonCodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create or updated the reason code lines belongs to affiliations.
    /// </summary>
    /// <param name="_salesRecId">
    /// Sales Rec Id.
    /// </param>
    /// <param name="_custOrderInfo">
    /// Customer order information.
    /// </param>
    private static void createOrUpdateAffilitaionsReasonCodeLines(RecId _salesRecId, CustomerOrderInfo _custOrderInfo)
    {
        // Affiliations
        for (int i = 0; i < _custOrderInfo.Affiliations.get_Count(); i++)
        {
            AffiliationInfo affiliationInfo = _custOrderInfo.Affiliations.get_Item(i) as AffiliationInfo;
            ReasonCodeLineInfoCollection reasonCodeLines = ReflectionHelper::getObjectProperty(affiliationInfo, ReasonCodeLinesParamName) as ReasonCodeLineInfoCollection;
            if (reasonCodeLines != null)
            {
                RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(_salesRecId, affiliationInfo.AffiliationRecordId, reasonCodeLines, RetailInfoCodeLineRelatedTableType::Sales);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesQuotationByAffiliations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs affiliations and updates the quotation id of sales quotation.
    /// </summary>
    /// <param name = "_salesQuotationTable">
    /// SalesQuotationTable table buffer.
    /// </param>
    /// <param name = "_custOrderInfo">
    /// Customer order information table buffer.
    /// </param>
    protected static void updateSalesQuotationByAffiliations(SalesQuotationTable _salesQuotationTable, AffiliationInfoCollection _affiliations)
    {
        // Affiliations
        RetailSalesQuotationAffiliation::SetAffiliatonsAndLoyaltyTiers(_salesQuotationTable.QuotationId, _affiliations);

        for (int i = 0; i < _affiliations.get_Count(); i++)
        {
            AffiliationInfo affiliationInfo = _affiliations.get_Item(i) as AffiliationInfo;
            ReasonCodeLineInfoCollection reasonCodeLines = ReflectionHelper::getObjectProperty(affiliationInfo, ReasonCodeLinesParamName) as ReasonCodeLineInfoCollection;

            if (reasonCodeLines != null)
            {
                RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(_salesQuotationTable.RecId, affiliationInfo.AffiliationRecordId, reasonCodeLines, RetailInfoCodeLineRelatedTableType::Quote);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnableQuantityForInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given an invoice line for a given sales line, calculate what quantity can still be returned.
    /// </summary>
    /// <param name = "_custInvoiceTrans">The invoice line.</param>
    /// <param name = "_salesLine">The sales line.</param>
    /// <returns>The returnable quantity.</returns>
    internal static real getReturnableQuantityForInvoiceLine(CustInvoiceTrans _custInvoiceTrans, SalesLine _salesLine)
    {
        if (_custInvoiceTrans.Qty <= 0) // Cannot return against a return.
        {
            return 0;
        }
        else if (!RetailOrdersFeatureControl::allowOverReturnAgainstInvoiceLine())
        {
            return _custInvoiceTrans.Qty - _salesLine.mcrGetReturnedQty(); // Kept for backwards compatibility.
        }
        else
        {
            // The correct solution would always be to return _custInvoiceTrans.Qty - <quantity returned against that invoice>.
            // However, there is currently no way to calculate this in AX.
            // See https://msdyneng.visualstudio.com/FinOps/_workitems/edit/372788/ for more details.
            return min(_custInvoiceTrans.Qty, _salesLine.invoicedInTotal() - _salesLine.mcrGetReturnedQty());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasReturnLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if there exist any return lines in the custOrderInfo to determine if it is an exchange order.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info object with information about transaction and lines.
    /// </param>
    /// <returns>true if any lines have negative quantity; otherwise, false.</returns>
    [Hookable(false), Wrappable(false)]
    internal static boolean hasReturnLines(CustomerOrderInfo _custOrderInfo)
    {
        ItemInfoCollection items = _custOrderInfo.Items as ItemInfoCollection;
        boolean hasReturnLines = false;

        // Go through every item to check for negative quantity
        for (int i = 0; i < items.get_Count(); i++)
        {
            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;

            if (itemInfo.Quantity < 0)
            {
                hasReturnLines = true;
                break;
            }
        }

        return hasReturnLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCarryOutLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if there exist any carry out dlv mode lines in the custOrderInfo to determine.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info object with information about transaction and lines.
    /// </param>
    /// <returns>true if any lines have delivery mode carry out; otherwise, false.</returns>
    [Hookable(false), Wrappable(false)]
    internal static boolean hasCarryOutLines(CustomerOrderInfo _custOrderInfo)
    {
        ItemInfoCollection items = _custOrderInfo.Items as ItemInfoCollection;
        str carryOutDeliveryModeCode = RetailParameters::find().CarryOutDeliveryModeCode;
        boolean hasCarryOutLines = false;

        // Go through every item to check for negative quantity
        for (int i = 0; i < items.get_Count(); i++)
        {
            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;

            if (itemInfo.DeliveryMode == carryOutDeliveryModeCode)
            {
                hasCarryOutLines = true;
                break;
            }
        }

        return hasCarryOutLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkUpTransTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add markup trans tax adjustments to map when invoicing customer orders.
    /// </summary>
    /// <param name="retailOrderTable">
    /// Either the sales table or sales line.
    /// </param>
    /// <param name="charges">
    /// The charge info from customer order info.
    /// </param>
    /// <param name="taxAdjustmentsMap">
    /// Map to keep track of our tax adjustments from the header/line charges and lines.
    /// </param>
    /// <param name="isGteTaxCalculationType">
    /// Tax type to determine if we need to use special GTE tax logic.
    /// </param>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    [Hookable(false), Wrappable(false)]
    internal static void addMarkUpTransTaxAdjustments(Common _retailOrderTable, ChargeInfoCollection _charges, Map _taxAdjustmentsMap, boolean _isGteTaxCalculationType, Common _salesTable = null)
    {
        MarkupTrans markupTrans;
        Set         processedChargeLineNums = new Set(Types::Integer);

        for (int i = 0; i < _charges.get_Count(); i++)
        {
            ChargeInfo chargeInfo = _charges.get_Item(i) as ChargeInfo;

            // Select the charges that exists on the line for the sales order
            while select markupTrans
                    where markupTrans.TransRecId   == _retailOrderTable.RecId
                    && markupTrans.TransTableId == _retailOrderTable.TableId
                    && markupTrans.Value        == chargeInfo.Amount
                    && markupTrans.MarkupCode   == chargeInfo.Code
                    && markupTrans.TaxGroup     == chargeInfo.SalesTaxGroup
                    && markupTrans.TaxItemGroup == chargeInfo.TaxGroup
            {
                if (!processedChargeLineNums.in(markupTrans.LineNum))
                {
                    if (!_isGteTaxCalculationType)
                    {
                        RetailTransactionServiceOrders::CreateTaxLines(tableNum(MarkupTrans), markupTrans.RecId, chargeInfo.Taxes, _taxAdjustmentsMap);
                    }
                    else if (_salesTable)
                    {
                        RetailTransactionServiceOrders::CreateTaxMeasureAdjustments(_salesTable.TableId, _salesTable.RecId, markupTrans.TableId, markupTrans.RecId, chargeInfo.TaxMeasures, _taxAdjustmentsMap);
                    }

                    // Add line num to the set so we know not to use already created markupTrans recid
                    processedChargeLineNums.add(markupTrans.LineNum);
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete existing tax adjustments for the customer order as we want to honor what is coming from POS or recalculate in AX.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order info object with information about transaction and lines.
    /// </param>
    /// <param name="salesOrderRecId">
    /// The recId of the sales order created from the transaction.
    /// </param>
    [Hookable(false), Wrappable(false)]
    internal static void deleteExistingTaxAdjustments(CustomerOrderInfo _custOrderInfo, RecId _salesOrderRecId)
    {
        TaxWorkRegulation taxWorkRegulation;
        MarkupTrans markupTrans;
        SalesLine salesLine;

        // Delete header adjustments
        delete_from taxWorkRegulation
            where taxWorkRegulation.HeadingTableId == tableNum(SalesTable)
                && taxWorkRegulation.HeadingRecId == _salesOrderRecId;

        // Delete header charge adjustments
        for (int i = 0; i < _custOrderInfo.Charges.get_Count(); i++)
        {
            ChargeInfo chargeInfo = _custOrderInfo.Charges.get_Item(i) as ChargeInfo;

            // Delete the charges that exists on the header for the sales order
            delete_from taxWorkRegulation
                exists join markupTrans
                    where taxWorkRegulation.HeadingRecId == markupTrans.RecId
                       && taxWorkRegulation.HeadingTableId == tableNum(MarkupTrans)
                       && markupTrans.TransRecId == _salesOrderRecId
                       && markupTrans.TransTableId == tableNum(SalesTable);
        }

        ItemInfoCollection items = _custOrderInfo.Items as ItemInfoCollection;

        // Delete line tax adjustments
        for (int i = 0; i < items.get_Count(); i++)
        {
            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;

            delete_from taxWorkRegulation
                where taxWorkRegulation.HeadingTableId == tableNum(SalesLine)
                   && taxWorkRegulation.HeadingRecId == itemInfo.RecId;

            // Delete line charge tax adjustments
            for (int j = 0; j < itemInfo.Charges.get_Count(); j++)
            {
                ChargeInfo chargeInfo = itemInfo.Charges.get_Item(j) as ChargeInfo;

                // Delete the charges that exists on the lines for the sales line
                delete_from taxWorkRegulation
                    exists join markupTrans
                        where taxWorkRegulation.HeadingRecId == markupTrans.RecId
                           && taxWorkRegulation.HeadingTableId == tableNum(MarkupTrans)
                           && markupTrans.TransRecId == itemInfo.RecId
                           && markupTrans.TransTableId == tableNum(SalesLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingGTETaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete existing GTE tax adjustments for the customer order as we want to honor what is coming from POS or recalculate in AX.
    /// </summary>
    /// <param name="salesOrderRecId">
    /// The recId of the sales order created from the transaction.
    /// </param>
    [Hookable(false), Wrappable(false)]
    internal static void deleteExistingGTETaxAdjustments(RecId _salesOrderRecId)
    {
        TaxDocumentRowTaxDeterminedInfo determinedInfo;
        TaxDocumentRowDeterminedComponent determinedComponent;
        TaxDocumentRowMeasureAdjustment taxDocumentRowMeasureAdjustment;

        delete_from determinedComponent
        exists join determinedInfo
            where determinedInfo.RecId == determinedComponent.DeterminedInfo
                && determinedInfo.HeadingTableId == tableNum(SalesTable)
                && determinedInfo.HeadingRecId == _salesOrderRecId;

        delete_from determinedInfo
            where determinedInfo.HeadingTableId == tableNum(SalesTable)
                && determinedInfo.HeadingRecId == _salesOrderRecId;

        delete_from taxDocumentRowMeasureAdjustment
            where taxDocumentRowMeasureAdjustment.HeadingTableId == tableNum(SalesTable)
                && taxDocumentRowMeasureAdjustment.HeadingRecId == _salesOrderRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderListCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the count of retail orders that match the passed in criteria.
    /// </summary>
    /// <param name = "_channelId">The channel RecId of store.</param>
    /// <param name = "_argFulfillmentTypeValues">The fulfillment types.</param>
    /// <returns>[Count of orders to recall, last modified datetime of sale lines of qualified orders].</returns>
    private static container getOrderListCount(RetailChannelRecId _channelId, List _argFulfillmentTypeValues)
    {
        int resultsCount = 0;
        utcdatetime lastUpdatedDateTime = DateTimeUtil::minValue();
        if (!RetailImprovedRecallOrderOperationInPosFeatureExposure::isEnabledInFeatureManagement())
        {
            // if the "Improved Recall order operation in POS" feature was disabled and the user has configured the fulfill/ship/pickup action for recall orders operation,
            // the action would be ignored (user will see no orders on clicked button and entering the recall order form)
            eventSource.EventWriteRecallOrderNotificationCountsReturnZero(funcName());
            return [resultsCount, lastUpdatedDateTime];
        }

        Query query = new Query();
        QueryBuildDataSource qbdsRoot = query.addDataSource(tableNum(SalesTable));
        qbdsRoot.addRange(fieldNum(SalesTable, MCROrderStopped)).value(queryValue(NoYes::No));

        // Call extension point to add custom data sources.
        RetailTransactionServiceOrders::registerGetOrderListCountCustomDataSources(_channelId, _argFulfillmentTypeValues, qbdsRoot);

        QueryBuildDataSource qbdsRetailSalesTable = qbdsRoot.addDataSource(tableNum(RetailSalesTable));
        qbdsRetailSalesTable.fetchMode(QueryFetchMode::One2One);
        qbdsRetailSalesTable.joinMode(JoinMode::NoExistsJoin);
        qbdsRetailSalesTable.relations(true);
        qbdsRetailSalesTable.addRange(fieldNum(RetailSalesTable, StatementId)).value(SysQuery::valueNot(""));

        // settings for getRecallOrderQueryWithSalesLineCriteria.
        RetailStoreTable retailStoreTable = RetailStoreTable::findRecId(_channelId);
        RetailParameters retailParameters = RetailParameters::find();

        var enumerator = _argFulfillmentTypeValues.getEnumerator();
        boolean multiplePickupDeliveryModeEnabled = RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled();

        boolean hasPickupFulfillmentType = false;
        boolean hasShipFulfillmentType = false;

        while (enumerator.moveNext())
        {
            int argFulfillmentType = enumerator.current();
            if (argFulfillmentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.FulfillmentOperationType::Pickup)
            {
                hasPickupFulfillmentType = true;
            }
            else if (argFulfillmentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.FulfillmentOperationType::Ship)
            {
                hasShipFulfillmentType = true;
            }
        }
        // end settings for getRecallOrderQueryWithSalesLineCriteria.

        // prepare dlvMode-inventLocation temp table.
        RetailDlvModeInventLocationTmp dlvModeInventLocationTmp;
        if (multiplePickupDeliveryModeEnabled)
        {
            DlvMode dlvMode;
            InventLocationId inventLocation = retailStoreTable.inventLocation;
            DlvModeId carryOutDlvMode = retailParameters.CarryOutDeliveryModeCode;
            DlvModeId electronicDlvMode = retailParameters.ElectronicDeliveryModeCode;

            RetailDlvModeTmp pickupDlvModes = RetailDlvMode::getPickupDeliveryModes();

            if (hasPickupFulfillmentType)
            {
                insert_recordset dlvModeInventLocationTmp(DlvMode, InventLocationId)
                            select Code, inventLocation from pickupDlvModes;
            }

            if (hasShipFulfillmentType)
            {
                insert_recordset dlvModeInventLocationTmp(DlvMode, InventLocationId)
                                select Code, inventLocation from dlvMode
                                    where dlvMode.Code != carryOutDlvMode
                                        && dlvMode.Code != electronicDlvMode
                                    notexists join pickupDlvModes
                                    where dlvMode.Code == pickupDlvModes.Code;
            }
        }
        // end prepare dlvMode-inventLocation temp table.

        QueryBuildDataSource qbdsSalesLine = qbdsRoot.addDataSource(tableNum(SalesLine));
        qbdsSalesLine.fetchMode(QueryFetchMode::One2Many);
        qbdsSalesLine.joinMode(JoinMode::ExistsJoin);
        qbdsSalesLine.relations(true);

        RetailTransactionServiceOrders::getRecallOrderQueryWithSalesLineCriteria(qbdsSalesLine, retailStoreTable, retailParameters, multiplePickupDeliveryModeEnabled, hasPickupFulfillmentType, hasShipFulfillmentType);
        QueryRun qr = new QueryRun(query);
        if (multiplePickupDeliveryModeEnabled)
        {
            qr.setRecord(dlvModeInventLocationTmp);
        }

        Query finalQuery = qr.query();
        finalQuery.clearAllFields();
        finalQuery.dataSourceNo(1).addSelectionField(fieldnum(SalesTable, SalesId));

        Map targetToResourceMap = new Map(Types::String, Types::Container);
        targetToResourceMap.insert(fieldStr(SalesIdTempTable, SalesId), [finalQuery.dataSourceNo(1).uniqueId(), fieldStr(SalesTable, SalesId)]);

        SalesIdTempTable tempTable;
        Query::insert_recordset(tempTable, targetToResourceMap, finalQuery);

        select count(RecId) from tempTable;
        resultsCount = tempTable.RecId;

        // last updated datetime of sale lines matching criteria.
        if (resultsCount > 0)
        {
            Query lastUpdatedDateTimeQuery = new Query();
            QueryBuildDataSource newQbdsSalesLine = lastUpdatedDateTimeQuery.addDataSource(tableNum(SalesLine));
            newQbdsSalesLine.addSelectionField(fieldnum(SalesLine, ModifiedDateTime), SelectionField::Max);

            QueryBuildDataSource newQbdsWithSalesLineCriteria = RetailTransactionServiceOrders::getRecallOrderQueryWithSalesLineCriteria(newQbdsSalesLine, retailStoreTable, retailParameters, multiplePickupDeliveryModeEnabled, hasPickupFulfillmentType, hasShipFulfillmentType);

            QueryBuildDataSource newQbdsSalesIdTempTable = newQbdsWithSalesLineCriteria.addDataSource(tableNum(SalesIdTempTable));
            newQbdsSalesIdTempTable.joinMode(JoinMode::ExistsJoin);
            newQbdsSalesIdTempTable.addLink(fieldNum(SalesLine, SalesId), fieldNum(SalesIdTempTable, SalesId), newQbdsSalesLine.name());

            QueryRun newQueryRun = new QueryRun(lastUpdatedDateTimeQuery);
            if (multiplePickupDeliveryModeEnabled)
            {
                newQueryRun.setRecord(dlvModeInventLocationTmp);
            }
            newQueryRun.setRecord(tempTable);

            if (newQueryRun.next())
            {
                lastUpdatedDateTime = newQueryRun.get(tableNum(SalesLine)).ModifiedDateTime;
            }
        }
        // end last updated datetime of sale lines matching criteria.

        return [resultsCount, lastUpdatedDateTime];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecallOrderQueryWithSalesLineCriteria</Name>
				<Source><![CDATA[
    private static QueryBuildDataSource getRecallOrderQueryWithSalesLineCriteria(QueryBuildDataSource qbdsSalesLine, RetailStoreTable retailStoreTable, RetailParameters retailParameters,
        boolean multiplePickupDeliveryModeEnabled, boolean hasPickupFulfillmentType, boolean hasShipFulfillmentType)
    {
        qbdsSalesLine.addRange(fieldNum(SalesLine, SalesStatus)).value(int2Str(enum2int(SalesStatus::Backorder)));
        qbdsSalesLine.addRange(fieldNum(SalesLine, SalesStatus)).value(int2Str(enum2int(SalesStatus::Delivered)));

        QueryBuildDataSource qbdsInventDim = qbdsSalesLine.addDataSource(tableNum(InventDim));
        qbdsInventDim.relations(true);

        if (!multiplePickupDeliveryModeEnabled)
        {
            if (hasPickupFulfillmentType)
            {
                qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(
                                strFmt('((%1.%2 == "%3") && (%4.%5 == "%6"))',
                                    qbdsSalesLine.name(),
                                    fieldStr(SalesLine, DlvMode),
                                    retailParameters.PickUpDeliveryModeCode,
                                    qbdsInventDim.name(),
                                    fieldStr(InventDim, InventLocationId),
                                    retailStoreTable.InventLocation));
            }

            if (hasShipFulfillmentType)
            {
                qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(
                            strFmt('((%1.%2 != "%3") && (%1.%2 != "%4") && (%1.%2 != "%5") && (%6.%7 == "%8"))',
                                qbdsSalesLine.name(),
                                fieldStr(SalesLine, DlvMode),
                                retailParameters.PickUpDeliveryModeCode,
                                retailParameters.CarryOutDeliveryModeCode,
                                retailParameters.ElectronicDeliveryModeCode,
                                qbdsInventDim.name(),
                                fieldStr(InventDim, InventLocationId),
                                retailStoreTable.InventLocation));
            }

            return qbdsInventDim;
        }
        else
        {
            QueryBuildDataSource multiPickupQbdsDlvModeInventLocationTmp = qbdsInventDim.addDataSource(tableNum(RetailDlvModeInventLocationTmp));
            multiPickupQbdsDlvModeInventLocationTmp.joinMode(JoinMode::ExistsJoin);
            multiPickupQbdsDlvModeInventLocationTmp.addLink(fieldNum(SalesLine, DlvMode), fieldNum(RetailDlvModeInventLocationTmp, DlvMode), qbdsSalesLine.name());

            qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(retailStoreTable.InventLocation);

            return multiPickupQbdsDlvModeInventLocationTmp;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecallOrderNotificationLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets notification counts based on recall order lines.
    /// </summary>
    /// <param name = "_channelId">The channel id.</param>
    /// <returns>A container that has list of notification lines for given channel.</returns>
    internal static DataModel.NotificationDetailCollection getRecallOrderNotificationLines(RetailChannelRecId _channelId)
    {
        DataModel.NotificationDetailCollection result = new DataModel.NotificationDetailCollection();

        DataModel.NotificationDetail ordersToPickup = RetailTransactionServiceOrders::recallOrdersNotificationDetailInfo(
            _channelId,
            con2List([
                DataModel.FulfillmentOperationType::Pickup
            ]),
            "RECALLORDER_TO_PICKUP_RESOURCE_ID",
            int2Str(enum2Int(RetailFulfillmentType::Pickup))
        );
        DataModel.NotificationDetail ordersToShip = RetailTransactionServiceOrders::recallOrdersNotificationDetailInfo(
            _channelId,
            con2List([
                DataModel.FulfillmentOperationType::Ship
            ]),
            "RECALLORDER_TO_SHIP_RESOURCE_ID",
            int2Str(enum2Int(RetailFulfillmentType::Ship))
        );
        DataModel.NotificationDetail ordersToFulfill = RetailTransactionServiceOrders::recallOrdersNotificationDetailInfo(
            _channelId,
            con2List([
                DataModel.FulfillmentOperationType::Ship,
                DataModel.FulfillmentOperationType::Pickup
            ]),
            "RECALLORDER_TO_FULFILL_RESOURCE_ID",
            int2Str(enum2Int(RetailFulfillmentType::Fulfill))
        );

        result.Add(ordersToFulfill);
        result.Add(ordersToPickup);
        result.Add(ordersToShip);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recallOrdersNotificationDetailInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create recall order notification detail object.
    /// </summary>
    /// <param name = "_channelId">The channel RecId of store.</param>
    /// <param name = "_argFulfillmentTypeValues">The fulfillment types.</param>
    /// <param name = "_resourceId">The resource id for display text.</param>
    /// <param name = "_actionProperty">The action property of notification detail.</param>
    /// <returns>A notification line for orders count.</returns>
    private static DataModel.NotificationDetail recallOrdersNotificationDetailInfo(RetailChannelRecId _channelId, List _argFulfillmentTypeValues, str _resourceId, str _actionProperty)
    {
        int countOrders;
        utcdatetime lastUpdatedDateTime;
        [countOrders, lastUpdatedDateTime] = RetailTransactionServiceOrders::getOrderListCount(_channelId, _argFulfillmentTypeValues);
        DataModel.NotificationDetail result = new DataModel.NotificationDetail();

        result.DisplayText = _resourceId;
        result.ActionProperty = _actionProperty;
        result.ItemCount = countOrders;
        result.IsSuccess = true;
        if (countOrders)
        {
            result.LastUpdatedDateTimeStr = DateTimeUtil::toStr(lastUpdatedDateTime);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the channel default language if the associated channel has set default language,
    /// Otherwise get the language id from the invoice journal,
    /// Otherwise get the company default language.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId of store.</param>
    /// <param name = "_invoiceLanguageId">The languageid of invoice journal.</param>
    /// <returns>Returns the languageid of invoiced order.</returns>
    private static LanguageId getInvoiceLanguageId(RetailChannelRecId _channelRecId, LanguageId _invoiceLanguageId)
    {
        RetailChannelDefaultLanguage channelDefaultLanguage;

        str languageId;

        select firstonly languageId from channelDefaultLanguage
            where channelDefaultLanguage.Channel == _channelRecId;

        if (channelDefaultLanguage.LanguageId)
        {
            languageId = channelDefaultLanguage.LanguageId;
        }
        else if (_invoiceLanguageId)
        {
            languageId = _invoiceLanguageId;
        }
        else
        {
            languageId = CompanyInfo::find().LanguageId;
        }

        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCreatedOrderSynchronizationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    // We update set the synchronization status to pending so synchronizer job can update the sales transaction with order id
    // when it is  uploaded. This is required when order creation is running as part of asynchrononous operation.
    // Update RetailTransactionOrderStatus table with the last InventTransId for the sales order.
    // Retail server product availability APIs depend on this.
    /// </summary>
    /// <param name = "salesTable">Created sales order.</param>
    /// <param name = "custOrderInfo">Created sales order info object.</param>
    private static void setCreatedOrderSynchronizationStatus(SalesTable salesTable, CustomerOrderInfo custOrderInfo)
    {
        RetailCustomerOrderCreationContext context = RetailCustomerOrderCreationContext::current();

        if (context && context.parmShouldUpdateSynchronizationStatus())
        {
            SalesId createdSalesId = salesTable.SalesId;
            RefRecId lastInventTrans = RetailInventTransHelper::getLastInventTransForSalesOrder(createdSalesId);

            RetailTransactionOrderStatus::setOrderStatus(str2Int64(custOrderInfo.ChannelRecordId),
            custOrderInfo.StoreId,
            custOrderInfo.TerminalId,
            custOrderInfo.TransactionId,
            RetailTransactionOrderStatusType::PendingSynchronization,
            '', // No error details.
            createdSalesId,
            lastInventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRequestedDeliveryDateForOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set up the shipping date for order lines as the current date + 1 day during order creation for intercompany products.
    /// </summary>
    [Replaceable]
    protected static void setRequestedDeliveryDateForOrderLines(RetailOrderLineMap _orderLine)
    {
        date currentDate =  DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (_orderLine.ShippingDateRequested < currentDate)
        {
            date updatedDate = currentDate + 1;

            _orderLine.ShippingDateRequested = updatedDate;
            _orderLine.ReceiptDateRequested = updatedDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRequestedDeliveryDateForOrderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set up the shipping date for order header as the current date + 1 day during order creation for Intercompany products.
    /// </summary>
    [Replaceable]
    protected static void setRequestedDeliveryDateForOrderHeader(RetailOrderHeaderMap _orderHeader)
    {
        date currentDate =  DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (_orderHeader.ShippingDateRequested < currentDate)
        {
            date updatedDate = currentDate + 1;

            _orderHeader.ShippingDateRequested = updatedDate;
            _orderHeader.ReceiptDateRequested = updatedDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBatchIdForReturnCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// For return line which is batch controlled and do not have a batch number, we update the batchId from original sales inventtrans.
    /// </summary>
    /// <param name = "_inventDim">Inventory dimension of return line.</param>
    /// <param name = "_itemInfo">Item details of return line.</param>
    /// <returns>Updated or same inventory dimension.</returns>
    public static InventDim updateBatchIdForReturnCustomerOrder(InventDim _inventDim, ItemInfo _itemInfo)
    {
        if (_inventDim && !_inventDim.inventBatchId
            && EcoResDimensionGroupSetup::isInventoryDimensionActiveForItem(_itemInfo.ItemId, fieldNum(InventDim, InventBatchId)))
        {
            InventBatchId batchId = RetailTransactionServiceOrders::getBatchIdFromInventTrans(_itemInfo.ReturnInventTransId);

            if (batchId)
            {
                _inventDim.inventBatchId = batchId;
                _inventDim = InventDim::findOrCreate(_inventDim);
            }
        }

        return _inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchIdFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns batch number of the given inventory transaction id.
    /// </summary>
    /// <param name = "_inventTransId">Inventory transaction Id.</param>
    /// <returns>Batch number of given transaction id.</returns>
    private static InventBatchId getBatchIdFromInventTrans(InventTransId _inventTransId)
    {
        InventTrans inventTrans = InventTrans::findTransId(_inventTransId);
        InventDim inventDim = InventDim::find(inventTrans.inventDimId);

        return inventDim.inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConfirmSalesOrderParametersFromJson</Name>
				<Source><![CDATA[
    private static CrtTransactionService.TransactionServiceConfirmSalesOrderParameters getConfirmSalesOrderParametersFromJson(str parametersJsonString)
    {
        try
        {
            const str transactionServiceAssemblyName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService';
            const str TransactionServiceConfirmSalesOrderParametersTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceConfirmSalesOrderParameters';
            Assembly transactionServiceAssembly = Assembly::Load(transactionServiceAssemblyName);
            System.Type parametersType = transactionServiceAssembly.GetType(TransactionServiceConfirmSalesOrderParametersTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of client's version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CrtTransactionService.TransactionServiceConfirmSalesOrderParameters parameters = Newtonsoft.Json.JsonConvert::DeserializeObject(parametersJsonString, parametersType, settings);

            return parameters;
        }
        catch
        {
            throw error('Parsing json parameters failed.');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets language Id for customer order.
    /// </summary>
    /// <param name = "_custOrderInfo">The CustomerOrderInfo the salesOrder.</param>
    /// <param name = "_retailChannelTable">Buffer of RetailChannelTable.</param>
    /// <returns>
    /// Language id.
    /// </returns>
    private static LanguageId getCustomerOrderLanguageId(CustomerOrderInfo _custOrderInfo, RetailChannelTable _retailChannelTable)
    {
        LanguageId orderHeaderLanguageId;

        void assignTransactionOrChannelLangaugeId()
        {
            if (_custOrderInfo.LanguageId != null && _custOrderInfo.LanguageId != '')
            {
                orderHeaderLanguageId = _custOrderInfo.LanguageId;
            }
            else
            {
                LanguageId defaultChannelLangaugeId = RetailChannelDefaultLanguage::getChannelDefaultLanguageId(_retailChannelTable.RecId);

                orderHeaderLanguageId = (defaultChannelLangaugeId != null && defaultChannelLangaugeId != '') ? defaultChannelLangaugeId: CompanyInfo::find().LanguageId;
            }
        }

        if (_retailChannelTable.DefaultCustAccount != _custOrderInfo.CustomerAccount)
        {
            LanguageId custLanguageId = CustTable::find(_custOrderInfo.CustomerAccount).languageId();

            if (custLanguageId != null && custLanguageId != '')
            {
                orderHeaderLanguageId = custLanguageId;
            }
            else
            {
                assignTransactionOrChannelLangaugeId();
            }
        }
        else
        {
            assignTransactionOrChannelLangaugeId();
        }

        return orderHeaderLanguageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates notes for the given retail order header.
    /// </summary>
    /// <param name = "_recId">The retail order header record id.</param>
    /// <param name = "_tableId">The retail order header table id.</param>
    /// <param name = "_dataAreaId">The data area id.</param>
    /// <param name = "_noteInfoCollection">The collection of notes to be created.</param>
    /// <remarks>
    /// Today we only support adding notes for retail order headers.
    /// </remarks>
    private static void createNotes(
        RefRecId _recId,
        TableId _tableId,
        DataAreaId _dataAreaId,
        NoteInfoCollection _noteInfoCollection)
    {
        DocuRef docuRef;

        for (int i = 0; i < _noteInfoCollection.get_Count(); i++)
        {
            NoteInfo noteInfo = _noteInfoCollection.get_Item(i) as NoteInfo;

            // DocuRefRecId is only populated for existing notes and we do not support updating.
            if (!noteInfo.DocuRefRecId)
            {
                docuRef.clear();
                docuRef.initValue();

                docuRef.Name = noteInfo.Title;
                docuRef.Notes = noteInfo.Description;
                docuRef.Restriction = noteInfo.Restriction;

                docuRef.RefCompanyId = _dataAreaId;
                docuRef.ActualCompanyId = _dataAreaId;
                docuRef.TypeId = DocuType::typeNote();
                docuRef.RefTableId = _tableId;
                docuRef.RefRecId = _recId;

                docuRef.validateWrite();
                docuRef.insert();
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>