<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SettlementUtility</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SettlementUtility</c> class contains a collection of static methods
/// to be used during settlement.
/// </summary>
public static class SettlementUtility
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>reverseTransAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses amounts on <c>CustVendTrans</c> map record.
    /// </summary>
    /// <param name = "_vendTrans">
    /// The <c>CustVendTrans</c> map record that contains amounts to reverse.
    /// </param>
    public static void reverseTransAmounts(CustVendTrans _vendTrans)
    {
        if (_vendTrans.TableID != tableNum(VendTrans))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        _vendTrans.AmountCur                = - _vendTrans.AmountCur;
        _vendTrans.AmountMST                = - _vendTrans.AmountMST;
        _vendTrans.SettleAmountCur          = - _vendTrans.SettleAmountCur;
        _vendTrans.SettleAmountMST          = - _vendTrans.SettleAmountMST;
        _vendTrans.ExchAdjustment           = - _vendTrans.ExchAdjustment;
        _vendTrans.ExchAdjustmentRealized   = - _vendTrans.ExchAdjustmentRealized;
        _vendTrans.ExchAdjustmentUnrealized = - _vendTrans.ExchAdjustmentUnrealized;
        _vendTrans.ReportingCurrencyAmount  = - _vendTrans.ReportingCurrencyAmount;
        _vendTrans.SettleAmountReporting    = - _vendTrans.SettleAmountReporting;
        _vendTrans.ExchAdjustmentReporting  = - _vendTrans.ExchAdjustmentReporting;
        _vendTrans.ReportingExchAdjustmentRealized = - _vendTrans.ReportingExchAdjustmentRealized;
        _vendTrans.ReportingExchAdjustmentUnrealized = - _vendTrans.ReportingExchAdjustmentUnrealized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTransOpenAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses amounts on <c>CustVendTransOpen</c> map record.
    /// </summary>
    /// <param name = "_vendTransOpen">
    /// The <c>CustVendTransOpen</c> map record that contains amounts to reverse.
    /// </param>
    public static void reverseTransOpenAmounts(CustVendTransOpen _vendTransOpen)
    {
        if (_vendTransOpen.TableID != tableNum(VendTransOpen))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        _vendTransOpen.AmountCur         = - _vendTransOpen.AmountCur;
        _vendTransOpen.AmountMST         = - _vendTransOpen.AmountMST;
        _vendTransOpen.ExchAdjUnrealized = - _vendTransOpen.ExchAdjUnrealized;
        _vendTransOpen.PossibleCashDisc  = - _vendTransOpen.PossibleCashDisc;
        _vendTransOpen.ReportingCurrencyAmount    = - _vendTransOpen.ReportingCurrencyAmount;
        _vendTransOpen.ExchAdjUnrealizedReporting = - _vendTransOpen.ExchAdjUnrealizedReporting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSpecTransAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses amounts on <c>SpecTrans</c> table record.
    /// </summary>
    /// <param name = "_specTrans">
    /// The <c>SpecTrans</c> table record that contains the amounts to reverse.
    /// </param>
    public static void reverseSpecTransAmounts(SpecTrans _specTrans)
    {
        _specTrans.Balance01 = -_specTrans.Balance01;
        _specTrans.CashDiscToTake = -_specTrans.CashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundTransactionAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the amounts for the specified transactions.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record that contains the fields to round.
    /// </param>
    /// <param name="_specTrans">
    /// The SpecTrans record that contains the fields to round.
    /// </param>
    /// <param name="_mstCurrencyCode">
    /// The monetary standard currency code for the transaction company.
    /// </param>
    public static void roundTransactionAmounts(
        CustVendTrans _custVendTrans,
        SpecTrans _specTrans,
        CurrencyCode _mstCurrencyCode)
    {
        CurrencyCode reportingCurrencyCode = Ledger::reportingCurrency(CompanyInfo::findDataArea(_custVendTrans.company()).RecId);

        _custVendTrans.AmountCur       = CurrencyExchange::round(_custVendTrans.AmountCur, _custVendTrans.CurrencyCode);
        _custVendTrans.SettleAmountCur = CurrencyExchange::round(_custVendTrans.SettleAmountCur, _custVendTrans.CurrencyCode);

        _specTrans.Balance01           = CurrencyExchange::round(_specTrans.Balance01, _custVendTrans.CurrencyCode);

        // change to MST currency
        _custVendTrans.AmountMST       = CurrencyExchange::round(_custVendTrans.AmountMST, _mstCurrencyCode);
        _custVendTrans.SettleAmountMST = CurrencyExchange::round(_custVendTrans.SettleAmountMST, _mstCurrencyCode);

        // change to reporting currency
        _custVendTrans.ReportingCurrencyAmount = CurrencyExchange::round(_custVendTrans.ReportingCurrencyAmount, reportingCurrencyCode);
        _custVendTrans.SettleAmountReporting = CurrencyExchange::round(_custVendTrans.SettleAmountReporting, reportingCurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the sign of an amount if necessary.
    /// </summary>
    /// <param name = "_amount">The amount that is adjusted.</param>
    /// <param name = "_module">The module that is used to determine if the sign of the amount needs to be adjusted.</param>
    /// <returns>The sign adjusted amount.</returns>
    public static AmountMST adjustAmountSign(AmountMST _amount, SysModule _module)
    {
        AmountMST correctedAmount;

        switch (_module)
        {
            case SysModule::Cust:
                correctedAmount = _amount;
                break;

            case SysModule::Vend:
                correctedAmount = _amount * -1.0;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return correctedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxInaccurateAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the maximum amount an invoice and payment may differ during settlement.
    /// </summary>
    /// <param name = "_module">The module of the parameters used to determine the maximum inaccurate amount.</param>
    /// <returns>The real amount that an invoice and payment may differ by during settlement.</returns>
    public static AmountMST maxInaccurateAmountMST(SysModule _module)
    {
        AmountMST maxInaccurateAmountMST;
        AmountMST maxMSTOverUnder;
        AmountMST maxMSTPennyDiff;

        switch (_module)
        {
            case SysModule::Cust:
                CustParameters custParameters = CustParameters::find();
                maxMSTOverUnder = custParameters.MaxMSTOverUnder;
                maxMSTPennyDiff = custParameters.MaxMSTDiff;
                break;

            case SysModule::Vend:
                VendParameters vendParameters = VendParameters::find();
                maxMSTOverUnder = vendParameters.MaxMSTOverUnder;
                maxMSTPennyDiff = vendParameters.MaxMSTDiff;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (maxMSTOverUnder != 0.0)
        {
            maxInaccurateAmountMST = maxMSTOverUnder;
        }
        else
        {
            maxInaccurateAmountMST = maxMSTPennyDiff;
        }

        return maxInaccurateAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountCurToAmountCurCrossCompany</Name>
				<Source><![CDATA[
    // Refactor: Move to CurrencyExchangeHelper and either combine with calculateTransactionToTransaction() or create new API.
    // The timing and method will be decided by the currency framework team.
    /// <summary>
    ///    Converts the amount from one currency to another, considering that the currencies may be from
    ///    different companies.
    /// </summary>
    /// <param name="_fromCompany">
    ///    The company in which the currency and amount originates.
    /// </param>
    /// <param name="_fromCurrency">
    ///    The currency in which the <paramref name="_fromAmount" /> is given.
    /// </param>
    /// <param name="_fromAmount">
    ///    The amount to be converted, given in the currency specified by <paramref name="_fromCurrency" />.
    /// </param>
    /// <param name="_toCompany">
    ///    The company in which the target currency exists.
    /// </param>
    /// <param name="_toCurrency">
    ///    The target currency for the conversion.
    /// </param>
    /// <param name="_exchRateDate">
    ///    The date used to find exchange rates.
    /// </param>
    /// <param name="_rounding">
    ///    A Boolean value that determines whether the final amount should be rounded according to the target
    ///    company and currency setup; optional.
    /// </param>
    /// <param name="_crossCompanyCurrencyCompany">
    ///    The company in which the cross company exchange should occur. By default this is the originating
    ///    company; optional.
    /// </param>
    /// <param name="_fromExchRate">
    ///    The exchange rate used to convert from the originating currency to the MST currency of the
    ///    originating company; optional.
    /// </param>
    /// <param name="_toExchRate">
    ///    The exchange rate used to convert to the target currency from the MST currency of the target
    ///    company; optional.
    /// </param>
    /// <returns>
    ///    The converted amount in the target currency.
    /// </returns>
    /// <remarks>
    ///    When converting from one currency to another between companies, conversion is first done to the MST
    ///    currency of the originating company, then to the target company MST currency, and finally to the
    ///    target currency. This is important when all currencies do not necessarily exist in all companies.
    ///    Exchange rates for the first step are taken from the originating company, and the exchange rates
    ///    for the last step are taken from the target currency.For the middle step, the default is to take
    ///    the exchange rates from the originating company, but this can be overwritten with the <paramref
    ///    name="_crossCompanyCurrencyCompany" /> parameter.
    /// </remarks>
    public static AmountCur convertAmountCurToAmountCurCrossCompany(
        CompanyId _fromCompany,
        CurrencyCode _fromCurrency,
        AmountCur _fromAmount,
        CompanyId _toCompany,
        CurrencyCode _toCurrency,
        TransDate _exchRateDate,
        boolean _rounding = true,
        CompanyId _crossCompanyCurrencyCompany = _fromCompany,
        ExchRate _fromExchRate = 0.0,
        ExchRate _toExchRate = 0.0)
    {
        AmountCur totalSettleAmount;
        CompanyId specCompanyCurrency;
        CompanyId refCompanyCurrency;
        AmountMST refAmountMst;
        CurrencyExchangeHelper currencyHelper;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_fromCompany).RecId), _exchRateDate);

        if (_fromCurrency == _toCurrency)
        {
            // Currencies are the same, no conversion needed
            totalSettleAmount = _fromAmount;
        }
        else
        {
            if (_fromExchRate != 0.0)
            {
                refAmountMst = CurrencyExchange::calculateAmount(_fromAmount, _fromExchRate);
            }
            else
            {
                // Set helper to convert to fromCompany currency - use rate from fromCompany
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_fromCompany).RecId));
                refAmountMst = currencyHelper.calculateTransactionToAccounting(_fromCurrency, _fromAmount, false);
            }

            if (_fromCompany != _toCompany)
            {
                // Get company currencies
                changecompany(_fromCompany)
                {
                    refCompanyCurrency = CompanyInfoHelper::standardCurrency();

                    currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_crossCompanyCurrencyCompany).RecId));
                }

                changecompany(_toCompany)
                {
                    specCompanyCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (refCompanyCurrency != specCompanyCurrency)
                {
                    // Convert to spec ref company currency, interim result unrounded
                    refAmountMst = currencyHelper.calculateAccountingToTransaction(specCompanyCurrency, refAmountMst, false);
                }
            }

            // Set helper to convert to new currency
            currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_toCompany).RecId));

            if (_toExchRate != 0.0)
            {
                // Note: we need to take the reciprocal of the exchange rate here because CurrencyExchHelper::calculateAmount
                // method actually treats the exchange rate passed in as an 100 based ratio on the amount passed in.
                refAmountMst = CurrencyExchange::calculateAmount(refAmountMst, (100.0 * (100.0 / _toExchRate)));
                totalSettleAmount = _rounding ? CurrencyExchange::round(refAmountMst,_toCurrency) : refAmountMst;
            }
            else
            {
                // Convert to spec currency - lookup rate, optionally round result
                totalSettleAmount = currencyHelper.calculateAccountingToTransaction(_toCurrency, refAmountMst, _rounding);
            }
        }

        return totalSettleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFullSettlementAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the full settlement amount to the transaction currency.
    /// </summary>
    /// <param name = "_specTrans">The <c>SpecTrans</c> record that contains information about the full settlement amount.</param>
    /// <param name = "_currencyCode">The currency code that the returned amount will be in.</param>
    /// <param name = "_fullSettlementAmount">The full settlement amount to convert.</param>
    /// <returns>The full settlement amount converted to a different currency.</returns>
    public static AmountCur convertFullSettlementAmount(
        SpecTrans _specTrans,
        CurrencyCode _currencyCode,
        AmountCur _fullSettlementAmount)
    {
        AmountCur fullSettlementAmount;

        changecompany(_specTrans.SpecCompany)
        {
            switch (_specTrans.SpecTableId)
            {
                case tableNum(LedgerJournalTrans):
                    fullSettlementAmount = SettlementUtility::convertFullSettlementAmountForLedgerJournalTrans(
                        _specTrans,
                        _currencyCode,
                        _fullSettlementAmount);
                    break;

                case tableNum(CustTable), tableNum(VendTable):
                    fullSettlementAmount = SettlementUtility::convertFullSettlementAmountForCustVendTable(
                        _specTrans,
                        _currencyCode,
                        _fullSettlementAmount);
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        return fullSettlementAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFullSettlementAmountForLedgerJournalTrans</Name>
				<Source><![CDATA[
    private static AmountCur convertFullSettlementAmountForLedgerJournalTrans(
        SpecTrans _specTrans,
        CurrencyCode _currencyCode,
        AmountCur _fullSettlementAmount)
    {
        AmountCur fullSettlementAmount;
        LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_specTrans.SpecRecId, false);

        if (ledgerJournalTrans)
        {
            ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode);

            fullSettlementAmount = SettlementUtility::convertAmountCurToAmountCurCrossCompany(
                ledgerJournalTrans.company(),
                ledgerJournalTrans.CurrencyCode,
                _fullSettlementAmount,
                _specTrans.RefCompany,
                _currencyCode,
                ledgerJournalTrans.TransDate,
                true,
                _specTrans.RefCompany,
                exchangeRateHelper.prepareExchangeRateForStorage(ledgerJournalTrans.crossrate()));
        }

        return fullSettlementAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFullSettlementAmountForCustVendTable</Name>
				<Source><![CDATA[
    private static AmountCur convertFullSettlementAmountForCustVendTable(
        SpecTrans _specTrans,
        CurrencyCode _currencyCode,
        AmountCur _fullSettlementAmount)
    {
        AmountCur fullSettlementAmount;
        CustVendTable custVendTable = SettlementUtility::findCustVendTableByRecId(_specTrans.SpecRecId, _specTrans.SpecTableId);

        if (custVendTable)
        {
            fullSettlementAmount = SettlementUtility::convertAmountCurToAmountCurCrossCompany(
                custVendTable.company(),
                custVendTable.Currency,
                _fullSettlementAmount,
                _specTrans.RefCompany,
                _currencyCode,
                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                true,
                _specTrans.RefCompany);
        }

        return fullSettlementAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTableByRecId</Name>
				<Source><![CDATA[
    private static CustVendTable findCustVendTableByRecId(RecId _recId, TableId _tableId)
    {
        CustVendTable custVendTable;

        switch (_tableId)
        {
            case tableNum(CustTable):
                custVendTable = CustTable::findRecId(_recId);
                break;

            case tableNum(VendTable):
                custVendTable = VendTable::findRecId(_recId);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVoucherLedgerDimension_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension from the original voucher.
    /// </summary>
    /// <param name="_vendTrans">
    /// A <c>VendTrans</c> table buffer to be used to retrieve the related voucher
    /// </param>
    /// <returns>
    /// The ledger dimension for the original voucher.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If the PublicSector configuration key is not enabled a wrong use of function exception will be thrown.
    /// </exception>
    public static LedgerDimensionAccount findVoucherLedgerDimension_PSN(VendTrans _vendTrans)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerEntryJournal ledgerEntryJournal;

        if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (strLen(_vendTrans.JournalNum) > 0)
        {
            select firstonly crossCompany LedgerDimension from generalJournalAccountEntry
                where generalJournalAccountEntry.PostingType == LedgerPostingType::LedgerJournal
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                        && subledgerVoucherGeneralJournalEntry.Voucher == _vendTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _vendTrans.DataAreaId
                        && subledgerVoucherGeneralJournalEntry.AccountingDate == _vendTrans.TransDate
                exists join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                exists join ledgerEntryJournal
                    where ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal
                        && ledgerEntryJournal.JournalNumber == _vendTrans.JournalNum;
        }
        else
        {
            select firstonly crossCompany LedgerDimension from generalJournalAccountEntry
                where generalJournalAccountEntry.PostingType == LedgerPostingType::LedgerJournal
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                        && subledgerVoucherGeneralJournalEntry.Voucher == _vendTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _vendTrans.DataAreaId
                        && subledgerVoucherGeneralJournalEntry.AccountingDate == _vendTrans.TransDate;
        }

        return generalJournalAccountEntry.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSettleFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the percent of the transaction that is being settled.
    /// </summary>
    /// <param name="_transAmount">
    /// The amount of the transaction in the transaction currency.
    /// </param>
    /// <param name="_alreadySettledAmount">
    /// The amount already settled in the transaction currency.
    /// </param>
    /// <param name="_amountToSettle">
    /// The amount to settle in the transaction currency.
    /// </param>
    /// <param name="_cashDiscountAmount">
    /// The cash discount amount in the transaction currency.
    /// </param>
    /// <returns>
    /// The percent of the unsettled transaction that is being settled.
    /// </returns>
    /// <remarks>
    /// The value for the <paramref name="_amountToSettle" /> parameter does not include any cash discount.
    /// </remarks>
    public static Percent calcSettleFactor(
        AmountCur _transAmount,
        AmountCur _alreadySettledAmount,
        AmountCur _amountToSettle,
        AmountCur _cashDiscountAmount)
    {
        Percent settleFactor;
        AmountCur previousUnsettledAmount;

        // SettleAmountCur was previously updated for the cash discount, so now need to add in the cash discount amount.
        previousUnsettledAmount = _transAmount - _alreadySettledAmount + _cashDiscountAmount;

        if (previousUnsettledAmount == 0.0)
        {
            settleFactor = 1.0;
        }
        else
        {
            settleFactor = abs((_amountToSettle + _cashDiscountAmount) / previousUnsettledAmount);
        }

        return settleFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCashDiscountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount ledger dimension.
    /// </summary>
    /// <param name = "_module">
    /// The <c>SysModule</c> for which to find the ledger dimension.
    /// </param>
    /// <param name="_custVendTrans">
    /// The customer or vendor transaction.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open customer or vendor transaction.
    /// </param>
    /// <param name="_cashDiscountCode">
    /// The cash discount code.
    /// </param>
    /// <param name="_considerTaxLedgerDimension">
    /// true if the tax ledger dimension should be considered; otherwise, false.
    /// </param>
    /// <returns>
    /// The cash discount ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount determineCashDiscountLedgerDimension(
        SysModule _module,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        CashDiscCode _cashDiscountCode,
        boolean _considerTaxLedgerDimension = true)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        changecompany(_custVendTrans.company())
        {
            ledgerDimension = _custVendTransOpen.CashDiscountLedgerDimension;

            if (!ledgerDimension)
            {
                ledgerDimension = SettlementUtility::findCashDiscountAccountFromInvoice(
                    _module,
                    _custVendTrans.Invoice,
                    _custVendTrans.AccountNum,
                    _custVendTrans.TransDate,
                    _custVendTrans.Voucher,
                    _custVendTrans.OffsetRecId,
                    _considerTaxLedgerDimension,
                    _cashDiscountCode);
            }

            if (!ledgerDimension && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                ledgerDimension = SettlementUtility::findCashDiscountAccountFromJournalPosting_PSN(_custVendTrans, _cashDiscountCode);
            }

            if (!ledgerDimension && _cashDiscountCode != '')
            {
                ledgerDimension = SettlementUtility::findCashDiscountAccountFromCashDiscountCode(_module, _cashDiscountCode);

                if (ledgerDimension)
                {
                    // check if ledger account exists in the chart of accounts
                    boolean accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId);

                    if (!accountExists)
                    {
                        ledgerDimension = SettlementUtility::cashDiscountSystemLedgerDimension(_module);
                    }
                }
            }

            if (!ledgerDimension)
            {
                ledgerDimension = SettlementUtility::findCashDiscountAccountFromCustomerOrVendor(_custVendTrans);
            }

            if (!ledgerDimension)
            {
                ledgerDimension =  SettlementUtility::cashDiscountSystemLedgerDimension(_module);
            }

            return ledgerDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountAccountFromInvoice</Name>
				<Source><![CDATA[
    private static LedgerDimensionDefaultAccount findCashDiscountAccountFromInvoice(
        SysModule _module,
        InvoiceId _invoiceId,
        AccountNum _invoiceAccount,
        TransDate _invoiceDate,
        Voucher _invoiceVoucher,
        RecId _offsetRecId,
        boolean _considerTaxLedgerDimension,
        CashDiscCode _cashDiscountCode)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        CustVendInvoiceJour custVendInvoiceJour;
        ModuleCustVend moduleCustVend;

        switch (_module)
        {
            case SysModule::Cust:
                CustInvoiceJour custInvoiceJourBuffer;
                custVendInvoiceJour = custInvoiceJourBuffer;
                moduleCustVend = ModuleCustVend::Cust;
                break;

            case SysModule::Vend:
                VendInvoiceJour vendInvoiceJourBuffer;
                custVendInvoiceJour = vendInvoiceJourBuffer;
                moduleCustVend = ModuleCustVend::Vend;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        select firstonly custVendInvoiceJour
            where custVendInvoiceJour.InvoiceId == _invoiceId
                && custVendInvoiceJour.InvoiceAccount == _invoiceAccount
                && custVendInvoiceJour.InvoiceDate == _invoiceDate
                && custVendInvoiceJour.LedgerVoucher == _invoiceVoucher;

        if (!custVendInvoiceJour)
        {
            CustVendTrans custVendTransOffset = CustVendTrans::findByModule(moduleCustVend, _offsetRecId);

            if (custVendTransOffset)
            {
                select firstonly custVendInvoiceJour
                    where custVendInvoiceJour.InvoiceId == custVendTransOffset.Invoice
                        && custVendInvoiceJour.InvoiceAccount == custVendTransOffset.AccountNum
                        && custVendInvoiceJour.InvoiceDate == custVendTransOffset.TransDate
                        && custVendInvoiceJour.LedgerVoucher == custVendTransOffset.Voucher;
            }
        }

        if (custVendInvoiceJour)
        {
            if (_considerTaxLedgerDimension && custVendInvoiceJour.TaxGroup)
            {
                ledgerDimension = SettlementUtility::findTaxLedgerDimension(_module, custVendInvoiceJour.LedgerVoucher, custVendInvoiceJour.InvoiceDate);
            }
            else
            {
                if (_cashDiscountCode == '')
                {
                    ledgerDimension = SettlementUtility::findCashDiscountAccountFromCashDiscountCode(_module, custVendInvoiceJour.CashDiscCode);
                }
                else 
                {
                    ledgerDimension = SettlementUtility::findCashDiscountAccountFromCashDiscountCode(_module, _cashDiscountCode);
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountAccountFromJournalPosting_PSN</Name>
				<Source><![CDATA[
    private static LedgerDimensionDefaultAccount findCashDiscountAccountFromJournalPosting_PSN(CustVendTrans _custVendTrans, CashDiscCode _cashDiscCode)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        if (_custVendTrans.TableId == tableNum(VendTrans)
            && _custVendTrans.CashDiscCode
            && CashDisc::find(_custVendTrans.CashDiscCode).DiscountOffsetMethod_PSN == DiscountOffsetMethod::InvoiceAccount
            && !CustVendTransDistributionController::custVendTransHasSourceDocumentData(_custVendTrans))
        {
            ledgerDimension = SettlementUtility::findVoucherLedgerDimension_PSN(_custVendTrans);
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountAccountFromCashDiscountCode</Name>
				<Source><![CDATA[
    private static LedgerDimensionDefaultAccount findCashDiscountAccountFromCashDiscountCode(SysModule _module, CashDiscCode _cashDiscountCode)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        switch (_module)
        {
            case SysModule::Cust:
                ledgerDimension = CashDisc::paidLedgerDimension(_cashDiscountCode);
                break;

            case SysModule::Vend:
                ledgerDimension = CashDisc::receivedLedgerDimension(_cashDiscountCode);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscountSystemLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default <c>LedgerDimensionDefaultAccount</c> for customer or vendor cash discounts.
    /// </summary>
    /// <param name = "_module">The <c>SysModule</c> for which to find the account.</param>
    /// <returns></returns>
    public static LedgerDimensionDefaultAccount cashDiscountSystemLedgerDimension(SysModule _module)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        switch (_module)
        {
            case SysModule::Cust:
                ledgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::CustCashDisc);
                break;

            case SysModule::Vend:
                ledgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VendCashDisc);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountAccountFromCustomerOrVendor</Name>
				<Source><![CDATA[
    private static LedgerDimensionDefaultAccount findCashDiscountAccountFromCustomerOrVendor(CustVendTrans _custVendTrans)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        CashDiscCode cashDiscCode;
        SysModule module;

        switch (_custVendTrans.TableId)
        {
            case tableNum(CustTrans):
                module = SysModule::Cust;
                cashDiscCode = CustTable::find(_custVendTrans.AccountNum).CashDisc;
                break;

            case tableNum(VendTrans):
                module = SysModule::Vend;
                cashDiscCode = VendTable::find(_custVendTrans.AccountNum).CashDisc;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (cashDiscCode != '')
        {
            ledgerDimension = SettlementUtility::findCashDiscountAccountFromCashDiscountCode(module, cashDiscCode);
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the tax cash discount <c>LedgerDimensionDefaultAccount</c> for a given voucher.
    /// </summary>
    /// <param name = "_module">The <c>SysModule</c> for which to find the account.</param>
    /// <param name = "_voucher"><c>Voucher</c> of the voucher for which to find the account.</param>
    /// <param name = "_transDate"><c>TranDate</c> of the voucher for which to find the account. </param>
    /// <returns>The tax cash discount <c>LedgerDimensionDefaultAccount</c>.</returns>
    public static LedgerDimensionDefaultAccount findTaxLedgerDimension(SysModule _module, Voucher _voucher, TransDate _transDate)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        switch (_module)
        {
            case SysModule::Cust:
                ledgerDimension = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(TaxTrans::find(_voucher, _transDate).TaxCode)).CashDiscountOutgoingLedgerDimension;
                break;

            case SysModule::Vend:
                ledgerDimension = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(TaxTrans::find(_voucher, _transDate).TaxCode)).CashDiscountIncomingLedgerDimension;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFullSettlementAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates full settlement amount for the specified settlement.
    /// </summary>
    /// <param name = "_module">The module originating the settlement.</param>
    /// <param name = "_company">The company of record originating the settlement.</param>
    /// <param name = "_tableId">The ID of the table originating the settlement.</param>
    /// <param name = "_recId">The record ID of the record originating the settlement.</param>
    /// <returns></returns>
    public static AmountCur calcFullSettlementAmount(
        SysModule _module,
        CompanyId _company,
        TableId _tableId,
        RecId _recId)
    {
        AmountCur fullSettlementAmount;

        switch (_module)
        {
            case SysModule::Cust:

                changecompany(_company)
                {
                    switch (_tableId)
                    {
                        case tableNum(LedgerJournalTrans):

                            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_recId, false);

                            if (ledgerJournalTrans)
                            {
                                ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode);

                                fullSettlementAmount = SettlementUtility::sumRemainAmountCust(
                                    ledgerJournalTrans,
                                    ledgerJournalTrans.CurrencyCode,
                                    ledgerJournalTrans.TransDate ? ledgerJournalTrans.TransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                    exchangeRateHelper.prepareExchangeRateForStorage(ledgerJournalTrans.crossrate()));
                            }

                            break;

                        case tableNum(CustTable):
                            CustTable custTable = CustTable::findRecId(_recId);

                            if (custTable)
                            {
                                fullSettlementAmount = SettlementUtility::sumRemainAmountCust(custTable,
                                    custTable.Currency,
                                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                            }

                            break;

                        default:
                            fullSettlementAmount = 0.0;
                            break;
                    }
                }
                break;

            case SysModule::Vend:

                changecompany(_company)
                {
                    switch (_tableId)
                    {
                        case tableNum(LedgerJournalTrans):
                            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_recId, false);

                            if (ledgerJournalTrans)
                            {
                                ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode);

                                fullSettlementAmount = -SettlementUtility::sumRemainAmountVend(
                                    ledgerJournalTrans,
                                    ledgerJournalTrans.CurrencyCode,
                                    ledgerJournalTrans.TransDate ? ledgerJournalTrans.TransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                    exchangeRateHelper.prepareExchangeRateForStorage(ledgerJournalTrans.crossrate()));
                            }

                            break;

                        case tableNum(VendTable):
                            VendTable vendTable = VendTable::findRecId(_recId);

                            if (vendTable)
                            {
                                fullSettlementAmount = -SettlementUtility::sumRemainAmountVend(
                                    vendTable,
                                    vendTable.Currency,
                                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                            }

                            break;

                        default:
                            fullSettlementAmount = 0.0;
                            break;
                    }
                }
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return fullSettlementAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumRemainAmountVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount remaining to settle for given settlement.
    /// </summary>
    /// <param name = "_common">The record specifying the settlement.</param>
    /// <param name = "_currencyCode">The currency code to use for the calculation.</param>
    /// <param name = "_transDate">The date of the transaction.</param>
    /// <param name = "_exchRate">The exchange rate to use for the calculation.</param>
    /// <returns>The amount remaining to settle.</returns>
    public static AmountCur sumRemainAmountVend(
        Common _common,
        CurrencyCode _currencyCode,
        TransDate _transDate,
        ExchRate _exchRate = 0)
    {
        #ISOCountryRegionCodes

        SpecTrans specTrans;
        VendTransOpen vendTransOpen;
        VendTrans vendTrans;
        AmountCur remainAmount;
        VendTable vendTable;

        while select crossCompany CrossRate, Balance01, RefCompany, SpecCompany, CashDiscToTake, FullSettlement  from specTrans
            where specTrans.SpecCompany == _common.company()
                && specTrans.SpecTableId == _common.TableId
                && specTrans.SpecRecId == _common.RecId
            join vendTransOpen
                where vendTransOpen.DataAreaId == specTrans.RefCompany
                   && vendTransOpen.TableId == specTrans.RefTableId
                   && vendTransOpen.RecId == specTrans.RefRecId
            join CurrencyCode, VendExchAdjustmentUnrealized from vendTrans
                where vendTrans.RecId == vendTransOpen.RefRecId
                   && vendTrans.DataAreaId == specTrans.RefCompany
        {
            if (specTrans.FullSettlement && specTrans.CashDiscToTake)
            {
                specTrans.Balance01 =  specTrans.Balance01 + specTrans.CashDiscToTake;
            }

            if (specTrans.CrossRate != 0.0)
            {
                remainAmount += specTrans.Balance01 * specTrans.CrossRate / 100.0;
            }
            else
            {
                boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

                remainAmount += SettlementUtility::convertAmountCurToAmountCurCrossCompany(
                    specTrans.RefCompany,
                    vendTrans.CurrencyCode,
                    specTrans.Balance01,
                    specTrans.SpecCompany,
                    _currencyCode,
                    countryRegion_RU ? vendTrans.TransDate : _transDate,
                    false,               // No rounding
                    specTrans.RefCompany,
                    0,
                    _exchRate);
            }
        }

        return remainAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumRemainAmountCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount remaining to settle for given settlement.
    /// </summary>
    /// <param name = "_common">The record specifying the settlement.</param>
    /// <param name = "_currencyCode">The currency code to use for the calculation.</param>
    /// <param name = "_transDate">The date of the transaction.</param>
    /// <param name = "_exchRate">The exchange rate to use for the calculation.</param>
    /// <returns>The amount remaining to settle.</returns>
    public static AmountCur sumRemainAmountCust(
        Common _common,
        CurrencyCode _currencyCode,
        TransDate _transDate,
        ExchRate _exchRate = 0)
    {
        #ISOCountryRegionCodes

        SpecTrans specTrans;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        AmountCur remainAmount;
        CustTable custTable;

        while select crossCompany CrossRate, Balance01, RefCompany, SpecCompany, CashDiscToTake, FullSettlement from specTrans
            where specTrans.SpecCompany == _common.company()
                && specTrans.SpecTableId == _common.TableId
                && specTrans.SpecRecId   == _common.RecId
        join custTransOpen
            where custTransOpen.DataAreaId == specTrans.RefCompany
               && custTransOpen.TableId == specTrans.RefTableId
               && custTransOpen.RecId   == specTrans.RefRecId
        join CurrencyCode, CustExchAdjustmentUnrealized from custTrans
            where custTrans.DataAreaId == specTrans.RefCompany
               && custTrans.RecId == custTransOpen.RefRecId
        {
            if (specTrans.FullSettlement && specTrans.CashDiscToTake)
            {
                specTrans.Balance01 =  specTrans.Balance01 + specTrans.CashDiscToTake;
            }

            if (specTrans.CrossRate != 0.0)
            {
                remainAmount += specTrans.Balance01 * specTrans.CrossRate / 100.0;
            }
            else
            {
                boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

                remainAmount += SettlementUtility::convertAmountCurToAmountCurCrossCompany(
                    specTrans.RefCompany,
                    custTrans.CurrencyCode,
                    specTrans.Balance01,
                    specTrans.SpecCompany,
                    _currencyCode,
                    countryRegion_RU ? custTrans.TransDate : _transDate,
                    false, // no rounding
                    specTrans.RefCompany,
                    0,
                    _exchRate);
            }
        }

        return remainAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOpenAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given transaction amounts, determines whether there is remaining open amount.
    /// </summary>
    /// <param name = "_amountCur">Transaction amount in the transaction currency.</param>
    /// <param name = "_settleAmountCur">Settled amount of the transaction in the transaction currency.</param>
    /// <returns>true, if there is an open (unsettled) amount on the transaction; otherwise, false.</returns>
    public static boolean hasOpenAmountCur(AmountCur _amountCur, AmountCur _settleAmountCur)
    {
        boolean hasOpenAmount = (_amountCur != _settleAmountCur);
        return hasOpenAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnrealizedExchAdjToReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of the unrealized exchange adjustment to reverse in the accounting currency.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount of the transaction in the transaction currency.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The settled amount of the transaction in the transaction currency.
    /// </param>
    /// <param name="_exchAdjustmentUnrealized">
    /// The unrealized exchange adjustment amount for the transaction.
    /// </param>
    /// <param name="_settledFactor">
    /// The percent of transaction that is being settled.
    /// </param>
    /// <param name="_companyMstCurrencyCode">
    /// The accounting currency of the transaction company.
    /// </param>
    /// <returns>
    /// The amount of the unrealized exchange adjustment to reverse.
    /// </returns>
    public static AmountMST calcUnrealizedExchAdjToReverse(
        AmountCur _amountCur,
        AmountCur _settleAmountCur,
        AmountMST _exchAdjustmentUnrealized,
        Percent _settledFactor,
        CurrencyCode _companyMstCurrencyCode)
    {
        AmountMST unrealizedAmount;

        if (_amountCur != 0.0 && SettlementUtility::hasOpenAmountCur(_amountCur, _settleAmountCur))
        {
            // the transaction isn't fully settled, so calculate amount to reverse based on settled factor.
            unrealizedAmount = CurrencyExchange::round(_exchAdjustmentUnrealized * _settledFactor, _companyMstCurrencyCode);
        }
        else
        {
            unrealizedAmount = _exchAdjustmentUnrealized;
        }

        return unrealizedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnrealizedReportingExchAdjToReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of the unrealized exchange adjustment to reverse in the reporting currency.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount of the transaction in the transaction currency.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The settled amount of the transaction in the transaction currency.
    /// </param>
    /// <param name="_reportingExchAdjustmentUnrealized">
    /// The unrealized reporting exchange adjustment amount for the transaction.
    /// </param>
    /// <param name="_settledFactor">
    /// The percent of transaction that is being settled.
    /// </param>
    /// <param name="_transactionCompany">
    /// The company of the transaction.
    /// </param>
    /// <returns>
    /// The amount of the reporting unrealized exchange adjustment to reverse.
    /// </returns>
    public static AmountMSTSecondary calcUnrealizedReportingExchAdjToReverse(
        AmountCur _amountCur,
        AmountCur _settleAmountCur,
        AmountMSTSecondary _reportingExchAdjustmentUnrealized,
        Percent _settledFactor,
        DataAreaId _transactionCompany)
    {
        AmountMSTSecondary unrealizedAmount;

        if (_amountCur != 0.0 && SettlementUtility::hasOpenAmountCur(_amountCur, _settleAmountCur))
        {
            // the transaction isn't fully settled, so calculate amount to reverse based on settled factor and round result
            unrealizedAmount = CurrencyExchange::round(
                _reportingExchAdjustmentUnrealized * _settledFactor,
                Ledger::reportingCurrency(CompanyInfo::findDataArea(_transactionCompany).RecId));
        }
        else
        {
            unrealizedAmount = _reportingExchAdjustmentUnrealized;
        }

        return unrealizedAmount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>