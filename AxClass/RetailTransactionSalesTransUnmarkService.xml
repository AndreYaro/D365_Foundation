<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionSalesTransUnmarkService</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailTransactionSalesTransUnmarkService</c> class removes inventory transactions generated by the "Post Inventory" job.
/// </summary>
/// <remarks>
/// Currently this class is only removes orphan inventory transactions.
/// </remarks>
internal class RetailTransactionSalesTransUnmarkService extends SysOperationServiceBase
{
    private List cleanupErrors = new List(Types::String);
    private int cleanupCount = 0;

    private static container cleanupQueries = [queryStr(RetailStatementOrphanInventNoLinkToSalesTransQuery), 
                                               queryStr(RetailStatementOrphanInventNonExistentStmtQuery),
                                               queryStr(RetailStatementOrphanInventNoReferencePostedSalesTransQuery),
                                               queryStr(RetailStatementOrphanInventVoidedSalesTransQuery)];

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Entry point for the service.
    /// </summary>
    /// <param name = "_contract">The contract for the service execution.</param>
    public void run(RetailTransactionSalesTransUnmarkContract _contract)
    {
        eventSource.EventWriteInventoryPostingStartCleanUpStatementTempInventoryReservations();

        if (_contract.parmClearOrphanInventoryTransactions())
        {
            this.runClearOrphans();
        }

        eventSource.EventWriteInventoryPostingFinishCleanUpStatementTempInventoryReservations();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runClearOrphans</Name>
				<Source><![CDATA[
    private void runClearOrphans()
    {
        eventSource.EventWriteInventoryPostingStartCleanUpOrphanInventoryTransactions();

        for (int i = 1; i <= conLen(cleanupQueries); i ++)
        {
            str queryName = conPeek(cleanupQueries, i);

            eventSource.EventWriteInventoryPostingStartRunQuery(queryName);

            QueryRun qr = new QueryRun(queryName);

            this.iterateThroughInventoryTransactions(qr);

            eventSource.EventWriteInventoryPostingFinishRunQuery(queryName);
        }

        info(strFmt("@Retail:UnmarkInventoryStatusMessage", cleanupCount));
        
        if (cleanupErrors.elements() > 0)
        {
            error(strFmt("@Retail:UnmarkInventoryErrorMessage", cleanupErrors.elements()));
        }

        eventSource.EventWriteInventoryPostingFinshCleanUpOrphanInventoryTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>iterateThroughInventoryTransactions</Name>
				<Source><![CDATA[
    private void iterateThroughInventoryTransactions(QueryRun _qr)
    {
        while (_qr.next())
        {
            InventTransOrigin inventTransOrigin;
            InventTrans inventTrans;
            InventTableModule inventTableModule;
            RetailTransactionSalesTrans salesTrans;

            inventTransOrigin = _qr.get(tableNum(InventTransOrigin));
            inventTrans = _qr.get(tableNum(InventTrans));
            inventTableModule = _qr.get(tableNum(InventTableModule));

            eventSource.EventWriteInventoryPostingProcessingInventTransOrigin(inventTransOrigin.RecId);

            setPrefix(strFmt('%1: %2', "@SYS23057", inventTransOrigin.InventTransId));

            if (!inventTransOrigin.InventTransId ||
                !inventTransOrigin.ItemId ||
                !inventTableModule.UnitId ||
                !inventTrans.inventDimId  ||
                !inventTrans.qty)
            {
                eventSource.EventWriteInventoryPostingProcessingInventTransOriginQueryBadResults(inventTransOrigin.RecId,
                                    inventTableModule.RecId,
                                    inventTrans.RecId);

                cleanupErrors.addEnd(inventTransOrigin.InventTransId);

                continue;
            }

            int infoCnt = infologLine();
            System.Exception exception;

            try
            {
                ttsbegin;

                salesTrans.clear();
                salesTrans.ItemId = inventTransOrigin.ItemId;
                salesTrans.Unit = inventTableModule.UnitId;
                salesTrans.inventDimId = inventTrans.inventDimId;
                salesTrans.inventTransId = inventTransOrigin.InventTransId;
                salesTrans.qty = inventTrans.qty;

                // guarantees that no one can touch the invent trans id while we are doing it.
                InventTransOrigin inventTransOriginLocal;
                select pessimisticlock inventTransOriginLocal where inventTransOriginLocal.InventTransId == inventTransOrigin.InventTransId;
                
                // check if the record exists after the lock is released
                // it might have been removed by another thread.
                if (inventTransOriginLocal.RecId == 0)
                {
                    eventSource.EventWriteInventoryPostingInventTransOriginAlreadyRemoved(inventTransOrigin.RecId);

                    // throwing an exception here will force the transaction to be aborted
                    // there's a generic catch below that will handle logging and resuming the loop
                    throw Exception::UpdateConflict;
                }

                if (salesTrans.qty > 0)
                {
                    // first, unregister all registered transactions
                    this.unregisterInventoryTransaction(salesTrans);
                }

                // then delete all transactions
                this.deleteInventoryTransaction(salesTrans);
                
                cleanupCount++;
                
                ttscommit;
            }
            catch (Exception::Error)
            {
                eventSource.EventWriteInventoryPostingProcessingInventTransOriginError(inventTransOrigin.RecId);

                cleanupErrors.addEnd(inventTransOrigin.InventTransId);

                continue;
            }
            catch (exception)
            {
                str exceptionText = RetailTransactionSalesTransUnmarkService::exceptionToString(exception);

                eventSource.EventWriteInventoryPostingProcessingInventTransOriginException(inventTransOrigin.RecId, exceptionText);

                cleanupErrors.addEnd(inventTransOrigin.InventTransId);

                continue;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventoryTransaction</Name>
				<Source><![CDATA[
    private void deleteInventoryTransaction(RetailTransactionSalesTrans _salesTrans)
    {
        InventMovement inventMovement = InventMovement::construct(_salesTrans);
        InventUpd_DeleteMovement::newMovement(inventMovement).updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>unregisterInventoryTransaction</Name>
				<Source><![CDATA[
    private void unregisterInventoryTransaction(RetailTransactionSalesTrans _salesTrans)
    {
        InventMovement inventMovement = InventMovement::construct(_salesTrans);

        // Take into account partial registrations to avoid:
        // Quantity XX cannot be returned because items have already been returned or marked as open transactions.
        _salesTrans.qty = inventMovement.transIdSum().registered();

        if (inventMovement.isReturned(inventMovement.remainPhysical()))
        {
            InventDim inventDim = _salesTrans.inventDim();
            InventDimParm inventDimParm;
            inventDimParm.initFromInventDim(inventDim);
            InventUpd_Registered registered = InventUpd_Registered::newParameters(inventMovement,
                                                                                inventDim,
                                                                                inventDimParm,
                                                                                inventDim,
                                                                                inventDimParm,
                                                                                -1 * inventMovement.remainPhysical());
            registered.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exceptionToString</Name>
				<Source><![CDATA[
    private static str exceptionToString(System.Exception _exception)
    {
        if (_exception != null)
        {
            str exceptionType = _exception.GetType().FullName;
            str stackTrace = _exception.StackTrace != null ? _exception.StackTrace.ToString() : strFmt('Exception stack trace was null. Current stack is: %1', System.Environment::StackTrace);
            str exceptionMessage = _exception.Message != null ? _exception.Message : 'Exception message was null';
            str exceptionToLog = strFmt('Exception Type: %1 / Exception message: %2 / Exception stacktrace: %3', exceptionType, exceptionMessage, stackTrace);

            return exceptionToLog;
        }
        else
        {
            return strFmt('%1 was called with a null exception. Printing the current call stack: %2', funcName(),  System.Environment::StackTrace);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfInventoryTransactionsCleaned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of inventory transactions that were cleaned.
    /// </summary>
    /// <returns>The number of inventory transactions that were cleaned.</returns>
    /// <remarks>
    /// Used for testing purposes only.
    /// </remarks>
    internal int getNumberOfInventoryTransactionsCleaned()
    {
        return cleanupCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCleanupErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of Inventory Transactions that could not be removed.
    /// </summary>
    /// <returns>The list of Inventory Transactions that could not be removed.</returns>
    /// <remarks>
    /// Used for testing purposes only.
    /// </remarks>
    internal List getCleanupErrors()
    {
        return cleanupErrors;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>