<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsWorkExecuteDisplayTOReceiving</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to manage received transfer order items.
/// </summary>
public abstract class WhsWorkExecuteDisplayTOReceiving extends WHSWorkExecuteDisplay
{
    private boolean receivingWorkWasDeferred;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createReceivingExceptionLog</Name>
				<Source><![CDATA[
    protected void createReceivingExceptionLog(WhsWorkExecute _workExecute, WHSUserId _localUserId)
    {
        if (pass.lookupStr(#TONum))
        {
            _workExecute.createTOReceivingException(WHSUOMStructure::findFirstByLicensePlateModule(pass.lookupStr(#LicensePlateId), WHSModule::Transfer),
                                                    pass.lookup(#ReceivingExceptionDesc),
                                                    _localUserId,
                                                    pass.lookupStr(#TONum),
                                                    pass.lookupNum(#TOLineNum));
        }
        else 
        {
            super(_workExecute, _localUserId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildGetTOLineLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning a license plate to TO line.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extratext">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    protected container buildGetTOLineLP(container _con, str _extratext = '')
    {
        container       ret         = _con;
        int             numLP       = pass.lookup(#NumLP);
        int             currentLP   = pass.lookup(#CurrentLP);
        WHSInventTable  whsInventTable;

        whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));

        ret += [this.buildControl(#RFLabel, #LPLoop, strFmt("@WAX1246", currentLP, numLP), 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #TONum, "@WAX3858", 1, pass.lookup(#TONum), extendedTypeNum(InventTransferId), '', 0, false)];
        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        }

        ret += [this.buildControl(#RFText, #CurrentQty, "@SYS105177", 1, pass.lookup(#CurrentQty), extendedTypeNum(Qty), '', 0, false)];
        ret += [this.buildControl(#RFText, #CurrentUOM, "@WAX721", 1, pass.lookup(#CurrentUOM), extendedTypeNum(UnitOfMeasureSymbol), '', 0, false)];
        ret += [this.buildControl(#RFText, #RecvLocationId, "@WAX1196", 1, InventLocation::find(pass.lookup(#InventLocationId)).wmsLocationIdDefaultReceipt, extendedTypeNum(WMSLocationId), '', 0, false)];
        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.hasValue(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) : '', extendedTypeNum(WHSLicensePlateId), '', 0)];

        if (WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).DisplayContainerTypeCode == NoYes::Yes)
        {
            if (pass.hasValue(#LicensePlateId))
            {
                ret = this.buildContainerType(ret, pass.lookupStr(#ContainerType));

                if (!pass.exists(#Initiation))
                {
                    pass.insert(#Initiation, 1);
                }
            }
            else if (!pass.exists(#Initiation) && pass.hasValue(#ContainerType))
            {
                pass.remove(#ContainerType);
            }
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTOReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for TO Receiving screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extratext">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    abstract protected container buildTOReceiving(container _con, str _extratext = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTOReceivingAndPutawayExecuteMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the receiving and putaway execute mode enum value of the current process.
    /// </summary>
    /// <returns>
    /// The receiving and putaway execute mdoe enum value.
    /// </returns>
    protected abstract WHSWorkExecuteMode getTOReceivingAndPutawayExecuteMode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabels</Name>
				<Source><![CDATA[
    protected void buildLicensePlateLabels(WHSWorkBuildId _workBuildId)
    {
        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).PrintLabel)
        {
            WHSLicensePlateLabelBuild labelBuild = new WHSLicensePlateLabelBuild(WHSWorkTable::getFirstWorkLineByWorkBuildId(_workBuildId, userId).WorkId,
                                                                                null,
                                                                                pass.lookup(#MenuItem),
                                                                                pass.lookup(#UserId));

            if (pass.exists(#TransferOrderReceiveInventDimId))
            {
                labelBuild.parmTransferOrderReceiveInventDimId(pass.parmTransferOrderReceiveInventDimId());
                pass.remove(#TransferOrderReceiveInventDimId);
            }

            labelBuild.buildLicensePlateLabels();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryToDeferWork</Name>
				<Source><![CDATA[
    private boolean tryToDeferWork(InventTransferLine _transferLine, WHSRFMenuItemTable _menuItemTable)
    {
        WHSDeferredTOReceiving deferredReceiving = WHSDeferredTOReceiving::newFromParameters(
            pass, _transferLine, _menuItemTable, this.getDefaultContainerTypeCode());

        return deferredReceiving.tryToDeferTransferOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabelsForDeferredReceiving</Name>
				<Source><![CDATA[
    private void buildLicensePlateLabelsForDeferredReceiving(InventTransferLine _transferLine)
    {
        WHSDeferredReceivingPolicy deferredReceivingPolicy = WHSDeferredReceivingPolicy::find(WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).DeferredReceivingPolicyId);

        if (deferredReceivingPolicy.LabelPrintingOnConfirmingReceiving == WHSDeferredReceivingPrintLabelProcessEnum::DoNotGenerateLabels)
        {
            return;
        }

        WHSLicensePlateLabelBuildWithoutWorkParameters parameters = new WHSLicensePlateLabelBuildWithoutWorkParameters(_transferLine,
                                                                                                                        WHSWorkTransType::TransferReceipt,
                                                                                                                        pass.parmCurrentUOM(),
                                                                                                                        pass.parmCurrentQty(),
                                                                                                                        pass.lookupStr(#ShipmentId),
                                                                                                                        pass.parmLoadId(),
                                                                                                                        pass.parmLicensePlateId(),
                                                                                                                        pass.parmUserId());
                                                                                                                            
                                                                                                                                                
        WHSLicensePlateLabelBuildWithoutWork labelBuild = WHSLicensePlateLabelBuildWithoutWork::newFromWorkTransTypeAndParameters(WHSWorkTransType::TransferReceipt, parameters);

        boolean skipPrint = deferredReceivingPolicy.LabelPrintingOnConfirmingReceiving == WHSDeferredReceivingPrintLabelProcessEnum::OnlyGenerateLabels;

        using (var noPrintContext = skipPrint ? WHSDeferredReceivingSkipPrintContext::construct() : null)
        {
            labelBuild.buildLicensePlateLabels();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWork</Name>
				<Source><![CDATA[
    protected WHSWorkBuildId createWork(InventTransferLine _transferLine)
    {
        WHSLicensePlate licensePlate = WHSLicensePlate::createLicensePlate(pass.lookup(#LicensePlateId), true, this.getDefaultContainerTypeCode());

        WHSWorkCreateTransferLine workCreateTransferLine = new WHSWorkCreateTransferLine(_transferLine);

        workCreateTransferLine.parmInventQty(WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#CurrentUOM), pass.lookupNum(#CurrentQty), _transferLine.InventDimId));
        WHSTransWeight calcCatchWeight;
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_transferLine.ItemId);

        if (isCWItem)
        {
            InventHandlingQty totalReceiptQty = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#UOM), pass.lookupNum(#Qty), _transferLine.InventDimId);

            if (WHSDeferredPOReceivingHandleCatchWeightFlight::instance().isEnabled())
            {
                calcCatchWeight = WHSCatchWeightHelper::calculateCatchWeightAndUpdatePass(_transferLine.ItemId, workCreateTransferLine.parmInventQty(), totalReceiptQty, pass);
            }
            else
            {
                if (WHSInventTable::shouldCaptureAggregateWeight(_transferLine.ItemId))
                {
                    calcCatchWeight = WHSCatchWeightHelper::calculateAverageWeight(workCreateTransferLine.parmInventQty(),
                                                                            totalReceiptQty - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum),
                                                                            pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum),
                                                                            InventTable::inventDecimals(_transferLine.ItemId));
                }
                else
                {
                    // If not capturing aggregate weight use work creation handling quantity rounded to correct decimal precision.
                    calcCatchWeight = WHSCatchWeightHelper::calculateAverageWeight(workCreateTransferLine.parmInventQty(),
                                                                            workCreateTransferLine.parmInventQty(),
                                                                            pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight),
                                                                            InventTable::inventDecimals(_transferLine.ItemId));

                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
                }

                if (workCreateTransferLine.parmInventQty() != (totalReceiptQty - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum)))
                {
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum) + workCreateTransferLine.parmInventQty());
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum) + calcCatchWeight);
                }
            }
        }

        // Auto Generate catch weight tag records based on configs
        if (isCWItem
            && WHSInventTable::isCatchWeightTagTracked(_transferLine.ItemId)
            && WHSInventTable::shouldCaptureAggregateWeight(_transferLine.ItemId)
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateCatchWeightTag)
        {
            WHSCatchWeightTagCreationSource tagSource = WHSCatchWeightTagCreationSource::instantiateFromSource(_transferLine, pass);
            WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::newAutoTagCreation(workCreateTransferLine.parmInventQty(), calcCatchWeight);
            WHSCatchWeightTagCreator tagCreator = WHSCatchWeightTagCreator::construct();
            this.trackAutoGeneratedCatchWeightTags(tagCreator.createCatchWeightTags(tagSource, tagMethod));
        }

        workCreateTransferLine.parmCreatedBy(userId);
        workCreateTransferLine.parmInventTransferLine(_transferLine);
        workCreateTransferLine.parmUnitization(pass.lookup(#Unitization));
        workCreateTransferLine.parmTargetLicensePlateId(licensePlate.LicensePlateId);
        workCreateTransferLine.parmWorkTemplateCode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkTemplateCode);
        workCreateTransferLine.parmDispositionCode(pass.lookupStr(#Disposition));
        workCreateTransferLine.parmReceiptId(pass.parmReceiptId());

        WHSWorkBuildId workBuildId = workCreateTransferLine.createWork();

        if (isCWItem && pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
        {
            WHSCatchWeightTagLastRegistration::updateCatchWeightTagRegistrationWorkLine(str2con(pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList)),
                WHSWorkTable::findSingleInboundWorkByWorkBuildId(workBuildId).WorkId);
        }

        return workBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyAndUOMPassValuesForReceivingTheNextLP</Name>
				<Source><![CDATA[
    private void updateQtyAndUOMPassValuesForReceivingTheNextLP(InventTransferLine _transferLine)
    {
        Qty                 finalQty;
        UnitOfMeasureSymbol finalUnitId;

        [finalQty, finalUnitId] =  this.unitizeQtyForNextLicensePlate(
                                            pass, 
                                            _transferLine.ItemId, 
                                            _transferLine.InventDimId);

        pass.insert(#CurrentQty, finalQty);
        pass.insert(#CurrentUOM, finalUnitId);
        pass.insert(#CurrentLP, str2int(pass.lookup(#CurrentLP)) + 1);

        pass.remove(#LicensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePassAndDisplayToExecutePutawayWork</Name>
				<Source><![CDATA[
    private container updatePassAndDisplayToExecutePutawayWork(
                                            WHSWorkBuildId          _workBuildId,
                                            WhsWorkExecuteDisplay   _workExecuteDisplay,
                                            container               _con,
                                            WMSLocationId           _newLocationId,
                                            str                     _buttonClicked)
    {
        container con = _con;
        container ret;

        this.removeTrackingDimensionsFromPass(pass.lookup(#ItemId));
        pass.remove(#DimQty);
        pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));

        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(_workBuildId, userId);
        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        {
            throw error("@WAX1459");
        }
        workTable = workLine.whsWorkTable();

        if (workLine)
        {
            pass.insert(#DetermineStep, 1);
            Qty tmpQty = pass.lookupNum(#RunningQty);
            WHSMenuItemName menuItem = pass.lookup(#MenuItem);
            con = this.updateModeStepPass(con, mode, step, pass);

            boolean recall;
            container tmpPass;
            [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, _newLocationId, _buttonClicked, false);
            pass = new WHSRFPassthrough(Types::String, Types::String);
            pass = WHSRFPassthrough::create(tmpPass);

            pass.insert(#RunningQty, tmpQty);
            pass.insert(#MenuItem, menuItem);

            if (step == #Restart)
            {
                step = 0;
            }
            else if (step == #StepOne)
            {
                step = 1;
                pass.insert(#DetermineStep, 1);
            }

            con = this.updateModeStepPass(ret, mode, step, pass);
            con = conPoke(con, 1, [mode, step]);
            _workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
            ret = _workExecuteDisplay.displayForm(con, _buttonClicked);
            pass = new WHSRFPassthrough(Types::String, Types::String);
            pass = WHSRFPassthrough::create(conPeek(ret, 2));
            pass.insert(#DoingWork, 1);
            if (pass.exists(#WorkId) && pass.exists(#LineNum))
            {
                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                {
                    throw error("@WAX1459");
                }
                workTable = workLine.whsWorkTable();
            }
        }

        return [con, ret];
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    container displayForm(container _con, str _buttonClicked = '')
    {
        Set                         excludeLocationId = new Set(Types::String);
        WHSWorkExecuteDisplay       workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        InventTransferLine          transferLine;
        container                   ret = conNull();
        container                   con = _con;
        container                   tmpCon;
        WMSLocationId               newLocationId;
        WHSRFPassthrough            globalPass;
        int                         hasError = 0;
        boolean                     addCancel = true;
        container                   tmpFieldValues;
        WHSRFPassthrough            fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        boolean                     complete;
        WhsWorkExecute              workExecute = WhsWorkExecute::construct();
        Qty                         tmpQty;
        WHSMenuItemName             menuItem;
        WHSWorkBuildId              workBuildId;
        boolean                     recall;
        boolean                     addExceptionButton;
        container                   tmpPass;
        WHSRFPassthrough            tmpMap;
        int                         tmpStep;
        InventBatchId               tmpBatchId;
        InventTrans                 inventTrans;
        InventDim                   inventDim;
        InventDim                   trackingInventDim;
        InventQty                   dimInventQty;
        boolean                     displayContainerType;

        globalPass = pass;
        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        if (globalPass.exists(#CurrentUOM)                             &&
                   pass.exists(#CurrentUOM)                                    &&
                   globalPass.lookup(#CurrentUOM)  != ''                       &&
                   pass.lookup(#CurrentUOM)        != ''                       &&
                   globalPass.lookup(#CurrentUOM)  != pass.lookup(#CurrentUOM) &&
                   step == 2)
        {
            pass.insert(#CurrentUOM, globalPass.lookup(#CurrentUOM));
        }

        pass = this.combineMaps(globalPass, pass);

        hasError = this.hasError(_con);

        if (_buttonClicked == #RFException)          // Exception
        {
            step = #ReceivingExceptionStep1;
        }
        else if (_buttonClicked == #RFOverride)      // Override
        {
            step = #OverrideStep1;
        }
        else if (_buttonClicked == #RFFull && step != 0)      // Full (Split)
        {
            step = #SplitWork;
        }
        else if (_buttonClicked == #RFNoLocation)      // Suggest Location (NoLocation)
        {
            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
            if (pass.exists(#ExcludedLocations))
            {
                excludeLocationId = this.buildLocationListFromStr(pass.lookup(#ExcludedLocations));
            }
            else
            {
                excludeLocationId = this.buildLocationListFromStr(workLine.wmsLocationId);
            }
            [newLocationId, tmpCon] = workExecute.findNewLocation(workLine, excludeLocationId);
            excludeLocationId = Set::create(tmpCon);
            pass.insert(#SuggestLocation, 1);
            pass.insert(#ExcludedLocations, this.buildLocationListFromSet(excludeLocationId));
            if (pass.exists(#PrevStep))
            {
                step = pass.lookup(#PrevStep);
            }
            else
            {
                pass.insert(#NoValidation, '1');
            }
        }
        else if (_buttonClicked == #RFSplitPut)
        {
            this.validateSplitPutAllowed();
            step = #SplitPutWork;
        }

        int startInfologLine = infologLine() + 1;
        
        switch (step)
        {
            case 0,1:
                if (pass.exists(#WorkComplete))
                {
                    ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                    pass.remove(#WorkComplete);
                    addCancel = false;

                    ret = this.addClusterMessages(ret);
                }

                if (step)
                {
                    if (hasError)
                    {
                        con = this.removeErrorMessages(con);
                    }

                    [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                    fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                    pass = this.combineMaps(pass, fieldValues);
                    hasError = this.hasError(con);

                    if (hasError)
                    {
                        ret = con;
                        addCancel = false;
                        break;
                    }
                }
                else
                {
                    step = 1;
                    pass.insert(#Initiation, '1');
                }

                con = this.buildTOReceiving(ret);
  
                if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).Unitization == WHSLicensePlateGroupingPolicy::UserDefined
                    && numOfDec(pass.lookupNum(#Qty)))
                {
                    throw error("@WAX:ReceivingQuantityCannotBeDecimalWithUserDefinedLPGroupingError");
                }   

                if (pass.exists(#Qty) && fieldValues.exists(#Qty) && pass.lookupNum(#Qty) != fieldValues.lookupNum(#Qty))
                {
                    fieldValues.insert(#Qty, pass.lookup(#Qty));
                }

                if (pass.exists(#TONum) && pass.exists(#TOLineNum))
                {
                    if (WHSInventTransferLine::wasShippedWithLP(pass.lookup(#TONum), pass.lookupNum(#TOLineNum)))
                    {
                        throw error("@WAX5687");
                    }
                }

                if (!fieldValues.empty())
                {
                    [ret, complete] = this.processFieldValues(con, fieldValues);

                    if (complete)
                    {
                        if (!pass.exists(#Initiation) && !pass.exists(#CurrentUOM))
                        {
                            transferLine = this.inventTransferLine();
                            inventTrans  = InventTrans::findTransId(transferLine.InventTransIdReceive);
                            inventDim = inventTrans.inventDim();
                            if (inventDim.InventLocationId != pass.lookup(#InventLocationId))
                            {
                                addCancel = true;
                                throw error("@WAX1239");
                            }

                            if (!this.checkWarehouseAllowsRFReceipt(inventDim.InventLocationId))
                            {
                                throw error("@WAX4806");
                            }
                            pass.parmUnitization(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).Unitization);                            
                            Qty qtyReceived = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#UOM), pass.lookupNum(#Qty), transferLine.InventDimId);

                            Qty qtyRemainReceive = PdsGlobal::pdsIsCWItem(transferLine.ItemId) ?
                                transferLine.PdsCWQtyRemainReceive : transferLine.QtyRemainReceive;

                            qtyRemainReceive -= WHSMixedLicensePlateReceiptLine::getTotalOpenQtyOnTransId(transferLine.InventTransId);
                           
                            if (qtyReceived > qtyRemainReceive) 
                            {
                                addCancel = true;
                                throw error("@WAX1172");
                            }

                            this.calculateQuantities(transferLine, qtyReceived);

                            if (pass.lookupNum(#NumLP) > 1 && mode == this.getTOReceivingAndPutawayExecuteMode())
                            {
                                throw error("@WAX1615");
                            }
  
                            if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
                            {
                                pass.insert(#RunningQty, pass.lookupNum(#QtyReceived));
                                step = 2;
                                ret = this.displayForm(_con);
                                addCancel = false;
                                break;
                            }

                            // Number of license plate prompt during transfer order receiving for user defined grouping policy should be equal to the quantity when the license plates are generated manually.
                            if (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::UserDefined)
                            {
                                Qty runningQty = pass.lookupNum(#RunningQty);
                                pass.insert(#RunningQty, runningQty - 1);
                            }

                            pass.remove(#Initiation);
                            ret = conNull();
                            ret = this.buildGetTOLineLP(ret);
                            ret = this.addCancelButton(ret, 1, true);

                            step = 2;
                        }
                        else
                        {
                            pass.remove(#Initiation);
                            addExceptionButton = true;
                            pass.insert(#HideExceptionButton, '1');
                        }
                    }
                }
                else
                {
                    ret = con;
                }
                break;

            case 2:
                if (hasError)
                {
                    con = this.removeErrorMessages(con);
                }
                if (pass.exists(#WorkId) && pass.exists(#LineNum))
                {
                    pass.remove(#WorkId);
                    pass.remove(#LineNum);
                }

                if (!pass.exists(#ReceiptId))
                {
                    pass.parmReceiptId(NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                }

                pass.remove(#UpdatedBatchId);

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = this.addErrorLabel(ret, conPeek(conPeek(con, #IndexOfErrorControlInContainer), #IndexOfErrorControlInContainer));
                    ret = this.buildGetTOLineLP(ret);
                    addCancel = false;
                    break;
                }

                WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
                boolean            continueToNextStep;

                if (menuItemTable.GenerateLP)
                {
                    using(var deferredReceivingBatchTaskBundleCreationContext = WHSDeferredReceivingBatchTaskBundleCreationFlight::instance().isEnabled() ? WHSDeferredReceivingBatchTaskBundleCreationContext::construct() : null)
                    {
                        while (pass.lookupNum(#RunningQty) > 0)
                        {
                            if (!fieldValues.empty())
                            {
                                if (!pass.exists(#LicensePlateId))
                                {
                                    pass.insert(#LicensePlateId, WHSLicensePlate::generateLicensePlateId(pass.lookup(#ItemId), pass.lookup(#CurrentUOM)));
                                }

                                if (menuItemTable.DisplayContainerTypeCode && !pass.exists(#ContainerType))
                                {
                                    ret = this.buildGetTOLineLP(conNull());
                                    displayContainerType = true;
                                    break;
                                }

                                [ret, complete] = this.processFieldValues(con, fieldValues);

                                if (complete)
                                {
                                    transferLine = this.inventTransferLine();

                                    if (this.captureTrackingDimensions(pass.lookup(#ItemId))
                                    && !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.parmReceiptId(), pass.lookup(#LicensePlateId)))
                                    {
                                        ret = this.prepareAndBuildTrackingDimensions(transferLine.InventDimId);
                                        ret = this.updateModeStepPass(ret, mode, step, pass);
                                        return ret;
                                    }

                                    if (!this.captureTrackingDimensions(pass.lookup(#ItemId))
                                    &&  WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem))
                                    &&  !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                    {
                                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::convertInventQuantity(transferLine.ItemId,
                                                                                                                pass.lookup(#CurrentUOM),
                                                                                                                pass.lookupNum(#CurrentQty),
                                                                                                                transferLine.InventDimId));

                                        ret = conNull();
                                        ret = this.buildCWTagCapture(ret);

                                        step = #CatchWeightTagCapture;
                                        return ret;
                                    }

                                    if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                    {
                                        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                                    }

                                    inventTrans  = InventTrans::findTransId(transferLine.InventTransIdReceive);
                                    if (inventTrans.inventDim().InventLocationId != pass.lookup(#InventLocationId))
                                    {
                                        addCancel = true;
                                        throw error("@WAX1239");
                                    }

                                    receivingWorkWasDeferred = false;

                                    if (menuItemTable.DeferredReceivingPolicyId != '')
                                    {
                                        receivingWorkWasDeferred = this.tryToDeferWork(transferLine, menuItemTable);
                                    }

                                    if (receivingWorkWasDeferred)
                                    {
                                        pass.parmReceiptId(NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());

                                        this.buildLicensePlateLabelsForDeferredReceiving(transferLine);

                                        Qty runningQty = this.runningQuantityForTransferOrderReceiving(transferLine);
                                        pass.insert(#RunningQty, runningQty);
                                        this.updateQtyAndUOMPassValuesForReceivingTheNextLP(transferLine);
                                    }
                                    else
                                    {
                                        workBuildId = this.createWork(transferLine);

                                        this.buildLicensePlateLabels(workBuildId);

                                        Qty runningQty = this.runningQuantityForTransferOrderReceiving(transferLine);
                                        pass.insert(#RunningQty, runningQty);
                                        this.updateQtyAndUOMPassValuesForReceivingTheNextLP(transferLine);

                                        [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, step, menuItemTable);
                                    }

                                    if (continueToNextStep)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if (step == #SortReceive)
                    {
                        break;
                    }

                    if (displayContainerType)
                    {
                        break;
                    }

                    if (mode == this.getTOReceivingAndPutawayExecuteMode())
                    {
                        [con, ret] = this.updatePassAndDisplayToExecutePutawayWork(workBuildId,
                                                                                workExecuteDisplay,
                                                                                con,
                                                                                newLocationId,
                                                                                _buttonClicked);
                    }
                    else
                    {
                        pass = this.resetPassWithClusterMessages(pass, con, false);
                        pass.insert(#WorkComplete, 1);
                        pass.insert(#TONum, transferLine.TransferId);

                        con = conPoke(con, 2, pass.pack());
                        step = 0;
                        workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                        ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                        pass = new WHSRFPassthrough(Types::String, Types::String);
                        pass = WHSRFPassthrough::create(conPeek(ret, 2));
                        break;
                    }
                }
                else
                {
                    if (!fieldValues.empty())
                    {
                        // Display screen extra time to allow for entering the container type.
                        if (pass.hasValue(#LicensePlateId)
                            &&  menuItemTable.DisplayContainerTypeCode
                            && !pass.exists(#ContainerType))
                        {
                            ret = this.buildGetTOLineLP(conNull());
                            break;
                        }

                        [ret, complete] = this.processFieldValues(con, fieldValues);

                        if (complete)
                        {
                            transferLine = this.inventTransferLine();

                            if (this.captureTrackingDimensions(pass.lookup(#ItemId))
                                &&  !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.parmReceiptId(), pass.lookup(#LicensePlateId)))
                            {
                                ret = this.prepareAndBuildTrackingDimensions(transferLine.InventDimId);

                                break;
                            }

                            if (!this.captureTrackingDimensions(pass.lookup(#ItemId))
                                && WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem))
                                && !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                            {
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::convertInventQuantity(transferLine.ItemId,
                                                                                                        pass.lookup(#CurrentUOM),
                                                                                                        pass.lookupNum(#CurrentQty),
                                                                                                        transferLine.InventDimId));

                                ret = conNull();
                                ret = this.buildCWTagCapture(ret);

                                step = #CatchWeightTagCapture;
                                break;
                            }

                            if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                            {
                                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                            }

                            inventTrans  = InventTrans::findTransId(transferLine.InventTransIdReceive);
                            if (inventTrans.inventDim().InventLocationId != pass.lookup(#InventLocationId))
                            {
                                addCancel = true;
                                throw error("@WAX1239");
                            }

                            receivingWorkWasDeferred = false;

                            if (menuItemTable.DeferredReceivingPolicyId != '')
                            {
                                using(var deferredReceivingBatchTaskBundleCreationContext = WHSDeferredReceivingBatchTaskBundleCreationFlight::instance().isEnabled() ? WHSDeferredReceivingBatchTaskBundleCreationContext::construct() : null)
                                {
                                    receivingWorkWasDeferred = this.tryToDeferWork(transferLine, menuItemTable);
                                }
                            }

                            if (receivingWorkWasDeferred)
                            {
                                pass.parmReceiptId(NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                                
                                this.buildLicensePlateLabelsForDeferredReceiving(transferLine);
                            }
                            else
                            {
                                workBuildId = this.createWork(transferLine);

                                this.buildLicensePlateLabels(workBuildId);

                                if (mode == this.getTOReceivingAndPutawayExecuteMode())
                                {
                                    [con, ret] = this.updatePassAndDisplayToExecutePutawayWork(workBuildId,
                                                                                workExecuteDisplay,
                                                                                con,
                                                                                newLocationId,
                                                                                _buttonClicked);
                                }
                            }

                            if (pass.exists(#RunningQty) && pass.lookupNum(#RunningQty) == 0 &&
                                mode != this.getTOReceivingAndPutawayExecuteMode())
                            {
                                pass = this.resetPassthrough(con, false);
                                pass.insert(#TONum, transferLine.TransferId);
                                pass.insert(#WorkComplete, 1);

                                if (!receivingWorkWasDeferred)
                                {
                                    [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, 0, menuItemTable);
                                }

                                if (continueToNextStep)
                                {
                                    break;
                                }

                                con = conPoke(con, 2, pass.pack());
                                step = 0;
                                workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                                ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                                pass = new WHSRFPassthrough(Types::String, Types::String);
                                pass = WHSRFPassthrough::create(conPeek(ret, 2));
                                break;
                            }

                            if (!pass.exists(#DoingWork))
                            {
                                this.updateQtyAndUOMPassValuesForReceivingTheNextLP(transferLine);
                                this.removeTrackingDimensionsFromPass(pass.lookupStr(#ItemId));
                                Qty runningQty = this.runningQuantityForTransferOrderReceiving(transferLine);
                                pass.insert(#RunningQty, runningQty);

                                if (!receivingWorkWasDeferred)
                                {
                                    [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, step, menuItemTable);
                                }

                                if (continueToNextStep)
                                {
                                    break;
                                }

                                ret = this.addClusterMessages(conNull());
                                
                                ret = this.buildGetTOLineLP(ret);
                            }
                            pass.remove(#DoingWork);
                        }
                    }
                }
                break;

            // Capture tracking dimensions if necessary
            case #TrackingDimDetailsStep:
                [hasError, ret, addCancel] = this.processTrackingDimDetails(2, hasError, con, fieldValues, startInfologLine, addCancel, InventTransType::TransferOrderReceive);
                break;
            
            case #SortReceive:
                ret = this.stepSortReceive(con, _buttonClicked);
                break;
                
            case #CatchWeightTagCapture:
                ret = this.processCWTagCapture(hasError, con);
                break;

            default:
                    if (pass.exists(#WorkId))
                    {
                        if (pass.exists(#LineNum))
                        {
                            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                        }
                        else
                        {
                            workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                        }

                        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                        {
                            throw error("@WAX1459");
                        }

                        workTable = workLine.whsWorkTable();
                    }

                    tmpQty = pass.lookupNum(#RunningQty);
                    menuItem = pass.lookup(#MenuItem);
                    con = conPoke(con, 2, pass.pack());
                    tmpMap = pass;
                    tmpStep = step;
                    workBuildId = workTable.WorkBuildId;
                    [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, newLocationId, _buttonClicked, false);
                    pass = new WHSRFPassthrough(Types::String, Types::String);
                    pass = WHSRFPassthrough::create(tmpPass);
                    pass = this.combineMaps(tmpMap, pass);

                    if (tmpStep != #ReceivingExceptionStep1 && tmpStep != #ReceivingExceptionStep2)
                    {
                        pass.insert(#RunningQty, tmpQty);
                    }

                    pass.insert(#MenuItem, menuItem);

                    if (step == #Restart)
                    {
                        if (pass.lookupNum(#RunningQty) == 0)
                        {
                            // Check for additional work to execute in case of cross docking
                            workLine = WHSWorkTable::findOpenCrossDockWorkByWorkBuildId(workBuildId, userId);

                            if (workLine.RecId != 0)
                            {
                                if (pass.exists(#WorkComplete))
                                {
                                    pass.remove(#WorkComplete);
                                }

                                this.restartForCrossDockInbound();
                                tmpQty = pass.lookupNum(#RunningQty);
                                menuItem = pass.lookup(#MenuItem);
                                con = this.updateModeStepPass(con, mode, step, pass);
                                [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, newLocationId, _buttonClicked, false);
                                pass = WHSRFPassthrough::newReset(pass);
                                pass = WHSRFPassthrough::create(tmpPass);
                                pass.insert(#RunningQty, tmpQty);
                            }
                            else
                            {
                                transferLine = this.inventTransferLine();
                                pass = WHSRFPassthrough::newReset(pass);
                                pass.insert(#WorkComplete, 1);
                                pass.insert(#TONum, transferLine.TransferId);
                                con = conNull();
                                con = this.buildTOReceiving(con);
                                step = 0;
                            }
                        }
                        else
                        {
                            transferLine = this.inventTransferLine();

                            this.updateQtyAndUOMPassValuesForReceivingTheNextLP(transferLine);
                            Qty runningQty = this.runningQuantityForTransferOrderReceiving(transferLine);
                            pass.insert(#RunningQty, runningQty);

                            step = 2;
                            con = conNull();
                            con = this.buildGetTOLineLP(con);
                        }
                    }
                    else if (step == #StepOne)
                    {
                        if (!pass.exists(#RebuildForm))
                        {
                            step = #StepMax;
                            pass.insert(#DetermineStep, 1);
                        }
                        else
                        {
                            ret = conNull();
                            ret = this.buildTOReceiving(ret);
                            pass.remove(#RebuildForm);
                            step = 1;
                        }
                    }

                    if (recall)
                    {
                        con = this.updateModeStepPass(con, mode, step, pass);
                        con = conPoke(con, 1, [mode, step]);
                        workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                        ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                        pass = new WHSRFPassthrough(Types::String, Types::String);
                        pass = WHSRFPassthrough::create(conPeek(ret, 2));
                        if (pass.exists(#WorkId) && pass.exists(#LineNum))
                        {
                            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                            workTable = workLine.whsWorkTable();
                        }
                    }
                    break;
                }

                if (step > 1)
                {
                    ret = this.addButtons(ret);
                }
                else if (addCancel && !pass.exists(#NoCancelButton))
                {
                    ret = this.addCancelButton(ret, 1, true);
                }
                else
                {
                    pass.remove(#NoCancelButton);
                }
                if (addExceptionButton)
                {
                    ret = this.addExceptionButton(ret);
                }

                pass.remove(#HideExceptionButton);

                ret = this.updateModeStepPass(ret, mode, step, pass);

                return ret;
            }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransferLine</Name>
				<Source><![CDATA[
    private InventTransferLine inventTransferLine()
    {
        return InventTransferLine::find(pass.lookupstr(#TONum), pass.lookupNum(#TOLineNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureSerialOnReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given item needs to have serial numbers specified during receiving.
    /// </summary>
    /// <param name="_itemId">
    /// The item currently being received via the RF device.
    /// </param>
    /// <returns>
    /// True, if the serial number needs to be captured on receipt; otherwise False.
    /// </returns>
    /// <remarks>
    /// For transfer orders the serial must always be captured on receipt if serial is active.
    /// </remarks>
    protected boolean mustCaptureSerialOnReceipt(ItemId _itemId)
    {
        //check if there is a serial synched to any of the receipt transactions, if there is not then we are not receiving with serial
        return WHSInventTransferLine::existsReceiptTransWithSerial(this.inventTransferLine());
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareAndBuildTrackingDimensions</Name>
				<Source><![CDATA[
    private container prepareAndBuildTrackingDimensions(InventDimId _inventDimId)
    {
        container ret;

        pass.insert(#DimUOM, pass.lookup(#CurrentUOM));
        //if we need to capture the serial in this flow then we will not default since user needs to be able to specify a qty before the flow is considered done
        if (this.mustCaptureSerialOnReceiptInCurrentFlow(pass.lookup(#ItemId)))
        {
            pass.insert(#DimQty, '');
        }

        pass.insert(#DimRunningQty, WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId),
                                                                           pass.lookup(#CurrentUOM),
                                                                           pass.lookupNum(#CurrentQty),
                                                                           _inventDimId));
        step = #TrackingDimDetailsStep;
        ret = this.buildTORecTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runningQuantityForTransferOrderReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the running quantity for the transfer order receiving based on the license plate grouping.
    /// </summary>
    /// <param name="_transferLine">
    /// The transfer order line for which  the running quantity is being calculated for the license plate grouping.
    /// </param>
    /// <returns>
    /// Returns the running quantity for the transfer order for the various license plate grouping.
    /// </returns>
    protected Qty runningQuantityForTransferOrderReceiving(InventTransferLine _transferLine)
    {
        Qty runningQty;

        switch (pass.parmUnitization())
        {
            case WHSLicensePlateGroupingPolicy::UserDefined:
                //For user defined license plate grouping policy, quantity should be reduced by one as number of plates generated should be equal to running qty.
                runningQty = pass.lookupNum(#RunningQty) - 1;
                break;

            case WHSLicensePlateGroupingPolicy::None:
            case WHSLicensePlateGroupingPolicy::LicensePlateGrouping:
                runningQty = pass.lookupNum(#RunningQty) - WHSCatchWeightHelper::convertInventQuantity(
                                                                                _transferLine.ItemId,
                                                                                pass.lookup(#CurrentUOM),
                                                                                pass.lookupNum(#CurrentQty),
                                                                                _transferLine.InventDimId);
                break;
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantities for the Transfer Order receiving.
    /// </summary>
    /// <param name="_transferLine">
    /// The Transfer Order line  record for which running quantity is being calculated.
    /// </param>
    /// <param name="_qtyReceived">
    /// Total amount of the quantity received during Transfer Order receiving.
    /// </param>
    protected void calculateQuantities(InventTransferLine _transferLine, Qty _qtyReceived)
    {
        Qty                         finalQty;
        UnitOfMeasureSymbol         finalUnitId;
        int                         numLP;
        Qty                         runningQty;

        switch (pass.parmUnitization())
        {
            case WHSLicensePlateGroupingPolicy::UserDefined:
                [numLP, finalQty, finalUnitId] = WHSWorkCreateReceiving::unitizeQtyUserDefined(pass.lookupNum(#Qty), pass.lookup(#UOM));
                pass.insert(#QtyReceived, numLP);
                runningQty = numLP;
                break;

            case WHSLicensePlateGroupingPolicy::None:
            case WHSLicensePlateGroupingPolicy::LicensePlateGrouping:
                pass.insert(#QtyReceived, _qtyReceived);
                [numLP, finalQty, finalUnitId] = WHSWorkCreateReceiving::unitizeQuantity(_transferLine.ItemId, _qtyReceived, pass.lookup(#Unitization), _transferLine.InventDimId);
                runningQty = _qtyReceived - WHSCatchWeightHelper::convertInventQuantity(_transferLine.ItemId, finalUnitId, finalQty, _transferLine.InventDimId);
                break;
        }

        pass.insert(#CurrentQty, finalQty);
        pass.insert(#CurrentUOM, finalUnitId);
        pass.insert(#NumLP, numLP);
        pass.insert(#CurrentLP, 1);
        pass.insert(#RunningQty, runningQty);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>