<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqTransFormExplosion</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ReqTransFormExplosion extends ReqTransForm
{
    #resAppl

    private static readonly Types RecIdType = typeName2Type(extendedtypestr(recId));

    FormTreeControl             ctrlTree;
    FormComboBoxControl         ctrlReqExplodeType;
    FormStringControl           ctrlFormatExplain;
    FormStaticTextControl       reqTransCaption;

    ReqTransExplode             reqTransExplode;
    TmpReqExplosionTree         tmpReqExplosionTree;
    InventDimParm               inventDimParm;

    Map                         mapNode2RecId;      // integer,integer
    Map                         mapRecId2Node;      // integer,set
    Set                         setNodeReady;

    int                         rootId;
    int                         newIdSave;

    Set                         setTopRecId;
    Map                         mapDerived;
    Map                         mapReqTrans;
    Map                         mapReqTransPO;
    Map                         mapParent;
    Map                         mapReqTransSettled;

    Map                         mapReqTransText;

    Map                         mapDb2TmpRecId;
    Map                         mapTmpRecId2Db;

    ReqTrans                    reqTransCaller;

    ImageListAppl_StateReq      imageListAppl_StateReq;

    boolean                     initReqExplodeType;
    boolean                     forceRecursiveBuild;

    #DEFINE.CurrentVersion(15)

    #LOCALMACRO.CurrentList
        tmpReqExplosionTree,
        InventDimParm
    #ENDMACRO

    GanttClient_ReqExplosion    ganttClient;

    TmpReqExplosionOnHand       tmpReqExplosionOnHand;
    FormDataSource              tmpReqExplosionOnhand_DS;

    InventDimCtrl_Frm           inventDimFormSetup;
    ItemId                      lastItemId;

    boolean                     interCompany;

    FormDataSource              batchReqTrans_ds;
    QueryBuildRange             batchPlanVersion;
    QueryBuildRange             batchReqRefType;
    QueryBuildRange             batchReqRefId;
    QueryBuildRange             batchReqRecId;
    boolean                     isBatch;
    boolean                     isSessionLanguageRTL;

    ReqPlanningItemHelper       planningItemHelper;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>batchReqTransDSExecuteQueryPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is called before the executequery on the form.
    /// it builds a query related to batch reqtrans for a formula
    /// or by recid if its a non-formula
    /// </summary>
    public void batchReqTransDSExecuteQueryPre()
    {
        #define.comma(',')

        if (#PmfEnabled
            && (    reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                ||  reqTrans.RefType == ReqRefType::PmfCoProduct)
            &&  InventTable::find(reqTrans.ItemId).isFormulaAllowed())
        {
            batchPlanVersion.value(queryValue(reqTrans.PlanVersion));
            batchReqRefType.value(
                queryValue(
                    ReqRefType::PmfPlannedProdBatch)
                        + #comma
                        + queryValue(ReqRefType::PmfCoProduct));
            batchReqRefId.value(queryValue(reqTrans.RefId));
            batchReqRecId.value(SysQuery::valueUnlimited());
            isBatch = true;
        }
        else
        {
           batchReqRecId.value(queryValue(reqTrans.RecId));
           batchPlanVersion.value(SysQuery::valueUnlimited());
           batchReqRefType.value(SysQuery::valueUnlimited());
           batchReqRefId.value(SysQuery::valueUnlimited());
           isBatch = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchReqTransDSInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method initilized the datasource for the form.
    /// Here querybuildranges are added.
    /// </summary>
    /// <param name="_reqTrans">Current transaction.</param>
    public void batchReqTransDSInitPost(ReqTrans _reqTrans)
    {
        QueryBuildDataSource    qbs;

        batchReqTrans_ds    = FormDataUtil::getFormDataSource(_reqTrans);
        qbs = batchReqTrans_ds.query().dataSourceTable(tablenum(ReqTrans));
        batchPlanVersion    = qbs.addRange(fieldnum(ReqTrans,PlanVersion));
        batchReqRefType     = qbs.addRange(fieldnum(ReqTrans,RefType));
        batchReqRefId       = qbs.addRange(fieldnum(ReqTrans,RefId));
        batchReqRecId       = qbs.addRange(fieldnum(ReqTrans,RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCallerDSExecuteQueryPost</Name>
				<Source><![CDATA[
    public void reqTransCallerDSExecuteQueryPost(ReqTrans _reqTransCaller, Common _callerRecord)
    {
        if (!_reqTransCaller.RecId)
        {
            this.build();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustEnableReqCalcExplodeButton</Name>
				<Source><![CDATA[
    public boolean mustEnableReqCalcExplodeButton(ReqTrans _reqTransCaller)
    {
        return _reqTransCaller.RecId && ReqCalcExplode::canRunReqTrans(_reqTransCaller.RefType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buttonReqCalcExplodeClickedPre</Name>
				<Source><![CDATA[
    public void buttonReqCalcExplodeClickedPre()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buttonReqCalcExplodeNodeClickedPre</Name>
				<Source><![CDATA[
    public void buttonReqCalcExplodeNodeClickedPre()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>build</Name>
				<Source><![CDATA[
    public void build()
    {
        container conSetTopRecId;
        container conMapDerived;
        container conMapReqTrans;
        container conMapReqTransPO;
        container conMapParent;
        container conMapReqTransSettled;

        // init

        if (initReqExplodeType && ctrlReqExplodeType)
        {
            ctrlReqExplodeType.selection(reqTransCaller.reqExplodeTypeDefault());

            initReqExplodeType = false;
        }

        // Calc explosion
        [conSetTopRecId,conMapDerived,conMapReqTrans,conMapReqTransPO,conMapParent,conMapReqTransSettled] = ReqTransExplode::packRunReqTrans(reqTransCaller, this.reqExplodeType(), this.parmInterCompany());

        setTopRecId          = (conSetTopRecId)          ? Set::create(conSetTopRecId)           : new Set(Types::Integer);
        mapDerived           = (conMapDerived)           ? Map::create(conMapDerived)            : new Map(RecIdType, Types::Container);
        mapReqTrans          = (conMapReqTrans)          ? Map::create(conMapReqTrans)           : new Map(RecIdType, Types::Record);
        mapReqTransPO        = (conMapReqTransPO)        ? Map::create(conMapReqTransPO)         : new Map(RecIdType, Types::Record);
        mapParent            = (conMapParent)            ? Map::create(conMapParent)             : new Map(RecIdType, RecIdType);
        mapReqTransSettled   = (conMapReqTransSettled)   ? Map::create(conMapReqTransSettled)    : new Map(RecIdType, Types::Class);

        this.refreshForm();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconstruct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reconstructs the explosion tree from cached explosion results.
    /// </summary>
    /// <param name = "_container">A container containing the cached explosion.</param>
    public void reconstruct(container _container)
    {
        container conSetTopRecId;
        container conMapDerived;
        container conMapReqTrans;
        container conMapReqTransPO;
        container conMapParent;
        container conMapReqTransSettled;

        // Calc explosion
        [conSetTopRecId,conMapDerived,conMapReqTrans,conMapReqTransPO,conMapParent,conMapReqTransSettled] = _container;

        setTopRecId          = (conSetTopRecId)          ? Set::create(conSetTopRecId)           : new Set(Types::Integer);
        mapDerived           = (conMapDerived)           ? Map::create(conMapDerived)            : new Map(RecIdType, Types::Container);
        mapReqTrans          = (conMapReqTrans)          ? Map::create(conMapReqTrans)           : new Map(RecIdType, Types::Record);
        mapReqTransPO        = (conMapReqTransPO)        ? Map::create(conMapReqTransPO)         : new Map(RecIdType, Types::Record);
        mapParent            = (conMapParent)            ? Map::create(conMapParent)             : new Map(RecIdType, RecIdType);
        mapReqTransSettled   = (conMapReqTransSettled)   ? Map::create(conMapReqTransSettled)    : new Map(RecIdType, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the temporary <c>ReqTrans</c> buffer.
    /// </summary>
    public void clearReqTrans()
    {
        delete_from reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doReread</Name>
				<Source><![CDATA[
    public void doReread()
    {
        if (reqTransCaller.RecId)
        {
            FormDataUtil::getFormDataSource(reqTransCaller).reread();
            
            this.doRefresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doRefresh</Name>
				<Source><![CDATA[
    public void doRefresh()
    {
        if (reqTransCaller.RecId)
        {
            FormDataUtil::getFormDataSource(reqTransCaller).refresh();

            this.build();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doResearch</Name>
				<Source><![CDATA[
    public void doResearch()
    {
        if (reqTransCaller.RecId)
        {
            FormDataUtil::getFormDataSource(reqTransCaller).research();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formInitPost</Name>
				<Source><![CDATA[
    void formInitPost()
    {
        super();

        ctrlTree.setImagelist(imageListAppl.imageList());
        ctrlTree.setStateImagelist(imageListAppl_StateReq.imageList());

        ctrlFormatExplain.visible(tmpReqExplosionTree.SettingsDisplayFormatExplain);

        initReqExplodeType = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formPreClose</Name>
				<Source><![CDATA[
    public void formPreClose(boolean _saveLast = true)
    {
        if (ganttClient)
        {
            ganttClient.close();
        }

        super(_saveLast);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formUpdateDesign</Name>
				<Source><![CDATA[
    void formUpdateDesign(InventDimFormDesignUpdate mode)
    {
        InventDimParm       tmpInventDimParm;
        Set                 validInventDimDatasources = new Set(Types::String);

        switch (mode)
        {
            case InventDimFormDesignUpdate::Init          :
                if (! inventDimFormSetup)
                {
                    inventDimFormSetup  = InventDimCtrl::newFromForm(formRun);
                    validInventDimDatasources.add(formdatasourcestr(ReqTransExplosion, InventDimOnHand));
                    validInventDimDatasources.add(formdatasourcestr(ReqTransExplosion, InventDimCaller));
                    inventDimFormSetup.parmValidDataSources(validInventDimDatasources);
                }

                if (reqTransCaller.ItemId)
                {
                    if (lastItemId != reqTransCaller.ItemId)
                    {
                        tmpInventDimParm.initCovPrDimension(InventDimGroupSetup::newItemId(reqTransCaller.ItemId));
                        inventDimFormSetup.parmDimParmVisibleGrid(tmpInventDimParm.data());
                        inventDimFormSetup.parmDimParmEnabled(tmpInventDimParm.data());

                        inventDimFormSetup.formSetControls(true);

                        lastItemId = reqTransCaller.ItemId;
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExplosionViewButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates explosion type buttons' state.
    /// </summary>
    /// <param name = "_explosionTreeView">Form menu button containing up and down buttons.</param>
    /// <param name = "_explodeDown">Down form button.</param>
    /// <param name = "_explodeUp">Up form button.</param>
    /// <param name = "_invertArrowDirection">A value indicating whether arrow direction should be inverted.</param>
    public void updateExplosionViewButton(FormMenuButtonControl _explosionTreeView, FormButtonControl _explodeDown,  FormButtonControl _explodeUp, boolean _invertArrowDirection = false)
    {
        boolean downView = this.reqExplodeType() == ReqExplodeType::Down;
        downView = _invertArrowDirection ? !downView : downView;

        _explosionTreeView.normalImage(downView ? ImageReferenceSymbol::Down : ImageReferenceSymbol::Up);
        _explodeDown.enabled(!downView);
        _explodeUp.enabled(downView);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ganttBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and fills the Gantt control with data.
    /// </summary>
    /// <param name = "_ganttControl">The Gantt form control.</param>
    void ganttBuild(GanttControl _ganttControl)
    {
        if (!ganttClient)
        {
            ganttClient = GanttClient_ReqExplosion::newReqTransFormExplosion(_ganttControl, this);
            ganttClient.runOperation();
        }
        else
        {
            ganttClient.reload();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ganttClient</Name>
				<Source><![CDATA[
    GanttClient_ReqExplosion ganttClient()
    {
        return ganttClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqTransPOFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the <c>ReqPO</c> table record that relates to the specified requirement from the cache or looks it up if not on the cache.
    /// </summary>
    /// <param name="_reqTrans">
    ///     The planned order requirement.
    /// </param>
    /// <returns>
    ///     The planned order record.
    /// </returns>
    private ReqPO getReqTransPOFromCache(ReqTrans _reqTrans)
    {
        ReqPO reqTransPO;

        if (mapReqTransPO.exists(_reqTrans.RecId))
        {
            reqTransPO = mapReqTransPO.lookup(_reqTrans.RecId);
        }
        else
        {
            reqTransPO = _reqTrans.reqPo();
            mapReqTransPO.insert(_reqTrans.RecId, reqTransPO);
        }

        return reqTransPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCaller</Name>
				<Source><![CDATA[
    public void initFromCaller()
    {
        ProdTable prodTable;

        super();

        prodTable = formRun.args().record() as ProdTable;
        if (prodTable && prodTable.inventTable().PmfProductType == PmfProductType::MainItem)
        {
            if (!planningItemHelper)
            {
                planningItemHelper = ReqPlanningItemHelper::construct();
            }
            planningItemHelper.ensureProductionReqTransExists(prodTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        tmpReqExplosionTree.DisplayItemName = NoYes::Yes;
        tmpReqExplosionTree.DisplayItemId   = NoYes::Yes;
        tmpReqExplosionTree.DisplayRefType  = NoYes::Yes;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParm</Name>
				<Source><![CDATA[
    InventDimParm inventDimParm(InventDimParm _inventDimParm = inventDimParm)
    {
        inventDimParm = _inventDimParm;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    public dataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public identifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    public identifierName lastValueElementName()
    {
        return formRun.name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    public UtilElementType lastValueType()
    {
        return UtilElementType::Form;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    public userId lastValueUserId()
    {
        return curuserid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapDerived</Name>
				<Source><![CDATA[
    public Map mapDerived()
    {
        return mapDerived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapParent</Name>
				<Source><![CDATA[
    public Map mapParent()
    {
        return mapParent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapReqTrans</Name>
				<Source><![CDATA[
    Map mapReqTrans()
    {
        return mapReqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapReqTransSettled</Name>
				<Source><![CDATA[
    public Map mapReqTransSettled()
    {
        return mapReqTransSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapTmpRecId2Db</Name>
				<Source><![CDATA[
    Map mapTmpRecId2Db()
    {
        return mapTmpRecId2Db;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPErrorClassNewNotProtected', 'The constructor is preserved public due to API compatibility.')]
public void new(FormRun _formRun)
    {
        super(_formRun);

        imageListAppl_StateReq = new ImageListAppl_StateReq();

        this.parmInterCompany(false);

        mapReqTransText      = new Map(RecIdType, Types::String);
        isSessionLanguageRTL = currentSessionLanguageRTL();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newIdSave</Name>
				<Source><![CDATA[
    Integer newIdSave(Integer _newIdSave = newIdSave)
    {
        newIdSave = _newIdSave;
        return newIdSave;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container base = super();

        return [#CurrentVersion,#currentList,base];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlFormatExplain</Name>
				<Source><![CDATA[
    FormStringControl parmCtrlFormatExplain(FormStringControl _formatExplain = ctrlFormatExplain)
    {
        ctrlFormatExplain = _formatExplain;
        return ctrlFormatExplain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqTransCaption</Name>
				<Source><![CDATA[
    FormStaticTextControl parmReqTransCaption(FormStaticTextControl _reqTransCaption = reqTransCaption)
    {
        reqTransCaption = _reqTransCaption;
        return reqTransCaption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlReqExplodeType</Name>
				<Source><![CDATA[
    FormComboBoxControl parmCtrlReqExplodeType(FormComboBoxControl _reqExplodeType = ctrlReqExplodeType)
    {
        ctrlReqExplodeType = _reqExplodeType;
        return ctrlReqExplodeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlTree</Name>
				<Source><![CDATA[
    FormTreeControl parmCtrlTree(FormTreeControl _tree = ctrlTree)
    {
        ctrlTree = _tree;
        return ctrlTree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompany</Name>
				<Source><![CDATA[
    public boolean parmInterCompany(boolean _interCompany = interCompany)
    {
        interCompany = _interCompany;
        return interCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForceRecursiveBuild</Name>
				<Source><![CDATA[
    public boolean parmForceRecursiveBuild(boolean _forceRecursiveBuild = forceRecursiveBuild)
    {
        forceRecursiveBuild = _forceRecursiveBuild;
        return forceRecursiveBuild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>redraw</Name>
				<Source><![CDATA[
    public void redraw()
    {
        formRunObject.redrawTab();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the tab on the form.
    /// </summary>
    protected void refreshForm()
    {
        formRunObject.initTab(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqExplodeType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the type of explosion that will be performed.
    /// </summary>
    /// <returns>
    ///    The type of explosion that will be performed.
    /// </returns>
    protected ReqExplodeType reqExplodeType()
    {
        return ctrlReqExplodeType.selection();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCaller</Name>
				<Source><![CDATA[
    ReqTrans reqTransCaller()
    {
        return reqTransCaller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCallerDSInitPost</Name>
				<Source><![CDATA[
    void reqTransCallerDSInitPost(ReqTrans _reqTransCaller)
    {
        reqTransCaller  = _reqTransCaller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCovDSExecuteQueryPre</Name>
				<Source><![CDATA[
    public void reqTransCovDSExecuteQueryPre(recId _recId = reqTrans.RecId)
    {
        recId recId;
        ReqTrans    tmpReqTrans;
        str         qStr = '';
        #define.Or(',')

        if (this.mapTmpRecId2Db() && this.mapTmpRecId2Db().exists(reqTrans.RecId))
        {
            recId = this.mapTmpRecId2Db().lookup(reqTrans.RecId);
        }
        else
        {
            recId = 0;
        }

        super(recId);

        if (isBatch)
        {
            tmpReqTrans = batchReqTrans_ds.getFirst(0,false);
            while (tmpReqTrans.RecId)
            {
                if (qStr)
                {
                    qStr += #Or;
                }

                qStr += queryValue(tmpReqTrans.RecId);
                tmpReqTrans = batchReqTrans_ds.getNext();
            }
            rangeReceiptRecId.value(
                reqTrans.Qty >= 0
                    ? qStr
                    : SysQuery::valueUnlimited());
            rangeIssueRecId.value(
                reqTrans.Qty >= 0
                    ? SysQuery::valueUnlimited()
                    : qStr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransDSActivePost</Name>
				<Source><![CDATA[
    void reqTransDSActivePost()
    {
        recId   recId;

        if (reqTrans.RecId && mapTmpRecId2Db)
        {
            if (mapTmpRecId2Db.exists(reqTrans.RecId))
            {
                recId = mapTmpRecId2Db.lookup(reqTrans.RecId);

                if (recId != this.treeNode2RecId(ctrlTree.getFirstSelected()))
                {
                    if (ctrlTree.getItem(this.treeRecId2Node(recId)))
                    {
                        ctrlTree.select(this.treeRecId2Node(recId));
                        newIdSave = 0;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransDSFind</Name>
				<Source><![CDATA[
    void reqTransDSFind(int _newIdSave)
    {
        ReqTrans reqTransTmp;
        if (mapDb2TmpRecId && mapDb2TmpRecId.exists(this.treeNode2RecId(_newIdSave)))
        {
            reqTransTmp.RecId = mapDb2TmpRecId.lookup(this.treeNode2RecId(_newIdSave));

            reqTrans_ds.findRecord(reqTransTmp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showRefType</Name>
				<Source><![CDATA[
    public boolean showRefType(ReqTrans _tmp)
    {
        return _tmp.RefType != ReqRefType::InventOnHand ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReqExplosionOnhandBuild</Name>
				<Source><![CDATA[
    void tmpReqExplosionOnhandBuild()
    {
        ReqTransFormExplosion::tmpReqExplosionOnhandBuildServer(tmpReqExplosionOnHand, mapReqTransSettled.pack(), reqTransCaller.RecId, mapReqTrans.pack());

        tmpReqExplosionOnhand_DS.executeQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReqExplosionOnhandDSInitPost</Name>
				<Source><![CDATA[
    void tmpReqExplosionOnhandDSInitPost(TmpReqExplosionOnHand _tmpReqExplosionOnHand)
    {
        Query                query;
        QueryBuildDataSource qbs;

        tmpReqExplosionOnHand       = _tmpReqExplosionOnHand;
        tmpReqExplosionOnhand_DS    = FormDataUtil::getFormDataSource(_tmpReqExplosionOnHand);

        query = new Query();
        qbs   = query.addDataSource(tablenum(TmpReqExplosionOnHand));
        qbs.name(tmpReqExplosionOnhand_DS.name());

        qbs.addSortField(fieldnum(TmpReqExplosionOnHand,DelayDays),SortOrder::Descending);

        tmpReqExplosionOnhand_DS.query(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReqExplosionTree</Name>
				<Source><![CDATA[
    TmpReqExplosionTree tmpReqExplosionTree(TmpReqExplosionTree _tmpReqExplosionTree = tmpReqExplosionTree)
    {
        tmpReqExplosionTree = _tmpReqExplosionTree;
        return tmpReqExplosionTree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReqTransBuild</Name>
				<Source><![CDATA[
    public void tmpReqTransBuild()
    {
        ReqTrans                reqTransTmp;
        MapIterator             mi;

        // clear
        this.clearReqTrans();

        // Insert TmpReqTrans
        if (mapReqTrans)
        {
            mi = new MapIterator(mapReqTrans);

            mapDb2TmpRecId = new Map(RecIdType, RecIdType);
            mapTmpRecId2Db = new Map(RecIdType, RecIdType);

            mi.begin();
            while (mi.more())
            {
                reqTransTmp = mapReqTrans.lookup(mi.key());

                // Change company since the map might contain cross-company transactions
                changeCompany(
                    reqTransTmp.company()
                    )
                {
                    // Insert into the reqTrans temporary data set
                    reqTrans.clear();
                    buf2Buf(reqTransTmp, reqTrans);
                    reqTrans.doInsert();
                }

                mapDb2TmpRecId.insert(reqTransTmp.RecId,reqTrans.RecId);
                mapTmpRecId2Db.insert(reqTrans.RecId,reqTransTmp.RecId);

                mi.next();
            }
        }
        reqTrans_ds.executeQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeAddNode</Name>
				<Source><![CDATA[
    protected void treeAddNode(
        ReqTrans    _reqTrans,
        int         _nodeId
        )
    {
        Set setNodes;

        mapNode2RecId.insert(_nodeId,_reqTrans.RecId);

        if (mapRecId2Node.exists(_reqTrans.RecId))
        {
            setNodes = mapRecId2Node.lookup(_reqTrans.RecId);
        }
        else
        {
            setNodes = new Set(Types::Integer);
        }

        setNodes.add(_nodeId);
        mapRecId2Node.insert(_reqTrans.RecId,setNodes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeBuild</Name>
				<Source><![CDATA[
    public void treeBuild()
    {
        int                     rootCount;
        int                     newId;

        SetIterator             si;

        ReqTrans                reqTransTmp;

        if (!mapReqTrans)
        {
            //the initialization process is running as the form is being opened
            return;
        }

        // prepare the text maps
        mapReqTransText = Map::create(ReqTransFormExplosion::generateReqTransNodeTextsOnServer(
            mapReqTrans.pack(),
            inventDimParm,
            tmpReqExplosionTree,
            isSessionLanguageRTL));

        // clear
        rootId                  = 0;

        mapRecId2Node           = new Map(RecIdType,Types::Class);
        mapNode2RecId           = new Map(Types::Integer,RecIdType);
        setNodeReady            = new Set(Types::Integer);

        ctrlTree.deleteAll();

        // build tree
        if (setTopRecId && setTopRecId.elements())
        {
            si = new SetIterator(setTopRecId);
            si.begin();
            while (si.more())
            {
                if (mapReqTrans.exists(si.value()))
                {
                    reqTransTmp = mapReqTrans.lookup(si.value());
                }
                else
                {
                    reqTransTmp = null;
                }

                if (reqTransTmp.RecId)
                {
                    rootCount++;

                    changeCompany(
                        reqTransTmp.company()
                        )
                    {
                        newId = ctrlTree.add(FormTreeAdd::Root,FormTreeAdd::First,this.treeNodeTxt(reqTransTmp),this.displayImageReqRefType(reqTransTmp.RefType));

                        rootId = rootId ? rootId : newId;
                        this.treeAddNode(reqTransTmp,newId);

                        this.treeSetNodeProperty(newId,reqTransTmp);

                        this.treeBuildNode(newId,false,true);
                    }
                }

                si.next();
            }
        }

        if (rootCount == 1)
        {
            ctrlTree.expand(rootId);
        }

        ctrlTree.select(rootId);

        this.treeFormatExplain();
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeBuildNode</Name>
				<Source><![CDATA[
    public void treeBuildNode(
        int               parentNodeId,
        boolean           expandNode = false,
        boolean           recursive  = false
        )
    {
        ReqTrans        reqTransTmp;

        container       childContainer;
        Set             setChild;
        SetIterator     si;

        recId           recId;

        int             newId;
        boolean         nodeAlreadyExists;

        if (setNodeReady.in(parentNodeId))
        {
            return;
        }

        setNodeReady.add(parentNodeId);

        if (mapReqTrans.exists(this.treeNode2RecId(parentNodeId)))
        {
            reqTransTmp = mapReqTrans.lookup(this.treeNode2RecId(parentNodeId));
        }
        else
        {
            reqTransTmp = null;
        }

        if (reqTransTmp.RecId && mapDerived.exists(reqTransTmp.RecId))
        {
            childContainer = mapDerived.lookup(reqTransTmp.RecId);
            if (childContainer)
            {
                setChild = Set::create(childContainer);
            }
            if (childContainer && setChild && setChild.elements())
            {
                si = new SetIterator(setChild);
                si.begin();
                while (si.more())
                {
                    recId = si.value();

                    if (mapReqTrans.exists(recId))
                    {
                        reqTransTmp = mapReqTrans.lookup(recId);
                    }
                    else
                    {
                        reqTransTmp = null;
                    }

                    if (reqTransTmp.RecId)
                    {
                        changeCompany (reqTransTmp.company())
                        {
                            nodeAlreadyExists = mapRecId2Node.exists(reqTransTmp.RecId);

                            newId = ctrlTree.add(parentNodeId,0,this.treeNodeTxt(reqTransTmp),this.displayImageReqRefType(reqTransTmp.RefType));

                            this.treeAddNode(reqTransTmp,newId);

                            this.treeSetNodeProperty(newId,reqTransTmp);

                            if (recursive && mapDerived.exists(reqTransTmp.RecId) && !nodeAlreadyExists)
                            {
                                this.treeBuildNode(newId,false,forceRecursiveBuild ? true : this.reqExplodeType() != ReqExplodeType::Down);
                        }
                    }
                    }

                    si.next();
                }
            }

            if (expandNode)
            {
                ctrlTree.expand(parentNodeId);
        }
    }
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeFormatExplain</Name>
				<Source><![CDATA[
    void treeFormatExplain()
    {
        ctrlFormatExplain.visible(tmpReqExplosionTree.SettingsDisplayFormatExplain);

        if (tmpReqExplosionTree.SettingsDisplayFormatExplain)
        {
            ctrlFormatExplain.text(this.treeFormatTxt());
    }
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeFormatTxt</Name>
				<Source><![CDATA[
    FormatTxt treeFormatTxt()
    {
        FormatTxt       lineTxt;
        ListEnumerator  enumerator  = InventDim::dimFieldListEnumerator();
        fieldId         inventDimFieldId;
        fieldId         inventDimParmFieldId;

        lineTxt += (tmpReqExplosionTree.DisplayCompany              ? ((lineTxt ? ' / ' : '') +         "@SYS13342")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayPlanId               ? ((lineTxt ? ' / ' : '') +         "@SYS14433")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayProductNumber        ? ((lineTxt ? ' / ' : '') +         "@SYS133863")       : '');

        lineTxt += (tmpReqExplosionTree.DisplayItemName             ? ((lineTxt ? ' / ' : '') +         "@SYS5398")         : '');
        lineTxt += (tmpReqExplosionTree.DisplayItemId               ? ((lineTxt ? ' / ' : '') +         "@SYS12836")        : '');

        while (enumerator.moveNext())
        {
            inventDimFieldId = enumerator.current();
            inventDimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
            if (inventDimParm.(inventDimParmFieldId) == NoYes::Yes)
            {
                lineTxt +=                                            ((lineTxt ? ' / ' : '') +         (fieldid2pname(inventDimParm.TableId,inventDimParmFieldId)));
            }
        }

        lineTxt += (tmpReqExplosionTree.DisplayReceiptQty           ? ((lineTxt ? ' / ' : '') +         "@SYS25381")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayUnit                 ? ((lineTxt ? ' / ' : '') +         "@SYS96151")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayReceiptCovQty        ? ((lineTxt ? ' / ' : '') + '(' +   "@SYS28766" + ')')  : '');
        lineTxt += (tmpReqExplosionTree.DisplayReceiptDate          ? ((lineTxt ? ' / ' : '') +         "@SYS18075")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayReceiptDateOrder     ? ((lineTxt ? ' / ' : '') +         "@SYS27900")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayReceiptFututesDate   ? ((lineTxt ? ' / ' : '') +         "@SYS22952")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayRefId                ? ((lineTxt ? ' / ' : '') +         "@SYS13864")        : '');
        lineTxt += (tmpReqExplosionTree.DisplayRefType              ? ((lineTxt ? ' / ' : '') +         "@SYS24406")        : '');

        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeNode2RecId</Name>
				<Source><![CDATA[
    recId treeNode2RecId(int _nodeId)
    {
        if (mapNode2RecId && mapNode2RecId.exists(_nodeId))
        {
            return mapNode2RecId.lookup(_nodeId);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeNodeTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the text that fills the tree node that represents the specified <c>ReqTrans</c> table record.
    /// </summary>
    /// <param name="_reqTrans">
    ///     The record represented by the tree node.
    /// </param>
    /// <returns>
    ///     A string containing the tree node text.
    /// </returns>
    public TreeNodeTxt treeNodeTxt(ReqTrans _reqTrans)
    {
        TreeNodeTxt treeNodeText;
        PmfFormulaCoBy  pmfFormulaCoBy;

        if (mapReqTransText.exists(_reqTrans.RecId))
        {
            treeNodeText = mapReqTransText.lookup(_reqTrans.RecId);
        }
        else
        {
            treeNodeText = ReqTransFormExplosion::generateTreeNodeText(
                _reqTrans,
                inventDimParm,
                tmpReqExplosionTree,
                isSessionLanguageRTL);
            mapReqTransText.insert(_reqTrans.RecId, treeNodeText);
        }

        // If the current record is a By Product we add the product type to the tree node text
        pmfFormulaCoBy = PmfFormulaCoBy::findRecId(_reqTrans.PmfCoByRefRecId);
        if (pmfFormulaCoBy && pmfFormulaCoBy.ProductType == PmfProductType::By_Product)
        {
            treeNodeText = strFmt("@SYS70938", treeNodeText, "@PRO79");
        }

        return treeNodeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeRecId2Node</Name>
				<Source><![CDATA[
    Integer treeRecId2Node(recId _recId) // returns first node
    {
        Set         setNodes;
        SetIterator si;

        if (mapRecId2Node && mapRecId2Node.exists(_recId))
        {
            setNodes = mapRecId2Node.lookup(_recId);

            si = new SetIterator(setNodes);
            si.begin();
            while (si.more())
            {
                return si.value();
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeRedraw</Name>
				<Source><![CDATA[
    public void treeRedraw()
    {
        recId               recIdSelected;
        ReqTrans            reqTransTmp;

        MapEnumerator       mapNode2RecIdEnumerator;

        FormTreeItem        treeItem;

        Set                 setExpandRecId;

        // find current

        if (ctrlTree.getFirstSelected())
        {
            recIdSelected = this.treeNode2RecId(ctrlTree.getFirstSelected());
        }

        // find expanded nodes

        setExpandRecId = new Set(RecIdType);

        mapNode2RecIdEnumerator = new MapEnumerator(mapNode2RecId);
        while (mapNode2RecIdEnumerator.moveNext())
        {
            treeItem = ctrlTree.getItem(mapNode2RecIdEnumerator.currentKey());
            if (treeItem.children() && treeItem.stateExpanded())
            {
                if (mapReqTrans && mapReqTrans.exists(mapNode2RecIdEnumerator.currentValue()))
                {
                    reqTransTmp = mapReqTrans.lookup(mapNode2RecIdEnumerator.currentValue());
                }
                else
                {
                    reqTransTmp = null;
                }
                if (reqTransTmp.RecId)
                {
                    setExpandRecId.add(reqTransTmp.RecId);
                }
            }
        }

        this.treeBuild();

        // expanded nodes

        if (setExpandRecId.elements() > 0)
        {
			// use copy of the map in the enumerator because expanding a node may change the mapNode2RecId map and invalidate the enumerator.
            Map mapNode2RecIdCopy = Map::create(mapNode2RecId.pack());
            mapNode2RecIdEnumerator = new MapEnumerator(mapNode2RecIdCopy);
            while (mapNode2RecIdEnumerator.moveNext())
            {
                if (mapReqTrans && mapReqTrans.exists(mapNode2RecIdEnumerator.currentValue()))
                {
                    reqTransTmp = mapReqTrans.lookup(mapNode2RecIdEnumerator.currentValue());
                }
                else
                {
                    reqTransTmp = null;
                }

                if (reqTransTmp.RecId && setExpandRecId.in(reqTransTmp.RecId))
                {
                    ctrlTree.expand(mapNode2RecIdEnumerator.currentKey());
                }
            }
        }

        // Select current

        if (recIdSelected)
        {
            if (ctrlTree.getItem(this.treeRecId2Node(recIdSelected)))
            {
                ctrlTree.select(this.treeRecId2Node(recIdSelected));
        }
    }
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeSelectionChange</Name>
				<Source><![CDATA[
    void treeSelectionChange()
    {
        if (newIdSave)
        {
            this.reqTransDSFind(newIdSave);
            // Need to execute batchReqTrans datasource to reflect new selected tmpReqTrans record
            if (isBatch && batchReqTrans_ds)
            {
                batchReqTrans_ds.executeQuery();
            }
            newIdSave = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeSetNodeProperty</Name>
				<Source><![CDATA[
    void treeSetNodeProperty(
        int           _nodeId,
        ReqTrans      _reqTrans,
        boolean       _checkChildren = true
        )
    {
        ReqPO           reqTransPO;
        FormTreeItem    treeItem = ctrlTree.getItem(_nodeId);

        if (_reqTrans.isPlannedOrder())
        {
            treeItem.stateBold(true);
            reqTransPO = this.getReqTransPOFromCache(_reqTrans);
        }
        else
        {
            treeItem.stateBold(false);
        }

        if (_reqTrans.isDelayed(reqTransPO))
        {
            if (tmpReqExplosionTree.SettingsDisplayDelay == ReqDisplayDelay::AsOverlay)
            {
                treeItem.stateImage(0);
                treeItem.overlayImage(imageListAppl.image(#ImageOverlayRedLock));
            }
            else if (tmpReqExplosionTree.SettingsDisplayDelay == ReqDisplayDelay::AsSeparate)
            {
                treeItem.overlayImage(0);
                treeItem.stateImage(imageListAppl_StateReq.image(#ImageStateNotAtAllOK));
            }
            else
            {
                treeItem.stateImage(0);
                treeItem.overlayImage(0);
            }
        }

        if (_checkChildren)
        {
            if (mapDerived.exists(_reqTrans.RecId))
            {
                treeItem.children(true);
            }
            else
            {
                treeItem.children(false);
        }
        }

        ctrlTree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeUpdateNode</Name>
				<Source><![CDATA[
    void treeUpdateNode(
        int             _nodeId,
        ReqTrans        _reqTrans
        )
    {
        FormTreeItem    treeItem;
        ReqPO           reqTransPO;

        if (!_nodeId || !_reqTrans.RecId)
        {
            return;
        }

        treeItem = ctrlTree.getItem(_nodeId);

        if (!treeItem)
        {
            return;
        }

        if (_reqTrans.isPlannedOrder())
        {
            treeItem.stateBold(true);
            reqTransPO = this.getReqTransPOFromCache(_reqTrans);
        }
        else
        {
            treeItem.stateBold(false);
        }

        treeItem.image(this.displayImageReqRefType(_reqTrans.RefType));
        treeItem.selectedImage(this.displayImageReqRefType(_reqTrans.RefType));
        treeItem.text(this.treeNodeTxt(_reqTrans));

        if (_reqTrans.isDelayed(reqTransPO))
        {
            if (tmpReqExplosionTree.SettingsDisplayDelay == ReqDisplayDelay::AsOverlay)
            {
                treeItem.stateImage(0);
                treeItem.overlayImage(imageListAppl.image(#ImageOverlayRedLock));
            }
            else if (tmpReqExplosionTree.SettingsDisplayDelay == ReqDisplayDelay::AsSeparate)
            {
                treeItem.overlayImage(0);
                treeItem.stateImage(imageListAppl_StateReq.image(#ImageStateNotAtAllOK));
            }
            else
            {
                treeItem.stateImage(0);
                treeItem.overlayImage(0);
            }
        }

        ctrlTree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeUpdateReqTrans</Name>
				<Source><![CDATA[
    void treeUpdateReqTrans(ReqTrans _reqTrans)
    {
        Set         setNodes;
        SetIterator si;

        if (mapRecId2Node.exists(_reqTrans.RecId))
        {
            setNodes = mapRecId2Node.lookup(_reqTrans.RecId);

            si = new SetIterator(setNodes);
            si.begin();
            while (si.more())
            {
                this.treeUpdateNode(si.value(),_reqTrans);

                si.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer     version     = conpeek(packedClass,1);
        container   base;

        switch (version)
        {
            case #CurrentVersion :
                [version,#CurrentList,base] = packedClass;
                super(base);
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActiveReqTrans</Name>
				<Source><![CDATA[
    public void updateActiveReqTrans()
    {
        ReqTrans reqTransUpdate;

        if (reqTrans.mustTransIdBeUpdated())
        {
            ReqTransUpdate::runItemId(reqTrans.ItemId);

            reqTransUpdate = ReqTrans::findCommon(reqTrans.PlanVersion,reqTrans);
            if (reqTransUpdate.RecId)
            {
                if (mapReqTrans.exists(reqTransUpdate.RecId) && mapDb2TmpRecId.exists(reqTransUpdate.RecId))
                {
                    mapReqTrans.insert(reqTransUpdate.RecId,reqTransUpdate);

                    // remove the mapped PO and texts if they exist so they can be recalculated
                    if (mapReqTransText.exists(reqTransUpdate.RecId))
                    {
                        mapReqTransText.remove(reqTransUpdate.RecId);
                    }

                    if (mapReqTransPO.exists(reqTransUpdate.RecId))
                    {
                        mapReqTransPO.remove(reqTransUpdate.RecId);
                    }

                    buf2Buf(reqTransUpdate,reqTrans);

                    reqTrans_ds.write();

                    this.treeUpdateReqTrans(reqTransUpdate);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransFormCache</Name>
				<Source><![CDATA[
    [SuppressBPWarningAttribute('BPErrorSelectUsingFirstOnly', 'The buffer is used for multiple row updating.')]
public void updateReqTransFormCache(container _con)
    {
        Map             mapReqTransUpdate;
        MapIterator     mi;

        Integer         formMarked;
        ReqTrans        reqTransUpdate;
        ReqTrans        reqTransCache;
        ReqTrans        reqTransMap;
        ReqTrans        reqTransTmp;

        recId           recId;

        if (! mapDb2TmpRecId || ! mapTmpRecId2Db)
        {
            return;
        }

        ttsbegin;
        mapReqTransUpdate = (_con) ? Map::create(_con) : null;
        if (mapReqTransUpdate)
        {
            mi = new MapIterator(mapReqTransUpdate);
            mi.begin();
            while (mi.more())
            {
                reqTransUpdate = mapReqTransUpdate.lookup(mi.key());
                if (mapReqTrans.exists(reqTransUpdate.RecId))
                {
                    mapReqTrans.insert(reqTransUpdate.RecId,reqTransUpdate);

                    // remove the mapped PO and texts if they exist so they can be recalculated
                    if (mapReqTransText.exists(reqTransUpdate.RecId))
                    {
                        mapReqTransText.remove(reqTransUpdate.RecId);
                    }

                    if (mapReqTransPO.exists(reqTransUpdate.RecId))
                    {
                        mapReqTransPO.remove(reqTransUpdate.RecId);
                    }

                    if (mapDb2TmpRecId.exists(reqTransUpdate.RecId))
                    {
                        reqTransTmp.setTmp();
                        reqTransTmp.setTmpData(reqTrans);
                        select forupdate reqTransTmp
                            index hint recId
                            where reqTransTmp.RecId == mapDb2TmpRecId.lookup(reqTransUpdate.RecId);

                        if (reqTransTmp.RecId)
                        {
                            buf2Buf(reqTransUpdate,reqTransTmp);

                            reqTransTmp.doUpdate();
                        }
                    }
                }

                mi.next();
            }
        }
        ttscommit;

        while (formMarked <= 1)
        {
            reqTransCache = reqTrans_ds.getFirst(formMarked,false);
            while (reqTransCache)
            {
                if (mapTmpRecId2Db.exists(reqTransCache.RecId))
                {
                    recId = mapTmpRecId2Db.lookup(reqTransCache.RecId);

                    if (mapReqTransUpdate && mapReqTransUpdate.exists(recId))
                    {
                        reqTransMap         = mapReqTransUpdate.lookup(recId);

                        this.treeUpdateReqTrans(reqTransMap);

                        reqTransMap.RecId   = reqTransCache.RecId;
                        reqTransMap.(fieldnum(ReqTrans,SequenceNum)) = reqTransCache.(fieldnum(ReqTrans,SequenceNum));
                        reqTransCache.data(reqTransMap);
                        if (reqTransMap.RecId == reqTrans.RecId)
                        {
                            reqTrans.data(reqTransMap);
                            reqTrans_ds.setCurrent();
                        }
                    }
                }
                reqTransCache = reqTrans_ds.getNext();
            }
            formMarked++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static private ReqTransFormExplosion construct(FormRun _formRun)
    {
        return new ReqTransFormExplosion(_formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateReqTransNodeTextsOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generate the texts that should be displayed on the tree nodes based on the collection of the requirement maps specified.
    /// </summary>
    /// <param name="_mapReqTransPack">
    ///     The packed map of the parent <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_mapDerivedPack">
    ///     The packed map of the references <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_inventDimParm">
    ///     The selected dimensions to display on the tree node texts.
    /// </param>
    /// <param name="_tmpReqExplosionTree">
    ///     The selected properties to display on the tree node texts.
    /// </param>
    /// <param name="_isSessionLanguageRTL">
    ///     A boolean value indicating whether the session language is RTL.
    /// </param>
    /// <returns>
    ///     A packed map with the ID of the tree nodes and the text of the tree nodes.
    /// </returns>
    /// <remarks>
    ///     This method runs exclusively on the server tier.
    /// </remarks>
    private static container generateReqTransNodeTextsOnServer(
        container           _mapReqTransPack,
        InventDimParm       _inventDimParm,
        TmpReqExplosionTree _tmpReqExplosionTree,
        boolean             _isSessionLanguageRTL)
    {
        Map             mapReqTrans     = Map::create(_mapReqTransPack);
        Map             mapReqTransText = new Map(RecIdType, Types::String);

        Set             mapReqTransKeys;
        SetEnumerator   mapReqTransKeysEnumerator;
        ReqTrans        currentReqTrans;

        mapReqTransKeys             = mapReqTrans.keySet();
        mapReqTransKeysEnumerator   = mapReqTransKeys.getEnumerator();

        while (mapReqTransKeysEnumerator.moveNext())
        {
            // parent TreeNodes
            currentReqTrans = mapReqTrans.lookup(mapReqTransKeysEnumerator.current());
            if (!mapReqTransText.exists(currentReqTrans.RecId))
            {
                // Change company since the map might contain cross-company transactions
                changeCompany (currentReqTrans.company())
                {
                mapReqTransText.insert(
                    currentReqTrans.RecId,
                    ReqTransFormExplosion::generateTreeNodeText(
                        currentReqTrans,
                        _inventDimParm,
                        _tmpReqExplosionTree,
                        _isSessionLanguageRTL));
            }
        }
        }

        return mapReqTransText.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTreeNodeText</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates the text that fills the tree node that represents the specified <c>ReqTrans</c> table record.
    /// </summary>
    /// <param name="_reqTrans">
    ///     The record represented by the tree node.
    /// </param>
    /// <param name="_inventDimParm">
    ///     The selected dimensions to display on the tree node texts.
    /// </param>
    /// <param name="_tmpReqExplosionTree">
    ///     The selected properties to display on the tree node texts.
    /// </param>
    /// <param name="_isSessionLanguageRTL">
    ///     A boolean value indicating whether the client session is RTL.
    /// </param>
    /// <returns>
    ///     A string containing the tree node text.
    /// </returns>
    public static TreeNodeTxt generateTreeNodeText(
        ReqTrans            _reqTrans,
        InventDimParm       _inventDimParm,
        TmpReqExplosionTree _tmpReqExplosionTree,
        boolean             _isSessionLanguageRTL)
    {
        TreeNodeTxt         lineTxt;
        DictEnum            dictEnum;
        Integer             qtyDecimals;
        ItemName            itemName;
        EcoResProductNumber productNumber;
        ListEnumerator      enumerator  = InventDim::dimFieldListEnumerator();
        fieldId             inventDimFieldId;
        fieldId             inventDimParmFieldId;
        str                 formatCode;
        InventDim           inventDimTmp;
        InventUnitId        unitId;
        InventTable         inventTable;

        //formating the text according to LTR or RTL
        if (_isSessionLanguageRTL)
        {
            //
            //using RLM (right-to-left mark) to define the text orientation
            //%1 - previous chunk of text (RTL)
            //%2 - separator - (ascii or LTR)
            //%3 - added chunk (RTL)
            //
            formatCode = '%1\u200F%2\u200E%3\u200F';
        }
        else
        {
            // regular text
            formatCode = '%1%2%3';
        }

        if (! _inventDimParm.isAllFlagNo())
        {
            inventDimTmp = InventDim::find(_reqTrans.CovInventDimId);
        }

        inventTable = InventTable::find(_reqTrans.ItemId);

        if (_tmpReqExplosionTree.DisplayItemName)
        {
            itemName = inventTable.defaultProductName();
        }

        unitId = inventTable.inventUnitId();

        qtyDecimals = UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(unitId));
        qtyDecimals = qtyDecimals ? qtyDecimals : 2;

        if (_tmpReqExplosionTree.DisplayCompany)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), _reqTrans.dataAreaId );
        }

        if (_tmpReqExplosionTree.DisplayPlanId)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), _reqTrans.displayReqPlanId() );
        }

        if (_tmpReqExplosionTree.DisplayProductNumber)
        {
            productNumber = EcoResProduct::find(inventTable.Product).productNumber();
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (productNumber    ? productNumber  : '--'));
        }

        if (_tmpReqExplosionTree.DisplayItemName)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (itemName            ? itemName          : '--'));
        }
        if (_tmpReqExplosionTree.DisplayItemId)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.ItemId    ? _reqTrans.ItemId  : '--'));
        }

        if (inventDimTmp.RecId)
        {
            while (enumerator.moveNext())
            {
                inventDimFieldId = enumerator.current();
                inventDimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                if (_inventDimParm.(inventDimParmFieldId) == NoYes::Yes)
                {
                    if (inventDimTmp.(inventDimFieldId))
                    {
                        lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), inventDimTmp.(inventDimFieldId));
                    }
                    else
                    {
                        lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), '--');
                    }
                }
            }
        }

        if (_tmpReqExplosionTree.DisplayReceiptQty)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.Qty     ?  num2str(_reqTrans.Qty,0,qtyDecimals,0,0)                 : '--'));
        }

        if (_tmpReqExplosionTree.DisplayUnit)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (unitId            ?  unitId          : '--'));
        }

        if (_tmpReqExplosionTree.DisplayReceiptCovQty)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.CovQty  ?  '(' + num2str(_reqTrans.CovQty,0,qtyDecimals,0,0) + ')'  : '--'));
        }
        if (_tmpReqExplosionTree.DisplayReceiptDate)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.ReqDate ?  date2StrUsr(_reqTrans.ReqDate, DateFlags::FormatAll)     : '--'));
        }
        if (_tmpReqExplosionTree.DisplayReceiptDateOrder)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.reqDateOrder() ?  date2StrUsr(_reqTrans.reqDateOrder(),   DateFlags::FormatAll)     : '--'));
        }
        if (_tmpReqExplosionTree.DisplayReceiptFututesDate)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.FuturesDate    ?  date2StrUsr(_reqTrans.FuturesDate,      DateFlags::FormatAll)     : '--'));
        }
        if (_tmpReqExplosionTree.DisplayRefId)
        {
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_reqTrans.RefId          ?  _reqTrans.RefId     : '--'));
        }
        if (_tmpReqExplosionTree.DisplayRefType)
        {
            dictEnum = new DictEnum(enumnum(ReqRefType));
            lineTxt = strfmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (dictEnum.value2Name(enum2int(_reqTrans.RefType)) + (_reqTrans.IsDerivedDirectly    ? ' (' + "@SYS53674" + ')' : '')));
        }

        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFormRun</Name>
				<Source><![CDATA[
    static ReqTransFormExplosion newFormRun(FormRun _formRun)
    {
        if (_formRun.args() && _formRun.args().caller() && !_formRun.args().record().RecId)
        {
            throw(error("@SYS82774"));
        }

        return ReqTransFormExplosion::construct(_formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReqExplosionOnhandBuildServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the table for critical on-hand information on the server.
    /// </summary>
    /// <param name="_tmpReqExplosionOnHand">
    ///     The table to be populated.
    /// </param>
    /// <param name="_packedMapReqTransSettled">
    ///     The packed map containing settled requirement transactions.
    /// </param>
    /// <param name="_reqTransCallerRecId">
    ///     The ID of the calling requirement transaction.
    /// </param>
    /// <param name="_packedMapReqTrans">
    ///     The packed map containing requirement transactions.
    /// </param>
    [SuppressBPWarningAttribute('BPErrorSelectUsingFirstOnly', 'The buffer is used for multiple row updating.')]
    public static void tmpReqExplosionOnhandBuildServer(
        TmpReqExplosionOnHand   _tmpReqExplosionOnHand,
        container               _packedMapReqTransSettled,
        RefRecId                _reqTransCallerRecId,
        container               _packedMapReqTrans)
    {
        ReqTrans                reqTransTmp;
        container               tmpReqExplosionOnhandContainer;
        MapIterator             mi;
        Map                     mapTmpReqExplosionOnhand;
        TmpReqExplosionOnHand   tmpOnhand;
        PdsCatchWeightItem      pdsCatchWeightItem;
        Map                     mapReqTransSettled = Map::create(_packedMapReqTransSettled);
        Map                     mapReqTrans = Map::create(_packedMapReqTrans);

        delete_from _tmpReqExplosionOnHand;

        mapTmpReqExplosionOnhand = new Map(RecIdType, Types::Record);

        mi = new MapIterator(mapReqTrans);

        mi.begin();
        while (mi.more())
        {
            reqTransTmp = mapReqTrans.lookup(mi.key());

            if (reqTransTmp.Qty > 0 || reqTransTmp.CovQty < 0)
            {
                ReqTransFormExplosion::initTmpReqExplosionOnHand(reqTransTmp, _tmpReqExplosionOnHand, _reqTransCallerRecId, mapReqTransSettled);

                _tmpReqExplosionOnHand.write();
                mapTmpReqExplosionOnhand.insert(_tmpReqExplosionOnHand.RecId, _tmpReqExplosionOnHand);
            }

            mi.next();
        }

        tmpReqExplosionOnhandContainer = TmpReqExplosionOnHand::initPhysicalInventAndItemName(mapTmpReqExplosionOnhand.pack());
        if (tmpReqExplosionOnhandContainer)
        {
            mapTmpReqExplosionOnhand = Map::create(tmpReqExplosionOnhandContainer);

            ttsBegin;
            mi = new MapIterator(mapTmpReqExplosionOnhand);
            mi.begin();
            while (mi.more())
            {
                tmpOnhand = mapTmpReqExplosionOnhand.lookup(mi.key());

                select forupdate _tmpReqExplosionOnHand
                    where _tmpReqExplosionOnHand.ItemId          == tmpOnhand.ItemId  &&
                          _tmpReqExplosionOnHand.CovInventDimId  == tmpOnhand.CovInventDimId;

                _tmpReqExplosionOnHand.PhysicalInvent = tmpOnhand.PhysicalInvent;
                _tmpReqExplosionOnHand.ItemName       = tmpOnhand.ItemName;

                _tmpReqExplosionOnHand.write();

                mi.next();
            }
            ttsCommit;
        }

        if (#PdsCatchWeightEnabled)
        {
            ttsBegin;
            while select forupdate _tmpReqExplosionOnHand
                exists join pdsCatchWeightItem
                where pdsCatchWeightItem.ItemId == _tmpReqExplosionOnHand.ItemId

            {
                _tmpReqExplosionOnHand.cwPhysicalInvent = PdsCatchWeight::cwQty(_tmpReqExplosionOnHand.ItemId, _tmpReqExplosionOnHand.physicalInvent);
                _tmpReqExplosionOnHand.cwQtyReqPlannedOrder = PdsCatchWeight::cwQty(_tmpReqExplosionOnHand.ItemId, _tmpReqExplosionOnHand.qtyReqPlannedOrder);
                _tmpReqExplosionOnHand.cwQtyReqOnOrders = PdsCatchWeight::cwQty(_tmpReqExplosionOnHand.ItemId, _tmpReqExplosionOnHand.qtyReqOnOrders);
                _tmpReqExplosionOnHand.cwQtyReqOnhand = PdsCatchWeight::cwQty(_tmpReqExplosionOnHand.ItemId, _tmpReqExplosionOnHand.qtyReqOnhand);
                _tmpReqExplosionOnHand.cwQtyReq = PdsCatchWeight::cwQty(_tmpReqExplosionOnHand.ItemId, _tmpReqExplosionOnHand.qtyReq);
                _tmpReqExplosionOnHand.update();
            }
            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpReqExplosionOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the ReqTrans record 
    /// </summary>
    /// <param name="_reqTrans">
    ///     The reqTrans record to be added
    /// </param>
    /// <param name="_tmpReqExplosionOnHand">
    ///     The table to be populated.
    /// </param>
    /// <param name="_reqTransCallerRecId">
    ///     The ID of the calling requirement transaction.
    /// </param>
    /// <param name="_mapReqTransSettled">
    ///     The map containing settled requirement transactions.
    /// </param>
    protected static void initTmpReqExplosionOnHand(  
                ReqTrans              _reqTrans,
                TmpReqExplosionOnHand _tmpReqExplosionOnHand,
                RefRecId              _reqTransCallerRecId,
                Map                   _mapReqTransSettled)
    {
        ReqTransCov     reqTransCoverage;
        ReqTrans        reqTransJoinChild;
        ReqQtySettled   qtySettled;
        Set             setRecIdReqTransSettled;

        select forupdate _tmpReqExplosionOnHand
                where _tmpReqExplosionOnHand.ItemId             == _reqTrans.ItemId            &&
                      _tmpReqExplosionOnHand.CovInventDimId     == _reqTrans.CovInventDimId;

        if (!_tmpReqExplosionOnHand)
        {
            _tmpReqExplosionOnHand.ItemId          = _reqTrans.ItemId;
            _tmpReqExplosionOnHand.CovInventDimId  = _reqTrans.CovInventDimId;
        }

        if (_mapReqTransSettled.exists(_reqTrans.RecId))
        {
            setRecIdReqTransSettled = _mapReqTransSettled.lookup(_reqTrans.RecId);
        }
        else
        {
            setRecIdReqTransSettled = new Set(RecIdType);
        }

        if (_reqTrans.CovQty > 0)
        {
            reqTransCoverage  = _reqTrans.selectCovJoinTrans();
            while (reqTransCoverage.RecId)
            {
                if (_reqTrans.RecId == _reqTransCallerRecId || setRecIdReqTransSettled.in(reqTransCoverage.IssueRecId))
                {
                    qtySettled += reqTransCoverage.Qty;
                }

                next reqTransCoverage;
            }

            if (qtySettled)
            {
                _tmpReqExplosionOnHand.QtyReq += qtySettled;

                if (_reqTrans.RefType == ReqRefType::InventOnHand)
                {
                    _tmpReqExplosionOnHand.QtyReqOnhand += qtySettled;
                }
                else if (_reqTrans.isPlannedOrder() || _reqTrans.isDerivedFromPlannedOrder())
                {
                    _tmpReqExplosionOnHand.QtyReqPlannedorder += qtySettled;
                }
                else
                {
                    _tmpReqExplosionOnHand.QtyReqOnOrders += qtySettled;
                }
            }
        }
        else if (_reqTrans.CovQty < 0)
        {
            reqTransCoverage  = _reqTrans.selectCovJoinTrans();
            reqTransJoinChild = reqTransCoverage.joinChild();

            while (reqTransCoverage.RecId)
            {
                if (_reqTrans.RecId == _reqTransCallerRecId || setRecIdReqTransSettled.in(reqTransCoverage.ReceiptRecId))
                {
                    qtySettled = reqTransCoverage.Qty;
                }

                if (qtySettled)
                {
                    _tmpReqExplosionOnHand.QtyReq += qtySettled;

                    if (reqTransJoinChild.RefType == ReqRefType::InventOnHand)
                    {
                        _tmpReqExplosionOnHand.QtyReqOnhand += qtySettled;
                    }
                    else if (reqTransJoinChild.isPlannedOrder() || reqTransJoinChild.isDerivedFromPlannedOrder())
                    {
                        _tmpReqExplosionOnHand.QtyReqPlannedorder += qtySettled;
                    }
                    else
                    {
                        _tmpReqExplosionOnHand.QtyReqOnOrders += qtySettled;
                    }
                }

                qtySettled = 0;
                next reqTransCoverage;
            }
        }

        if (_reqTrans.FuturesDays > _tmpReqExplosionOnHand.DelayDays)
        {
            _tmpReqExplosionOnHand.DelayDays = _reqTrans.FuturesDays;
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimFormSetupObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the controller that governs the dimension fields in the form.
    /// </summary>
    /// <returns>
    ///     A instance of the <c>InventDimCtrl</c> class.
    /// </returns>
    public InventDimCtrl inventDimFormSetupObject()
    {
        return inventDimFormSetup;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>