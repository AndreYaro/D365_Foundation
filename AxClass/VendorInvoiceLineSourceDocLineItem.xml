<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendorInvoiceLineSourceDocLineItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>VendorInvoiceLineSourceDocLineItem</c> class provides the information that is required to
/// handle the distributions and sub-ledger journal account entries for an invoice line.
/// </summary>
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_VendorInvoice), SourceDocumentLine_VendorInvoice::VendorInvoiceLine)]
public class VendorInvoiceLineSourceDocLineItem extends SourceDocumentLineItem
    implements SourceDocumentLineItemIProductQuantity,
               SourceDocumentLineItemIProduct,
               SourceDocumentLineItemIInventory,
               SourceDocumentIChargeSource,
               SourceDocumentLineItemIProjectRevenue,
               SourceDocumentIDataProvider,
               SourceDocumentLineItemIFixedAsset,
               SourceDocumentLineItemIProductionFlow,
               SourceDocumentLineItemIProject,
               SourceDocumentLineItemIProjectTransDate,
               SourceDocumentLineItemITermQuantity,
               SourceDocumentLineItemIFixedAsset_RU,
               SourceDocumentIReportingExchRate,
               SourceDocumentIClearChildLineItemList,
               SourceDocumentIFixedExchangeRate,
               AccountingFinTagIDistributionTaggable
               
{
    PurchLine purchLine;
    VendInvoiceMap vendInvoiceMap;
    VendInvoiceLineMap vendInvoiceLineMap;
    PurchLineType purchLineType;
    PurchQty totalPreviouslyInvoicedQty;
    boolean isCalculatedTotalPreviouslyInvoicedQty;
    boolean hasVendGroupChanged;
    VendInvoiceInfoLine_Asset vendInvoiceInfoLine_Asset;

    VendInvoiceInfoLine vendInvoiceInfoLine;
    VendInvoiceTrans vendInvoiceTrans;
    VendInvoiceTrans vendInvoiceTrans_Advance;
    VendInvoiceJour vendInvoiceJour_Advance;
    Percent advanceApplicationRatio;

    InventTable inventTable;
    boolean isPrepaymentApplication;
    boolean isPrepaymentApplicationReversal;
    MarkupTrans markupTrans;

    VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
    ProjActivityNumber projectActivityNumber;
    ProjCategoryId projectCategoryId;
    ProjId projectId;
    ProjTaxItemGroup projectItemSalesTaxGroup;
    ProjLinePropertyId projectLineProperty;
    ProjSalesCurrencyCode projectSalesCurrencyCode;
    SalesPrice projectSalesPrice;
    ProjTaxGroup projectSalesTaxGroup;
    SalesUnit projectSalesUnit;
    ProjTransIdBase projectTransactionId;
    InventTransId projectLotId;
    DataAreaId projectDataAreaId;

    boolean isoRU;
    boolean isoIN;

    boolean isProjectInitialized;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcRemainingAmount</Name>
				<Source><![CDATA[
    private Amount calcRemainingAmount(
        SourceDocumentLineItem _sourceDocumentLineItem,
        MonetaryAmount _monetaryAmount,
        boolean _doRestrictDistributionsByAcctEvent)
    {
        SourceDocumentBalanceProvider balanceProvider;

        if (_sourceDocumentLineItem)
        {
            balanceProvider = SourceDocumentBalanceProvider::newFromSourceDocumentLineItem(_sourceDocumentLineItem);

            balanceProvider.parmMonetaryAmountRestriction(_monetaryAmount);
            balanceProvider.parmBalanceCurrencyCode(this.parmTransactionCurrencyCode());
            balanceProvider.parmDoRestrictByAccountingEvent(_doRestrictDistributionsByAcctEvent);

            balanceProvider.initializeBalanceLine(_sourceDocumentLineItem.parmSourceDocumentLine());

            return balanceProvider.parmTotalBalance();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalPreviouslyInvoicedQty</Name>
				<Source><![CDATA[
    private Qty calcTotalPreviouslyInvoicedQty()
    {
        VendInvoiceTrans localVendInvoiceTrans;
        VendInvoiceTrans currentVendInvoiceTrans;
        VendInvoiceInfoLine currentVendInvoiceInfoLine;
        Qty invoicedQty;

        Debug::assert(purchLine.RecId != 0);

        switch (vendInvoiceLineMap.TableId)
        {
            case tableNum(VendInvoiceTrans):
                currentVendInvoiceTrans = vendInvoiceLineMap;

                select sum(Qty) from localVendInvoiceTrans
                    where localVendInvoiceTrans.InventTransId == purchLine.InventTransId
                        && localVendInvoiceTrans.SourceDocumentLine != currentVendInvoiceTrans.SourceDocumentLine;

                invoicedQty = localVendInvoiceTrans.Qty;
                break;

            case tableNum(VendInvoiceInfoLine):
                currentVendInvoiceInfoLine = vendInvoiceLineMap;

                // During posting a record exists in both VendInvoiceInfoLine and VendInvoiceTrans,
                // so we need to avoid double counting.

                select sum(Qty) from localVendInvoiceTrans
                    where localVendInvoiceTrans.InventTransId == purchLine.InventTransId
                        && localVendInvoiceTrans.SourceDocumentLine != currentVendInvoiceInfoLine.SourceDocumentLine;

                invoicedQty = localVendInvoiceTrans.Qty;
                break;

            default:
                throw error(strFmt("@SYS19306", funcName())); // incorrect use
        }

        return invoicedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault calculateDefaultDimension()
    {
        return vendInvoiceLineMap.defltDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLegalEntityRecId</Name>
				<Source><![CDATA[
    protected LegalEntityRecId calculateLegalEntityRecId()
    {
        return CompanyInfo::current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateActualGrossAmountForPurchPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the actual gross amount for purchase price.  
    /// </summary>
    /// <returns>
    ///     The actual gross amount.
    /// </returns>
    protected Amount calculateActualGrossAmountForPurchPrice()
    {
        return CurrencyExchangeHelper::amount(this.parmQuantity() * vendInvoiceLineMap.pdsPurchPrice() / (vendInvoiceLineMap.PriceUnit ? vendInvoiceLineMap.PriceUnit :1.0), vendInvoiceLineMap.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateActualPriceAdjustmentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the actual price adjustment amount.
    /// </summary>
    /// <param name = "_actualGrossAmount">
    ///     The actual gross amount.
    /// </param>
    /// <param name = "_actualChargeAmount">
    ///     The actual charge amount.
    /// </param>
    /// <returns>
    ///     The amount of actual price adjustment.
    /// </returns>
    protected Amount calculateActualPriceAdjustmentAmount(Amount _actualGrossAmount, Amount _actualChargeAmount)
    {
        Amount actualPriceAdjustmentAmount;
        if (vendInvoiceLineMap.discPercent())
        {
            actualPriceAdjustmentAmount = -CurrencyExchangeHelper::amount(this.parmQuantity() * vendInvoiceLineMap.discAmount() / (vendInvoiceLineMap.PriceUnit ? vendInvoiceLineMap.PriceUnit : 1.0), vendInvoiceLineMap.CurrencyCode);
        }
        else
        {
            actualPriceAdjustmentAmount = vendInvoiceLineMap.LineAmount - _actualGrossAmount - _actualChargeAmount;
        }

        return actualPriceAdjustmentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateActualDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the actual discount amount.
    /// </summary>
    /// <param name = "_actualGrossAmount">
    ///     The actual gross amount.
    /// </param>
    /// <param name = "_actualChargeAmount">
    ///     The actual charge amount.
    /// </param>
    /// <param name = "_actualPriceAdjustmentAmount">
    ///     The actual price adjustment amount.
    /// </param>
    /// <returns>
    ///     The actual discount amount.
    /// </returns>
    protected Amount calculateActualDiscountAmount(Amount _actualGrossAmount, Amount _actualChargeAmount, Amount _actualPriceAdjustmentAmount)
    {
        return vendInvoiceLineMap.LineAmount - _actualGrossAmount - _actualChargeAmount - _actualPriceAdjustmentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the amount associated with <c>SourceDocumentAmountMap</c> class.
    /// </summary>
    /// <returns>
    ///     A <c>SourceDocumentAmountMap</c> class.
    /// </returns>
    protected SourceDocumentAmountMap calculateSourceDocumentAmountMap()
    {
        SourceDocumentAmountMap sourceDocumentAmountMap;
        boolean includesTax;
        Amount actualGrossAmount, actualPriceAdjustmentAmount, actualChargeAmount, actualDiscountAmount;
        Amount expectedGrossAmount, expectedPriceAdjustmentAmount, expectedChargeAmount, expectedDiscountAmount;
        Amount quantityVarianceAmount, priceVarianceAmount, discountVarianceAmount, priceAdjustmentVarianceAmount, chargeAmountVariance;
        Percent invoiceRatioLessVarQty = 1.0;
        Percent invoiceRatio = 1.0;
        SourceDocumentLineItem matchedSourceDocumentLineItem;
        SourceDocumentAmountMapEnumerator matchingAmountMapEnum;
        SourceDocumentAmount matchingSourceDocumentAmount;
        TaxBase taxBase;
        Qty invoicedQty, prevInvoicedQty, quantityVariance;
        PurchTable purchTable;
        Amount expectedTotalDiscountAmount;
        PurchTotals purchTotals;
        Amount purchBalance;
        Amount actualTotalDiscountAmountForDocument;
        Amount actualTotalDiscountAmount;
        Amount totalDiscountVarianceAmount;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceJour vendInvoiceJour;
        PurchLine localPurchLine;
        boolean usePrevRelieved;

        // <GEERU>
        TaxUpdateMode_RU taxUpdateMode = TaxUpdateMode_RU::Standard;
        Amount taxAmount;
        TaxGroup taxGroup;
        TaxItemGroup taxItemGroup;
        // </GEERU>

        if (this.useExistingDistributions())
        {
            // Posted invoice lines no longer need amounts calculated; use the posted distributions
            return SourceDocumentLineProvider::getDistributedAmountMap(sourceDocumentLine);
        }

        // Create map
        sourceDocumentAmountMap = SourceDocumentAmountMap::construct();

        if (purchLine)
        {
            purchTable = purchLine.purchTable();

            prevInvoicedQty = this.parmTotalPreviouslyInvoicedQty();
            invoicedQty = prevInvoicedQty + this.parmQuantity();

            if (abs(invoicedQty) > abs(purchLine.PurchQty))
            {
                // Invoice quantity is greater than purchase order quantity because invoice quantity amount
                // must have the same sign as the purchase order quantity amount.

                quantityVariance = (invoicedQty - purchLine.PurchQty);
                quantityVarianceAmount = CurrencyExchangeHelper::amount(quantityVariance * purchLine.getEffectiveLinePrice() / (purchLine.PriceUnit ? purchLine.PriceUnit : 1.0), vendInvoiceLineMap.CurrencyCode);
            }

            invoiceRatioLessVarQty = (this.parmQuantity() - quantityVariance) / (purchLine.PurchQty ? purchLine.PurchQty : 1.0);
            invoiceRatio = this.parmQuantity() / (purchLine.PurchQty ? purchLine.PurchQty : 1.0);

            matchedSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(purchLine);

            // If the PO line already has posted invoices, and this unposted invoice will invoice the remaining quantity,
            // then base the expected amount on the amounts already relieved
            usePrevRelieved = (prevInvoicedQty > 0) && (invoicedQty == purchLine.PurchQty);

            matchingAmountMapEnum = matchedSourceDocumentLineItem.parmSourceDocumentAmountMap().getEnumerator();

            while (matchingAmountMapEnum.moveNext())
            {
                matchingSourceDocumentAmount = matchingAmountMapEnum.currentValue();

                switch (matchingSourceDocumentAmount.parmMonetaryAmount())
                {
                    case MonetaryAmount::ExtendedPrice:
                        if (usePrevRelieved)
                        {
                            expectedGrossAmount = this.calcRemainingAmount(matchedSourceDocumentLineItem, MonetaryAmount::ExtendedPrice, true);
                        }
                        else
                        {
                            expectedGrossAmount = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, purchLine.CurrencyCode);
                        }
                        break;

                    case MonetaryAmount::PriceAdjustment:
                        expectedPriceAdjustmentAmount = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatioLessVarQty, purchLine.CurrencyCode);
                        break;

                    case MonetaryAmount::Charge:
                        expectedChargeAmount = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatioLessVarQty, purchLine.CurrencyCode);
                        break;

                    case MonetaryAmount::Discount:
                        expectedDiscountAmount = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatioLessVarQty, purchLine.CurrencyCode);
                        break;
                }
            }

            if (purchTable.DiscPercent)
            {
                localPurchLine = purchLine.data();
                expectedTotalDiscountAmount = -CurrencyExchangeHelper::amount(localPurchLine.calcLineAmountExclTax(this.parmQuantity()) * purchTable.DiscPercent / 100, purchLine.CurrencyCode);
            }
        }

        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            // Make sure we are not reversing more than the advance invoice amount
            actualGrossAmount = CurrencyExchangeHelper::amount(this.getAdvanceInvoiceLine().LineAmount * this.getAdvanceApplicationRatio(), vendInvoiceLineMap.CurrencyCode);

            if (isPrepaymentApplication)
            {
                actualGrossAmount = -actualGrossAmount;
            }

            includesTax = true;
        }
        else
        {
            if (vendInvoiceLineMap.PurchPrice)
            {
                actualGrossAmount = this.calculateActualGrossAmountForPurchPrice();
            }
            else if (vendInvoiceLineMap.PurchMarkup == 0 && vendInvoiceLineMap.LineDisc == 0 && vendInvoiceLineMap.MultiLnDisc == 0)
            {
                // The logical gross amount can be set to the line amount only if none of these three amounts has a value
                // If one of these three amounts has a value, then the logical gross amount is zero
                actualGrossAmount = vendInvoiceLineMap.LineAmount;
            }

            if (this.parmQuantity() == 0)
            {
                actualChargeAmount = 0;
                actualPriceAdjustmentAmount = 0;
                actualGrossAmount = 0;
            }
            else
            {
                actualChargeAmount = CurrencyExchangeHelper::amount(this.parmQuantity() > 0 ? vendInvoiceLineMap.PurchMarkup : -vendInvoiceLineMap.PurchMarkup, vendInvoiceLineMap.CurrencyCode);
                actualPriceAdjustmentAmount = this.calculateActualPriceAdjustmentAmount(actualGrossAmount, actualChargeAmount);
                if (vendInvoiceLineMap.discPercent())
                {
                    actualDiscountAmount = this.calculateActualDiscountAmount(actualGrossAmount, actualChargeAmount, actualPriceAdjustmentAmount);
                }
            }
        }

        // Do amounts include tax?
        if (vendInvoiceLineMap.VendInvoiceLineMap::includeTax(purchTable, vendInvoiceMap)
        // <GIN>
        || (isoIN && FormulaDesigner_IN::isPriceInclTaxOnLineAmount(purchLine.TaxItemGroup))
        // </GIN>
        )
        {
            includesTax = true;
        }

        // <GEERU>
        if (isoRU && purchLine)
        {
            taxUpdateMode = purchLine.inventDim().inventProfile_RU().taxUpdateIncoming();
        }
        // </GEERU>

        if (vendInvoiceMap.TableId == tableNum(VendInvoiceInfoTable))
        {
            vendInvoiceInfoTable = vendInvoiceMap;
        }

        // If this is a prepayment application or reversal, skip totals calculations for a perf gain
        if (!isPrepaymentApplication && !isPrepaymentApplicationReversal)
        {
            // If called from accounting distribution form at the line level with zero header discount %
            // and line has no taxes on it, totals don't need to be calculated for complete document
            if (vendInvoiceInfoTable.RecId != 0 &&
                ((purchTable.DiscPercent != 0 || vendInvoiceInfoTable.EndDisc != 0 || purchTable.InclTax != NoYes::No) ||
                    (vendInvoiceInfoLine.TaxGroup != '' && vendInvoiceInfoLine.TaxItemGroup != '') ||
                    vendInvoiceInfoLine.hasMarkupTransWithTaxes() ||
                    !(caller is AccountingDistributionViewModelCaller && caller.parmIsLineLevel())))
            {
                purchTotals = PurchTotals::newParmTable(vendInvoiceInfoTable, // parmTable
                                                        PurchUpdate::All, // specQty
                                                        vendInvoiceInfoTable.ParmId, // parmId
                                                        '', // sumPurchId
                                                        vendInvoiceInfoTable.Ordering, // documentStatus
                                                        PurchTotalsCachingMethod::Reuse); // Use existing cache (override default)

                purchTotals.calc(true);
                purchBalance = purchTotals.purchBalance();
                actualTotalDiscountAmountForDocument = -purchTotals.endDisc();
            }
            else if (vendInvoiceMap.TableId == tableNum(VendInvoiceJour))
            {
                vendInvoiceJour = vendInvoiceMap;
                actualTotalDiscountAmountForDocument = -vendInvoiceJour.EndDisc;
                purchBalance = vendInvoiceJour.SalesBalance;
            }
        }

        taxBase = vendInvoiceLineMap.LineAmount;

        if (includesTax && !isPrepaymentApplication && !isPrepaymentApplicationReversal)
        {
            // <GEERU>
            if (taxUpdateMode == TaxUpdateMode_RU::Standard)
            {
                // </GEERU>
                taxBase = vendInvoiceLineMap.amountExclTax(vendInvoiceLineMap.LineAmount, this.parmQuantity() - quantityVariance, vendInvoiceMap.VendInvoiceMap::documentDate());
                // Prorate the amounts
                actualGrossAmount = CurrencyExchangeHelper::amount(actualGrossAmount * taxBase / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);

                actualChargeAmount = CurrencyExchangeHelper::amount(actualChargeAmount * taxBase / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);

                if (purchLine.discPercent() || vendInvoiceLineMap.discPercent())
                {
                    actualPriceAdjustmentAmount = CurrencyExchangeHelper::amount(actualPriceAdjustmentAmount * taxBase / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);
                    actualDiscountAmount = taxBase - actualGrossAmount - actualPriceAdjustmentAmount - actualChargeAmount;
                }
                else
                {
                    actualPriceAdjustmentAmount = taxBase - actualGrossAmount - actualChargeAmount;
                }
                // <GEERU>
            }
            // </GEERU>
        }
        // <GEERU>
        else if (isoRU && taxUpdateMode == TaxUpdateMode_RU::NoPost)
        {
            if (vendInvoiceLineMap.isNonPO() || vendInvoiceLineMap.isAdvance())
            {
                taxGroup = vendInvoiceLineMap.TaxGroup;
                taxItemGroup = vendInvoiceLineMap.TaxItemGroup;
            }
            else
            {
                taxGroup = purchLine.TaxGroup;
                taxItemGroup = purchLine.TaxItemGroup;
            }

            taxAmount = Tax::calcTaxAmount(taxGroup,
                                           taxItemGroup,
                                           purchTable.AccountingDate,
                                           vendInvoiceLineMap.CurrencyCode,
                                           vendInvoiceLineMap.LineAmount,
                                           TaxModuleType::Purch,
                                           this.parmQuantity() - quantityVariance,
                                           vendInvoiceLineMap.PurchUnit,
                                           vendInvoiceLineMap.ItemId);

            actualGrossAmount = CurrencyExchangeHelper::amount(actualGrossAmount + actualGrossAmount * taxAmount / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);
            actualChargeAmount = CurrencyExchangeHelper::amount(actualChargeAmount + actualChargeAmount * taxAmount / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);

            if (purchLine.discPercent() || vendInvoiceLineMap.discPercent())
            {
                actualPriceAdjustmentAmount = CurrencyExchangeHelper::amount(actualPriceAdjustmentAmount + actualPriceAdjustmentAmount * taxAmount / (vendInvoiceLineMap.LineAmount ? vendInvoiceLineMap.LineAmount : 1.0), vendInvoiceLineMap.CurrencyCode);
                actualDiscountAmount = vendInvoiceLineMap.LineAmount + taxAmount - actualGrossAmount - actualPriceAdjustmentAmount - actualChargeAmount;
            }
            else
            {
                actualPriceAdjustmentAmount = vendInvoiceLineMap.LineAmount + taxAmount - actualGrossAmount - actualChargeAmount;
            }
        }
        // </GEERU>

        if (purchLine)
        {
            priceVarianceAmount = actualGrossAmount - expectedGrossAmount;
            discountVarianceAmount = actualDiscountAmount - expectedDiscountAmount;
            priceAdjustmentVarianceAmount = actualPriceAdjustmentAmount - expectedPriceAdjustmentAmount;
            chargeAmountVariance = actualChargeAmount - expectedChargeAmount;
        }

        if (actualPriceAdjustmentAmount || priceAdjustmentVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, actualPriceAdjustmentAmount - priceAdjustmentVarianceAmount, MonetaryAmount::PriceAdjustment, includesTax));
        }

        if (actualChargeAmount || chargeAmountVariance)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, actualChargeAmount - chargeAmountVariance, MonetaryAmount::Charge, includesTax));
        }

        if (actualDiscountAmount || discountVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, actualDiscountAmount - discountVarianceAmount, MonetaryAmount::Discount, includesTax));
        }

        if (priceVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, priceVarianceAmount, MonetaryAmount::PriceVariance, includesTax));
        }

        if (discountVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, discountVarianceAmount, MonetaryAmount::DiscountVariance, includesTax));
        }

        if (priceAdjustmentVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, priceAdjustmentVarianceAmount, MonetaryAmount::PriceAdjustmentVariance, includesTax));
        }

        if (chargeAmountVariance)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, chargeAmountVariance, MonetaryAmount::ChargeVariance, includesTax));
        }

        if (quantityVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, quantityVarianceAmount, MonetaryAmount::QuantityVariance, includesTax));
        }

        if (!actualGrossAmount && this.isProjRetentionRelease())
        {
            actualGrossAmount = vendInvoiceInfoLine.PSAReleaseAmount;
        }
        // Always create a distribution for the line's net amount, even if it is empty
        sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, actualGrossAmount - priceVarianceAmount - quantityVarianceAmount, MonetaryAmount::ExtendedPrice, includesTax));

        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            // Prepayment application and application reversal lines should not be included in total discount calculation
            return sourceDocumentAmountMap;
        }

        if (actualTotalDiscountAmountForDocument)
        {
            // prorate the document total discount for this line
            actualTotalDiscountAmount = CurrencyExchangeHelper::amount(actualTotalDiscountAmountForDocument * taxBase / (purchBalance ? purchBalance : 1.0), vendInvoiceLineMap.CurrencyCode);
        }

        if (!vendInvoiceLineMap.isNonPO())
        {
            totalDiscountVarianceAmount = actualTotalDiscountAmount - expectedTotalDiscountAmount;
        }

        if (actualTotalDiscountAmount || totalDiscountVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, actualTotalDiscountAmount - totalDiscountVarianceAmount, MonetaryAmount::TotalDiscount, includesTax));
        }

        if (totalDiscountVarianceAmount)
        {
            sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, totalDiscountVarianceAmount, MonetaryAmount::TotalDiscountVariance, includesTax));
        }

        return sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjRetentionRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the retention amount exists without the line amount.
    /// </summary>
    /// <returns>true if the the retention amount exists without the line amount; otherwise, false.</returns>
    public boolean isProjRetentionRelease()
    {
        return vendInvoiceInfoLine && !vendInvoiceInfoLine.ReceiveNow && vendInvoiceInfoLine.PSAReleaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineMatchAmountExceedReferenceDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the total line match amount can exceed the reference distribution amount.
    /// </summary>
    /// <returns>
    /// true if the total line match amount can exceed the reference distribution; otherwise, false.
    /// </returns>
    public boolean canLineMatchAmountExceedReferenceDist()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>SourceDocumentLineItem</c> class documents a business event.
    /// </summary>
    /// <returns>
    /// true if the <c>SourceDocumentLineItem</c> class documents a business event; otherwise, false.
    /// </returns>
    public BusinessEvent documentsBusinessEvent()
    {
        BusinessEvent businessEvent;

        if (isPrepaymentApplication)
        {
            businessEvent = new BusinessEvent(enumNum(BusinessEvent_VendorInvoice),BusinessEvent_VendorInvoice::VendorPrepaymentApplication);
        }
        else if (isPrepaymentApplicationReversal)
        {
            businessEvent = new BusinessEvent(enumNum(BusinessEvent_VendorInvoice),BusinessEvent_VendorInvoice::VendorPrepaymentReverseApplication);
        }
        else
        {
            businessEvent = new BusinessEvent(enumNum(BusinessEvent_VendorInvoice),BusinessEvent_VendorInvoice::VendorPaymentRequestForExpensedProducts);
        }

        return businessEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUseMatchListOnCheckMainAccDervInputChg</Name>
				<Source><![CDATA[
    protected boolean doUseMatchListOnCheckMainAccDervInputChg()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existRAssets_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks is exists any russian assets purchase transactions for current line
    /// </summary>
    /// <returns>
    /// True if transactions exist; otherwise false
    /// </returns>
    public boolean existRAssets_RU()
    {
        return vendInvoiceInfoLine.isNonPO() ? RAssetPurchTrans::exist(vendInvoiceInfoLine) : RAssetPurchTrans::exist(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdvanceApplicationRatio</Name>
				<Source><![CDATA[
    private Percent getAdvanceApplicationRatio()
    {
        this.getAdvanceInvoiceLine();

        return advanceApplicationRatio;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdvanceInvoiceLine</Name>
				<Source><![CDATA[
    private VendInvoiceTrans getAdvanceInvoiceLine()
    {
        // If the record is already cached, just return it
        if (!vendInvoiceTrans_Advance && (isPrepaymentApplication || isPrepaymentApplicationReversal))
        {
            vendInvoiceJour_Advance = this.getAdvanceInvoice();

            select firstOnly vendInvoiceTrans_Advance
                where vendInvoiceTrans_Advance.PurchID == vendInvoiceJour_Advance.PurchId &&
                        vendInvoiceTrans_Advance.InvoiceId == vendInvoiceJour_Advance.InvoiceId &&
                        vendInvoiceTrans_Advance.InvoiceDate == vendInvoiceJour_Advance.InvoiceDate &&
                        vendInvoiceTrans_Advance.NumberSequenceGroup == vendInvoiceJour_Advance.NumberSequenceGroup &&
                        vendInvoiceTrans_Advance.InternalInvoiceId == vendInvoiceJour_Advance.InternalInvoiceId;

            // The factor holds the proportion of the advance application that is being relieved from the advance invoice
            if (vendInvoiceTrans_Advance.lineAmountInclTax() != 0)
            {
                advanceApplicationRatio = abs(vendInvoiceInfoLine.LineAmount / vendInvoiceTrans_Advance.lineAmountInclTax());

                // Make sure we are not reversing more than the advance invoice amount
                advanceApplicationRatio = min(1, advanceApplicationRatio);
            }
        }

        return vendInvoiceTrans_Advance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdvanceInvoice</Name>
				<Source><![CDATA[
    private VendInvoiceJour getAdvanceInvoice()
    {
        vendInvoiceTrans vendInvoiceTrans_AdvanceApplication;

        // If the record is already cached, return it; otherwise, retrieve the advance invoice header
        if (!vendInvoiceJour_Advance)
        {
            if (isPrepaymentApplicationReversal)
            {
                // Retrieve the advance application being reversed
                vendInvoiceTrans_AdvanceApplication = VendInvoiceTrans::findRecId(vendInvoiceInfoLine.AdvanceApplicationId);

                // Retrieve the advance invoice header
                vendInvoiceJour_Advance = VendInvoiceJour::findRecId(vendInvoiceTrans_AdvanceApplication.AdvanceApplicationId);
            }
            else
            {
                // Retrieve the advance invoice header
                vendInvoiceJour_Advance = VendInvoiceJour::findRecId(vendInvoiceInfoLine.AdvanceApplicationId);
            }
        }

        return vendInvoiceJour_Advance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether any changes require the main account to be changed.
    /// </summary>
    /// <returns>
    /// True if the main account needs to change.
    /// </returns>
    public boolean hasMainAccDerivationInputChanged()
    {
        boolean hasMainAccDerivationInputChanged;
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProject originSourceDocumentLineItemIProject;

        if (this.canDefinitivelyDetermineMainAccDerivationInputChanged())
        {
            hasMainAccDerivationInputChanged = true;
        }
        else
        {
            hasMainAccDerivationInputChanged = super();

            if (!hasMainAccDerivationInputChanged &&
                this is SourceDocumentLineItemIProject &&
                this.parmOriginSourceDocumentLineItem() is SourceDocumentLineItemIProject)
            {
                sourceDocumentLineItemIProject = this as SourceDocumentLineItemIProject;
                originSourceDocumentLineItemIProject = this.parmOriginSourceDocumentLineItem() as SourceDocumentLineItemIProject;
                if (sourceDocumentLineItemIProject.parmProjectId() && !originSourceDocumentLineItemIProject.parmProjectId())
                {
                    hasMainAccDerivationInputChanged = true;
                }
            }
        }

        if (!hasMainAccDerivationInputChanged &&
            this.isProjPLPostingRequired())
        {
            hasMainAccDerivationInputChanged = true;
        }

        return hasMainAccDerivationInputChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSourceDocumentAmountMatchDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if matched source document amount accounting distributions can be used
    /// to derive ledger dimensions.
    /// </summary>
    /// <param name="_monetaryAmount">
    /// Monetary amount of accounting distribution
    /// </param>
    /// <returns>
    /// true if matching source document amount accounting distributions can be used; otherwise, false.
    /// </returns>
    public boolean useSourceDocumentAmountMatchDist(MonetaryAmount _monetaryAmount)
    {
        boolean useMatchingDistribution;

        useMatchingDistribution = super(_monetaryAmount);

        return useMatchingDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjPLPostingRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method decides whether the Source document line should be posted to Project profit and Loss accounts
    /// or not.
    /// </summary>
    /// <returns>
    /// True if posting is to be done on to the profit and loss account else returns false.
    /// </returns>
    public boolean isProjPLPostingRequired()
    {
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject;
        boolean isPLPostingReq;

        if (this is SourceDocumentLineItemIProject)
        {
            sourceDocumentLineItemIProject = this as SourceDocumentLineItemIProject;

            if (sourceDocumentLineItemIProject.parmProjectId())
            {
                ProjTable projTable;
                ProjLineProperty projLineProperty;

                select firstOnly projTable
                    where projTable.ProjId == sourceDocumentLineItemIProject.parmProjectId()
                exists join projLineProperty
                    where projLineProperty.LinePropertyId == sourceDocumentLineItemIProject.parmProjectLineProperty() &&
                          projLineProperty.ToBeCapitalize;

                if (projTable && projTable.ProjInvoiceProjId)
                {
                    ProjLedgerStatus ledgerStatus;
                    ProjTransType projTransTypeLocal;
                    ProjCategory projCategory;

                    select firstonly CategoryType from projCategory
                        where projCategory.CategoryId == projectCategoryId;
                    
                    if (!projCategory && ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
                    {
                        throw error(strFmt("@ProjectOperations:MessageValidation_ProjIntegrationJournalCategoryNotFound", projectCategoryId));
                    }
                    
                    switch (projCategory.CategoryType)
                    {
                        case ProjCategoryType::Cost:
                            projTransTypeLocal = ProjTransType::Cost;
                            ledgerStatus = ProjRevRecHelper::getCostLedgerStatus(projTable);
                            break;

                        case ProjCategoryType::Hour:
                            projTransTypeLocal = ProjTransType::Hour;
                            ledgerStatus = ProjRevRecHelper::getEmplLedgerStatus(projTable);
                            break;

                        default:
                            projTransTypeLocal = ProjTransType::Item;
                            ledgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTable);
                            break;
                    }

                    if (ledgerStatus == ProjLedgerStatus::BalanceSheet && ProjTable::isPLPostingRequiredForTransType(projTable.ProjId, projTransTypeLocal))
                    {
                        isPLPostingReq = true;
                    }
                }
            }
        }

        return isPLPostingReq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMatchedMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    public boolean hasMatchedMainAccDerivationInputChanged()
    {
        boolean hasChanged;

        if (this.canDefinitivelyDetermineMainAccDerivationInputChanged())
        {
            hasChanged = true;
        }
        else
        {
            hasChanged = super();
        }

        return hasChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDefinitivelyDetermineMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether main account derivation input is changed.
    /// </summary>
    /// <returns>
    /// true if purchase main account derivation input is changed; otherwise, false.
    /// </returns>
    protected boolean canDefinitivelyDetermineMainAccDerivationInputChanged()
    {
        return (this.hasAssetAssociated() && AssetParameters::find().AssetAllowAcqPostingPO)
            || (this.parmStocked() && !this.hasVendGroupChanged());
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasVendGroupChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the Vendor Group has been changed on InvoiceAccount.
    /// </summary>
    /// <returns>
    /// True if the Vendor Group has changed; otherwise, false.
    /// </returns>
    private boolean hasVendGroupChanged()
    {
        if (!hasVendGroupChanged)
        {
            hasVendGroupChanged = (purchLine.VendGroup != VendTable::groupId(vendInvoiceMap.InvoiceAccount));
        }
        return hasVendGroupChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSourceDocumentLineImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    /// A source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects needed by the framework to the source document.
    /// </param>
    private void initFromSourceDocumentLineImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        #ISOCountryRegionCodes

        isPrepaymentApplication = false;

        if (_sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLine = _sourceDocumentLineImplementation;
            vendInvoiceLineMap = vendInvoiceInfoLine;
            vendInvoiceMap = vendInvoiceLineMap.vendInvoiceInfoTable();
            isPrepaymentApplication = vendInvoiceInfoLine.isAdvanceApplication();
            isPrepaymentApplicationReversal = vendInvoiceInfoLine.LineType == PurchInvoiceLineType::ReverseAdvanceApplication;
        }
        else if (_sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
        {
            vendInvoiceTrans = _sourceDocumentLineImplementation;
            vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendInvoiceTrans.SourceDocumentLine);
            vendInvoiceLineMap = vendInvoiceTrans;
            vendInvoiceMap = vendInvoiceTrans.vendInvoiceJour();
            isPrepaymentApplication = vendInvoiceTrans.isAdvanceApplication();
            isPrepaymentApplicationReversal = vendInvoiceTrans.LineType == PurchInvoiceLineType::ReverseAdvanceApplication;
        }

        // If asset information is provided, use that instead of doing a lookup
        if (_additionalInformation && _additionalInformation.exists(tableNum(VendInvoiceInfoLine_Asset)))
        {
            vendInvoiceInfoLine_Asset = _additionalInformation.lookup(tableNum(VendInvoiceInfoLine_Asset));
        }
        else
        {
            vendInvoiceInfoLine_Asset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(vendInvoiceInfoLine.RecId);
        }

        if (vendInvoiceLineMap.PurchID && !vendInvoiceLineMap.isAdvance())
        {
            purchLine = vendInvoiceLineMap.purchLine();
        }

        isoRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        isoIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    /// A source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects needed by the framework to the source document.
    /// </param>
    protected void initializeImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        this.initFromSourceDocumentLineImplementation(_sourceDocumentLineImplementation, _additionalInformation);

        isProjectInitialized = false;
        this.initializeProjectFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjectFields</Name>
				<Source><![CDATA[
    protected void initializeProjectFields(Map _additionalInformation = null)
    {
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem;
        SourceDocumentLineItemIProjectRevenue iProjectRevenue;
        SourceDocumentLineImplementation localSourceDocumentLineImplementation;

        if (!vendInvoiceLineMap.isInitialized())
        {
            localSourceDocumentLineImplementation = this.parmSourceDocumentLine().getSourceDocumentLineImplementation();
            this.initFromSourceDocumentLineImplementation(localSourceDocumentLineImplementation);
        }

        if (vendInvoiceLineMap.TableId == tableNum(VendInvoiceInfoLine))
        {
            localVendInvoiceInfoLine = vendInvoiceInfoLine;
        }
        else if (vendInvoiceLineMap.TableId == tableNum(VendInvoiceTrans))
        {
            localVendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendInvoiceTrans.SourceDocumentLine);
        }

        if (!vendInvoiceInfoLine_Project)
        {
            // If project is provided in additional information, use it
            if (_additionalInformation && _additionalInformation.exists(tableNum(VendInvoiceInfoLine_Project)))
            {
                vendInvoiceInfoLine_Project = _additionalInformation.lookup(tableNum(VendInvoiceInfoLine_Project));
            }
            else
            {
                vendInvoiceInfoLine_Project = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(localVendInvoiceInfoLine.RecId);
            }
        }

        if (vendInvoiceInfoLine_Project && !projectId
            && (ProjParameters::find().PostPrepaymentCostToProject == NoYes::Yes
            || localVendInvoiceInfoLine.isNonPO()))
        {
            projectDataAreaId = vendInvoiceInfoLine_Project.ProjDataAreaId;
            projectActivityNumber = vendInvoiceInfoLine_Project.ProjActivityNumber;
            projectCategoryId = vendInvoiceInfoLine_Project.ProjCategoryId;
            projectId = vendInvoiceInfoLine_Project.ProjId;
            projectItemSalesTaxGroup = vendInvoiceInfoLine_Project.ProjTaxItemGroupId;
            projectLineProperty = vendInvoiceInfoLine_Project.ProjLinePropertyId;
            projectSalesCurrencyCode = vendInvoiceInfoLine_Project.ProjSalesCurrencyId;
            projectSalesPrice = vendInvoiceInfoLine_Project.ProjSalesPrice;
            projectSalesTaxGroup = vendInvoiceInfoLine_Project.ProjTaxGroupId;
            projectSalesUnit = UnitOfMeasure::find(vendInvoiceInfoLine_Project.ProjSalesUnitId).Symbol;
            projectTransactionId = vendInvoiceInfoLine_Project.ProjTransId;
            projectLotId = localVendInvoiceInfoLine.InventTransId;
            isProjectInitialized = true;
        }
        else if (purchLine && purchLine.ProjId && !projectId)
        {
            purchOrderLineSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(purchLine);
            iProjectRevenue = purchOrderLineSourceDocumentLineItem as SourceDocumentLineItemIProjectRevenue;

            projectDataAreaId = curext();
            projectActivityNumber = iProjectRevenue.parmProjectActivityNumber();
            projectCategoryId = iProjectRevenue.parmProjectCategoryId();
            projectId = iProjectRevenue.parmProjectId();
            projectItemSalesTaxGroup = iProjectRevenue.parmProjectItemSalesTaxGroup();
            projectLineProperty = iProjectRevenue.parmProjectLineProperty();
            projectSalesCurrencyCode = iProjectRevenue.parmProjectSalesCurrencyCode();
            projectSalesPrice = iProjectRevenue.parmProjectSalesPrice();
            projectSalesTaxGroup = iProjectRevenue.parmProjectSalesTaxGroup();
            projectSalesUnit = iProjectRevenue.parmProjectSalesUnit();
            projectTransactionId = iProjectRevenue.parmProjectTransactionId();
            projectLotId = purchLine.InventTransId;
            isProjectInitialized = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineMatchingList()
    {
        if (purchLine)
        {
            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, purchLine);
        }
        else if (vendInvoiceInfoLine.PurchCommitmentLine_PSN && PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendInvoiceInfoLine.getPurchCommitmentLine_PSN());
        }
        else if (vendInvoiceInfoLine.isBudgetReservationLineReferenced())
        {
            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendInvoiceInfoLine.getBudgetReservationLine());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineRelievingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineRelievingList()
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        Factor factor;
        int64 numOfPackingSlips;
        VendInvoicePackingSlipQuantityMatch vendInvoicePackingSlipQuantityMatch;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        // <GIN>
        CustomsVendBOETrans_IN customsVendBOETrans_IN;
        // </GIN>

        // Prepay application and reversals do not use the relieving list
        sourceDocumentLineRelievingList = SourceDocumentLineMatchingList::construct();
        factor = 1;

        if (purchLine)
        {
            if (vendInvoiceLineMap.TableId == tableNum(VendInvoiceTrans))
            {
                // When the document is posted, the vendPackingSlipTrans records are matched by vendInvoicePackingSlipQuantityMatch on a late match
                // and vendInvoiceInfoSubLine on an early match.

                select count(RecId) from vendInvoicePackingSlipQuantityMatch where
                    vendInvoicePackingSlipQuantityMatch.InvoiceSourceDocumentLIne == vendInvoiceLineMap.SourceDocumentLine;

                numOfPackingSlips = vendInvoicePackingSlipQuantityMatch.RecId;

                if (numOfPackingSlips > 0)
                {
                    while select vendPackingSlipTrans
                       join Quantity from vendInvoicePackingSlipQuantityMatch where
                        vendInvoicePackingSlipQuantityMatch.InvoiceSourceDocumentLIne == vendInvoiceLineMap.SourceDocumentLine &&
                        vendPackingSlipTrans.SourceDocumentLine == vendInvoicePackingSlipQuantityMatch.PackingSlipSourceDocumentLine

                    {
                        // The factor holds the proportion of the purchase receipt quantity that has been matched
                        // to the vendor invoice line.
                        factor = vendInvoicePackingSlipQuantityMatch.Quantity / vendPackingSlipTrans.Qty;
                        sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendPackingSlipTrans, factor, sourceDocumentLineRelievingList, vendInvoicePackingSlipQuantityMatch.Quantity);
                    }
                }
                else
                {
                    localVendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendInvoiceLineMap.SourceDocumentLine);
                    // <GIN>
                    if (isoIN && CustomsVendBOETrans_IN::findPurchLineRecId(localVendInvoiceInfoLine.PurchLineRecId).RecId != 0)
                    {
                        while select vendPackingSlipTrans
                            join InventTransId from customsVendBOETrans_IN
                            where vendPackingSlipTrans.InventTransId == customsVendBOETrans_IN.InventTransId
                            join ReceiveNow from vendInvoiceInfoSubLine
                            where vendInvoiceInfoSubLine.LineRefRecId == localVendInvoiceInfoLine.RecId
                                && customsVendBOETrans_IN.RecId == vendInvoiceInfoSubLine.JournalRefRecId
                                && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(CustomsVendBOETrans_IN)
                        {
                            // factor is amount of the purchase receipt represented by the invoice match quantity
                            factor = vendInvoiceInfoSubLine.ReceiveNow / vendPackingSlipTrans.Qty;
                            sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendPackingSlipTrans, factor, sourceDocumentLineRelievingList, vendInvoiceInfoSubLine.ReceiveNow);
                        }
                    }
                    else
                    {
                        // </GIN>
                        while select vendPackingSlipTrans
                            join ReceiveNow from vendInvoiceInfoSubLine
                            where vendInvoiceInfoSubLine.LineRefRecId == localVendInvoiceInfoLine.RecId
                                && vendInvoiceInfoSubLine.JournalRefRecId == vendPackingSlipTrans.RecId
                                && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans)
                        {
                            // factor is amount of the purchase receipt represented by the invoice match quantity
                            factor = vendInvoiceInfoSubLine.ReceiveNow / vendPackingSlipTrans.Qty;
                            sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendPackingSlipTrans, factor, sourceDocumentLineRelievingList, vendInvoiceInfoSubLine.ReceiveNow);
                        }
                        // <GIN>
                    }
                    // </GIN>
                }
            }
            // Look for unposted
            else
            {
                // <GIN>
                // When the default quantity for lines on invoice posting is set to Bill of entry quantity during Invoice.
                if (isoIN)
                {
                    localVendInvoiceInfoLine = vendInvoiceLineMap;
                    if (CustomsVendBOETrans_IN::findPurchLineRecId(localVendInvoiceInfoLine.PurchLineRecId).RecId != 0)
                    {
                        while select vendPackingSlipTrans
                            join InventTransId from customsVendBOETrans_IN
                                where vendPackingSlipTrans.InventTransId == customsVendBOETrans_IN.InventTransId
                            join ReceiveNow from vendInvoiceInfoSubLine
                                where vendInvoiceInfoSubLine.LineRefRecId == localVendInvoiceInfoLine.RecId
                                && customsVendBOETrans_IN.RecId == vendInvoiceInfoSubLine.JournalRefRecId
                                && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(CustomsVendBOETrans_IN)
                        {
                            sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendPackingSlipTrans, factor, sourceDocumentLineRelievingList, vendInvoiceInfoSubLine.ReceiveNow);
                        }
                    }
                }
                // </GIN>

                while select vendPackingSlipTrans
                    join ReceiveNow from vendInvoiceInfoSubLine
                        where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceLineMap.RecId
                            && vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId
                            && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans)
                {
                    // factor is amount of the purchase receipt represented by the invoice match quantity
                    factor = vendInvoiceInfoSubLine.ReceiveNow / vendPackingSlipTrans.Qty;
                    sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, vendPackingSlipTrans, factor, sourceDocumentLineRelievingList, vendInvoiceInfoSubLine.ReceiveNow);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTermQuantity</Name>
				<Source><![CDATA[
    public Qty parmTermQuantity()
    {
        return this.parmQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPosted</Name>
				<Source><![CDATA[
    private boolean isPosted()
    {
        SourceDocumentAccountingStatus status = this.parmSourceDocument().parmSourceDocumentHeader().AccountingStatus;

        return (status == SourceDocumentAccountingStatus::Completed ||
                    status == SourceDocumentAccountingStatus::Finalized);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmAssetDataAreaId()
    {
        DataAreaId dataAreaId;

        if (vendInvoiceInfoLine_Asset.AssetId)
        {
            dataAreaId = vendInvoiceInfoLine_Asset.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetGroupDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmAssetGroupDataAreaId()
    {
        DataAreaId dataAreaId;

        if (vendInvoiceInfoLine_Asset.AssetGroup)
        {
            dataAreaId = vendInvoiceInfoLine_Asset.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetGroupId</Name>
				<Source><![CDATA[
    public AssetGroupId parmAssetGroupId()
    {
        return vendInvoiceInfoLine_Asset.AssetGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetId</Name>
				<Source><![CDATA[
    public AssetId parmAssetId()
    {
        return vendInvoiceInfoLine_Asset.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetTransactionType</Name>
				<Source><![CDATA[
    public AssetTransType parmAssetTransactionType()
    {
        if (vendInvoiceInfoLine_Asset.AssetTransTypePurch == AssetTransTypePurch::PreAcquisition_CZ)
        {
            return AssetTransType::PreAcquisition_CZ;
        }
        else
        {
            return AssetTransType::Acquisition;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategory</Name>
				<Source><![CDATA[
    public Common parmCategory()
    {
        return EcoResCategory::find(vendInvoiceLineMap.ProcurementCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryName</Name>
				<Source><![CDATA[
    public str parmCategoryName()
    {
        return EcoResCategory::find(vendInvoiceLineMap.ProcurementCategory).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeInputAmount</Name>
				<Source><![CDATA[
    public Amount parmChargeInputAmount()
    {
        return vendInvoiceLineMap.lineAmountExclTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeQuantity</Name>
				<Source><![CDATA[
    public Qty parmChargeQuantity()
    {
        return this.parmQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeSource</Name>
				<Source><![CDATA[
    public Common parmChargeSource(Common _markupTrans = markupTrans)
    {
        markupTrans = _markupTrans;
        return markupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompletedSourceRelationType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the table Id which owns the source document line after completion/posting.
    /// </summary>
    /// <returns>
    /// The table Id which owns the source document line after completion/posting.
    /// </returns>
    public TableId parmCompletedSourceRelationType()
    {
        // It is necessary to check VendInvoiceTrans in case the line wasn't posted because of zero quantity
        if (VendInvoiceTrans::findSourceDocumentLine(sourceDocumentLine.RecId))
        {
            return tableNum(VendInvoiceTrans);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCopyDistributionReferenceOfOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether the distribution reference information from original source document can be copied.
    /// </summary>
    /// <returns>
    /// true if the distribution reference information from original source document can be copied; otherwise, false.
    /// </returns>
    public boolean parmCopyDistributionReferenceOfOriginal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmDefaultDimension()
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionTemplateRecId</Name>
				<Source><![CDATA[
    public AccountingDistributionTemplateRecId parmDistributionTemplateRecId()
    {
        return vendInvoiceLineMap.accDistributionTemplateRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate1()
    {
        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            // Return exchange rate for original prepayment invoice
            return this.getAdvanceInvoice().ExchRate;
        }

        return vendInvoiceMap.ExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate2</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate2()
    {
        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            // Return secondary exchange rate for original prepayment invoice
            return this.getAdvanceInvoice().ExchRateSecondary;
        }

        return vendInvoiceMap.ExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFundingSourceId</Name>
				<Source><![CDATA[
    public ProjFundingSourceId parmFundingSourceId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInProcessSourceRelationType</Name>
				<Source><![CDATA[
    public TableId parmInProcessSourceRelationType()
    {
        return tableNum(VendInvoiceInfoLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventoryDimensionId</Name>
				<Source><![CDATA[
    public InventDimId parmInventoryDimensionId()
    {
        InventDimId inventDimId;

        switch (vendInvoiceLineMap.TableId)
        {
            case tableNum(VendInvoiceInfoLine):
                inventDimId = vendInvoiceInfoLine.InventDimId;
                break;
            case tableNum(VendInvoiceTrans):
                inventDimId = vendInvoiceTrans.InventDimId;
                break;
            default:
                throw error("@SYS6144");
        }

        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTable</Name>
				<Source><![CDATA[
    public Common parmInventTable()
    {
        if (vendInvoiceLineMap.ItemId && !inventTable.RecId)
        {
            inventTable = InventTable::find(vendInvoiceLineMap.ItemId);
        }

        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentLineEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentLineEditable()
    {
        boolean isDocumentLineEditable;

        if (vendInvoiceInfoLine.isAdvanceApplication() || vendInvoiceLineMap.isAdvance())
        {
            isDocumentLineEditable = false;
        }
        else
        {
            isDocumentLineEditable = super();
        }

        return isDocumentLineEditable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxInChargeInputAmountIncluded</Name>
				<Source><![CDATA[
    public boolean parmIsTaxInChargeInputAmountIncluded()
    {
        return vendInvoiceMap.isInclTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmItemDataAreaId()
    {
        DataAreaId dataAreaId;

        if (vendInvoiceLineMap.ItemId)
        {
            dataAreaId = vendInvoiceLineMap.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId()
    {
        return vendInvoiceLineMap.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resolved item name on the vendor invoice line based
    /// on the item being a catalog or non-catalog item.
    /// </summary>
    /// <returns>
    /// The item name on the vendor invoice line.
    /// </returns>
    /// <remarks>
    /// This is a read-only method.
    /// </remarks>
    public ProdName getItemName()
    {
        ProdName productName;

        if (vendInvoiceLineMap.ItemId)
        {
            productName = vendInvoiceLineMap.itemName();
        }
        else
        {
            productName = EcoResCategory::find(vendInvoiceLineMap.ProcurementCategory).Name;
        }

        return productName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionDefaultAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerDimensionDefaultAccount(LegalEntityRecId _legalEntityRecId = 0)
    {
        if (this.isProjRetentionRelease())
        {
            return LedgerSystemAccounts::find(LedgerPostingType::PSAProjPurchRetain).LedgerDimension;
        }
        else
        {
            return vendInvoiceLineMap.ledgerDim();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLegalEntity</Name>
				<Source><![CDATA[
    public CompanyInfo parmLegalEntity()
    {
        return CompanyInfo::findDataArea(curext());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum()
    {
        return vendInvoiceLineMap.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineOrderByValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the value of the order by field of <C>SourceDocumentTmpAmount</C> table. It is used to match
    /// the source document line order of the tree control in accounting distribution form to the original transaction line form.
    /// </summary>
    /// <returns>
    /// The order by field value.
    /// </returns>
    public container parmLineOrderByValue()
    {
        container lineOrderByValue;

        if (vendInvoiceInfoLine)
        {
            lineOrderByValue = [vendInvoiceInfoLine.ParmId, vendInvoiceInfoLine.TableRefId, vendInvoiceInfoLine.OrigPurchId];
        }
        else
        {
            lineOrderByValue = [vendInvoiceLineMap.PurchID];
        }

        return lineOrderByValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLotId</Name>
				<Source><![CDATA[
    public InventTransId parmLotId()
    {
        InventTransId inventTransId;

        if (projectLotId)
        {
            inventTransId = projectLotId;
        }
        else
        {
            switch (vendInvoiceLineMap.TableId)
            {
                case tableNum(VendInvoiceInfoLine):
                    inventTransId = vendInvoiceInfoLine.InventTransId;
                    break;
                case tableNum(VendInvoiceTrans):
                    inventTransId = vendInvoiceTrans.InventTransId;
                    break;
                default:
                    throw error("@SYS6144");
            }
        }

        return inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmId</Name>
				<Source><![CDATA[
    public ParmId parmParmId()
    {
        return vendInvoiceInfoLine.ParmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPlanReference</Name>
				<Source><![CDATA[
    public LeanProductionFlowReferenceRefRecId parmPlanReference()
    {
        return purchLine.PlanReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectActivityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber parmProjectActivityNumber()
    {
        return projectActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId parmProjectCategoryId()
    {
        return projectCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmProjectDataAreaId()
    {
        if (!isProjectInitialized)
        {
            this.initializeProjectFields();
        }
        return projectDataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectFundingSourceRecId</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId parmProjectFundingSourceRecId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectId</Name>
				<Source><![CDATA[
    public ProjId parmProjectId()
    {
        if (!isProjectInitialized)
        {
            this.initializeProjectFields();
        }

        return projectId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectItemSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup parmProjectItemSalesTaxGroup()
    {
        return projectItemSalesTaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectLineProperty</Name>
				<Source><![CDATA[
    public ProjLinePropertyId parmProjectLineProperty()
    {
        return projectLineProperty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceCategoryRecId</Name>
				<Source><![CDATA[
    public ResourceCategoryRecId parmProjectResourceCategoryRecId()
    {
        return ResourceFacade::getResourceCategory(this.parmProjectResourceRecId(), TSTimesheetUseResourceRoleByTransDateFlight::instance().isEnabled() ? this.parmProjTransDate() : this.parmAccountingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceRecId</Name>
				<Source><![CDATA[
    public ResourceRecId parmProjectResourceRecId()
    {
        return vendInvoiceInfoLine_Project.Resource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesCurrencyCode</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode parmProjectSalesCurrencyCode()
    {
        return projectSalesCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesPrice</Name>
				<Source><![CDATA[
    public SalesPrice parmProjectSalesPrice()
    {
        return projectSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxGroup parmProjectSalesTaxGroup()
    {
        return projectSalesTaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesUnit</Name>
				<Source><![CDATA[
    public SalesUnit parmProjectSalesUnit()
    {
        return projectSalesUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectTransactionId</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmProjectTransactionId()
    {
        return projectTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the ProjTransDate of the project vendor invoice line
    /// </summary>
    /// <returns>
    /// Returns Transaction date of the vendor invoice line if it is not equal to dateNull()
    /// else it returns the Accounting date.
    /// </returns>
    public ProjTransDate parmProjTransDate()
    {
        if (vendInvoiceInfoLine_Project.TransDate != dateNull())
        {
            return vendInvoiceInfoLine_Project.TransDate;
        }
        else
        {
            return this.parmAccountingDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    public Qty parmQuantity()
    {
        return vendInvoiceLineMap.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantityDecimalPlaces</Name>
				<Source><![CDATA[
    public Decimals parmQuantityDecimalPlaces()
    {
        Decimals inventDecimalPlaces;

        inventTable = this.parmInventTable();

        if (inventTable)
        {
            inventDecimalPlaces = InventTable::inventDecimals(vendInvoiceLineMap.ItemId);
        }

        return inventDecimalPlaces;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentLineImplementation</Name>
				<Source><![CDATA[
    public SourceDocumentLineImplementation parmSourceDocumentLineImplementation()
    {
        if (vendInvoiceLineMap.isInitialized())
        {
            return sourceDocumentLineImplementation;
        }

        sourceDocumentLineImplementation = super();

        return sourceDocumentLineImplementation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStocked</Name>
				<Source><![CDATA[
    public TradeStockedProduct parmStocked()
    {
        return purchLine.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxGroup</Name>
				<Source><![CDATA[
    public TaxGroup parmTaxGroup(TaxGroup _taxGroup = vendInvoiceLineMap.TaxGroup)
    {
        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            return this.getAdvanceInvoiceLine().TaxGroup;
        }

        vendInvoiceLineMap.TaxGroup = _taxGroup;

        return vendInvoiceLineMap.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotalPreviouslyInvoicedQty</Name>
				<Source><![CDATA[
    private Qty parmTotalPreviouslyInvoicedQty()
    {
        if (!isCalculatedTotalPreviouslyInvoicedQty)
        {
            totalPreviouslyInvoicedQty = this.calcTotalPreviouslyInvoicedQty();
            isCalculatedTotalPreviouslyInvoicedQty = true;
        }

        return totalPreviouslyInvoicedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode()
    {
        return vendInvoiceLineMap.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmValueModel</Name>
				<Source><![CDATA[
    public AssetBookId parmValueModel()
    {
        return vendInvoiceInfoLine_Asset.AssetBookId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendInvoiceLineMap</Name>
				<Source><![CDATA[
    public VendInvoiceLineMap parmVendInvoiceLineMap()
    {
        return vendInvoiceLineMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useExistingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not to use the existing distributions when calculating the source document map.
    /// </summary>
    /// <returns>True if conditions are met to use existing distributions, else false.</returns>
    public boolean useExistingDistributions()
    {
        return this.isPosted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useOriginalDistributionAmount</Name>
				<Source><![CDATA[
    public boolean useOriginalDistributionAmount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionOverrideAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerDimensionOverrideAccount()
    {
        if (this.isProjRetentionRelease())
        {
            return LedgerSystemAccounts::find(LedgerPostingType::PSAProjPurchRetain).LedgerDimension;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAssetAssociated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the vendInvoiceInfoLine_Asset has an associated asset.
    /// </summary>
    /// <returns>
    /// true if the vendInvoiceInfoLine_Asset has asset information set; otherwise, false.
    /// </returns>
    public boolean hasAssetAssociated()
    {
        return (vendInvoiceInfoLine_Asset.AssetId != '' || vendInvoiceInfoLine_Asset.CreateFixedAsset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmReportingCurrencyExchangeRate1()
    {
        if (isPrepaymentApplication || isPrepaymentApplicationReversal)
        {
            return this.getAdvanceInvoice().ReportingCurrencyExchangeRate;
        }

        return vendInvoiceMap.VendInvoiceMap::parmReportingCurrencyExchangeRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTransactionAmountForProjectVendorInvoiceRetention</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate transaction amount with project vendor invoice payment retention.
    /// </summary>
    /// <param name = "_accountingDistribution"><c>AccountingDistribution</c> table buffer.</param>
    /// <param name = "_transAmount">Transaction amount.</param>
    /// <param name = "_skipLineAmountReleaseCalculationIfNoLineAmount">Whether to skip line amount release calculation if no line amount.</param>
    /// <param name = "_multipleFlipOfRetentionPercentage">Whether to have the value multiple the 100 minus retention percentage or not.</param>
    /// <param name = "_skipReleaseCalculation">Whether to skip release calculation.</param>
    /// <param name = "_addReleaseAmount">Whether release amount should be added to the retainage amount.</param>
    /// <returns>Calculated transaction amount by retainage and release formula.</returns>
    /// <remarks>
    /// The parameter value _skipReleaseCalculation should usually be false if this is an uncommitted tax transaction. 
    /// </remarks>
    internal AmountCur calcTransactionAmountForProjectVendorInvoiceRetention(
        AccountingDistribution _accountingDistribution, AmountCur _transAmount, boolean _skipLineAmountReleaseCalculationIfNoLineAmount = true,
        boolean _multipleFlipOfRetentionPercentage = true, boolean _skipReleaseCalculation = false, boolean _addReleaseAmount = true)
    {
        AmountCur transAmount = _transAmount;

        if (_accountingDistribution)
        {
            if (!vendInvoiceInfoLine)
            {
                vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(this.parmSourceDocumentLine().RecId);
            }

            if (!purchLine)
            {
                purchLine = this.parmVendInvoiceLineMap().purchLine();
            }

            // In case of project item retention scenario, the transaction amount should subtract the vendor payment retention amount.
            if (purchLine.PSARetainScheduleId)
            {
                PSAPercent paymentRetentionPercentage;
                AmountCur paymentRetentionReleaseAmount;

                if (vendInvoiceInfoLine.PSARetainagePercent || vendInvoiceInfoLine.PSAReleaseAmount)
                {
                    paymentRetentionPercentage = vendInvoiceInfoLine.PSARetainagePercent;
                    paymentRetentionReleaseAmount = vendInvoiceInfoLine.PSAReleaseAmount * _accountingDistribution.AllocationFactor;
                }

                // The transaction amount should factor in the retention percentage.
                if (transAmount 
                    && paymentRetentionPercentage 
                    && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabled(
                        ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled(),
                        purchLine.InventTransId))
                {
                    if (_multipleFlipOfRetentionPercentage)
                    {
                        transAmount = transAmount * ((100 - paymentRetentionPercentage) / 100);
                    }
                    else
                    {
                        transAmount = transAmount * paymentRetentionPercentage / 100;
                    }
                }

                // The transaction amount should factor in the release amount.
                // In the case of uncommitted tax transaction, release amount calculation is not needed because that was calculated by the tax engine. 
                // In the case of vendor invoice info line transaction, the release amount will need to be calculated.
                if (!_skipReleaseCalculation && paymentRetentionReleaseAmount)
                {
                    if (vendInvoiceInfoLine.LineAmount != 0 || !_skipLineAmountReleaseCalculationIfNoLineAmount)
                    {
                        if (_addReleaseAmount)
                        {
                            transAmount += paymentRetentionReleaseAmount;
                        }
                        else
                        {
                            transAmount -= paymentRetentionReleaseAmount;
                        }
                    }
                }

                transAmount = round(transAmount, AccountingDistributionConstants::AllocationFactorRoundingPrecision);
            }   
        }

        return transAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentStatus</Name>
				<Source><![CDATA[
    internal VendInvoiceRequestStatus getSourceDocumentStatus()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable = vendInvoiceMap;

        return vendInvoiceInfoTable.RequestStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChildSourceDocumentLineItemListToNull</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set childSourceDocumentLineItemList to null
    /// </summary>
    [Hookable(false)]
    public void setChildSourceDocumentLineItemListToNull()
    {
        childSourceDocumentLineItemList = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUseFixedExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to use the fixed exchange rate or not
    /// </summary>
    /// <returns>
    /// Returns Yes if FixedExchRate is selected; otherwise, No
    /// </returns>
    [Hookable(false)]
    public FixedExchRate doUseFixedExchangeRate()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceJour VendInvoiceJour;
        FixedExchRate isFixedExchRateSelected = NoYes::No;

        switch (vendInvoiceMap.TableId)
        {
            case tableNum(VendInvoiceInfoTable):
                vendInvoiceInfoTable = vendInvoiceMap;

                isFixedExchRateSelected = vendInvoiceInfoTable.FixedExchRate;
                break;

            case tableNum(VendInvoiceJour):
                vendInvoiceJour = vendInvoiceMap;

                vendInvoiceInfoTable = vendInvoiceInfoTable::findFromVendInvoiceJour(
                    VendInvoiceJour.PurchId,
                    VendInvoiceJour.InvoiceId,
                    VendInvoiceJour.ParmId);

                isFixedExchRateSelected = vendInvoiceInfoTable.FixedExchRate;
                break;
        }

        return isFixedExchRateSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public Common parmPurchLine()
    {
        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyTagsToAllocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies financial tags to a list of allocations for the current source document line.
    /// </summary>
    /// <param name = "_allocations">The list of allocations.</param>
    /// <returns>The list of allocations with financial tags applied.</returns>
    public LedgerDimensionAllocationList applyTagsToAllocations(LedgerDimensionAllocationList _allocations)
    {
        if (PurchaseOrderFinTagFeature::isEnabled() && !vendInvoiceInfoLine.OrigPurchId)
        {
            LedgerDimensionAllocationListEnumerator ledgerDimensionAllocationListEnumerator = _allocations.getEnumerator();
            LedgerDimensionAllocationList returnList = LedgerDimensionAllocationList::construct();

            while (ledgerDimensionAllocationListEnumerator.moveNext())
            {
                LedgerDimensionAllocation currentItem = ledgerDimensionAllocationListEnumerator.current();
                currentItem.parmFinTag(vendInvoiceInfoLine.FinTag);
                returnList.addEnd(currentItem);
            }

            return returnList;
        }

        return _allocations;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>