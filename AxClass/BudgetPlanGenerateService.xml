<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetPlanGenerateService</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BudgetPlanGenerateService</c> class is an abstract class used as a base class for data generation in budget plan tables.
/// </summary>
public abstract class BudgetPlanGenerateService
{
    BudgetPlanGenerateContract       budgetPlanGenerateContract;
    boolean                          isBudgetPlanLineCreated;
    BudgetPlanLineDataGenerationTmp  budgetPlanLineDataGenerationTmpBulkInsert;
    CurrencyCode                     currencyCode;
    CurrencyExchangeHelper           currencyExchange;
    Ledger                           ledger;
    BudgetPlanCurrencyExchangeHelper budgetPlanCurrencyExchangeHelper;
    protected boolean useHistoricalAmount;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addOrUpdateRecordInTmpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds or updates the record in the <c>BudgetPlanLineDataGenerationTmp</c> table for bulk insertion.
    /// </summary>
    /// <param name="_budgetPlanLineDataGenerationTmp">
    /// The <c>BudgetPlanLineDataGenerationTmp</c> record that needs to be added for bulk insertion.
    /// </param>
    protected void addOrUpdateRecordInTmpTable(BudgetPlanLineDataGenerationTmp _budgetPlanLineDataGenerationTmp)
    {
        this.findRecordInTmpTable(_budgetPlanLineDataGenerationTmp);

        // If a record exists then update and summarize the record
        if (budgetPlanLineDataGenerationTmpBulkInsert)
        {
            if (budgetPlanLineDataGenerationTmpBulkInsert.EstimateType == BudgetPlanEstimateType::Monetary)
            {
                if (currencyCode == ledger.AccountingCurrency && useHistoricalAmount)
                {
                    budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount += _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;

                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount += _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;
                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount += _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount;
                }
                else if (currencyCode == _budgetPlanLineDataGenerationTmp.TransactionCurrencyCode && useHistoricalAmount)
                {
                    budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount += _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount;

                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount += _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;
                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount += _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount;
                }
                else
                {
                    budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount += budgetPlanCurrencyExchangeHelper.calculateTransactionCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyCode,
                        currencyCode,
                        _budgetPlanLineDataGenerationTmp.EffectiveDate);

                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount += budgetPlanCurrencyExchangeHelper.calculateAccountingCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        currencyCode,
                        budgetPlanLineDataGenerationTmpBulkInsert.EffectiveDate);

                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount += budgetPlanCurrencyExchangeHelper.calculateReportingCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        currencyCode,
                        budgetPlanLineDataGenerationTmpBulkInsert.EffectiveDate);
                }
            }
            else
            {
                budgetPlanLineDataGenerationTmpBulkInsert.Quantity += _budgetPlanLineDataGenerationTmp.Quantity;
            }

            budgetPlanLineDataGenerationTmpBulkInsert.update();
        }
        else
        {
            if (_budgetPlanLineDataGenerationTmp.EstimateType == BudgetPlanEstimateType::Monetary)
            {
                if (currencyCode == ledger.AccountingCurrency && useHistoricalAmount)
                {
                    _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount = _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;
                    _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount = _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;
                    _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount = _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount;
                }
                else if (currencyCode == _budgetPlanLineDataGenerationTmp.TransactionCurrencyCode && useHistoricalAmount)
                {
                    _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount = _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount;
                    _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount = _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount;
                    _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount = _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount;
                }
                else
                {
                    _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount = budgetPlanCurrencyExchangeHelper.calculateTransactionCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyCode,
                        currencyCode,
                        _budgetPlanLineDataGenerationTmp.EffectiveDate);

                    _budgetPlanLineDataGenerationTmp.AccountingCurrencyAmount = budgetPlanCurrencyExchangeHelper.calculateAccountingCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        currencyCode,
                        _budgetPlanLineDataGenerationTmp.EffectiveDate);

                    _budgetPlanLineDataGenerationTmp.ReportingCurrencyAmount = budgetPlanCurrencyExchangeHelper.calculateReportingCurrencyAmount(
                        _budgetPlanLineDataGenerationTmp.TransactionCurrencyAmount,
                        currencyCode,
                        _budgetPlanLineDataGenerationTmp.EffectiveDate);
                }

                _budgetPlanLineDataGenerationTmp.TransactionCurrencyCode = currencyCode;
            }

            _budgetPlanLineDataGenerationTmp.LineReferenceId = newGuid();

            budgetPlanLineDataGenerationTmpBulkInsert.data(_budgetPlanLineDataGenerationTmp);

            budgetPlanLineDataGenerationTmpBulkInsert.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountByFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount by applying the factor to the specified amount.
    /// </summary>
    /// <param name="_budgetPlanCurrencyAmount">
    /// The amount to which factor will be applied.
    /// </param>
    /// <param name="_factor">
    /// The factor that the amount should be multiplied by; optional.
    /// </param>
    /// <returns>
    /// The amount adjusted by the factor.
    /// </returns>
    /// <remarks>
    /// This should only be specified if the factor on the contract should not be used.
    /// </remarks>
    protected BudgetPlanCurrencyAmount adjustAmountByFactor(BudgetPlanCurrencyAmount _budgetPlanCurrencyAmount, Factor _factor = 1.00)
    {
        BudgetPlanCurrencyAmount    budgetPlanCurrencyAmount;
        Factor                      factor;

        // Decide if we are using a document-level factor from the contract or a line-level factor being passed in.
        if (!prmIsDefault(_factor))
        {
            factor = _factor;
        }
        else
        {
            factor = this.parmBudgetPlanGenerateContract().parmTargetFactor();
        }

        if (factor != 0)
        {
            budgetPlanCurrencyAmount = _budgetPlanCurrencyAmount * factor;
        }

        return budgetPlanCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bulkInsertOrUpdateBudgetPlanLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the factor and determines whether the amount is greater than minimum value for budget line.
    /// Then performs the rounding on the amount. Finally, adds or updates the record in the <c>BudgetPlanLine</c> table.
    /// </summary>
    protected void bulkInsertOrUpdateBudgetPlanLines()
    {
        BudgetPlanLine            budgetPlanLine;
        BudgetPlanCurrencyAmount  transactionCurrencyAmount;

        while select forUpdate budgetPlanLineDataGenerationTmpBulkInsert
        {
            transactionCurrencyAmount = budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount;
            transactionCurrencyAmount = this.adjustAmountByFactor(transactionCurrencyAmount);
            transactionCurrencyAmount = this.roundAmountForCurrency(transactionCurrencyAmount, currencyCode);

            if (this.isAmountGreaterThanMinimumValue(transactionCurrencyAmount))
            {
                budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount = this.roundAmount(transactionCurrencyAmount);

                if (useHistoricalAmount)
                {
                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount = this.adjustAmountByFactor(budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount);
                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount = this.roundAmount(budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount);

                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount = this.adjustAmountByFactor(budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount);
                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount = this.roundAmount(budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount);
                }
                else
                {
                    budgetPlanLineDataGenerationTmpBulkInsert.AccountingCurrencyAmount = budgetPlanCurrencyExchangeHelper.calculateAccountingCurrencyAmount(
                        budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount,
                        budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyCode,
                        budgetPlanLineDataGenerationTmpBulkInsert.EffectiveDate);

                    budgetPlanLineDataGenerationTmpBulkInsert.ReportingCurrencyAmount = budgetPlanCurrencyExchangeHelper.calculateReportingCurrencyAmount(
                        budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyAmount,
                        budgetPlanLineDataGenerationTmpBulkInsert.TransactionCurrencyCode,
                        budgetPlanLineDataGenerationTmpBulkInsert.EffectiveDate);
                }

                isBudgetPlanLineCreated = true;
            }
            else
            {
                // Set BudgetPlanHeader to zero to indicate the temp table records should not be processed as they do not meet the minimum.
                budgetPlanLineDataGenerationTmpBulkInsert.BudgetPlanHeader = 0;
            }

            budgetPlanLineDataGenerationTmpBulkInsert.update();
        }

        if (isBudgetPlanLineCreated)
        {
            BudgetInstrumentationLogger budgetPlanLogger = BudgetInstrumentationLogger::createLogger(classStr(BudgetPlanGenerateService));
            using (SysInstrumentationActivityContext budgetPlanGenerateContext = budgetPlanLogger.budgetPlanGeneration().planLineContext())
            {
                insert_recordset budgetPlanLine(
                    BudgetClass,
                    BudgetPlanHeader,
                    BudgetPlanScenario,
                    LineReferenceId,
                    Comment,
                    EffectiveDate,
                    EstimateType,
                    IsRecurring,
                    IsNewRequest,
                    LedgerDimension,
                    TransactionCurrencyAmount,
                    AccountingCurrencyAmount,
                    ReportingCurrencyAmount,
                    TransactionCurrencyCode,
                    Quantity,
                    UnitOfMeasure,
                    TransactionUnitPrice,
                    AssetId,
                    PositionScenario,
                    Position,
                    ProjectId,
                    ProposedAsset,
                    ProposedProject,
                    SourceDataAreaId,
                    ForecastModelId
                )
                select
                    BudgetClass,
                    BudgetPlanHeader,
                    BudgetPlanScenario,
                    LineReferenceId,
                    Comment,
                    EffectiveDate,
                    EstimateType,
                    IsRecurring,
                    IsNewRequest,
                    LedgerDimension,
                    TransactionCurrencyAmount,
                    AccountingCurrencyAmount,
                    ReportingCurrencyAmount,
                    TransactionCurrencyCode,
                    Quantity,
                    UnitOfMeasure,
                    UnitPrice,
                    AssetId,
                    PositionForecastScenario,
                    HcmPosition,
                    ProjectId,
                    BudgetPlanProposedAsset,
                    BudgetPlanProposedProject,
                    SourceDataAreaId,
                    ForecastModelId
                from budgetPlanLineDataGenerationTmpBulkInsert
                where budgetPlanLineDataGenerationTmpBulkInsert.BudgetPlanHeader != 0;

                budgetPlanLogger.logBucketizedCount(budgetPlanGenerateContext, budgetPlanLine.rowCount());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateOrUpdateBudgetPlanLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the creation or update of the <c>BudgetPlanLine</c> must be skipped.
    /// </summary>
    /// <param name="_budgetPlanLineDataGenerationTmp">
    /// The <c>BudgetPlanLineDataGenerationTmp</c> record that needs to be validated for insert or update.
    /// </param>
    /// <returns>
    /// true if the <c>BudgetPlanLine</c> can be created or updated; otherwise, false.
    /// </returns>
    protected boolean canCreateOrUpdateBudgetPlanLine(BudgetPlanLineDataGenerationTmp _budgetPlanLineDataGenerationTmp)
    {
        BudgetPlanLine          budgetPlanLine;
        BudgetPlanLineItemLine  budgetPlanLineItem;
        boolean                 canCreateOrUpdateBudgetPlanLine = true;

        budgetPlanLineItem = BudgetPlanLineItemLine::construct();

        if (budgetPlanGenerateContract.parmTargetIsHistorical() == NoYes::No
            && _budgetPlanLineDataGenerationTmp.LedgerDimension)
        {
            budgetPlanLine.BudgetPlanHeader = _budgetPlanLineDataGenerationTmp.BudgetPlanHeader;
            budgetPlanLine.EffectiveDate    = _budgetPlanLineDataGenerationTmp.EffectiveDate;
            budgetPlanLine.LedgerDimension  = _budgetPlanLineDataGenerationTmp.LedgerDimension;

            budgetPlanLineItem.parmBudgetPlanLine(budgetPlanLine);

            // Determine whether any dimension attribute value has been suspended for this dimension attribute value combination.
            canCreateOrUpdateBudgetPlanLine = budgetPlanLineItem.validateField(fieldNum(BudgetPlanLine, LedgerDimension));
        }

        return canCreateOrUpdateBudgetPlanLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetPlanHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the record in the <c>BudgetPlanHeader</c> table.
    /// </summary>
    /// <returns>
    /// A record in the <c>BudgetPlanHeader</c> table.
    /// </returns>
    protected BudgetPlanHeader createOrUpdateBudgetPlanHeader()
    {
        BudgetPlanHeader        budgetPlanHeader;
        BudgetPlanGenerateType  budgetPlanGenerateType;
        BudgetPlanLine          budgetPlanLine;
        BudgetPlanScenarioRecId targetBudgetPlanScenarioRecId;

        budgetPlanGenerateType = budgetPlanGenerateContract.parmTargetBudgetPlanGenerateType();

        switch (budgetPlanGenerateType)
        {
            case BudgetPlanGenerateType::NewBudgetPlan:
                budgetPlanHeader = this.setBudgetPlanHeader();
                budgetPlanHeader.insert();
                break;

            case BudgetPlanGenerateType::ReplaceBudgetPlan:
                budgetPlanHeader = BudgetPlanHeader::find(budgetPlanGenerateContract.parmTargetBudgetPlanDocumentNumber());

                targetBudgetPlanScenarioRecId = budgetPlanGenerateContract.parmTargetBudgetPlanScenario();

                if (targetBudgetPlanScenarioRecId)
                {
                    delete_from budgetPlanLine
                        where budgetPlanLine.BudgetPlanHeader    == budgetPlanHeader.RecId
                            && budgetPlanLine.BudgetPlanScenario == targetBudgetPlanScenarioRecId;
                }
                break;

            case BudgetPlanGenerateType::UpdateBudgetPlan:
                budgetPlanHeader = BudgetPlanHeader::find(budgetPlanGenerateContract.parmTargetBudgetPlanDocumentNumber());
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        budgetPlanGenerateContract.parmTargetBudgetPlanDocumentNumber(budgetPlanHeader.RecId);

        return budgetPlanHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBudgetPlanLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the record in the <c>BudgetPlanLine</c> table.
    /// </summary>
    /// <param name="_budgetPlanLineDataGenerationTmp">
    /// The <c>BudgetPlanLineDataGenerationTmp</c> record that needs to be created or updated.
    /// </param>
    protected void createOrUpdateBudgetPlanLine(BudgetPlanLineDataGenerationTmp _budgetPlanLineDataGenerationTmp)
    {
        if (this.canCreateOrUpdateBudgetPlanLine(_budgetPlanLineDataGenerationTmp))
        {
            switch (budgetPlanGenerateContract.parmTargetBudgetPlanGenerateType())
            {
                case BudgetPlanGenerateType::NewBudgetPlan,
                     BudgetPlanGenerateType::ReplaceBudgetPlan:
                    this.addOrUpdateRecordInTmpTable(_budgetPlanLineDataGenerationTmp);
                    break;

                case BudgetPlanGenerateType::UpdateBudgetPlan:
                    // Delete all matching target budget plan lines
                    this.deleteAllMatchingBudgetPlanLine(_budgetPlanLineDataGenerationTmp);
                    this.addOrUpdateRecordInTmpTable(_budgetPlanLineDataGenerationTmp);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllMatchingBudgetPlanLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes records in the <c>BudgetPlanLine</c> table that match the values in the passed
    /// in buffer.
    /// </summary>
    /// <param name="_budgetPlanLineDataGenerationTmp">
    /// The <c>BudgetPlanLineDataGenerationTmp</c> record used to find an existing record in
    /// the <c>BudgetPlanLine</c> table.
    /// </param>
    /// <remarks>
    /// Use this method only if the budget plan line is expected to have no line source field data. Individual child classes that have
    /// a different find and delete criteria should override this method and skip calling super().
    /// </remarks>
    protected void deleteAllMatchingBudgetPlanLine(BudgetPlanLineDataGenerationTmp _budgetPlanLineDataGenerationTmp)
    {
        BudgetPlanLine       budgetPlanLine;

        delete_from budgetPlanLine
            where budgetPlanLine.BudgetPlanHeader       == _budgetPlanLineDataGenerationTmp.BudgetPlanHeader
                && budgetPlanLine.BudgetPlanScenario    == _budgetPlanLineDataGenerationTmp.BudgetPlanScenario
                && budgetPlanLine.LedgerDimension       == _budgetPlanLineDataGenerationTmp.LedgerDimension
                && budgetPlanLine.EffectiveDate         == _budgetPlanLineDataGenerationTmp.EffectiveDate
                && budgetPlanLine.BudgetClass           == _budgetPlanLineDataGenerationTmp.BudgetClass
                && budgetPlanLine.AssetId               == ''
                && budgetPlanLine.ProjectId             == ''
                && budgetPlanLine.PositionScenario      == 0
                && budgetPlanLine.ProposedAsset         == 0
                && budgetPlanLine.ProposedProject       == 0
                && budgetPlanLine.SourceBudgetPlanLine  == 0
                && budgetPlanLine.SourceDataAreaId      == '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecordInTmpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>BudgetPlanLineDataGenerationTmp</c> table that matches the values in the passed
    /// in buffer.
    /// </summary>
    /// <param name="_budgetPlanLineDataGenerationTmp">
    /// The <c>BudgetPlanLineDataGenerationTmp</c> record used to find an existing record in
    /// the <c>BudgetPlanLineDataGenerationTmp</c> table.
    /// </param>
    /// <remarks>
    /// Individual child classes that have a different find criteria should override this method and skip calling super().
    /// </remarks>
    protected void findRecordInTmpTable(BudgetPlanLineDataGenerationTmp _budgetPlanLineDataGenerationTmp)
    {
        select firstonly forupdate budgetPlanLineDataGenerationTmpBulkInsert
            where budgetPlanLineDataGenerationTmpBulkInsert.BudgetPlanHeader   == _budgetPlanLineDataGenerationTmp.BudgetPlanHeader
               && budgetPlanLineDataGenerationTmpBulkInsert.BudgetPlanScenario == _budgetPlanLineDataGenerationTmp.BudgetPlanScenario
               && budgetPlanLineDataGenerationTmpBulkInsert.LedgerDimension    == _budgetPlanLineDataGenerationTmp.LedgerDimension
               && budgetPlanLineDataGenerationTmpBulkInsert.EffectiveDate      == _budgetPlanLineDataGenerationTmp.EffectiveDate
               && budgetPlanLineDataGenerationTmpBulkInsert.BudgetClass        == _budgetPlanLineDataGenerationTmp.BudgetClass;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateBudgetPlanningLedgerDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a LedgerDimension of type BudgetPlanning.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The record Id of the <c>DimensionAttributeValueCombination</c> record.
    /// </param>
    /// <returns>
    /// The record Id of the <c>DimensionAttributeValueCombination</c> record which
    /// is of type BudgetPlanning.
    /// </returns>
    protected LedgerDimensionBudgetPlanning generateBudgetPlanningLedgerDim(LedgerDimensionBase _ledgerDimension)
    {
        LedgerDimensionBudgetPlanning bpLedgerDimension;

        // Apply the additonal budget planning rules for the active structure that are not associated to the ledger accounts the combination was generated from.
        bpLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(LedgerDimensionType::BudgetPlanning, _ledgerDimension);

        return bpLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the data in the budget plan tables.
    /// </summary>
    protected abstract void generateData()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the document number for a <c>BudgetPlanHeader</c> record.
    /// </summary>
    /// <returns>
    /// A new number sequence number.
    /// </returns>
    protected BudgetPlanDocumentNumber getDocumentNumberSequence()
    {
        NumberSequenceReference numberSequenceReference;
        NumberSeq               numSeq;

        numberSequenceReference = BudgetPlan::getBudgetPlanNumberSeqBasedOnProcess(budgetPlanGenerateContract.parmTargetBudgetPlanningProcess());

        changecompany (CompanyInfo::getDataArea(ledger.PrimaryForLegalEntity))
        {
            if (BudgetPlan::checkBudgetPlanNumberSequence(numberSequenceReference))
            {
                numSeq = NumberSeq::newGetNumFromId(numberSequenceReference.NumberSequenceId);
            }
            else
            {
                throw Exception::Error;
            }
        }

        return numSeq.num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserDefinedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the query object according to the settings which the user defined on the dialog.
    /// </summary>
    /// <returns>
    /// An instance of the <c>Query</c> class.
    /// </returns>
    public abstract Query getUserDefinedQuery()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BudgetPlanGenerateService</c> object.
    /// </summary>
    public void initialize()
    {
        budgetPlanCurrencyExchangeHelper = BudgetPlanCurrencyExchangeHelper::construct();

        ledger = Ledger::find(budgetPlanGenerateContract.parmTargetLedgerRecId());

        // Set currency to the Accouting currency when the BudgetPlanGenerateType is NewBudgetPlan
        // Set currency to the Target plan currency when the BudgetPlanGenerateType is either ReplaceBudgetPlan or UpdateBudgetPlan
        if (budgetPlanGenerateContract.parmTargetBudgetPlanGenerateType() == BudgetPlanGenerateType::NewBudgetPlan)
        {
            currencyCode = ledger.AccountingCurrency;
        }
        else
        {
            currencyCode = BudgetPlanHeader::find(budgetPlanGenerateContract.parmTargetBudgetPlanDocumentNumber()).Currency;
        }

        budgetPlanCurrencyExchangeHelper.initializeCurrencyExchangeHelper(ledger.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountGreaterThanMinimumValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the absolute value of the amount is greater or equal to minimum value.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount which needs to be checked against the minimum value benchmark.
    /// </param>
    /// <returns>
    /// true if the specified amount is greater than minimum value; otherwise, false.
    /// </returns>
    protected boolean isAmountGreaterThanMinimumValue(AmountCur _amountCur)
    {
        boolean isGreater;

        if (this.parmBudgetPlanGenerateContract().parmTargetMinimumValue() <= abs(_amountCur))
        {
            isGreater = true;
        }

        return isGreater;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        budgetPlanLineDataGenerationTmpBulkInsert.clear();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetPlanGenerateContract</Name>
				<Source><![CDATA[
    public BudgetPlanGenerateContract parmBudgetPlanGenerateContract(BudgetPlanGenerateContract _budgetPlanGenerateContract = budgetPlanGenerateContract)
    {
        budgetPlanGenerateContract = _budgetPlanGenerateContract;

        return budgetPlanGenerateContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserDefinedQueryRowCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the amount of lines the user defined query will return.
    /// </summary>
    /// <param name = "_maxRowCount">
    /// The max amount of rows.
    /// </param>
    /// <returns>
    /// The amount of lines.
    /// </returns>
    protected int getUserDefinedQueryRowCount(int _maxRowCount = 1)
    {
        Query query = this.getUserDefinedQuery();
        query.clearGroupBy();

        return QueryRun::getQueryRowCount(query, _maxRowCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryProducesBudgetPlanLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the user defined query will produce budget plan lines to generate.
    /// </summary>
    /// <returns>
    /// true if the query will produce budget plan lines; otherwise, false.
    /// </returns>
    public boolean queryProducesBudgetPlanLines()
    {
        int queryRowCount = this.getUserDefinedQueryRowCount();
        boolean queryProducesLines = (queryRowCount > 0);

        if (!queryProducesLines)
        {
            error(this.recordNotFoundErrorMessage());
        }

        return queryProducesLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForNonBatchRunOverride</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to allow the generate process run in non-batch mode.
    /// </summary>
    /// <returns>
    /// true if the user wants to execute the process in non-batch mode; otherwise, false.
    /// </returns>
    public boolean promptForNonBatchRunOverride()
    {
        boolean         executeProcess = true;
        DialogButton    result;
        const int       maxRowCount = 100000;

        if (this.getUserDefinedQueryRowCount(maxRowCount + 1) > maxRowCount)
        {
            result = Box::yesNo("@GLS70660", DialogButton::No);

            if (result == DialogButton::No)
            {
                executeProcess = false;
            }
        }

        return executeProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordNotFoundErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a message to indicate that no records were found.
    /// </summary>
    /// <returns>
    /// Returns the error message to be displayed.
    /// </returns>
    protected ErrorMsg recordNotFoundErrorMessage()
    {
        return "@GLS70658";
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the amount according to value specified by user.
    /// </summary>
    /// <param name="_budgetPlanCurrencyAmount">
    /// The amount which needs to be rounded.
    /// </param>
    /// <returns>
    /// The rounded amount.
    /// </returns>
    protected BudgetPlanCurrencyAmount roundAmount(BudgetPlanCurrencyAmount _budgetPlanCurrencyAmount)
    {
        return CurrencyExchange::roundWithRule(_budgetPlanCurrencyAmount, this.parmBudgetPlanGenerateContract().parmTargetRoundingPrecision(), RoundOffType::Ordinary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmountForCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the supplied amount.
    /// </summary>
    /// <param name="_budgetPlanCurrencyAmount">
    /// The amount to be rounded.
    /// </param>
    /// <param name="_budgetPlanCurrencyCode">
    /// The currency code to use when rounding.
    /// </param>
    /// <returns>
    /// The rounded amount.
    /// </returns>
    protected BudgetPlanCurrencyAmount roundAmountForCurrency(BudgetPlanCurrencyAmount _budgetPlanCurrencyAmount, BudgetPlanCurrencyCode _budgetPlanCurrencyCode)
    {
        _budgetPlanCurrencyAmount = CurrencyExchange::round(_budgetPlanCurrencyAmount, _budgetPlanCurrencyCode);

        return _budgetPlanCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBudgetPlanHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the values on a new <c>BudgetPlanHeader</c> record.
    /// </summary>
    /// <returns>
    /// The <c>BudgetPlanHeader</c> buffer with defaulted values.
    /// </returns>
    /// <remarks>
    /// All the child classes that require setting the fields in the <c>BudgetPlanHeader</c> record should
    /// implement this method.
    /// </remarks>
    protected BudgetPlanHeader setBudgetPlanHeader()
    {
        BudgetPlanHeader budgetPlanHeader;

        budgetPlanHeader.BudgetingOrganization = budgetPlanGenerateContract.parmTargetResponsibilityCenter();
        budgetPlanHeader.BudgetPlanningProcess = budgetPlanGenerateContract.parmTargetBudgetPlanningProcess();
        budgetPlanHeader.BudgetPlanPreparer    = budgetPlanGenerateContract.parmTargetPreparer();
        budgetPlanHeader.PlanningUserGroup     = budgetPlanGenerateContract.parmTargetBudgetPlanningUserGroup();
        budgetPlanHeader.DocumentNumber        = this.getDocumentNumberSequence();
        budgetPlanHeader.DocumentStatus        = BudgetPlanStatus::Draft;
        budgetPlanHeader.WorkflowStatus        = BudgetPlanWorkflowStatus::NotSubmitted;
        budgetPlanHeader.IsHistorical          = NoYes::No;
        budgetPlanHeader.Name                  = budgetPlanGenerateContract.parmTargetBudgetPlanName();
        budgetPlanHeader.BudgetPlanningStage   = BudgetPlanningWorkflowSetup::getFirstPlanningStage(
                                                        budgetPlanHeader.BudgetPlanningProcess,
                                                        budgetPlanHeader.BudgetingOrganization).RecId;
        budgetPlanHeader.Currency              = currencyCode;
        budgetPlanHeader.Layout                = BudgetPlanningStageRule::findByProcessOrganizationStage(
                                                        budgetPlanHeader.BudgetPlanningProcess,
                                                        budgetPlanHeader.BudgetingOrganization,
                                                        budgetPlanHeader.BudgetPlanningStage).Layout;

        return budgetPlanHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBudgetPlanLineDataGenerationTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the values on a new <c>BudgetPlanLineDataGenerationTmp</c> record.
    /// </summary>
    /// <param name="_budgetPlanHeaderRecId">
    /// The record ID of the <c>BudgetPlanHeader</c> record.
    /// </param>
    /// <returns>
    /// The <c>BudgetPlanLineDataGenerationTmp</c> buffer with defaulted values.
    /// </returns>
    /// <remarks>
    /// All the child classes that require setting the fields in the <c>BudgetPlanLineDataGenerationTmp</c>
    /// record should implement this method.
    /// </remarks>
    protected BudgetPlanLineDataGenerationTmp setBudgetPlanLineDataGenerationTmp(
        BudgetPlanHeaderRecId _budgetPlanHeaderRecId)
    {
        BudgetPlanLine                  budgetPlanLine;
        BudgetPlanLineItemLine          budgetPlanLineItem;
        BudgetPlanLineDataGenerationTmp budgetPlanLineDataGenerationTmp;

        budgetPlanLine.BudgetPlanHeader = _budgetPlanHeaderRecId;

        budgetPlanLineItem = BudgetPlanLineItemLine::construct();
        budgetPlanLineItem.parmBudgetPlanLine(budgetPlanLine);

        budgetPlanLineItem.initValue();
        budgetPlanLineItem.defaultRow();

        budgetPlanLineDataGenerationTmp.BudgetPlanHeader    = _budgetPlanHeaderRecId;
        budgetPlanLineDataGenerationTmp.BudgetPlanScenario  = budgetPlanGenerateContract.parmTargetBudgetPlanScenario();
        budgetPlanLineDataGenerationTmp.EstimateType        = budgetPlanLine.EstimateType;
        budgetPlanLineDataGenerationTmp.EffectiveDate       = budgetPlanLine.EffectiveDate;
        budgetPlanLineDataGenerationTmp.IsRecurring         = budgetPlanLine.IsRecurring;

        return budgetPlanLineDataGenerationTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaskCompleteMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the task complete message.
    /// </summary>
    protected void showTaskCompleteMessage()
    {
        BudgetPlanHeader      budgetPlanHeader;
        BudgetPlanHeaderRecId budgetPlanHeaderRecId;

        if (isBudgetPlanLineCreated)
        {
            budgetPlanHeaderRecId = this.parmBudgetPlanGenerateContract().parmTargetBudgetPlanDocumentNumber();
            budgetPlanHeader      = BudgetPlanHeader::find(budgetPlanHeaderRecId);

            if (budgetPlanGenerateContract.parmTargetBudgetPlanGenerateType() == BudgetPlanGenerateType::NewBudgetPlan)
            {
                info(strFmt("@GLS70669", budgetPlanHeader.DocumentNumber));
            }
            else
            {
                info(strFmt("@GLS70448", budgetPlanHeader.DocumentNumber));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new child <c>BudgetPlanGenerateService</c> class instance based upon the type of process as indicated by the <c>BudgetPlanGenerateContract</c> passed in.
    /// </summary>
    /// <param name="_contract">
    /// The contract for the <c>BudgetPlanGenerateService</c> child class to be created.
    /// </param>
    /// <returns>
    /// A <c>BudgetPlanGenerateService</c> child class instance.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown when a <paramref name="_contract"/> value is passed in that is not related to an expected child process.
    /// </exception>
    public static BudgetPlanGenerateService newFromContract(BudgetPlanGenerateContract _contract)
    {
        BudgetPlanGenerateService budgetPlanGenerateService;

        switch (classIdGet(_contract))
        {
            case classNum(BudgetPlanGenerateContractGenJour):
                budgetPlanGenerateService = BudgetPlanGenerateServiceGenJour::construct();
                break;

            case classNum(BudgetPlanGenerateContractBudgetPlan):
                budgetPlanGenerateService = BudgetPlanGenerateServiceBudgetPlan::construct();
                break;

            case classNum(BudgetPlanGenerateContractAsset):
                budgetPlanGenerateService = BudgetPlanGenerateServiceAsset::construct();
                break;

            case classNum(BudgetPlanGenerateContractHcm):
                budgetPlanGenerateService = BudgetPlanGenerateServiceHcm::construct();
                break;

            case classNum(BudgetPlanGenerateContractProjectForecast):
                budgetPlanGenerateService = BudgetPlanGenerateServiceProjectForecast::construct();
                break;

            case classNum(BudgetPlanGenerateContractDemandForecast):
                budgetPlanGenerateService = BudgetPlanGenerateServiceDemandForecast::construct();
                break;

            case classNum(BudgetPlanGenerateContractSupplyForecast):
                budgetPlanGenerateService = BudgetPlanGenerateServiceSupplyForecast::construct();
                break;

            case classNum(BudgetPlanGenerateContractBudgetTransaction):
                budgetPlanGenerateService = BudgetPlanGenerateServiceBudgetTransaction::construct();
                break;

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                BudgetPlanGenerateService::newFromContractDelegate(_contract, result);

                if (result.hasResult())
                {
                    budgetPlanGenerateService = result.result() as BudgetPlanGenerateService;
                }
                else
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
        }

        budgetPlanGenerateService.parmBudgetPlanGenerateContract(_contract);

        return budgetPlanGenerateService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromContractDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting a new instance of <c>BudgetPlanGenerateService</c>.
    /// </summary>
    /// <param name = "_contract">The <c>BudgetPlanGenerateContract</c> for the type of <c>BudgetPlanGenerateService</c> class to return.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>BudgetPlanGenerateService</c> object.</param>
    static delegate void newFromContractDelegate(BudgetPlanGenerateContract _contract, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the default account.
    /// </summary>
    /// <param name="_defaultAccount">
    /// The account to validate.
    /// </param>
    /// <param name="_postingType">
    /// The posting type.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The account number does not exist for the posting type.
    /// </exception>
    protected void validateDefaultAccount(LedgerDimensionDefaultAccount _defaultAccount, LedgerPostingType _postingType)
    {
        if (DimensionAttributeValueCombination::exist(_defaultAccount) == false)
        {
            throw error(strfmt("@SYS24816", _postingType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBudgetPlanLineEffectiveDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the date in the destination budget plan cycle base on the specified source budget cycle and base date.
    /// </summary>
    /// <param name="_sourceBudgetCycle">
    /// The source budget cycle.
    /// </param>
    /// <param name="_destinationBudgetCycle">
    /// The destination budget cycle.
    /// </param>
    /// <param name="_budgetPlanLineEffectiveDate">
    /// The Effective date from the Budget Plan Line record to calculate the new effective date.
    /// </param>
    /// <returns>
    /// The date from the destination budget cycle unless Historical is set to yes then returns the date from the source budget plan line.
    /// </returns>
    /// <remarks>
    /// It is assumed that it is being called after validateEquivalentBudgetCycles has returned true.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The value to aggregate by is invalid.
    /// </exception>
    protected BudgetPlanLineEffectiveDate calculateBudgetPlanLineEffectiveDate(BudgetCycle _sourceBudgetCycle, BudgetCycle _destinationBudgetCycle, date _budgetPlanLineEffectiveDate)
    {
        BudgetPlanLineEffectiveDate newBudgetPlanEffectiveDate;
        container                   fiscalYearStartEndDates;
        int                         diffInYears;
        date                        newDate;
        FiscalCalendarRecId         fiscalCalendarRecId;
        BudgetCycleTimeSpan         budgetCycleTimeSpan;
        BudgetCycle                 budgetCycle;
        BudgetPlanningProcess       budgetPlanningProcess;

        // Get the fiscal calendar for the target budget plan process
        select firstOnly fiscalCalendar from budgetCycleTimeSpan
            exists join budgetCycle
                where budgetCycle.BudgetCycleTimeSpan == budgetCycleTimeSpan.RecId
            exists join budgetPlanningProcess
                where budgetPlanningProcess.BudgetCycle == budgetCycle.RecId
                    && budgetPlanningProcess.RecId == budgetPlanGenerateContract.parmTargetBudgetPlanningProcess();

        fiscalCalendarRecId = budgetCycleTimeSpan.FiscalCalendar;

        // Create the date we will use to find the correct date later
        if (budgetPlanGenerateContract.parmTargetIsHistorical() == NoYes::Yes)
        {
            // If historical is set to yes we want to keep the original year
            newDate = _budgetPlanLineEffectiveDate;
        }
        else
        {
            // Find the difference in years between the source and destination budget cycles then add the amount to the year of the Effective date
            diffInYears = year(_destinationBudgetCycle.getStartDate()) - year(_sourceBudgetCycle.getStartDate());

            newDate = mkDate(this.switchFeb29toFeb28(_budgetPlanLineEffectiveDate), mthOfYr(_budgetPlanLineEffectiveDate), (year(_budgetPlanLineEffectiveDate) + diffInYears));
        }

        // Set the return value depending on what we are aggregating by
        switch (budgetPlanGenerateContract.parmTargetBudgetPlanGenerateAggregateBy())
        {
            case BudgetPlanGenerateAggregateBy::Day:
                newBudgetPlanEffectiveDate = newDate;
                break;

            case BudgetPlanGenerateAggregateBy::FiscalPeriod:
                newBudgetPlanEffectiveDate = LedgerFiscalCalendar::findPeriodStartDateByDate(fiscalCalendarRecId, newDate);
                break;

            case BudgetPlanGenerateAggregateBy::FiscalYear:
                fiscalYearStartEndDates = FiscalCalendars::findFiscalYearStartEndDatesByDate(fiscalCalendarRecId, newDate);
                newBudgetPlanEffectiveDate = conPeek(fiscalYearStartEndDates, 1);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Only check to see if the date is within the budget cycle if Historical is set to No
        if (budgetPlanGenerateContract.parmTargetIsHistorical() == NoYes::No && !_destinationBudgetCycle.isDateInBudgetCycle(newBudgetPlanEffectiveDate))
        {
            throw error(strFmt("@GLS70526", _destinationBudgetCycle.Name));
        }

        return newBudgetPlanEffectiveDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEquivalentBudgetCycles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the specified budget cycles based on the month and day of the start and end of the cycles and number of periods in the cycles.
    /// </summary>
    /// <param name="_sourceBudgetCycle">
    /// The source <c>BudgetCycle</c> record to compare.
    /// </param>
    /// <param name="_destinationBudgetCycle">
    /// The destination <c>BudgetCycle</c> record to compare.
    /// </param>
    /// <returns>
    /// true if the month and day for the start and end of the source and destination budget
    /// cycles match and the two budget cycles have the same number of periods; otherwise, false.
    /// </returns>
    /// <remarks>
    /// February 29 is equivalent to February 28 if it is the start or end date of the budget cycles being compared.
    /// </remarks>
    protected boolean validateEquivalentBudgetCycles(BudgetCycle _sourceBudgetCycle, BudgetCycle _destinationBudgetCycle)
    {
        BudgetCycleTimeSpan     sourceBudgetCycleTimeSpan, destinationBudgetCycleTimeSpan;
        BudgetNumberOfPeriods   sourceBudgetNumberOfPeriods, destinationBudgetNumberOfPeriods;
        FiscalCalendarRecId     fiscalCalendarRecId;
        FiscalPeriodStart       sourceStartDate = _sourceBudgetCycle.getStartDate();
        FiscalPeriodStart       destinationStartDate = _destinationBudgetCycle.getStartDate();
        FiscalPeriodEnd         sourceEndDate = _sourceBudgetCycle.getEndDate();
        FiscalPeriodEnd         destinationEndDate = _destinationBudgetCycle.getEndDate();

        //Get the Fiscal Calendar from the source budget cycle time span
        select FiscalCalendar from sourceBudgetCycleTimeSpan
            where sourceBudgetCycleTimeSpan.RecId == _sourceBudgetCycle.BudgetCycleTimeSpan;

        fiscalCalendarRecId = sourceBudgetCycleTimeSpan.FiscalCalendar;
        sourceBudgetNumberOfPeriods = BudgetCycleTimeSpan::calculateTotalPeriodsForFiscalCalendar(fiscalCalendarRecId);

        //Get the Fiscal Calendar from the destination budget cycle time span
        select FiscalCalendar from destinationBudgetCycleTimeSpan
            where destinationBudgetCycleTimeSpan.RecId == _destinationBudgetCycle.BudgetCycleTimeSpan;

        fiscalCalendarRecId = sourceBudgetCycleTimeSpan.FiscalCalendar;
        destinationBudgetNumberOfPeriods = BudgetCycleTimeSpan::calculateTotalPeriodsForFiscalCalendar(fiscalCalendarRecId);

        if (sourceBudgetNumberOfPeriods == destinationBudgetNumberOfPeriods
            && mthOfYr(sourceStartDate) == mthOfYr(destinationStartDate)
            && this.switchFeb29toFeb28(sourceStartDate) == this.switchFeb29toFeb28(destinationStartDate)
            && mthOfYr(sourceEndDate) == mthOfYr(destinationEndDate)
            && this.switchFeb29toFeb28(sourceEndDate) == this.switchFeb29toFeb28(destinationEndDate))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchFeb29toFeb28</Name>
				<Source><![CDATA[
    private Day switchFeb29toFeb28(Date _date)
    {
        if (mthOfYr(_date) == 2 && dayOfMth(_date) == 29)
        {
            return 28;
        }

        return dayOfMth(_date);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>