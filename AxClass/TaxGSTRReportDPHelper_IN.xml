<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxGSTRReportDPHelper_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Helper class for <c>TaxGSTRReportDP</c>
/// </summary>
public class TaxGSTRReportDPHelper_IN
{
    const str VendInvTDT  = 'General ledger - vendor invoice';
    const str CustPaymTDT = 'General ledger - customer payment';
    const str VendPaymTDT = 'General ledger - vendor payment';
    private const TaxComponent_IN IGST = 'IGST';

    private   TaxGSTRReportContractHeader_IN    taxGSTRReportContractHeader;
    private   boolean                           isForOfflineTool;
    private   boolean                           isAnx1;
    private   TmpTaxGSTRReportTaxLine_IN        tmpTaxGSTRReportTaxLine;
    protected TmpTaxGSTRReportTaxLineDetail_IN  tmpLineDetail;
    private   TaxGSTRReturnFilingMonth_IN       returnFilingMonth;
    private   TaxGSTRReturnFilingQuarter_IN     returnFilingQuarter;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(TaxGSTRReportDP_IN _dp)
    {
        taxGSTRReportContractHeader = _dp.parmTaxGSTRReportContractHeader();
        isForOfflineTool            = _dp.parmIsForOfflineTool();
        tmpTaxGSTRReportTaxLine     = _dp.parmTmpTaxGSTRReportTaxLine();
        isAnx1                      = _dp.parmIsNewOfflineTool();
        returnFilingMonth           = _dp.parmReturnFilingMonth();
        returnFilingQuarter         = _dp.parmReturnFilingQuarter();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillModelLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills in model lines
    /// </summary>
    /// <param name = "_fromDate">From date</param>
    /// <param name = "_toDate">To date</param>
    /// <param name = "_regNum">Registration number</param>
    /// <param name = "_taxDirection">Tax direction</param>
    public void fillModelLines(FromDate _fromDate, ToDate _toDate, TaxRegistrationNumber_IN _regNum, TaxDirection _taxDirection)
    {
        TaxDocumentComponentTransaction     taxDocumentComponentTransaction;
        TaxDocumentComponentTransaction_IN  taxDocumentComponentTransactionIn;
        RealBase                            settledInvoicePercent;
        RefTableId                          lastTransactionHeaderTableId;
        RefRecId                            lastTransactionHeaderRecId;
        #ISOCountryRegionCodes
        
        Map logisticsPostalAddressCacheMap                  = new Map(Types::Int64, Types::Record);
        Map logisticsAddressCountryRegionISOCodeCacheMap    = new Map(Types::String, Types::String);
        Map taxRegistrationNumbersCacheMap      = new Map(Types::Int64, Types::String);
        Map ecoResDescriptionCacheMap           = new Map(Types::String, Types::String);
        Map custVendNameCacheMap                = new Map(Types::Container, Types::String);
        Map taxComponentCacheMap                = new Map(Types::Int64, Types::String);
        Map unitWithDescriptionCacheMap         = new Map(Types::String, Types::String);
        Map eCommerceOperatorNameMap            = new Map(Types::String, Types::String);
        
        TaxDocumentRowTransaction               taxDocumentRowTransactionLocal;
        TaxDocumentRowTransaction_IN            taxDocumentRowTransactionInLocal;
        TaxDocumentExtension_IN                 taxDocumentExtensionInLocal;
        TaxDocumentExtension_IN                 taxDocumentExtensionRefInLocal;
        TaxDocumentExtension_IN                 taxDocumentExtensionRevisedOriginalLocal;

        this.prepareTrans(_fromDate, _toDate, _regNum, _taxDirection);

        while select tmpLineDetail
        {
            taxDocumentRowTransactionLocal.clear();
            taxDocumentRowTransactionLocal.RecId                    = tmpLineDetail.TaxDocumentRowTransactionRecId;
            taxDocumentRowTransactionLocal.BaseAmountCur            = tmpLineDetail.BaseAmountCur;
            taxDocumentRowTransactionLocal.CustVendAC               = tmpLineDetail.CustVendAC;
            TaxDocumentRowTransactionLocal.DiscountAmount           = tmpLineDetail.DiscountAmount;
            taxDocumentRowTransactionLocal.InvoiceId                = tmpLineDetail.InvoiceId;
            taxDocumentRowTransactionLocal.PartyPostalAddress       = tmpLineDetail.PartyPostalAddress;
            taxDocumentRowTransactionLocal.CompanyPostalAddress     = tmpLineDetail.CompanyPostalAddress;
            taxDocumentRowTransactionLocal.Source                   = tmpLineDetail.Source;
            taxDocumentRowTransactionLocal.TaxDirection             = tmpLineDetail.TaxDirection;
            taxDocumentRowTransactionLocal.TaxExemptTax             = tmpLineDetail.TaxExemptTax;
            taxDocumentRowTransactionLocal.TransactionDate          = tmpLineDetail.TransactionDate;
            taxDocumentRowTransactionLocal.TransactionLineRecId     = tmpLineDetail.TransactionLineRecId;
            taxDocumentRowTransactionLocal.TransactionLineTableId   = tmpLineDetail.TransactionLineTableId;
            taxDocumentRowTransactionLocal.Voucher                  = tmpLineDetail.Voucher;
            taxDocumentRowTransactionLocal.TransactionHeaderTableId = tmpLineDetail.TransactionHeaderTableId;
            taxDocumentRowTransactionLocal.TransactionHeaderRecId   = tmpLineDetail.TransactionHeaderRecId;

            taxDocumentRowTransactionInLocal.clear();
            taxDocumentRowTransactionInLocal.RecId                      = tmpLineDetail.TaxDocumentRowTransactionINRecId;
            taxDocumentRowTransactionInLocal.CustomsExportOrder         = tmpLineDetail.CustomsExportOrder;
            taxDocumentRowTransactionInLocal.CustomsImportOrder         = tmpLineDetail.CustomsImportOrder;
            taxDocumentRowTransactionInLocal.ECommerceOperatorGSTIN     = tmpLineDetail.ECommerceOperatorGSTIN;
            taxDocumentRowTransactionInLocal.PartyRegistrationNumber    = tmpLineDetail.PartyRegistrationNumber;
            taxDocumentRowTransactionInLocal.HSNCode                    = tmpLineDetail.HSNCode;
            taxDocumentRowTransactionInLocal.RefPartyRegistrationNumber = tmpLineDetail.RefPartyRegistrationNumber;
            taxDocumentRowTransactionInLocal.RegistrationNumber         = tmpLineDetail.RegistrationNumber;
            taxDocumentRowTransactionInLocal.SAC                        = tmpLineDetail.SAC;
            taxDocumentRowTransactionInLocal.TransCategory              = tmpLineDetail.TransCategory;
            taxDocumentRowTransactionInLocal.VendGSTCompositionScheme   = tmpLineDetail.VendGSTCompositionScheme;
            taxDocumentRowTransactionInLocal.WithIGSTPayment_IN         = tmpLineDetail.WithIGSTPayment_IN;
            taxDocumentRowTransactionInLocal.ECommerceSale_IN           = tmpLineDetail.ECommerceSale_IN;
            taxDocumentRowTransactionInLocal.ECommerceOperator_IN       = tmpLineDetail.ECommerceOperator_IN;
            taxDocumentRowTransactionInLocal.TaxGSTEPZCode_IN           = tmpLineDetail.TaxGSTEPZCode_IN;

            taxDocumentExtensionInLocal.clear();
            taxDocumentExtensionInLocal.RefTaxDocumentExtension         = tmpLineDetail.RefTaxDocumentExtensionRecId;
            taxDocumentExtensionInLocal.TaxTransactionDate              = tmpLineDetail.TaxTransactionDate;
            taxDocumentExtensionInLocal.TaxTransactionId                = tmpLineDetail.TaxTransactionId;
            taxDocumentExtensionInLocal.TaxTransactionRefType           = tmpLineDetail.TaxTransactionRefType;

            taxDocumentExtensionRefInLocal.clear();
            taxDocumentExtensionRefInLocal.RecId                        = tmpLineDetail.RefTaxDocumentExtensionRecId;
            taxDocumentExtensionRefInLocal.RefTaxDocumentExtension      = tmpLineDetail.OriginTaxDocumentExtensionRecId;
            taxDocumentExtensionRefInLocal.TaxTransactionDate           = tmpLineDetail.RefTaxTransactionDate;
            taxDocumentExtensionRefInLocal.TaxTransactionId             = tmpLineDetail.RefTaxTransactionId;
            taxDocumentExtensionRefInLocal.TaxTransactionRefType        = tmpLineDetail.RefTaxTransactionRefType;

            taxDocumentExtensionRevisedOriginalLocal.clear();
            taxDocumentExtensionRevisedOriginalLocal.RecId              = tmpLineDetail.OriginTaxDocumentExtensionRecId;
            taxDocumentExtensionRevisedOriginalLocal.TaxTransactionDate = tmpLineDetail.OriginTaxTransactionDate;
            taxDocumentExtensionRevisedOriginalLocal.TaxTransactionId   = tmpLineDetail.OriginTaxTransactionId;

            TaxGSTRReportContractLine_IN  taxGSTRReportContractLine = new TaxGSTRReportContractLine_IN();
            taxGSTRReportContractLine.parmTransCategory(tmpLineDetail.TransCategory);
            taxGSTRReportContractLine.parmTaxDirection(tmpLineDetail.TaxDirection);
            taxGSTRReportContractLine.parmServiceCategory(tmpLineDetail.ServiceCategory);
            taxGSTRReportContractLine.parmInventQty(tmpLineDetail.InventQuantity);
            taxGSTRReportContractLine.parmVoucher(tmpLineDetail.Voucher);
            taxGSTRReportContractLine.parmIsInterstateEnum(tmpLineDetail.IsInterState);
            taxGSTRReportContractLine.parmItemId(tmpLineDetail.ItemId);
            taxGSTRReportContractLine.parmGSTTransactionInNumSeq(tmpLineDetail.GSTTransactionInNumSeq);
            taxGSTRReportContractLine.parmIsExportOrderEnum(tmpLineDetail.CustomsExportOrder);
            taxGSTRReportContractLine.parmIsImportOrderEnum(tmpLineDetail.CustomsImportOrder);
            taxGSTRReportContractLine.parmIsDocumentCancelled(tmpLineDetail.IsDocumentCancelled);
            taxGSTRReportContractLine.parmWouldYouClaimRefundEnum(tmpLineDetail.WouldYouClaimRefund_IN);
            taxGSTRReportContractLine.parmReturnFilingMonth(returnFilingMonth);
            taxGSTRReportContractLine.parmReturnFilingQuarter(ReturnFilingQuarter);
            taxGSTRReportContractLine.parmItcEligibility(tmpLineDetail.ITCCategory);

            boolean isFirstInvoiceLine = false;
            if ((tmpLineDetail.TransactionHeaderTableId && lastTransactionHeaderTableId != tmpLineDetail.TransactionHeaderTableId)
                || (tmpLineDetail.TransactionHeaderRecId && lastTransactionHeaderRecId != tmpLineDetail.TransactionHeaderRecId))
            {
                isFirstInvoiceLine = true;
                lastTransactionHeaderTableId = tmpLineDetail.TransactionHeaderTableId;
                lastTransactionHeaderRecId   = tmpLineDetail.TransactionHeaderRecId;
            }

            taxGSTRReportContractLine.parmTotalTransactionValue(TaxGSTRReportUtil_IN::roundingTotalTransactionValue(tmpLineDetail.Source, abs(tmpLineDetail.TotalTransactionValue)));
            
            switch (tmpLineDetail.TransCategory)
            {
                // If the type is PaymentVoucher or RefundVoucher, we need filter the record again.
                case TaxTransactionCategory_IN::PaymentVoucher,
                     TaxTransactionCategory_IN::RefundVoucher:

                    // If this paynment is settlement fully, filter this row, and continous.
                    if (!taxGSTRReportContractLine.fillPayment(
                            taxDocumentRowTransactionLocal,
                            taxDocumentRowTransactionInLocal,
                            taxDocumentExtensionInLocal,
                            taxDocumentExtensionRefInLocal,
                            taxDocumentExtensionRevisedOriginalLocal,
                            _toDate,
                            isForOfflineTool))
                    {
                        continue;
                    }
                    break;

                // If the type is Credit/Debit note, find the original credit/debit note number and invoice's GST transaction id
                case TaxTransactionCategory_IN::CreditNote,
                     TaxTransactionCategory_IN::DebitNote:
                    // Revised invoice: transaction type = Revised, original transaction Id != '', and the original transaction Id of the original trans is empty.
                    if (taxDocumentExtensionInLocal.TaxTransactionRefType == TaxTransactionRefType_IN::Revised
                        && taxDocumentExtensionRefInLocal.TaxTransactionId
                        && !taxDocumentExtensionRevisedOriginalLocal.TaxTransactionId)
                    {
                        taxGSTRReportContractLine.parmTransCategory(TaxTransactionCategory_IN::GSTInvoice);
                        taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);
                        taxGSTRReportContractLine.parmOriginalInvoiceNumber(taxDocumentExtensionRefInLocal.TaxTransactionID);
                        taxGSTRReportContractLine.parmOriginalInvoiceDate(taxDocumentExtensionRefInLocal.TaxTransactionDate);
                    }
                    else
                    {
                        if (taxGSTRReportContractLine.parmIsImportOrderEnum())
                        {
                            taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);
                        }
                        taxGSTRReportContractLine.fillCreditDebitNote(taxDocumentExtensionInLocal, taxDocumentExtensionRefInLocal, isForOfflineTool);
                        taxGSTRReportContractLine.parmTypeOfInvoiceIsNoteLinkedTo(tmpLineDetail.TypeOfInvoiceIsNoteLinkedTo);
                    }
                    
                    if (isFirstInvoiceLine)
                    {
                        taxGSTRReportContractLine.fillSettlementForInvoiceUseBuffer(
                            taxDocumentRowTransactionLocal,
                            taxDocumentRowTransactionInLocal,
                            _fromDate,
                            _toDate,
                            taxGSTRReportContractHeader,
                            taxDocumentExtensionInLocal);
                        settledInvoicePercent = taxGSTRReportContractLine.getSettledByAdvacedPaymentPercentage();
                    }
                    else
                    {
                        taxGSTRReportContractLine.setSettledByAdvacedPaymentPercentage(settledInvoicePercent);
                    }

                    break;

                // If the type id Invoice, find the settlement GST transaction id
                case TaxTransactionCategory_IN::GSTInvoice:
                    taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);
                    taxGSTRReportContractLine.parmOriginalInvoiceNumber(taxDocumentExtensionRefInLocal.TaxTransactionID);
                    taxGSTRReportContractLine.parmOriginalInvoiceDate(taxDocumentExtensionRefInLocal.TaxTransactionDate);

                    if (isFirstInvoiceLine)
                    {
                        taxGSTRReportContractLine.fillSettlementForInvoiceUseBuffer(
                            taxDocumentRowTransactionLocal,
                            taxDocumentRowTransactionInLocal,
                            _fromDate,
                            _toDate,
                            taxGSTRReportContractHeader,
                            taxDocumentExtensionInLocal);
                        settledInvoicePercent = taxGSTRReportContractLine.getSettledByAdvacedPaymentPercentage();
                    }
                    else
                    {
                        taxGSTRReportContractLine.setSettledByAdvacedPaymentPercentage(settledInvoicePercent);
                    }
                    break;

                case TaxTransactionCategory_IN::BillOfSupply:

                    taxGSTRReportContractLine.parmIsBillOfSupplyEnum(NoYes::Yes);
                    // Maintaining the call for compatibilty.
                    taxGSTRReportContractLine.fillTypeOfSupply(taxDocumentRowTransactionLocal);
                    // Doing the real call.
                    taxGSTRReportContractLine.parmTypeOfBillOfSupplyEnum(tmpLineDetail.TypeOfBillOfSupply);

                    if (taxDocumentRowTransactionLocal.BaseAmountCur >= 0)
                    {
                        // If Original transaction id exists, this record is belong to Credit/Debt note.
                        if (taxDocumentExtensionInLocal.RefTaxDocumentExtension)
                        {
                            // Revised invoice
                            if (taxDocumentExtensionInLocal.TaxTransactionRefType == TaxTransactionRefType_IN::Revised
                                && taxDocumentExtensionRefInLocal.TaxTransactionId
                                && !taxDocumentExtensionRevisedOriginalLocal.TaxTransactionId)
                            {
                                taxGSTRReportContractLine.parmTransCategory(TaxTransactionCategory_IN::GSTInvoice);
                                taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);

                                taxGSTRReportContractLine.parmOriginalInvoiceNumber(taxDocumentExtensionRefInLocal.TaxTransactionID);
                                taxGSTRReportContractLine.parmOriginalInvoiceDate(taxDocumentExtensionRefInLocal.TaxTransactionDate);
                            }
                            else
                            {
                                taxGSTRReportContractLine.parmTransCategory(TaxTransactionCategory_IN::DebitNote);
                                taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);
                                taxGSTRReportContractLine.fillCreditDebitNote(taxDocumentExtensionInLocal, taxDocumentExtensionRefInLocal, isForOfflineTool);
                                taxGSTRReportContractLine.parmTypeOfInvoiceIsNoteLinkedTo(tmpLineDetail.TypeOfInvoiceIsNoteLinkedTo);
                            }
                        }
                        else
                        {
                            taxGSTRReportContractLine.parmTransCategory(TaxTransactionCategory_IN::GSTInvoice);
                            taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);

                            taxGSTRReportContractLine.parmOriginalInvoiceNumber(taxDocumentExtensionRefInLocal.TaxTransactionID);
                            taxGSTRReportContractLine.parmOriginalInvoiceDate(taxDocumentExtensionRefInLocal.TaxTransactionDate);
                        }
                    }
                    else
                    {
                        taxGSTRReportContractLine.parmTransCategory(TaxTransactionCategory_IN::CreditNote);
                        taxGSTRReportContractLine.fillFromOrder(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);
                        taxGSTRReportContractLine.fillCreditDebitNote(taxDocumentExtensionInLocal, taxDocumentExtensionRefInLocal, isForOfflineTool);
                        taxGSTRReportContractLine.parmTypeOfInvoiceIsNoteLinkedTo(tmpLineDetail.TypeOfInvoiceIsNoteLinkedTo);
                    }
                    
                    if (isFirstInvoiceLine)
                    {
                        taxGSTRReportContractLine.fillSettlementForInvoiceUseBuffer(
                            taxDocumentRowTransactionLocal,
                            taxDocumentRowTransactionInLocal,
                            _fromDate,
                            _toDate,
                            taxGSTRReportContractHeader,
                            taxDocumentExtensionInLocal);
                        settledInvoicePercent = taxGSTRReportContractLine.getSettledByAdvacedPaymentPercentage();
                    }
                    else
                    {
                        taxGSTRReportContractLine.setSettledByAdvacedPaymentPercentage(settledInvoicePercent);
                    }
                    break;

                default :
                    break;
            }

            LogisticsPostalAddress partyPostalAddress;
            if (logisticsPostalAddressCacheMap.exists(taxDocumentRowTransactionLocal.PartyPostalAddress))
            {
                partyPostalAddress = logisticsPostalAddressCacheMap.lookup(taxDocumentRowTransactionLocal.PartyPostalAddress);
            }
            else
            {
                partyPostalAddress = LogisticsPostalAddress::findRecId(taxDocumentRowTransactionLocal.PartyPostalAddress);
                logisticsPostalAddressCacheMap.insert(taxDocumentRowTransactionLocal.PartyPostalAddress, partyPostalAddress);
            }

            LogisticsPostalAddress companyPostalAddress;
            if (logisticsPostalAddressCacheMap.exists(taxDocumentRowTransactionLocal.CompanyPostalAddress))
            {
                companyPostalAddress = logisticsPostalAddressCacheMap.lookup(taxDocumentRowTransactionLocal.CompanyPostalAddress);
            }
            else
            {
                companyPostalAddress = LogisticsPostalAddress::findRecId(taxDocumentRowTransactionLocal.CompanyPostalAddress);
                logisticsPostalAddressCacheMap.insert(taxDocumentRowTransactionLocal.CompanyPostalAddress, companyPostalAddress);
            }

            LogisticsAddressCountryRegionISOCode logisticsAddressCountryRegionISOCode;
            if (logisticsAddressCountryRegionISOCodeCacheMap.exists(partyPostalAddress.CountryRegionId))
            {
                logisticsAddressCountryRegionISOCode = logisticsAddressCountryRegionISOCodeCacheMap.lookup(partyPostalAddress.CountryRegionId);
            }
            else
            {
                logisticsAddressCountryRegionISOCode = LogisticsAddressCountryRegion::find(partyPostalAddress.CountryRegionId).isOcode;
                logisticsAddressCountryRegionISOCodeCacheMap.insert(partyPostalAddress.CountryRegionId, logisticsAddressCountryRegionISOCode);
            }

            TaxRegistrationNumber_IN taxRegistrationNumber;
            if (taxRegistrationNumbersCacheMap.exists(taxDocumentRowTransactionInLocal.ECommerceOperatorGSTIN))
            {
                taxRegistrationNumber = taxRegistrationNumbersCacheMap.lookup(taxDocumentRowTransactionInLocal.ECommerceOperatorGSTIN);
            }
            else
            {
                taxRegistrationNumber = TaxRegistrationNumbers_IN::find(taxDocumentRowTransactionInLocal.ECommerceOperatorGSTIN).RegistrationNumber;
                taxRegistrationNumbersCacheMap.insert(taxDocumentRowTransactionInLocal.ECommerceOperatorGSTIN, taxRegistrationNumber);
            }
            
            DirPartyName eCommerceOperatorName;
            if (eCommerceOperatorNameMap.exists(taxDocumentRowTransactionInLocal.ECommerceOperator_IN))
            {
                eCommerceOperatorName = eCommerceOperatorNameMap.lookup(taxDocumentRowTransactionInLocal.ECommerceOperator_IN);
            }
            else
            {
                eCommerceOperatorName = CustTable::find(taxDocumentRowTransactionInLocal.ECommerceOperator_IN).name();
                eCommerceOperatorNameMap.insert(taxDocumentRowTransactionInLocal.ECommerceOperator_IN, eCommerceOperatorName);
            }

            EcoResDescription ecoResDescription;
            if (!tmpLineDetail.ItemId)
            {
                ecoResDescription = tmpLineDetail.ItemDescription;
            }
            else if (ecoResDescriptionCacheMap.exists(tmpLineDetail.ItemId))
            {
                ecoResDescription = ecoResDescriptionCacheMap.lookup(tmpLineDetail.ItemId);
            }
            else
            {
                ecoResDescription = InventTable::find(tmpLineDetail.ItemId).itemDescriptionOrName();
                ecoResDescriptionCacheMap.insert(tmpLineDetail.ItemId, ecoResDescription);
            }

            DirPartyName custVendName;
            if (custVendNameCacheMap.exists([tmpLineDetail.TaxDirection, tmpLineDetail.CustVendAC]))
            {
                custVendName = custVendNameCacheMap.lookup([tmpLineDetail.TaxDirection, tmpLineDetail.CustVendAC]);
            }
            else
            {
                if (tmpLineDetail.TaxDirection == TaxDirection::OutgoingTax)
                {
                    custVendName = CustTable::find(tmpLineDetail.CustVendAC).name();
                }
                else if (tmpLineDetail.TaxDirection == TaxDirection::IncomingTax)
                {
                    custVendName = VendTable::find(tmpLineDetail.CustVendAC).name();
                }
                custVendNameCacheMap.insert([tmpLineDetail.TaxDirection, tmpLineDetail.CustVendAC], custVendName);
            }

            Description unitwithDescription;
            if(unitWithDescriptionCacheMap.exists(tmpLineDetail.UnitOfMeasure))
            {
                unitwithDescription = unitWithDescriptionCacheMap.lookup(tmpLineDetail.UnitOfMeasure);
            }
            else
            {
                Description    description;
                description =  this.getUnit(tmpLineDetail.UnitOfMeasure).Description;
                if(description)
                {
                    unitwithDescription = strFmt("%1-%2", tmpLineDetail.UnitOfMeasure, description);
                }
                else
                {
                    unitwithDescription = strFmt("%1", tmpLineDetail.UnitOfMeasure);
                }
                unitWithDescriptionCacheMap.insert(tmpLineDetail.UnitOfMeasure, unitwithDescription);
            }

            taxGSTRReportContractLine.parmInvoiceNumber(taxDocumentExtensionInLocal.TaxTransactionId);
            taxGSTRReportContractLine.parmInvoiceId(taxDocumentRowTransactionLocal.InvoiceId);
            taxGSTRReportContractLine.parmVoucher(taxDocumentRowTransactionLocal.Voucher);
            taxGSTRReportContractLine.parmInvoiceDate(taxDocumentExtensionInLocal.TaxTransactionDate);
            taxGSTRReportContractLine.parmCompanyRegNumber(taxDocumentRowTransactionInLocal.RegistrationNumber);
            taxGSTRReportContractLine.parmReasonComment(ReasonTableRef::find(tmpLineDetail.ReasonTableRef).ReasonComment);
            taxGSTRReportContractLine.parmIsSupplierCompositionDealer(taxDocumentRowTransactionInLocal.VendGSTCompositionScheme);
            taxGSTRReportContractLine.parmCustVendAddress(partyPostalAddress.Address);
            taxGSTRReportContractLine.parmCustVendIsoCode(logisticsAddressCountryRegionISOCode);
            taxGSTRReportContractLine.parmCustVendCity(partyPostalAddress.City);
            taxGSTRReportContractLine.parmCustVendState(partyPostalAddress.State);
            taxGSTRReportContractLine.parmEPZCode(taxDocumentRowTransactionInLocal.TaxGSTEPZCode_IN);

            if ((tmpLineDetail.TaxDirection == TaxDirection::IncomingTax && !this.isCreditNote(tmpLineDetail, taxDocumentRowTransactionLocal)) ||
                (tmpLineDetail.TaxDirection == TaxDirection::OutgoingTax && this.isCreditNote(tmpLineDetail, taxDocumentRowTransactionLocal)))
            {
                taxGSTRReportContractLine.parmPlaceOfSupply(companyPostalAddress.State);
            }
            else
            {
                taxGSTRReportContractLine.parmPlaceOfSupply(partyPostalAddress.State);
            }
            taxGSTRReportContractLine.parmGstin(taxDocumentRowTransactionInLocal.PartyRegistrationNumber);
            taxGSTRReportContractLine.parmGstinEcommerce(taxRegistrationNumber);
            taxGSTRReportContractLine.parmECommerceOperatorName(eCommerceOperatorName);
            taxGSTRReportContractLine.parmIsECommerceEnum(taxDocumentRowTransactionInLocal.ECommerceSale_IN && taxRegistrationNumber && eCommerceOperatorName);
            taxGSTRReportContractLine.parmOriginalGstin(taxDocumentRowTransactionInLocal.RefPartyRegistrationNumber);
            taxGSTRReportContractLine.parmItemDescription(ecoResDescription);
            taxGSTRReportContractLine.parmQuantity(tmpLineDetail.Quantity);
            taxGSTRReportContractLine.parmUnitOfMeasure(unitwithDescription);
            taxGSTRReportContractLine.parmCustVendAccount(custVendName);
            taxGSTRReportContractLine.parmItemRate(TaxGSTRReportUtil_IN::getItemRate(tmpLineDetail));

            taxGSTRReportContractLine.fillCustVendName(taxDocumentRowTransactionLocal);
            taxGSTRReportContractLine.fillHSNSACCodeFromRowTransaction(taxDocumentRowTransactionInLocal);
            taxGSTRReportContractLine.parmIsAnx1(isAnx1);
            taxGSTRReportContractLine.fillExportImport(taxDocumentRowTransactionLocal, taxDocumentRowTransactionInLocal);

            NoYes isReverseCharge = NoYes::No;
            
            if (!taxGSTRReportContractLine.parmUnsettledPaymentPercent())
            {
                taxGSTRReportContractLine.parmUnsettledPaymentPercent(1.00);
            }

            taxGSTRReportContractLine.parmTotalItemDiscountAmount(CurrencyExchangeHelper::amount(taxDocumentRowTransactionLocal.DiscountAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
            taxGSTRReportContractLine.parmTaxableValue(CurrencyExchangeHelper::amount(tmpLineDetail.BaseAmountMST * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));

            this.fillModelLineExtension(taxGSTRReportContractLine, tmpLineDetail);

            taxDocumentComponentTransaction.clear();

            while select taxDocumentComponentTransaction
                where taxDocumentComponentTransaction.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
                join taxDocumentComponentTransactionIn
                    where taxDocumentComponentTransactionIn.TaxDocumentComponnetTransactionRecId == taxDocumentComponentTransaction.RecId
            {
                if (taxDocumentComponentTransactionIn.TotalReverseChargeAmount
                    || (tmpLineDetail.TaxDirection == TaxDirection::IncomingTax
                    && ((!taxDocumentRowTransactionInLocal.PartyRegistrationNumber && taxDocumentComponentTransactionIN.ReverseChargePercentage)
                        || taxDocumentComponentTransaction.TotalTaxPayableAmount)))
                {
                    isReverseCharge = NoYes::Yes;
                }

                TaxComponent_IN taxComponentIn;
                if (taxComponentCacheMap.exists(taxDocumentComponentTransactionIn.TaxComponent))
                {
                    taxComponentIn = taxComponentCacheMap.lookup(taxDocumentComponentTransactionIn.TaxComponent);
                }
                else
                {
                    taxComponentIn = TaxComponentTable_IN::find(taxDocumentComponentTransactionIn.TaxComponent).Component;
                    taxComponentCacheMap.insert(taxDocumentComponentTransactionIn.TaxComponent, taxComponentIn);
                }

                taxGSTRReportContractLine.parmTaxComponent(taxComponentIn);

                if (tmpLineDetail.TaxDirection == TaxDirection::OutgoingTax)
                {
                    if (taxDocumentRowTransactionInLocal.CustomsExportOrder == NoYes::Yes)
                    {
                        taxGSTRReportContractLine.parmTaxAmount(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TaxAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
                    }
                    else
                    {
                        taxGSTRReportContractLine.parmTaxAmount(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TotalTaxPayableAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
                    }
                }
                else
                {
                    if (taxDocumentRowTransactionInLocal.TransCategory == TaxTransactionCategory_IN::PaymentVoucher || taxDocumentRowTransactionInLocal.TransCategory == TaxTransactionCategory_IN::RefundVoucher)
                    {
                        taxGSTRReportContractLine.parmTaxAmount(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TotalTaxPayableAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
                    }
                    else
                    {
                        taxGSTRReportContractLine.parmTaxAmount(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TaxAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
                    }
                }
                taxGSTRReportContractLine.parmTaxRate(taxDocumentComponentTransaction.TaxRate * 100);
                taxGSTRReportContractLine.parmApplicableRate(taxDocumentComponentTransaction.ApplicablePercentageOfTax * 100);
                taxGSTRReportContractLine.parmRecoverableAmount(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TotalTaxRecoverableAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));

                if (tmpLineDetail.IsDocumentCancelled)
                {
                    taxGSTRReportContractLine.parmTaxAmount(0);
                }

                taxGSTRReportContractLine.fillGSTAmounts();

                //The taxable value of IGST should include custom duty, which is different from line base amount.
                if (taxGSTRReportContractLine.parmTaxComponent() == IGST)
                {
                    taxGSTRReportContractLine.parmTaxableValue(CurrencyExchangeHelper::amount(taxDocumentComponentTransaction.TaxBaseAmount * taxGSTRReportContractLine.parmUnsettledPaymentPercent()));
                }

                this.fillModelLineFromTaxCompTransExtension(
                    taxGSTRReportContractLine, 
                    tmpLineDetail,
                    taxDocumentComponentTransaction, 
                    taxDocumentComponentTransactionIn);
            }

            taxGSTRReportContractLine.fillAdvanceForBillOfSupply();

            if (tmpLineDetail.TaxDirection == TaxDirection::IncomingTax
                && taxDocumentRowTransactionInLocal.HSNCode
                && taxDocumentRowTransactionInLocal.CustomsImportOrder == NoYes::Yes)
            {
                isReverseCharge = NoYes::No;
            }
            taxGSTRReportContractLine.parmIsReverseCharge(isReverseCharge);
            taxGSTRReportContractLine.fillITCAvailabilityType();
            taxGSTRReportContractLine.fillSupplyCoveredUnderSec7(LogisticsAddressCountryRegion::find(companyPostalAddress.CountryRegionId).ISOcode != #isoIN);
            
            if (isForOfflineTool && !tmpLineDetail.IsDocumentCancelled)
            {
                taxGSTRReportContractLine.fillPlaceOfSupplyLongForm(partyPostalAddress);

                tmpTaxGSTRReportTaxLine.clear();
                tmpTaxGSTRReportTaxLine.initFromModelClass(taxGSTRReportContractLine);
                this.updateTaxableValueForEcommerceReport(tmpTaxGSTRReportTaxLine);
                tmpTaxGSTRReportTaxLine.insert();
            }
            else
            {
                taxGSTRReportContractHeader.addLine(taxGSTRReportContractLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepare transactions
    /// </summary>
    /// <param name = "_fromDate">From date</param>
    /// <param name = "_toDate">To date</param>
    /// <param name = "_regNum">Registration number</param>
    /// <param name = "_taxDirection">Tax direction</param>
    protected void prepareTrans(FromDate _fromDate, ToDate _toDate, TaxRegistrationNumber_IN _regNum, TaxDirection _taxDirection)
    {
        this.queryTrans(_fromDate, _toDate, _regNum, _taxDirection);
        this.filterTrans();
        this.updateTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Query out the transactions to be printed to the report
    /// </summary>
    /// <param name = "_fromDate">From date</param>
    /// <param name = "_toDate">To date</param>
    /// <param name = "_regNum">Registration number</param>
    /// <param name = "_taxDirection">Tax direction</param>
    protected void queryTrans(FromDate _fromDate, ToDate _toDate, TaxRegistrationNumber_IN _regNum, TaxDirection _taxDirection)
    {
        TaxDocumentExtension_IN             taxDocumentExtensionIn;
        TaxDocumentExtension_IN             taxDocumentExtensionRefIn;
        TaxDocumentExtension_IN             taxDocumentExtensionRevisedOriginal;
        TaxDocumentRowTransaction           taxDocumentRowTransaction;
        TaxDocumentRowTransaction_IN        taxDocumentRowTransactionIn;
        
        Map logisticsPostalAddressCacheMap                  = new Map(Types::Int64, Types::Record);
        Map logisticsAddressCountryRegionISOCodeCacheMap    = new Map(Types::String, Types::String);
        Map taxRegistrationNumbersCacheMap      = new Map(Types::Int64, Types::String);
        Map ecoResDescriptionCacheMap           = new Map(Types::String, Types::String);
        Map custVendNameCacheMap                = new Map(Types::Container, Types::String);
        Map taxComponentCacheMap                = new Map(Types::Int64, Types::String);
        TaxDocumentRowTransaction               originTaxDocumentRowTransaction;
        TaxDocumentRowTransaction_IN            originTaxDocumentRowTransactionIn;

        LedgerJournalTable                      ledgerJournalTableInvApp, ledgerJournalTableInvReg;
        LedgerJournalTrans                      ledgerJournalTransInvApp, ledgerJournalTransInvReg;

        insert_recordset tmpLineDetail(
            TaxDocumentRowTransactionRecId, CustVendAC, ItemId, Quantity, InventQuantity,
            UnitOfMeasure, UnitPrice, TransactionCurrency, TransactionDate, Voucher, TaxDirection, ReasonTableRef,
            PartyPostalAddress,CompanyPostalAddress, DiscountAmount, BaseAmountMST, Source, InvoiceId, TaxExemptTax, BaseAmountCur,
            TransactionHeaderTableId, TransactionHeaderRecId, TransactionLineTableId, TransactionLineRecId,
            TransactionJourHeaderTableId, TransactionJourHeaderRecId, TransactionJourLineTableId, TransactionJourLineRecId,
            TaxDocumentRowTransactionINRecId, TransCategory, ServiceCategory, IsInterState, PartyRegistrationNumber, CustomsExportOrder,
            CustomsImportOrder, WithIGSTPayment_IN, HSNCode, SAC, RefPartyRegistrationNumber, VendGSTCompositionScheme,
            RegistrationNumber, ECommerceOperatorGSTIN, TaxDocumentExtensionRecId, NonGST,
            ECommerceSale_IN, ECommerceOperator_IN, WouldYouClaimRefund_IN, TaxGSTEPZCode_IN, ITCCategory)
        select forceliterals RecId, CustVendAC, ItemId, Qty, InventQty,
            UnitOfMeasureSymbol, UnitPrice, TransactionCurrency, TransactionDate, Voucher, TaxDirection, ReasonTableRef,
            PartyPostalAddress, CompanyPostalAddress, DiscountAmount, BaseAmountMST, Source, InvoiceId, TaxExemptTax, BaseAmountCur,
            TransactionHeaderTableId, TransactionHeaderRecId,  TransactionLineTableId, TransactionLineRecId,
            TransactionJourHeaderTableId, TransactionJourHeaderRecId, TransactionJourLineTableId, TransactionJourLineRecId
            from taxDocumentRowTransaction
            where taxDocumentRowTransaction.TransactionDate    >= _fromDate
                && taxDocumentRowTransaction.TransactionDate   <= _toDate
                && taxDocumentRowTransaction.TaxDocumentStatus != TaxDocumentStatus::Reversed
                && taxDocumentRowTransaction.TaxDocumentStatus != TaxDocumentStatus::Transferred
                && (taxDocumentRowTransaction.TransactionHeaderTableId != tableNum(TaxEngineTaxJournal)
                    || taxDocumentRowTransaction.TransactionLineTableId != tableNum(TaxEngineTaxJournalLine))
                && (isAnx1 == true
                    || (_taxDirection == TaxDirection::OutgoingTax
                        && ((taxDocumentRowTransaction.TaxDirection == TaxDirection::OutgoingTax
                                && taxDocumentRowTransaction.Source   != TaxModuleType::PurchInvoice)
                            || (taxDocumentRowTransaction.TaxDirection == TaxDirection::IncomingTax
                                && taxDocumentRowTransaction.Source == TaxModuleType::SalesInvoice)))
                    || (_taxDirection == TaxDirection::IncomingTax
                        && ((taxDocumentRowTransaction.TaxDirection == TaxDirection::IncomingTax
                                && taxDocumentRowTransaction.Source   != TaxModuleType::SalesInvoice)
                            || (taxDocumentRowTransaction.TaxDirection == TaxDirection::OutgoingTax
                                && taxDocumentRowTransaction.Source == TaxModuleType::PurchInvoice))))
            join RecId, TransCategory, ServiceCategory, IsInterState, PartyRegistrationNumber, CustomsExportOrder,
                CustomsImportOrder, WithIGSTPayment_IN, HSNCode, SAC, RefPartyRegistrationNumber, VendGSTCompositionScheme,
                RegistrationNumber, ECommerceOperatorGSTIN, TaxDocumentExtension, NonGST,
                ECommerceSale_IN, ECommerceOperator_IN, WouldYouClaimRefund_IN, TaxGSTEPZCode_IN, ITCCategory
                from taxDocumentRowTransactionIn
                where taxDocumentRowTransactionIn.TaxDocumentRowTransactionRecId == taxDocumentRowTransaction.RecId
                    && (!_regNum || taxDocumentRowTransactionIn.RegistrationNumber == _regNum);

        update_recordset tmpLineDetail
            setting TaxTransactionId = taxDocumentExtensionIn.TaxTransactionId,
                    TaxTransactionDate = taxDocumentExtensionIn.TaxTransactionDate,
                    GSTTransactionInNumSeq = taxDocumentExtensionIn.GSTTransactionInNumSeq,
                    TaxableDocumentType = taxDocumentExtensionIn.TaxableDocumentType,
                    RefTaxDocumentExtensionRecId = taxDocumentExtensionIn.RefTaxDocumentExtension,
                    TaxTransactionRefType = taxDocumentExtensionIn.TaxTransactionRefType
            join taxDocumentExtensionIn
                where taxDocumentExtensionIn.RecId == tmpLineDetail.TaxDocumentExtensionRecId;

        update_recordset tmpLineDetail
            setting RefTaxDocumentRowTransactionRecId = originTaxDocumentRowTransactionIn.TaxDocumentRowTransactionRecId
            join TaxDocumentRowTransactionRecId from originTaxDocumentRowTransactionIn
                where originTaxDocumentRowTransactionIn.TaxDocumentExtension == tmpLineDetail.RefTaxDocumentExtensionRecId;
                
        update_recordset tmpLineDetail
            setting RefTaxTransactionId = taxDocumentExtensionRefIn.TaxTransactionId,
                    RefTaxTransactionDate = taxDocumentExtensionRefIn.TaxTransactionDate,
                    RefTaxTransactionRefType = taxDocumentExtensionRefIn.TaxTransactionRefType,
                    OriginTaxDocumentExtensionRecId = taxDocumentExtensionRefIn.RefTaxDocumentExtension
            join  taxDocumentExtensionRefIn
                where taxDocumentExtensionRefIn.RecId == tmpLineDetail.RefTaxDocumentExtensionRecId;

        update_recordset tmpLineDetail
            setting OriginTaxTransactionId = taxDocumentExtensionRevisedOriginal.TaxTransactionId,
                    OriginTaxTransactionDate = taxDocumentExtensionRevisedOriginal.TaxTransactionDate
            join taxDocumentExtensionRevisedOriginal
                where taxDocumentExtensionRevisedOriginal.RecId == tmpLineDetail.OriginTaxDocumentExtensionRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters transactions
    /// </summary>
    protected void filterTrans()
    {
        this.filterLedgerJournalTransInvoiceApproval();
        this.filterTaxJournalTrans();
        this.filterShouldSkipForGSTRReporting();
        this.filterTransferOrderCancellation();
        this.filterPackingSlipTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterTransferOrderCancellation</Name>
				<Source><![CDATA[
    private void filterTransferOrderCancellation()
    {
        InventTransferJour      inventTransferJour, inventTransferJourCancelled;
        LedgerJournalTrans      ledgerJournalTransInvApp, ledgerJournalTransInvReg;
        TmpTaxGSTRReportTaxLineDetail_IN originalTmpTaxGSTRReportTaxLine;
        originalTmpTaxGSTRReportTaxLine.linkPhysicalTableInstance(tmpLineDetail);

        update_recordset originalTmpTaxGSTRReportTaxLine
            setting IsDocumentCancelled = NoYes::Yes
            exists join inventTransferJourCancelled
                 where originalTmpTaxGSTRReportTaxLine.TransactionJourHeaderTableId == tableNum(InventTransferJour)
                    && originalTmpTaxGSTRReportTaxLine.TransactionJourHeaderRecId == inventTransferJourCancelled.RecId
            exists join inventTransferJour
                where inventTransferJour.CanceledShipmentJournalRecId == inventTransferJourCancelled.RecId
            exists join tmpLineDetail
                where tmpLineDetail.TransactionJourHeaderRecId == inventTransferJour.RecId
                    && tmpLineDetail.TransactionJourHeaderTableId == tableNum(InventTransferJour);

        delete_from tmpLineDetail
            exists join inventTransferJour
                where tmpLineDetail.TransactionJourHeaderRecId == inventTransferJour.RecId
                    && tmpLineDetail.TransactionJourHeaderTableId == tableNum(InventTransferJour)
                    && inventTransferJour.CanceledShipmentJournalRecId != 0
                    && inventTransferJour.UpdateType == InventTransferUpdateType::Shipment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterLedgerJournalTransInvoiceApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters LedgerJournalTransInvoiceApproval records
    /// </summary>
    private void filterLedgerJournalTransInvoiceApproval()
    {
        LedgerJournalTable      ledgerJournalTableInvApp, ledgerJournalTableInvReg;
        LedgerJournalTrans      ledgerJournalTransInvApp, ledgerJournalTransInvReg;

        update_recordset tmpLineDetail
            setting ledgerJournalTransInvAppRecId = ledgerJournalTransInvApp.RecId
            join RecId from ledgerJournalTransInvApp
                where ledgerJournalTransInvApp.RecId == tmpLineDetail.TransactionLineRecId
                    && tmpLineDetail.TaxableDocumentType == VendInvTDT
                    && tmpLineDetail.TransactionHeaderTableId == tableNum(TaxEngineLedgerJournalTransHeader)
                    && tmpLineDetail.TransactionLineTableId == tableNum(LedgerJournalTrans)
                exists join ledgerJournalTableInvApp
                    where ledgerJournalTableInvApp.JournalNum == ledgerJournalTransInvApp.JournalNum
                        && ledgerJournalTableInvApp.JournalType == LedgerJournalType::Approval
                exists join ledgerJournalTransInvReg
                    where ledgerJournalTransInvReg.Invoice == ledgerJournalTransInvApp.Invoice
                        && ledgerJournalTransInvReg.Voucher == ledgerJournalTransInvApp.Voucher
                        && ledgerJournalTransInvReg.JournalNum != ledgerJournalTransInvApp.JournalNum
                    exists join ledgerJournalTableInvReg
                        where ledgerJournalTableInvReg.JournalNum == ledgerJournalTransInvReg.JournalNum
                            && ledgerJournalTableInvReg.JournalType == LedgerJournalType::PurchaseLedger;

        // Filter invoice approval journals
        delete_from tmpLineDetail where tmpLineDetail.ledgerJournalTransInvAppRecId > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterShouldSkipForGSTRReporting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters transactions that should be skipped for GSTR reporting
    /// </summary>
    protected void filterShouldSkipForGSTRReporting()
    {
        TaxDocumentComponentTransaction taxDocumentComponentTransactionLoc;
        /*
            There are scenarios that the entries need to be included into the GSTR report even though there is no tax.
                1. TaxExemptTax is set to Yes.
                2. NonGST is set to Yes.
                3. VendGSTCompostionScheme is set to Yes.
                4. It is export order and with tax payment is set to No.
            For entry matching these scenarios, don't delete the entry from the table.
        */
        delete_from tmpLineDetail
            where tmpLineDetail.TaxExemptTax == NoYes::No
                && tmpLineDetail.NonGST == NoYes::No
                && tmpLineDetail.VendGSTCompositionScheme == NoYes::No
                && !(tmpLineDetail.CustomsExportOrder == NoYes::Yes
                    && tmpLineDetail.WithIGSTPayment_IN == NoneNoYes_IN::No)
            notexists join taxDocumentComponentTransactionLoc
                where taxDocumentComponentTransactionLoc.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterTaxJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters tax journal transations
    /// </summary>
    protected void filterTaxJournalTrans()
    {
        delete_from tmpLineDetail
            where tmpLineDetail.TransactionHeaderTableId  == tableNum(TaxEngineTaxJournal)
                && tmpLineDetail.TransactionLineTableId == tableNum(TaxEngineTaxJournalLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterPackingSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters packing slip transations
    /// </summary>
    protected void filterPackingSlipTrans()
    {
        delete_from tmpLineDetail
            where tmpLineDetail.TransactionJourHeaderTableId == tableNum(VendPackingSlipJour)
                && tmpLineDetail.TransactionJourLineTableId == tableNum(VendPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update transactions
    /// </summary>
    protected void updateTrans()
    {
        this.updateTotalTransactionValue();
        this.updateTypeOfInvoice();
        this.updateItemDescription();
        this.updateSumTaxAmoutForGST();
        this.updateTypeOfBillOfSupplyEnum();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSumTaxAmoutForGST</Name>
				<Source><![CDATA[
    private void updateSumTaxAmoutForGST()
    {
        TaxDocumentComponentTransaction componentTrans;
        TaxTable taxTable;

        update_recordset tmpLineDetail
             setting TotalTaxAmountForGST = componentTrans.TaxAmount
             join sum(TaxAmount) from componentTrans
                where componentTrans.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
             exists join taxTable
                where taxTable.TaxCode == componentTrans.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::GST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTypeOfBillOfSupplyEnum</Name>
				<Source><![CDATA[
    private void updateTypeOfBillOfSupplyEnum()
    {
        update_recordset tmpLineDetail
            setting TypeOfBillOfSupply = TaxTypeOfBillOfSupply_IN::Exempted
                where tmpLineDetail.TransCategory == TaxTransactionCategory_IN::BillOfSupply
                    && tmpLineDetail.TaxExemptTax == NoYes::Yes;

        TaxDocumentComponentTransaction componentTrans;
        TaxTable taxTable;
        update_recordset tmpLineDetail
            setting TypeOfBillOfSupply = TaxTypeOfBillOfSupply_IN::NilRated
                where tmpLineDetail.TransCategory == TaxTransactionCategory_IN::BillOfSupply
                    && tmpLineDetail.TaxExemptTax == NoYes::No
                    && tmpLineDetail.TotalTaxAmountForGST == 0
            join TaxDocumentRowTransactionRecId from componentTrans
                where componentTrans.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
            exists join taxTable
                where taxTable.TaxCode == componentTrans.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::GST;

        update_recordset tmpLineDetail
            setting TypeOfBillOfSupply = TaxTypeOfBillOfSupply_IN::NonGST
                where tmpLineDetail.TransCategory == TaxTransactionCategory_IN::BillOfSupply
                    && tmpLineDetail.TaxExemptTax == NoYes::No
                notexists join TaxDocumentRowTransactionRecId from componentTrans
                    where componentTrans.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
                exists join taxTable
                    where taxTable.TaxCode == componentTrans.TaxCode
                        && taxTable.TaxType_IN == TaxType_IN::GST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemDescription</Name>
				<Source><![CDATA[
    private void updateItemDescription()
    {
        CustInvoiceTrans custInvoiceTrans;
        VendInvoiceTrans vendInvoiceTrans;
        LedgerJournalTrans ledgerJournalTrans;
        ProjInvoiceEmpl projInvoiceEmpl;
        ProjInvoiceRevenue projInvoiceRevenue;
        ProjInvoiceCost projInvoiceCost;
        ProjInvoiceOnAcc projInvoiceOnAcc;

        // FTI, Sales order with sales category
        update_recordset tmpLineDetail
            setting ItemDescription = custInvoiceTrans.Name
            where tmpLineDetail.TransactionJourLineTableId == tableNum(CustInvoiceTrans)
                join Name from custInvoiceTrans
                    where custInvoiceTrans.RecId == tmpLineDetail.TransactionJourLineRecId;

        // Purchase order with procurement category
        update_recordset tmpLineDetail
            setting ItemDescription = vendInvoiceTrans.Name
            where tmpLineDetail.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
                join Name from vendInvoiceTrans
                    where vendInvoiceTrans.RecId == tmpLineDetail.TransactionJourLineRecId;

        // General journal/invoice journal
        update_recordset tmpLineDetail
            setting ItemDescription = ledgerJournalTrans.Txt
            where tmpLineDetail.TransactionJourLineTableId == tableNum(LedgerJournalTrans)
                join Txt from ledgerJournalTrans
                    where ledgerJournalTrans.RecId == tmpLineDetail.TransactionJourLineRecId;

        // Project hour
        update_recordset tmpLineDetail
            setting ItemDescription = projInvoiceEmpl.Txt
            where tmpLineDetail.TransactionJourLineTableId == tableNum(ProjInvoiceEmpl)
                join Txt from projInvoiceEmpl
                    where projInvoiceEmpl.RecId == tmpLineDetail.TransactionJourLineRecId;

        // Project sub fee/project fee
        update_recordset tmpLineDetail
            setting ItemDescription = projInvoiceRevenue.Txt
            where tmpLineDetail.TransactionJourLineTableId == tableNum(ProjInvoiceRevenue)
                join Txt from projInvoiceRevenue
                    where projInvoiceRevenue.RecId == tmpLineDetail.TransactionJourLineRecId;

        // Project expense
        update_recordset tmpLineDetail
            setting ItemDescription = projInvoiceCost.Txt
            where tmpLineDetail.TransactionJourLineTableId == tableNum(ProjInvoiceCost)
                join Txt from projInvoiceCost
                    where projInvoiceCost.RecId == tmpLineDetail.TransactionJourLineRecId;

        // Project on-account
        update_recordset tmpLineDetail
            setting ItemDescription = projInvoiceOnAcc.Txt
            where tmpLineDetail.TransactionJourLineTableId == tableNum(ProjInvoiceOnAcc)
                join Txt from projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == tmpLineDetail.TransactionJourLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTypeOfInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update type of invoice for the records.
    /// </summary>
    /// <remarks>
    /// Same logic as TaxGSTRReportContractLine_IN::getTypeOfInvoice()
    /// </remarks>
    protected void updateTypeOfInvoice()
    {
        const str TypeB2B  = 'B2B';
        const str TypeB2CL = 'B2CL';
        const str TypeB2CS = 'B2CS';
        const str TypeExportWithPaym    = 'Export with payment';
        const str TypeExportWithoutPaym = 'Export without payment GST';

        TmpTaxGSTRReportTaxLineDetail_IN originalTmpTaxGSTRReportTaxLine;
        originalTmpTaxGSTRReportTaxLine.linkPhysicalTableInstance(tmpLineDetail);

        // B2B: Credit note /Debit note against B2B transaction
        // PartyRegistrationNumber != "" AND (transCategory == "GSTInvoice" OR transCategory == "BillOfSupply")
        update_recordset tmpLineDetail
        setting TypeOfInvoiceIsNoteLinkedTo = TypeB2B
            where tmpLineDetail.RefTaxDocumentRowTransactionRecId > 0
        join originalTmpTaxGSTRReportTaxLine
            where originalTmpTaxGSTRReportTaxLine.TaxDocumentRowTransactionRecId == tmpLineDetail.RefTaxDocumentRowTransactionRecId
                && (originalTmpTaxGSTRReportTaxLine.TransCategory                == TaxTransactionCategory_IN::GSTInvoice
                    ||  originalTmpTaxGSTRReportTaxLine.TransCategory            == TaxTransactionCategory_IN::BillOfSupply)
                && originalTmpTaxGSTRReportTaxLine.PartyRegistrationNumber   != ''
                && originalTmpTaxGSTRReportTaxLine.CustomsExportOrder        == false
                && originalTmpTaxGSTRReportTaxLine.CustomsImportOrder        == false;

        // B2CL: Original transaction -Interstate transaction over 2.5 lacs
        // PartyRegistrationNumber == "" AND IsInterState == true AND InvoiceValue > 250000
        // AND (transCategory == "GSTInvoice" OR transCategory == "BillOfSupply")
        update_recordset tmpLineDetail
        setting TypeOfInvoiceIsNoteLinkedTo = TypeB2CL
            where tmpLineDetail.RefTaxDocumentRowTransactionRecId > 0
        join originalTmpTaxGSTRReportTaxLine
            where originalTmpTaxGSTRReportTaxLine.TaxDocumentRowTransactionRecId == tmpLineDetail.RefTaxDocumentRowTransactionRecId
                && (originalTmpTaxGSTRReportTaxLine.TransCategory          == TaxTransactionCategory_IN::GSTInvoice
                    ||  originalTmpTaxGSTRReportTaxLine.TransCategory            == TaxTransactionCategory_IN::BillOfSupply)
                && originalTmpTaxGSTRReportTaxLine.PartyRegistrationNumber   == ''
                && originalTmpTaxGSTRReportTaxLine.IsInterState              == true
                && originalTmpTaxGSTRReportTaxLine.CustomsExportOrder        == false
                && originalTmpTaxGSTRReportTaxLine.CustomsImportOrder        == false
                && (originalTmpTaxGSTRReportTaxLine.TotalTransactionValue > TaxGSTRReportConstants_IN::InvoiceAmountThreshold
                    || originalTmpTaxGSTRReportTaxLine.TotalTransactionValue < -TaxGSTRReportConstants_IN::InvoiceAmountThreshold);

        // B2CS: Original transaction - Intra state any value, Inter-state below 2.5 lacs
        // PartyRegistrationNumber == "" AND (IsInterState == false OR InvoiceValue <= 250000)
        // AND (transCategory == "GSTInvoice" OR transCategory == "BillOfSupply")
        update_recordset tmpLineDetail
        setting TypeOfInvoiceIsNoteLinkedTo = TypeB2CS
            where tmpLineDetail.RefTaxDocumentRowTransactionRecId > 0
        join originalTmpTaxGSTRReportTaxLine
            where originalTmpTaxGSTRReportTaxLine.TaxDocumentRowTransactionRecId == tmpLineDetail.RefTaxDocumentRowTransactionRecId
                && (originalTmpTaxGSTRReportTaxLine.TransCategory          == TaxTransactionCategory_IN::GSTInvoice
                    || originalTmpTaxGSTRReportTaxLine.TransCategory       == TaxTransactionCategory_IN::BillOfSupply)
                && originalTmpTaxGSTRReportTaxLine.PartyRegistrationNumber == ''
                && (originalTmpTaxGSTRReportTaxLine.IsInterState           == false
                    || (originalTmpTaxGSTRReportTaxLine.TotalTransactionValue <= TaxGSTRReportConstants_IN::InvoiceAmountThreshold
                        && originalTmpTaxGSTRReportTaxLine.TotalTransactionValue >= -TaxGSTRReportConstants_IN::InvoiceAmountThreshold))
                && originalTmpTaxGSTRReportTaxLine.CustomsExportOrder        == false
                && originalTmpTaxGSTRReportTaxLine.CustomsImportOrder        == false;

        // Export with payment : Export transaction if GST is paid
        // (CustomsExportOrder == true OR CustomsImportOrder == true) AND TransCategory == "GSTInvoice"
        update_recordset tmpLineDetail
        setting TypeOfInvoiceIsNoteLinkedTo = TypeExportWithPaym
            where tmpLineDetail.RefTaxDocumentRowTransactionRecId > 0
        join originalTmpTaxGSTRReportTaxLine
            where originalTmpTaxGSTRReportTaxLine.TaxDocumentRowTransactionRecId == tmpLineDetail.RefTaxDocumentRowTransactionRecId
                && originalTmpTaxGSTRReportTaxLine.TransCategory     == TaxTransactionCategory_IN::GSTInvoice
                && (originalTmpTaxGSTRReportTaxLine.CustomsExportOrder == true
                    || originalTmpTaxGSTRReportTaxLine.CustomsImportOrder == true);

        // Export without payment GST-  Export transaction if no GST is applied.
        // (CustomsExportOrder == true OR CustomsImportOrder == true) AND TransCategory == "BillOfSupply"
        update_recordset tmpLineDetail
        setting TypeOfInvoiceIsNoteLinkedTo = TypeExportWithoutPaym
            where tmpLineDetail.RefTaxDocumentRowTransactionRecId > 0
        join originalTmpTaxGSTRReportTaxLine
            where originalTmpTaxGSTRReportTaxLine.TaxDocumentRowTransactionRecId == tmpLineDetail.RefTaxDocumentRowTransactionRecId
                && originalTmpTaxGSTRReportTaxLine.TransCategory     == TaxTransactionCategory_IN::BillOfSupply
                && (originalTmpTaxGSTRReportTaxLine.CustomsExportOrder == true
                    || originalTmpTaxGSTRReportTaxLine.CustomsImportOrder == true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalTransactionValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the total transaction value for the records.
    /// </summary>
    protected void updateTotalTransactionValue()
    {
        CustTrans                           custTrans;
        VendTrans                           vendTrans;
        LedgerJournalTrans                  ledgerJournalTransLoc;
        TaxDocumentRowTransaction           rowTrans;
        TmpTaxGSTRReportTaxLineDetail_IN    tmpLineDetailSTO;
        TaxDocumentComponentTransaction     componentTrans;
        TaxDocumentComponentTransaction_IN  componentTransIN;

        // Get ledger transaction type
        update_recordset tmpLineDetail
            setting LedgerTransType = ledgerJournalTransLoc.TransactionType
            where tmpLineDetail.TransactionHeaderTableId == tableNum(TaxEngineLedgerJournalTransHeader)
                && tmpLineDetail.TransactionLineTableId == tableNum(LedgerJournalTrans)
            join TransactionType from ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == tmpLineDetail.TransactionJourLineRecId;

        update_recordset tmpLineDetail
            setting TransCategory = TaxTransactionCategory_IN::GSTInvoice
            where tmpLineDetail.LedgerTransType == LedgerTransType::Fee;

        update_recordset tmpLineDetail
            setting TotalTransactionValue = CustTrans.AmountMST
            join rowTrans
                where rowTrans.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && rowTrans.TransactionJourHeaderRecId  == tmpLineDetail.TransactionJourHeaderRecId
                    && rowTrans.TransactionJourHeaderTableId > 0
                    && rowTrans.TransactionJourHeaderRecId != 0
                    && (rowTrans.TransactionJourHeaderTableId     == tableNum(TaxEngineProjCostJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjEmplJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjItemJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjItemSOJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjOnAcctJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjRevenueJourHeader)
                        || rowTrans.TransactionJourHeaderTableId  == tableNum(TaxEngineProjRevenueSubJourHeader)
                        || rowTrans.TransactionJourLineTableId    == tableNum(CustInvoiceTrans)
                        || rowTrans.TransactionJourLineTableId    == tableNum(LedgerJournalTrans))
            join AmountMST from custTrans
                where (custTrans.TransDate == rowTrans.TransactionDate
                    || custTrans.TransDate == rowTrans.InvoiceDate)
                    && custTrans.Voucher == rowTrans.Voucher;

        update_recordset tmpLineDetail
            setting TotalTransactionValue = vendTrans.AmountMST
            join rowTrans
                where rowTrans.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && rowTrans.TransactionJourHeaderRecId  == tmpLineDetail.TransactionJourHeaderRecId
                    && rowTrans.TransactionJourHeaderTableId > 0
                    && rowTrans.TransactionJourHeaderRecId != 0
                    && (rowTrans.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
                        || rowTrans.TransactionJourLineTableId  == tableNum(LedgerJournalTrans))
            join AmountMST from vendTrans
                where (vendTrans.TransDate == rowTrans.TransactionDate
                    || vendTrans.TransDate == rowTrans.InvoiceDate)
                    && vendTrans.Voucher == rowTrans.Voucher;

        this.updateTotalValueToIncludeWithholdingTax();

        while select avg(TaxBaseAmount), sum(TaxAmount) from componentTrans
            group by componentTrans.TaxDocumentRowTransactionRecId, tmpLineDetail.Voucher, tmpLineDetail.TransactionJourHeaderRecId, tmpLineDetail.TransactionJourHeaderTableId
                join tmpLineDetail
                    where tmpLineDetail.TaxDocumentRowTransactionRecId == componentTrans.TaxDocumentRowTransactionRecId
                        && tmpLineDetail.TransactionJourHeaderTableId > 0
                        && tmpLineDetail.TransactionJourHeaderRecId != 0
                        && tmpLineDetail.TransactionJourHeaderTableId == tableNum(InventTransferJour)
                exists join componentTransIN
                    where componentTransIN.TaxDocumentComponnetTransactionRecId == componentTrans.RecId
                        && componentTransIN.TaxType == TaxType_IN::GST
        {
            ttsbegin;
            select forupdate tmpLineDetailSTO
                where tmpLineDetailSTO.Voucher == tmpLineDetail.Voucher;

            if (tmpLineDetailSTO)
            {
                tmpLineDetailSTO.TotalTransactionValue += componentTrans.TaxBaseAmount + componentTrans.TaxAmount;
                tmpLineDetailSTO.update();
            }
            else
            {
                tmpLineDetailSTO.TotalTransactionValue = componentTrans.TaxBaseAmount + componentTrans.TaxAmount;
                tmpLineDetailSTO.Voucher = tmpLineDetail.Voucher;
                tmpLineDetailSTO.TransactionJourHeaderTableId = tmpLineDetail.TransactionJourHeaderTableId;
                tmpLineDetailSTO.TransactionJourHeaderRecId   = tmpLineDetail.TransactionJourHeaderRecId;
                tmpLineDetailSTO.insert();
            }
            ttscommit;
        }

        update_recordset tmpLineDetail
            setting TotalTransactionValue = tmpLineDetailSTO.TotalTransactionValue
            where tmpLineDetail.TransactionJourHeaderTableId > 0
                && tmpLineDetail.TransactionJourHeaderRecId != 0
                && tmpLineDetail.TransactionJourHeaderTableId == tableNum(InventTransferJour)
            join tmpLineDetailSTO
                where tmpLineDetailSTO.voucher == tmpLineDetail.Voucher
                    && tmpLineDetailSTO.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && tmpLineDetailSTO.TransactionJourHeaderRecId == tmpLineDetail.TransactionJourHeaderRecId;

        this.updateTotalValueForExportAndImportOrder();

        this.updateTotalValueForCustPaymentToIncludeGST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalValueForCustPaymentToIncludeGST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates TotalTransactionValue for customer payment.
    /// </summary>
    private void updateTotalValueForCustPaymentToIncludeGST()
    {
        TaxDocumentComponentTransaction componentTrans;
        TaxDocumentComponentTransaction_IN componentTrans_IN;
        TmpTaxGSTRReportTaxLineDetail_IN tmpLineDetailCustPayment;

        insert_recordset tmpLineDetailCustPayment (TransactionJourHeaderTableId, TransactionJourHeaderRecId, Voucher, TotalTransactionValue)
            select TransactionJourHeaderTableId, TransactionJourHeaderRecId, Voucher from tmpLineDetail
                group by tmpLineDetail.TransactionJourHeaderTableId, tmpLineDetail.TransactionJourHeaderRecId, tmpLineDetail.Voucher
                    where tmpLineDetail.TransactionHeaderTableId == tableNum(TaxEngineLedgerJournalTransHeader)
                        && tmpLineDetail.TransactionLineTableId == tableNum(LedgerJournalTrans)
                        && tmpLinedetail.LedgerTransType == LedgerTransType::Payment
                        && tmpLineDetail.TaxableDocumentType == CustPaymTDT
            join sum(TaxAmount) from componentTrans
                where componentTrans.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
            join componentTrans_IN
                where componentTrans_IN.TaxDocumentComponnetTransactionRecId == ComponentTrans.RecId
                    && componentTrans_IN.TaxType == TaxType_IN::GST;

        // TotalTransactionValue =  Transaction amount + GST
        update_recordset tmpLineDetail
            setting TotalTransactionValue = tmpLineDetail.TotalTransactionValue + -1 * tmpLineDetailCustPayment.TotalTransactionValue
            join tmpLineDetailCustPayment
                where tmpLineDetailCustPayment.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && tmpLineDetailCustPayment.TransactionJourHeaderRecId == tmpLineDetail.TransactionJourHeaderRecId
                    && tmpLineDetailCustPayment.voucher == tmpLineDetail.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalValueToIncludeWithholdingTax</Name>
				<Source><![CDATA[
    private void updateTotalValueToIncludeWithholdingTax()
    {
        TaxWithholdTrans_IN taxWithholdTrans_IN;
        TaxDocumentRowTransaction rowTrans;
        TmpTaxGSTRReportTaxLineDetail_IN tmpLineDetailWithholdTax;

        insert_recordset tmpLineDetailWithholdTax (TransactionJourLineTableId, TransactionJourLineRecId, Voucher, TotalTransactionValue)
        select TransactionJourLineTableId, TransactionJourLineRecId, Voucher from tmpLineDetail
            group by tmpLineDetail.TransactionJourLineTableId, tmpLineDetail.TransactionJourLineRecId, tmpLineDetail.Voucher
                where tmpLineDetail.TransactionJourHeaderTableId != 0
                    && tmpLineDetail.TransactionJourHeaderRecId != 0
                    && tmpLineDetail.TransCategory != TaxTransactionCategory_IN::PaymentVoucher
                    && tmpLineDetail.TransCategory != TaxTransactionCategory_IN::RefundVoucher
                    && (tmpLineDetail.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
                        || tmpLineDetail.TransactionJourLineTableId == tableNum(CustInvoiceTrans)
                        || tmpLineDetail.TransactionJourLineTableId == tableNum(LedgerJournalTrans))
            join rowTrans
                where rowTrans.TransactionJourLineTableId == tmpLineDetail.TransactionJourLineTableId
                    && rowTrans.TransactionJourLineRecId == tmpLineDetail.TransactionJourLineRecId
                    && (rowTrans.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
                        || rowTrans.TransactionJourLineTableId == tableNum(CustInvoiceTrans)
                        || rowTrans.TransactionJourLineTableId == tableNum(LedgerJournalTrans))
            join sum(TaxWithholdAmountCur) from taxWithholdTrans_IN
                where (taxWithholdTrans_IN.TransDate == rowTrans.TransactionDate
                        || taxWithholdTrans_IN.TransDate == rowTrans.InvoiceDate)
                    && taxWithholdTrans_IN.Voucher == tmpLineDetail.Voucher
                    && taxWithholdTrans_IN.TaxType == TaxWithholdCodeType_IN::TDS;

        update_recordset tmpLineDetail
        setting TotalTransactionValue = tmpLineDetail.TotalTransactionValue + tmpLineDetailWithholdTax.TotalTransactionValue
        join tmpLineDetailWithholdTax
            where tmpLineDetailWithholdTax.TransactionJourLineTableId == tmpLineDetail.TransactionJourLineTableId
                && tmpLineDetailWithholdTax.TransactionJourLineRecId == tmpLineDetail.TransactionJourLineRecId
                && tmpLineDetailWithholdTax.voucher == tmpLineDetail.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalValueForExportAndImportOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the total transaction value for Export orders and Import orders.
    /// </summary>
    private void updateTotalValueForExportAndImportOrder()
    {
        PurchTable                          purchTable;
        PurchTable_W                        purchTable_W;
        CustInvoiceJour                     custInvoiceJour;
        VendInvoiceTrans                    vendInvoiceTrans;
        GeneralJournalEntry                 generalJournalEntry;
        TaxDocumentRowTransaction           rowTrans;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        CustomsShippingBillTrans_IN         customsShippingBillTrans_IN;
        TmpTaxGSTRReportTaxLineDetail_IN    tmpLineDetailImport;

        //Export order
        update_recordset tmpLineDetail
           setting TotalTransactionValue = custInvoiceJour.InvoiceAmountMST + generalJournalAccountEntry.AccountingCurrencyAmount
           join rowTrans
                where rowTrans.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && rowTrans.TransactionJourHeaderRecId  == tmpLineDetail.TransactionJourHeaderRecId
                    && rowTrans.TransactionJourHeaderTableId > 0
                    && rowTrans.TransactionJourHeaderRecId != 0
                    && rowTrans.TransactionJourLineTableId == tableNum(CustomsShippingBillTrans_IN)
            join customsShippingBillTrans_IN
                where customsShippingBillTrans_IN.RecId == rowTrans.TransactionJourLIneRecId
            join InvoiceAmountMST from custInvoiceJour
                where custInvoiceJour.SalesId == customsShippingBillTrans_IN.SalesId
                    && custInvoiceJour.InvoiceId == customsShippingBillTrans_IN.InvoiceId
            join generalJournalEntry
                where generalJournalEntry.SubledgerVoucher == rowTrans.Voucher
            join generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && generalJournalAccountEntry.PostingType == LedgerPostingType::GST_IN
                    && generalJournalAccountEntry.IsCredit == NoYes::No;

        // Import order
        this.updateTotalTransValueImportOrderByTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillModelLineExtension</Name>
				<Source><![CDATA[
    /// <summary>
    /// This is customization extension method for filling more model line fields.
    /// </summary>
    /// <param name = "_taxGSTRReportContractLine">
    /// <c>TaxGSTRReportContractLine_IN</c> instance
    /// </param>
    /// <param name = "_tmpLineDetail">
    /// <c>TmpTaxGSTRReportTaxLineDetail_IN</c> record
    /// </param>
    /// <remarks>
    /// You can query out <c>TaxDocumentRowTransaction</c> by _tmpLineDetail.TaxDocumentRowTransactionRecId and 
    /// <c>TaxDocumentRowTransaction_IN</c> by _tmpLineDetail.TaxDocumentRowTransactionINRecId.
    /// </remarks>
    protected void fillModelLineExtension(
        TaxGSTRReportContractLine_IN        _taxGSTRReportContractLine,
        TmpTaxGSTRReportTaxLineDetail_IN    _tmpLineDetail)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillModelLineFromTaxCompTransExtension</Name>
				<Source><![CDATA[
    /// <summary>
    /// This is customizationthe extension method for filling more model line fields from
    /// tax component transaction.
    /// </summary>
    /// <param name = "_taxGSTRReportContractLine">
    /// <c>TaxGSTRReportContractLine_IN</c> instance
    /// </param>
    /// <param name = "_tmpLineDetail">
    /// <c>TmpTaxGSTRReportTaxLineDetail_IN</c> record
    /// </param>
    /// <param name = "_taxDocumentComponentTransaction">
    /// <c>TaxDocumentComponentTransaction</c> record
    /// </param>
    /// <param name = "_taxDocumentComponentTransactionIn">
    /// <c>TaxDocumentComponentTransaction_IN</c> record
    /// </param>
    protected void fillModelLineFromTaxCompTransExtension(
        TaxGSTRReportContractLine_IN        _taxGSTRReportContractLine,
        TmpTaxGSTRReportTaxLineDetail_IN    _tmpLineDetail,
        TaxDocumentComponentTransaction     _taxDocumentComponentTransaction,
        TaxDocumentComponentTransaction_IN  _taxDocumentComponentTransactionIn)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get transaction unit
    /// </summary>
    /// <param name = "_unitOfMeasureSymbol">UnitOfMeasureTranslation table</param>
    /// <returns>UnitOfMeasureTranslation</returns>
    [Hookable]
    protected UnitOfMeasureTranslation getUnit(UnitOfMeasureSymbol _unitOfMeasureSymbol)
    {
        UnitOfMeasure                           unitOfMeasure;
        UnitOfMeasureTranslation                unitOfMeasureTranslation;

        select firstonly Description from unitOfMeasureTranslation
            where unitOfMeasureTranslation.LanguageId == SystemParameters::getSystemLanguageId()
                join RecId from unitOfMeasure
                where unitOfMeasure.Symbol == _unitOfMeasureSymbol
                    && unitOfMeasure.RecId == unitOfMeasureTranslation.UnitOfMeasure;

        return unitOfMeasureTranslation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxableValueForEcommerceReport</Name>
				<Source><![CDATA[
    private void updateTaxableValueForEcommerceReport(TmpTaxGSTRReportTaxLine_IN _tmpTaxGSTRReportTaxLine)
    {
        if (this.isAnx1
            && _tmpTaxGSTRReportTaxLine.IsECommerce
            && _tmpTaxGSTRReportTaxLine.TransCategory == TaxTransactionCategory_IN::CreditNote)
        {
            _tmpTaxGSTRReportTaxLine.TaxableValueReturned = _tmpTaxGSTRReportTaxLine.TaxableValue * -1;
            _tmpTaxGSTRReportTaxLine.TaxableValue = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalTransValueImportOrderByTax</Name>
				<Source><![CDATA[
    private void updateTotalTransValueImportOrderByTax()
    {
        TaxDocumentComponentTransaction componentTrans;
        TaxDocumentComponentTransaction_IN componentTrans_IN;
        VendInvoiceJour VendInvoiceJour;
        TmpTaxGSTRReportTaxLineDetail_IN tmpLineDetailImport;

        //Calculate tax = custom duty + IGST (Not include IGST CUS)
        insert_recordset tmpLineDetailImport (TransactionJourHeaderTableId, TransactionJourHeaderRecId, Voucher, TotalTransactionValue)
        select TransactionJourHeaderTableId, TransactionJourHeaderRecId, Voucher from tmpLineDetail
            group by tmpLineDetail.Voucher, tmpLineDetail.TransactionJourHeaderTableId, tmpLineDetail.TransactionJourHeaderRecId
                where tmpLineDetail.TransactionJourHeaderTableId > 0
                    && tmpLineDetail.TransactionJourHeaderRecId != 0
                    && tmpLineDetail.TransactionJourHeaderTableId == tableNum(VendInvoiceJour)
                    && tmpLineDetail.CustomsImportOrder == NoYes::Yes
            join sum(TaxAmount) from componentTrans
                where componentTrans.TaxDocumentRowTransactionRecId == tmpLineDetail.TaxDocumentRowTransactionRecId
                    && componentTrans.TaxCode != TaxGSTRReportConstants_IN::IGST_CUS //IGST CUS should not be considered. Already included by IGST
            join componentTrans_IN
                where componentTrans_IN.TaxDocumentComponnetTransactionRecId == ComponentTrans.RecId
                    && (componentTrans_IN.TaxType == TaxType_IN::GST
                        || componentTrans_IN.TaxType == TaxType_IN::Customs);

        //TotalTransactionValue = InvoiceAmount + Tax
        update_recordset tmpLineDetail
            setting TotalTransactionValue = VendInvoiceJour.InvoiceAmountMST + tmpLineDetailImport.TotalTransactionValue
            where tmpLineDetail.TransactionJourHeaderTableId > 0
                && tmpLineDetail.TransactionJourHeaderRecId != 0
                && tmpLineDetail.TransactionJourHeaderTableId == tableNum(VendInvoiceJour)
            join InvoiceAmountMST, RecId from VendInvoiceJour
                where VendInvoiceJour.RecId == tmpLineDetail.TransactionJourHeaderRecId
            join tmpLineDetailImport
                where tmpLineDetailImport.Voucher == tmpLineDetail.Voucher
                    && tmpLineDetailImport.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && tmpLineDetailImport.TransactionJourHeaderRecId   == tmpLineDetail.TransactionJourHeaderRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalTransValueImportOrderByGL</Name>
				<Source><![CDATA[
    private void updateTotalTransValueImportOrderByGL()
    {
        PurchTable                          purchTable;
        PurchTable_W                        purchTable_W;
        VendInvoiceTrans                    vendInvoiceTrans;
        GeneralJournalEntry                 generalJournalEntry;
        TaxDocumentRowTransaction           rowTrans;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        TmpTaxGSTRReportTaxLineDetail_IN    tmpLineDetailImport;

        while select sum(AccountingCurrencyAmount) from generalJournalAccountEntry
            where generalJournalAccountEntry.PostingType == LedgerPostingType::GST_IN
                && generalJournalAccountEntry.IsCredit == NoYes::No
            join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
            join rowTrans
                group by RecId, Voucher, TransactionJourHeaderRecId, TransactionJourHeaderTableId
                where rowTrans.Voucher == generalJournalEntry.SubledgerVoucher
                    && rowTrans.TransactionJourHeaderTableId > 0
                    && rowTrans.TransactionJourHeaderRecId != 0
                    && rowTrans.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
            join vendInvoiceTrans
                where vendInvoiceTrans.RecId == rowTrans.TransactionJourLIneRecId
            join purchTable
                where purchTable.PurchId == vendInvoiceTrans.PurchID
            join purchTable_W
                where purchTable_W.PurchTable == purchTable.RecId
                    && purchTable_W.CustomsImportOrder_IN == NoYes::Yes
        {
            tmpLineDetailImport.TotalTransactionValue = generalJournalAccountEntry.AccountingCurrencyAmount;
            tmpLineDetailImport.Voucher = rowTrans.Voucher;
            tmpLineDetailImport.TransactionJourHeaderTableId = rowTrans.TransactionJourHeaderTableId;
            tmpLineDetailImport.TransactionJourHeaderRecId   = rowTrans.TransactionJourHeaderRecId;
            tmpLineDetailImport.insert();
        }

        update_recordset tmpLineDetail
            setting TotalTransactionValue = tmpLineDetail.TotalTransactionValue - tmpLineDetailImport.TotalTransactionValue
            join rowTrans
                where rowTrans.TransactionJourHeaderTableId == tmpLineDetail.TransactionJourHeaderTableId
                    && rowTrans.TransactionJourHeaderRecId  == tmpLineDetail.TransactionJourHeaderRecId
                    && rowTrans.TransactionJourHeaderTableId > 0
                    && rowTrans.TransactionJourHeaderRecId != 0
                    && rowTrans.TransactionJourLineTableId == tableNum(VendInvoiceTrans)
            join tmpLineDetailImport
                where tmpLineDetailImport.Voucher == rowTrans.Voucher
                    && tmpLineDetailImport.TransactionJourHeaderTableId == rowTrans.TransactionJourHeaderTableId
                    && tmpLineDetailImport.TransactionJourHeaderRecId   == rowTrans.TransactionJourHeaderRecId;

    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    private boolean isCreditNote(TmpTaxGSTRReportTaxLineDetail_IN _tmpLineDetail, TaxDocumentRowTransaction _taxDocumentRowTransaction)
    {
        return (_tmpLineDetail.TransCategory == TaxTransactionCategory_IN::CreditNote || _tmpLineDetail.TransCategory == TaxTransactionCategory_IN::DebitNote)
            && _taxDocumentRowTransaction.BaseAmountCur <= 0
            && _tmpLineDetail.Quantity <= 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>