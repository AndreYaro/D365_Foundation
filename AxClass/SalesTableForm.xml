<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesTableForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
class  SalesTableForm
{
    const int CalculatedId_Idx = 1;
    const int CalculatedLineAmount_Idx = 2;
    const int CalculatedUnitPrice_Idx = 3;

    private static UnknownNoYes MCRChannelUserExists;

    SalesTable              salesTable;
    SalesType               salesType;
    SalesType               defaultSalesType;
    SalesId                 salesId;
    SalesId                 newSalesId;
    ProjId                  projId;
    CustAccount             custAccount;
    CustInvoiceAccount      invoiceAccount;
    CustLanguageId          languageId;
    boolean                 advancedStartup;
    SalesLine               newlyCreatedSalesLine;
    ReturnStatusHeader      returnStatus;
    SalesReturnItemNum      returnItemNum;
    boolean                 replacementOrder;
    SalesTableType          salesTableType;
    FormDataSource          salesTable_ds;
    boolean                 interCompanyAutoCreateOrdersNow;
    Map                     interCompanyOriginalSalesCache;
    Map                     interCompanySalesCache;
    Map                     mapTmsDisplayRoute;
    boolean                 isInterCompanyPurchaseOrderInvoiceMatched;

    // Store whether in express mode or not
    MCRSourceID         mcrSourceID;
    NoYes               mcrIsExchange;
    CustDlvModeId       dlvMode;
    smmCampaignId       smmCampaignId;
    ContactPersonId     contactPersonId;
    smmTMCallListID     smmTMCallListID;
    SalesId             originalSalesId;
    //cache whether the item price is potency enabled
    Map                     itemPotencyPricingEnabled;

    Map                     pdsPricingCalculatedCache;

    // <GBR>
    SalesTable_BR           salesTable_BR;
    FormDataSource          salesTable_BR_ds;
    // </GBR>

    boolean                 shouldEstimateBeCalculated;
    boolean                 shouldEstimateBeCalculatedIsSet;

    SalesTableFormLineInstanceCache lineInstanceCache;

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        advancedStartup
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustLineAccessBasedOnItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts line field access based on line item.
    /// </summary>
    /// <param name="_salesLine">
    /// The <c>SalesLine</c> to set access.
    /// </param>
    public void adjustLineAccessBasedOnItem(SalesLine _salesLine)
    {
        boolean                             interCompanySalesLineExist = _salesLine.interCompanySalesLineExist();
        boolean                             isInterCompanyOrder        = salesTable.isInterCompanyOrder();
        boolean                             returnItem                 = salesTable.returnItem();
        boolean                             itemBased                  = _salesLine.ItemId != '';
        boolean                             stockedProduct            = _salesLine.isStocked();
        boolean                             isRelatedPOLineInvoiceMatched = _salesLine.isInterCompanyOrderLineInvoiceMatched() || _salesLine.isDropShipmentPOLineInvoiceMatched();

        if (FormDataUtil::getFormDataSource(_salesLine))
        {
            FormDataSource salesLine_ds = FormDataUtil::getFormDataSource(_salesLine);

            if ((isInterCompanyOrder && _salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
            ||   returnItem)
            {
                if (! #PdsCatchWeightEnabled)
                {
                    salesLine_ds.object(fieldNum(SalesLine,QtyOrdered)).allowEdit(false);
                }
                else
                {
                    this.enableLineSalesQtyFields(_salesLine, false, false);
                    this.enableLineExpectedRetQtyFields(_salesLine, false);
                }
            }
            else
            {
                if (! #PdsCatchWeightEnabled)
                {
                    salesLine_ds.object(fieldNum(SalesLine,QtyOrdered)).allowEdit(stockedProduct);
                }
                else
                {
                    this.enableLineSalesQtyFields(
                                                  _salesLine,
                                                  _salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries && !isRelatedPOLineInvoiceMatched,
                                                 stockedProduct);
                    this.enableLineExpectedRetQtyFields(_salesLine, !isRelatedPOLineInvoiceMatched);
                }
            }

            salesLine_ds.object(fieldNum(SalesLine, Scrap)).allowEdit(
                lineInstanceCache.getDeliveredInTotal(_salesLine) == 0
                && !interCompanySalesLineExist
                && stockedProduct);

            // Disable inventory fields if not inventoried
            if (! #PdsCatchWeightEnabled)
            {
                salesLine_ds.object(fieldNum(SalesLine, InventDeliverNow)).allowEdit(stockedProduct);
                salesLine_ds.object(fieldNum(SalesLine, RemainInventPhysical)).allowEdit(stockedProduct);
                salesLine_ds.object(fieldNum(SalesLine, RemainInventFinancial)).allowEdit(stockedProduct);
            }
            else
            {
                this.enableLineDeliverNowFields(
                                                _salesLine,
                                                _salesLine.DeliveryType     != TradeLineDlvType::DropShip
                                                && _salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries
                                                && !_salesLine.returnItem(),
                                                stockedProduct);
                this.enableLineRemainPhysicalFields(_salesLine, stockedProduct);
                this.enableLineRemainFinancialFields(_salesLine, stockedProduct);
            }
            salesLine_ds.object(fieldNum(SalesLine, CostPrice)).allowEdit(stockedProduct);
            salesLine_ds.object(fieldNum(SalesLine, Reservation)).allowEdit(stockedProduct);

            // Disable delivery fields if not item based
            salesLine_ds.object(fieldNum(SalesLine, ServiceOrderId)).allowEdit(itemBased);
            salesLine_ds.object(fieldNum(SalesLine, ItemRouteId)).allowEdit(itemBased);
            salesLine_ds.object(fieldNum(SalesLine, ItemBOMId)).allowEdit(itemBased);
            salesLine_ds.object(fieldNum(SalesLine, LineHeader)).allowEdit(itemBased);

            if (!_salesLine.returnItem())
            {
                salesLine_ds.object(fieldNum(SalesLine, BarCode)).allowEdit(itemBased);
                salesLine_ds.object(fieldNum(SalesLine, BarCodeType)).allowEdit(itemBased);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canClose</Name>
				<Source><![CDATA[
    public boolean canClose(SalesTable _salesTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExpandBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the BOM of a sales order line can be expanded.
    /// </summary>
    /// <param name="_salesLine">
    /// The currently selected sales order line.
    /// </param>
    /// <returns>
    /// true if the BOM can be expanded; otherwise, false.
    /// </returns>
    public boolean canExpandBOM(SalesLine _salesLine)
    {
        boolean ok = true;

        if (!_salesLine.inventTable().isBOMAllowed())
        {
            ok = checkFailed("@SYS2069");
        }

        if (_salesLine.isStocked() && isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing)))
        {
            if (   ok
                && LeanRuleEvent::hasSalesLineKanbanPegging(_salesLine))
            {
                ok = checkFailed(strFmt("@SYS324018",_salesLine.InventTransId,_salesLine.ItemId));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canNewLineBeAppended</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new order line can be inserted after the currently selected one.
    /// </summary>
    /// <param name="_salesLine">
    ///     The currently selected sales order line.
    /// </param>
    /// <returns>
    ///     false for order lines with multiple deliveries; otherwise, true.
    /// </returns>
    /// <remarks>
    ///     When working on order form and an order line with multiple deliveries is selected a new line should always be inserted before it.
    /// </remarks>
    public boolean canNewLineBeAppended(SalesLine _salesLine)
    {
        return _salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>captionName</Name>
				<Source><![CDATA[
    Caption captionName()
    {
        Name    name;

        if (salesTable.isInterCompanyOrder())
            name = salesTable.DeliveryName;
        else
            name = salesTable.SalesName;

        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    boolean  create(
        str             _custAccount    = "",
        WMSShipment     _wmsShipment    = null
        )
    {
        Args            args = new Args();
        SalesTable currentRecord = salesTable;

        args.name(this.createForm());
        args.caller(this);

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            if (_custAccount != "")
            {
                args.parm(_custAccount);
            }
            else if (_wmsShipment != null)
            {
                args.record(_wmsShipment);
            }
        }

        FormRun salesCreateOrder = classfactory.formRunClass(args);
        salesCreateOrder.init();
        salesCreateOrder.run();
        if (!salesCreateOrder.closed())
            salesCreateOrder.wait();

        if (salesCreateOrder.closedOk())
        {
            return true;
        }
        else
        {
            salesTable = currentRecord;
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForm</Name>
				<Source><![CDATA[
    str createForm()
    {
        return formStr(SalesCreateOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new order line can be created.
    /// </summary>
    /// <param name="_salesLine">
    ///     The currently selected sales order line.
    /// </param>
    /// <returns>
    ///     true when order lines can be edited, the intercompany settings allow line creation, the current line is not
    ///     a delivery line and the order is not a return order; otherwise, false.
    /// </returns>
    public boolean createLineAllowed(SalesLine _salesLine)
    {
        boolean ret = (_salesLine.LineDeliveryType != LineDeliveryType::DeliveryLine
                || _salesLine.LineNum == SalesDeliverySchedule::lastDeliveryLineNumber(_salesLine.InventTransId))
            && this.editLineAllowed()
            && !salesTable.returnItem()
            && !salesTable.interCompanyAllowIndirectCreationOrig();

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            ret = this.postCreateLineAllowed_BR(_salesLine, ret);
        }
        // </GBR>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custAccount</Name>
				<Source><![CDATA[
    CustAccount  custAccount(CustAccount  _custAccount = custAccount)
    {
        custAccount = _custAccount;
        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultSalesType</Name>
				<Source><![CDATA[
    SalesType  defaultSalesType()
    {
        return SalesParameters::find().OrderType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteHeaderAllowed</Name>
				<Source><![CDATA[
    public boolean deleteHeaderAllowed()
    {
        return !salesTable.type().interCompanyIsDerivedOrder()
            &&  salesTable.checkDelete(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLineAllowed</Name>
				<Source><![CDATA[
    public boolean deleteLineAllowed(SalesLine _salesLine)
    {
        boolean  deleteLine = true;

        if (_salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived
        &&  salesTable.isInterCompanyOrder())
            deleteLine = false;
        else
        {
            deleteLine = _salesLine.LineDeliveryType != LineDeliveryType::DeliveryLine
                && !_salesLine.isDropShipmentPOLineInvoiceMatched()
                && this.editLineAllowed();
        }
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            deleteLine = this.postDeleteLineAllowed_BR(_salesLine, deleteLine);
        }
        // </GBR>

        if (salesTable.isRetailCashAndCarrySales())
        {
            deleteLine = false;
        }

        if (salesTable.isSalesJournalCreatedFromProductList())
        {
            deleteLine = false;
        }

        return deleteLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>design</Name>
				<Source><![CDATA[
    void  design()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>editHeaderAllowed</Name>
				<Source><![CDATA[
    public boolean editHeaderAllowed(boolean useWarning = false)
    {
        boolean  editHeader = true;

        if (!salesTable.checkUpdate(useWarning,false))
        {
            editHeader = false;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            editHeader = this.postEditHeaderAllowed_BR(editHeader);
        }
        // </GBR>

        if (salesTable.isSalesJournalCreatedFromProductList())
        {
            editHeader = false;
        }

        return editHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editLineAllowed</Name>
				<Source><![CDATA[
    public boolean editLineAllowed(SalesLine _salesLine = null)
    {
        // <GEEU>
        #ISOCountryRegionCodes
        // </GEEU>
        boolean  ret = true;

        if (!salesTable.checkUpdate(false, false))
        {
            ret = false;
        }

        // <GEEU>
        if (ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoLT, #isoLV, #isoEE, #isoCZ, #isoPL, #isoHU]))
        {
             ret = !(_salesLine.CreditNoteInternalRef_PL && _salesLine.InventTransIdReturn);
        }
        // </GEEU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            ret = this.postEditLineAllowed_BR(ret);
        }
        // </GBR>

        if (salesTable.isSalesJournalCreatedFromProductList())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSalesType</Name>
				<Source><![CDATA[
    boolean  editSalesType()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableAvailableDlvDatesButtons</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled property on buttons that are used for the available delivery date calculation.
    /// </summary>
    /// <param name="_salesTable">
    ///    The <c>salesTable</c> record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    /// <param name="_buttonAvailableDlvDatesHeader">
    ///    The available delivery date calculation button used on the order header.
    /// </param>
    /// <param name="_buttonAvailableDlvDatesLine">
    ///    The available delivery date calculation button used on order lines.
    /// </param>
    /// <param name="_lineDeliveryType">
    ///    The <c>lineDeliveryType</c> type of line that is used to determine whether the buttons
    ///    must be enabled or disabled.
    /// </param>
    public void enableAvailableDlvDatesButtons(SalesTable                  _salesTable,
                                               FormFunctionButtonControl   _buttonAvailableDlvDatesHeader,
                                               FormFunctionButtonControl   _buttonAvailableDlvDatesLine,
                                               LineDeliveryType            _lineDeliveryType
                                               )
    {
        boolean canAvailableDlvDatesBeCalculated    = _salesTable.type().canAvailableDlvDatesBeCalculated();

        if (_buttonAvailableDlvDatesHeader)
        {
            _buttonAvailableDlvDatesHeader.enabled(canAvailableDlvDatesBeCalculated);
        }

        if (_buttonAvailableDlvDatesLine)
        {
            _buttonAvailableDlvDatesLine.enabled(canAvailableDlvDatesBeCalculated && _lineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableDeliveryAlternativesButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled property on Delivery alternatives button on the sales line details
    /// </summary>
    /// <param name="_salesTable">
    ///    The <c>_salesTable</c> record that is used to determine whether the button must be enabled or disabled.
    /// </param>
    /// <param name="_salesLine">
    ///    The <c>_salesLine</c> record that is used to determine whether the button must be enabled or disabled.
    /// </param>
    /// <param name="_buttonDeliveryAlternatives">
    ///    The Delivery alternatives button on the sales line details
    /// </param>
    public void enableDeliveryAlternativesButton(SalesTable _salesTable, SalesLine _salesLine, FormFunctionButtonControl _buttonDeliveryAlternatives)
    {
        SalesTableInteractionHelper salesTableInteractionHelper = SalesTableInteractionHelper::construct();
        salesTableInteractionHelper.initLineActions(_salesTable, _salesLine);
		
        _buttonDeliveryAlternatives.enabled(salesTableInteractionHelper.parmSalesLineDeliveryDetailsEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableExportOrderButton_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or Disables the button of Export Order
    /// </summary>
    /// <param name="_salesTable">
    /// Focused SalesTable buffer.
    /// </param>
    /// <param name="_exportOrderButton">
    /// The button of Export Order
    /// </param>
    public void enableExportOrderButton_IN(
        SalesTable                  _salesTable,
        FormFunctionButtonControl   _exportOrderButton)
    {
        if (TaxParameters::isCustomsEnable_IN())
        {
            boolean isCreditDebitNote;

            // 1. If original export Id is attached with the sales order it will be treated as debit note against export order and 'Create export order' for shipping bill will be disabled.
            // 2. If credit note is created against export invoice only Invoice will be posted and 'Create export order' option will be disabled in the sales order tab.
            // 3. Negative export order will be consider as credit note against export order and 'Create export order' will be disabled.
            if (_salesTable.CustomsExportOrder_IN
                && _salesTable.DocumentStatus == DocumentStatus::Invoice)
            {
                CustInvoiceJour custInvoiceJour;
                TaxDocument taxDocument;
                TaxDocumentExtension_IN taxDocumentExtension;

                select firstonly RecId from custInvoiceJour
                    where custInvoiceJour.SalesId == salesTable.SalesId
                        && custInvoiceJour.InvoiceAmount < 0;

                if (custInvoiceJour.RecId)
                {
                    isCreditDebitNote = true;
                }
                else
                {
                    select firstonly RecId from taxDocumentExtension
                        where taxDocumentExtension.RefTaxDocumentExtension != 0
                        join RecId from taxDocument
                            where taxDocument.TaxDocumentGuid == taxDocumentExtension.TaxDocumentGUID
                            join RecId from custInvoiceJour
                                where custInvoiceJour.TableId == taxDocument.OriginSourceTableId
                                    && custInvoiceJour.RecId == taxDocument.OriginSourceRecId
                                    && custInvoiceJour.SalesId == _salesTable.SalesId;

                    isCreditDebitNote = (taxDocumentExtension.RecId != 0);
                }
            }
            _exportOrderButton.enabled(_salesTable.CustomsExportOrder_IN
                && ((_salesTable.DocumentStatus == DocumentStatus::Invoice
                    && !isCreditDebitNote)
                    || _salesTable.DocumentStatus   == DocumentStatus::ProjectInvoice
                    || _salesTable.DocumentStatus   == DocumentStatus::ShippingBill_IN));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineDeliverNowFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the quantity or catch weight quantity field.
    /// </summary>
    /// <param name="_salesLine">
    /// A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enableUnit">
    /// A Boolean value indicating whether to enable the appropriate qty (in sales units) field.
    /// </param>
    /// <param name="_enableInvent">
    /// A Boolean value indicating whether to enable the inventory qty field.
    /// </param>
    public void enableLineDeliverNowFields(SalesLine _salesLine, boolean _enableUnit, boolean _enableInvent)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_salesLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, InventDeliverNow), _enableInvent && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, SalesDeliverNow), _enableUnit && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, PdsCWInventDeliverNow), _enableUnit && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineExpectedRetQtyFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the expected return quantity or catch weight quantity field.
    /// </summary>
    /// <param name="_salesLine">
    /// A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    /// A Boolean value that indicates whether to enable the appropriate quantity field.
    /// </param>
    public void enableLineExpectedRetQtyFields(SalesLine _salesLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_salesLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, ExpectedRetQty), _enable && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, PdsCWExpectedRetQty), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineRemainFinancialFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the remaining physical quantity or catch weight quantity field.
    /// </summary>
    /// <param name="_salesLine">
    /// A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    /// A Boolean value that indicates whether to enable the appropriate quantity field.
    /// </param>
    public void enableLineRemainFinancialFields(SalesLine _salesLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_salesLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, RemainInventFinancial), _enable && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, PdsCWRemainInventFinancial), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineRemainPhysicalFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the remaining physical quantity or catch weight quantity field.
    /// </summary>
    /// <param name="_salesLine">
    /// A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    /// A Boolean value that indicates whether to enable the appropriate quantity field.
    /// </param>
    public void enableLineRemainPhysicalFields(SalesLine _salesLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_salesLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, RemainInventPhysical), _enable && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, PdsCWRemainInventPhysical), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasWorkOrderIntegrationOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the sales order originates from work order integration.
    /// </summary>
    /// <returns>true if the sales order originates from work order integration; otherwise, false.</returns>
    public boolean hasWorkOrderIntegrationOrigin()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(CDSIntegration))
            && SalesOriginInternalType::find(salesTable.SalesOriginId).OriginType == SalesOriginType::WorkOrderIntegration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineSalesQtyFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the quantity or catch weight quantity field.
    /// </summary>
    /// <param name="_salesLine">
    /// A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enableUnit">
    /// A Boolean value that indicates whether to enable the appropriate sales quantity field.
    /// </param>
    /// <param name="_enableInvent">
    /// A Boolean value that indicates whether to enable the ordered quantity field.
    /// </param>
    public void enableLineSalesQtyFields(SalesLine _salesLine, boolean _enableUnit, boolean _enableInvent)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_salesLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, QtyOrdered), _enableInvent && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, SalesQty), _enableUnit && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_salesLine), fieldNum(SalesLine, PdsCWQty), _enableUnit && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableUpdateJournalButtonsMultipleOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled property on buttons that are used for posting sales orders, when multiple sales orders are selected.
    /// </summary>
    /// <param name="_salesTable">
    ///    The <c>SalesTable</c> data source record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    /// <param name="_buttonUpdateConfirmation">Unused</param>
    /// <param name="_buttonUpdatePickingList">Unused</param>
    /// <param name="_buttonUpdatePickingListRegistrate">Unused</param>
    /// <param name="_buttonUpdatePackingSlip">Unused</param>
    /// <param name="_buttonUpdateInvoice">Unused</param>
    /// <param name="_buttonUpdateProjectPackingSlip">Unused</param>
    /// <param name="_buttonProformaConfirmation">Unused</param>
    /// <param name="_buttonProformaPackingSlip">Unused</param>
    /// <param name="_buttonProformaInvoice">Unused</param>
    /// <param name="_buttonUpdateInvoice4Paym">Unused</param>
    /// <param name="_buttonUpdateFacture">Unused</param>
    /// <param name="_buttonUpdateFactureEditLines">Unused</param>
    /// <param name="_buttonUpdateInvoice4PaymProforma">Unused</param>
    /// <param name="_buttonUpdateFactureProforma">Unused</param>
    /// <param name="_buttonUpdateFactureEditLinesProforma">Unused</param>
    /// <remarks>The buttons are controlled by their name in the <c>SalesTableFormJournalButtonState</c> class.</remarks>
    void enableUpdateJournalButtonsMultipleOrders(
        SalesTable                      _salesTable,
        FormFunctionButtonControl       _buttonUpdateConfirmation,
        FormFunctionButtonControl       _buttonUpdatePickingList,
        FormFunctionButtonControl       _buttonUpdatePickingListRegistrate,
        FormFunctionButtonControl       _buttonUpdatePackingSlip,
        FormFunctionButtonControl       _buttonUpdateInvoice,
        FormFunctionButtonControl       _buttonUpdateProjectPackingSlip,
        FormFunctionButtonControl       _buttonProformaConfirmation,
        FormFunctionButtonControl       _buttonProformaPackingSlip,
        FormFunctionButtonControl       _buttonProformaInvoice,
        FormFunctionButtonControl       _buttonUpdateInvoice4Paym             = null,
        FormFunctionButtonControl       _buttonUpdateFacture                  = null,
        FormFunctionButtonControl       _buttonUpdateFactureEditLines         = null,
        FormFunctionButtonControl       _buttonUpdateInvoice4PaymProforma     = null,
        FormFunctionButtonControl       _buttonUpdateFactureProforma          = null,
        FormFunctionButtonControl       _buttonUpdateFactureEditLinesProforma = null)
    {
        SalesTableInteractionHelper::updateStateJournalButtonsMultipleOrders(_salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableUpdateJournalTransButtons</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled property on buttons used for posting sales order lines.
    /// </summary>
    /// <param name="_salesLine">
    ///    The <c>SalesLine</c> record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    /// <param name="_buttonUpdateConfirmation">
    ///    The form button control for confirmation updating sales order lines.
    /// </param>
    /// <param name="_buttonUpdatePickingList">
    ///    The form button control for picking list updating sales order lines.
    /// </param>
    /// <param name="_buttonUpdatePickingListRegistrate">
    ///    The form button control for picking list registrate sales order lines.
    /// </param>
    /// <param name="_buttonUpdatePackingSlip">
    ///    The form button control for packing slip updating sales order lines.
    /// </param>
    /// <param name="_buttonUpdateInvoice">
    ///    The form button control for invoice updating sales order lines.
    /// </param>
    /// <param name="_buttonUpdateProjectPackingSlip">
    ///    The form button control for packing slip updating sales order lines that relate to projects.
    /// </param>
    void enableUpdateJournalTransButtons(SalesLine                   _salesLine,
                                         FormFunctionButtonControl   _buttonUpdateConfirmation,
                                         FormFunctionButtonControl   _buttonUpdatePickingList,
                                         FormFunctionButtonControl   _buttonUpdatePickingListRegistrate,
                                         FormFunctionButtonControl   _buttonUpdatePackingSlip,
                                         FormFunctionButtonControl   _buttonUpdateInvoice,
                                         FormFunctionButtonControl   _buttonUpdateProjectPackingSlip)
    {
        container           checkIfupdate;
        boolean             enableConfirmationButton;
        boolean             enablePickingListButton;
        boolean             enablePickingListRegistrateButton;
        boolean             enablePackingSlipButton;
        boolean             enableInvoiceButton;
        boolean             enableProjectPackingSlipButton;

        FormDataSource salesLine_ds = FormDataUtil::getFormDataSource(_salesLine);
        SalesLine localSalesLine = salesLine_ds.getFirst(true) as SalesLine;

        if (localSalesLine)
        {
            while (localSalesLine)
            {
                if ((enableConfirmationButton          == true) && (enablePickingListButton == true)   &&
                    (enablePickingListRegistrateButton == true) && (enablePackingSlipButton == true)   &&
                    (enableInvoiceButton               == true) && (enableProjectPackingSlipButton == true))
                {
                    break;
                }

                checkIfupdate                           = localSalesLine.checkIfUpdate();

                if (!enableConfirmationButton)
                    enableConfirmationButton            = conPeek(checkIfupdate, SalesLineType::posConfirmation());

                if (!enablePickingListButton)
                    enablePickingListButton             = conPeek(checkIfupdate, SalesLineType::posPickingList());

                if (!enablePickingListRegistrateButton)
                    enablePickingListRegistrateButton   = conPeek(checkIfupdate, SalesLineType::posPickingListRegistration());

                if (!enablePackingSlipButton)
                    enablePackingSlipButton             = conPeek(checkIfupdate, SalesLineType::posPackingSlip());

                if (!enableInvoiceButton)
                    enableInvoiceButton                 = conPeek(checkIfupdate, SalesLineType::posInvoice());

                if (!enableProjectPackingSlipButton)
                    enableProjectPackingSlipButton      = conPeek(checkIfupdate, SalesLineType::posProjectPackingSlip());

                localSalesLine = salesLine_ds.getNext() as SalesLine;
            }
        }

        else if (_salesLine)
        {
            checkIfupdate                       = _salesLine.checkIfUpdate();

            enableConfirmationButton            = conPeek(checkIfupdate, SalesLineType::posConfirmation());
            enablePickingListButton             = conPeek(checkIfupdate, SalesLineType::posPickingList());
            enablePickingListRegistrateButton   = conPeek(checkIfupdate, SalesLineType::posPickingListRegistration());
            enablePackingSlipButton             = conPeek(checkIfupdate, SalesLineType::posPackingSlip());
            enableInvoiceButton                 = conPeek(checkIfupdate, SalesLineType::posInvoice());
            enableProjectPackingSlipButton      = conPeek(checkIfupdate, SalesLineType::posProjectPackingSlip());
        }

        if (_buttonUpdateConfirmation)
        {
            _buttonUpdateConfirmation.enabled(enableConfirmationButton);
        }

        if (_buttonUpdatePickingList)
        {
            _buttonUpdatePickingList.enabled(enablePickingListButton);
        }

        if (_buttonUpdatePickingListRegistrate)
        {
            _buttonUpdatePickingListRegistrate.enabled(enablePickingListRegistrateButton);
        }

        if (_buttonUpdatePackingSlip)
        {
            _buttonUpdatePackingSlip.enabled(enablePackingSlipButton);
        }

        if (_buttonUpdateInvoice)
        {
            _buttonUpdateInvoice.enabled(enableInvoiceButton);
        }

        if (_buttonUpdateProjectPackingSlip)
        {
            _buttonUpdateProjectPackingSlip.enabled(enableProjectPackingSlipButton);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveLineCalculatedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the adjusted net amount for the specified sales line.
    /// </summary>
    /// <param name="_salesLineRefRecId">
    ///     Record ID of a sales line record to get the adjusted net amount from.
    /// </param>
    /// <param name="_itemId">
    ///     The ID of the item to use.
    /// </param>
    /// <returns>
    ///     The adjusted net amount.
    /// </returns>
    public PDSCalculatedLineAmount getActiveLineCalculatedAmount(
        SalesLineRefRecId   _salesLineRefRecId,
        ItemId              _itemId = SalesLine::findRecId(_salesLineRefRecId).ItemId)
    {
        PDSCalculatedLineAmount pdsPricingCalculatedLineAmount;

        if (this.shouldCalculatePotencyPricing(_itemId))
        {
            this.initPotencyCacheMap();

            if (pdsPricingCalculatedCache.exists(_salesLineRefRecId))
            {
                pdsPricingCalculatedLineAmount = conPeek(pdsPricingCalculatedCache.lookup(_salesLineRefRecId), CalculatedLineAmount_Idx);
            }
        }

        return pdsPricingCalculatedLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveLineCalculatedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the adjusted unit price if this is an advanced pricing order.
    /// </summary>
    /// <param name="_salesLineRefRecId">
    ///     Record ID of a sales line record to get the adjusted unit price from.
    /// </param>
    /// <param name="_itemId">
    ///     The ID of the item to use.
    /// </param>
    /// <returns>
    ///     The adjusted unit price.
    /// </returns>
    public PDSCalculatedUnitPrice getActiveLineCalculatedUnitPrice(
        SalesLineRefRecId _salesLineRefRecId,
        ItemId            _itemId = SalesLine::findRecId(_salesLineRefRecId).ItemId)
    {
        PDSCalculatedUnitPrice  pdsPricingCalculatedUnitPrice;

        if (this.shouldCalculatePotencyPricing(_itemId))
        {
            this.initPotencyCacheMap();

            if (pdsPricingCalculatedCache.exists(_salesLineRefRecId))
            {
                pdsPricingCalculatedUnitPrice = conPeek(pdsPricingCalculatedCache.lookup(_salesLineRefRecId), CalculatedUnitPrice_Idx);
            }
        }

        return pdsPricingCalculatedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveLineCalculationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the calculation ID if this is an advanced pricing order.
    /// </summary>
    /// <param name="_salesLineRefRecId">
    ///     Record ID of a sales line record to get the calculation ID from.
    /// </param>
    /// <param name="_itemId">
    ///     The ID of the item to use.
    /// </param>
    /// <returns>
    ///     The calculation ID.
    /// </returns>
    public PDSCalculationId getActiveLineCalculationId(
        SalesLineRefRecId _salesLineRefRecId,
        ItemId            _itemId = SalesLine::findRecId(_salesLineRefRecId).ItemId)
    {
        PDSCalculationId pdsPricingCalculatedPriceId;

        if (this.shouldCalculatePotencyPricing(_itemId))
        {
            this.initPotencyCacheMap();

            if (pdsPricingCalculatedCache.exists(_salesLineRefRecId))
            {
                pdsPricingCalculatedPriceId = conPeek(pdsPricingCalculatedCache.lookup(_salesLineRefRecId), CalculatedId_Idx);
            }
        }

        return pdsPricingCalculatedPriceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hideReturnReservationLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifies the <c>SalesLine</c> query to exclude <c>ReturnReservationlines</c>.
    /// </summary>
    /// <param name="_query">
    ///    The <c>SalesLine_ds</c> query from the form.
    /// </param>
    /// <returns>
    ///    The modified <c>SalesLine_ds</c> query.
    /// </returns>
    Query hideReturnReservationLine(Query _query)
    {
        QueryBuildDataSource qbdsSalesLine = _query.dataSourceTable(tableNum(SalesLine));
        int                  statusAwaiting = ReturnStatusLine::Awaiting;

        QueryBuildRange qbrHideReservationLine = qbdsSalesLine.addRange(fieldNum(SalesLine, RecId));
        qbrHideReservationLine.value(strFmt('((%1.%4 != %5) || (%1.%2 < %3)&&(%1.%4 == %5))',
                                                            qbdsSalesLine.name(),               //%1
                                                            fieldStr(SalesLine, ExpectedRetQty),//%2
                                                            0,                                  //%3
                                                            fieldStr(SalesLine, ReturnStatus),  //%4
                                                            statusAwaiting));                   //%5
                                                            qbrHideReservationLine.status(RangeStatus::Hidden);

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    void initParmDefault()
    {
        advancedStartup = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPotencyCacheMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the cache with calculated pricing information in the current sales order.
    /// </summary>
    /// <remarks>
    ///     In regards to sales order lines, this class is typically referenced on a line by line basis. Thus, relevant information may not be available for the sales grid using this
    ///     strategy. Therefore, the cache is filled in one shot by examining the sales order as a whole.
    /// </remarks>
    protected void initPotencyCacheMap()
    {
        if (pdsPricingCalculatedCache == null)
        {
            if (salesTable.SalesId
                &&  salesTable.RecId
                &&  #PDSPotencyEnabled)
            {
                pdsPricingCalculatedCache = Map::create(SalesTableForm::buildPotencyCache(salesTable.SalesId));
            }
            else
            {
                pdsPricingCalculatedCache = new Map(extendedTypeId2Type(extendedTypeNum(SalesLineRefRecId)), Types::Container);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValues</Name>
				<Source><![CDATA[
    void  initValues()
    {
        salesTable.SalesType        = this.defaultSalesType();
        salesTable.ProjId           = this.projId();
        salesTable.CustAccount      = this.custAccount();
        salesTable.InvoiceAccount   = this.invoiceAccount();
        salesTable.LanguageId       = this.languageId();
        salesTable.ReturnStatus     = this.parmReturnStatus();
        salesTable.ReturnItemNum    = this.returnItemNum();
        
        if (this.returnItemNum() && IntrastatCountryRegionParameters::isInEUByIsoCode())
        {
            SalesTable  salesTableLocal;
            select firstonly salesTableLocal
                       where salesTableLocal.ReturnItemNum == this.returnItemNum()
                          && salesTableLocal.SalesType     == SalesType::ReturnItem
                          && salesTableLocal.TransportationDocument;

            if (salesTableLocal)
            {
                TransportationDocument::copy(salesTableLocal, salesTable);
            }
        }

        if (salesTable
            && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            MCRReturnSalesTable mcrReturnSalesTable = salesTable.mcrReturnSalesTable();
            MCRSalesTable mcrSalesTable = salesTable.mcrSalesTable();

            // set values used for exchange order defaulting
            salesType                           = salesTable.SalesType;
            salesTable.WorkerSalesResponsible   = HcmWorker::userId2Worker(curUserId());
            salesTable.SmmCampaignId            = this.parmMCRSmmCampaignId();
            salesTable.ContactPersonId          = this.parmMCRContactPersonID();

            if (mcrSalesTable.SourceId != this.parmMCRSourceId()
                || mcrSalesTable.SmmTMCallListId != this.parmMCRSmmTMCallListID())
            {
                mcrSalesTable.SmmTMCallListId       = this.parmMCRSmmTMCallListID();
                mcrSalesTable.SourceId              = this.parmMCRSourceId();
                salesTable.mcrPackMCRSalesTable(mcrSalesTable);
            }

            if (mcrReturnSalesTable.IsExchange != this.parmMCRIsExchange()
                || mcrReturnSalesTable.OriginalSalesId != this.parmMCROriginalSalesId())
            {
                mcrReturnSalesTable.OriginalSalesId = this.parmMCROriginalSalesId();
                mcrReturnSalesTable.IsExchange      = this.parmMCRIsExchange();
                salesTable.mcrPackMCRReturnSalesTable(mcrReturnSalesTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyAllowIndirectCreationOrig</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the <c>SalesTable</c> form control
    /// <c>InterCompanyAllowIndirectCreationOrig</c> .
    /// </summary>
    /// <param name="_interCompanyAllowIndirectCreationOrig">
    /// An object type that represents the form control.
    /// </param>
    public void interCompanyAllowIndirectCreationOrig(Object _interCompanyAllowIndirectCreationOrig = null)
    {
        _interCompanyAllowIndirectCreationOrig.visible(salesTable.interCompanyAllowIndirectCreationOrig() ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyAutoCreateOrders</Name>
				<Source><![CDATA[
    public void interCompanyAutoCreateOrders(boolean _interCompanyAutoCreateOrdersNow = interCompanyAutoCreateOrdersNow)
    {
        boolean     interCompanyVendorFound;

        interCompanyAutoCreateOrdersNow = _interCompanyAutoCreateOrdersNow;

        if (this.canInterCompanyAutoCreateOrders())
        {
            SalesLine   salesLineLocal;

            // <GIN>
            if (TaxParameters::find().Excise_IN
                || TaxParameters::find().vat_in
                || TaxWithholdParameters_IN::checkTaxParameters())
            {
                while select forceplaceholders salesLineLocal
                      where salesLineLocal.SalesId == salesTable.SalesId
                      &&    salesLineLocal.ItemId  != ''
                {
                    if (salesLineLocal.defaultIntercompanyVendor().interCompanyTradingPartnerCustomer())
                    {
                        interCompanyVendorFound = true;
                        break;
                    }
                }
            }
            else
            // </GIN>
            {
                while select forceplaceholders salesLineLocal
                      where salesLineLocal.SalesId     == salesTable.SalesId
                      &&    salesLineLocal.InventRefId == ''
                      &&    salesLineLocal.ItemId      != ''
                {
                    if (salesLineLocal.defaultIntercompanyVendor().interCompanyTradingRelationActive())
                    {
                        interCompanyVendorFound = true;
                        break;
                    }
                }
            }

            // Don't execute intercompany logic for exchange orders - intercompany processing
            // will happen when the exchange is completed via the
            // returns process or payments are approved or when the last hold
            // is released against it.
            if (interCompanyVendorFound
                && (!salesTable.mcrIsCallCenter() || !salesTable.mcrReturnSalesTable().IsExchange))
            {
                TradeInterCompany::autoCreateOrder(salesTable);
            }
        }

        interCompanyAutoCreateOrdersNow = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInterCompanyAutoCreateOrders</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean canInterCompanyAutoCreateOrders()
    {
        return salesTable.InterCompanyAutoCreateOrders
                &&  salesTable.ReturnStatus != ReturnStatusHeader::Canceled
                &&  salesTable.ReturnStatus != ReturnStatusHeader::Closed
                && (salesTable.CreatedBy  == curUserId() ||
                    salesTable.ModifiedBy == curUserId() ||
                   !SalesTable::find(salesTable.SalesId).InterCompanyAutoCreateOrders)
                &&  SalesTableType::construct(salesTable).canCreatePurchOrder()
                && (!salesTable.existInterCompanySales() || interCompanyAutoCreateOrdersNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyAutoCreateOrdersNow</Name>
				<Source><![CDATA[
    public boolean interCompanyAutoCreateOrdersNow(boolean _interCompanyAutoCreateOrdersNow = interCompanyAutoCreateOrdersNow)
    {
        interCompanyAutoCreateOrdersNow = _interCompanyAutoCreateOrdersNow;

        return interCompanyAutoCreateOrdersNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyClearCache</Name>
				<Source><![CDATA[
    public void interCompanyClearCache()
    {
        interCompanyOriginalSalesCache = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Container);
        interCompanySalesCache         = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyOriginalSalesCache</Name>
				<Source><![CDATA[
    public container interCompanyOriginalSalesCache(SalesTable _salesTable)
    {
        if (!interCompanyOriginalSalesCache.exists(_salesTable.RecId))
        {
            interCompanyOriginalSalesCache.insert(_salesTable.RecId,_salesTable.interCompanyOriginalSalesInfo());
        }
        return interCompanyOriginalSalesCache.lookup(_salesTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySalesCache</Name>
				<Source><![CDATA[
    public container interCompanySalesCache(PurchTable _purchTable)
    {
        if (!interCompanySalesCache.exists(_purchTable.RecId))
        {
            interCompanySalesCache.insert(_purchTable.RecId,_purchTable.interCompanySalesInfo());
        }
        return interCompanySalesCache.lookup(_purchTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySetHeaderAccess</Name>
				<Source><![CDATA[
    public void interCompanySetHeaderAccess(Object _interCompanyAllowIndirectCreationOrig = null,
                                            Object _groupInterCompanyPurchTable           = null,
                                            LogisticsLocation _location = null,
                                            LogisticsPostalAddress _postalAddress = null)
    {
        FormDataSource                      location_ds = _location? FormDataUtil::getFormDataSource(_location) : null;
        FormDataSource                      postalAddress_ds = _postalAddress?FormDataUtil::getFormDataSource(_postalAddress) :null;
        boolean                             isInterCompanyOrder        = salesTable.isInterCompanyOrder();
        boolean                             returnItem                 = salesTable.returnItem();
        boolean                             canCreatePurchaseOrder     = salesTableType.canCreatePurchOrder();
        boolean                             editDisc                   = salesTableType.editDisc();
        boolean                             editDiscPercent            = !CustParameters::find().AutomaticTotalDiscount;
        boolean                             existInterCompanySales     = salesTable.RecId && salesTable.existInterCompanySales();

        if (salesTable.RecId
        &&  salesTable.InterCompanyCompanyId
        &&  salesTable.InterCompanyOriginalSalesId)
        {
            salesTable_ds.allowDelete(this.deleteHeaderAllowed());
        }

        if (_interCompanyAllowIndirectCreationOrig)
        {
            this.interCompanyAllowIndirectCreationOrig(_interCompanyAllowIndirectCreationOrig);
        }

        if (_groupInterCompanyPurchTable)
        {
            _groupInterCompanyPurchTable.visible(salesTable.InterCompanyOrder);
        }

        if (salesTable.RecId
        &&  salesTable.InterCompanyCompanyId
        &&  salesTable.InterCompanyPurchId)
        {
            salesTable_ds.object(fieldNum(SalesTable,SalesType              )).allowEdit(false);
            salesTable_ds.object(fieldNum(SalesTable,ReturnReasonCodeId     )).allowEdit(false);

            salesTable_ds.object(fieldNum(SalesTable,DeliveryDateControlType)).allowEdit(true);
            salesTable_ds.object(fieldNum(SalesTable,ReceiptDateRequested   )).allowEdit(false);
            salesTable_ds.object(fieldNum(SalesTable,ShippingDateRequested  )).allowEdit(false);

            salesTable_ds.object(fieldNum(SalesTable,DeliveryPostalAddress  )).allowEdit(false);
            if (location_ds)
            {
                location_ds.allowEdit(false);
            }
            if (postalAddress_ds)
            {
                postalAddress_ds.allowEdit(false);
            }
        }
        else
        {
            salesTable_ds.object(fieldNum(SalesTable, SalesType             )).allowEdit(this.editSalesType() && salesTableType.editSalesType());
            salesTable_ds.object(fieldNum(SalesTable,ReturnReasonCodeId     )).allowEdit(true);

            salesTable_ds.object(fieldNum(SalesTable,ReceiptDateRequested   )).allowEdit(true);
            salesTable_ds.object(fieldNum(SalesTable,ShippingDateRequested  )).allowEdit(true);

            salesTable_ds.object(fieldNum(SalesTable,DeliveryDateControlType)).allowEdit(true);
            salesTable_ds.object(fieldNum(SalesTable,DeliveryPostalAddress  )).allowEdit(true);
            if (location_ds)
            {
                location_ds.allowEdit(true);
            }
            if (postalAddress_ds)
            {
                postalAddress_ds.allowEdit(true);
            }
        }

        if (salesTable.RecId
        &&  existInterCompanySales)
        {
            salesTable_ds.object(fieldNum(SalesTable,InterCompanyAutoCreateOrders)).allowEdit(canCreatePurchaseOrder);
            salesTable_ds.object(fieldNum(SalesTable,InterCompanyDirectDelivery  )).allowEdit(canCreatePurchaseOrder
                                                                                           && salesTable.SalesType != SalesType::ItemReq
                                                                                           && salesTable.existInterCompanySales(true));
        }
        else
        {
            salesTable_ds.object(fieldNum(SalesTable,InterCompanyAutoCreateOrders)).allowEdit(true);
            salesTable_ds.object(fieldNum(SalesTable,InterCompanyDirectDelivery  )).allowEdit(salesTable.SalesType != SalesType::ItemReq);
        }

        if (salesTable.RecId
        &&  salesTable.InterCompanyDirectDelivery
        &&  existInterCompanySales)
        {
            salesTable_ds.object(fieldNum(SalesTable,ReceiptDateConfirmed        )).allowEdit(false);
            salesTable_ds.object(fieldNum(SalesTable,ShippingDateConfirmed       )).allowEdit(false);
        }
        else
        {
            salesTable_ds.object(fieldNum(SalesTable,ReceiptDateConfirmed        )).allowEdit(true);
            salesTable_ds.object(fieldNum(SalesTable,ShippingDateConfirmed       )).allowEdit(true);
        }

        salesTable_ds.object(fieldNum(SalesTable,PriceGroupId)  ).enabled(editDisc);
        salesTable_ds.object(fieldNum(SalesTable,MultiLineDisc) ).enabled(editDisc && !isInterCompanyPurchaseOrderInvoiceMatched);
        salesTable_ds.object(fieldNum(SalesTable,EndDisc)       ).enabled(editDisc && !isInterCompanyPurchaseOrderInvoiceMatched);
        salesTable_ds.object(fieldNum(SalesTable,LineDisc)      ).enabled(editDisc);
        salesTable_ds.object(fieldNum(SalesTable,MarkupGroup)   ).enabled(editDisc && !isInterCompanyPurchaseOrderInvoiceMatched);

        if (isInterCompanyOrder || returnItem)
        {
            InterCompanyEndpointActionPolicy interCompanyEndpointActionPolicy = salesTable.interCompanyEndpointActionPolicy();
            salesTable_ds.object(fieldNum(SalesTable,DiscPercent)).allowEdit(editDiscPercent && editDisc && interCompanyEndpointActionPolicy.EditPrice
                && !isInterCompanyPurchaseOrderInvoiceMatched);
        }
        else
        {
            salesTable_ds.object(fieldNum(SalesTable,DiscPercent)).allowEdit(editDiscPercent && editDisc && !isInterCompanyPurchaseOrderInvoiceMatched);
        }

        salesTable_ds.object(fieldNum(SalesTable, DefaultDimension)).allowEdit(!isInterCompanyPurchaseOrderInvoiceMatched);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySetPriceDiscountLineAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets <c>allowEdit</c> on price and discount fields of a <c>SalesLine</c> datasource,
    /// depending on whether it's an intercompany order and/or a return item.
    /// </summary>
    /// <param name = "_salesLine">The <c>SalesLine</c> record.</param>
    /// <param name = "_salesLine_ds">The <c>SalesLine</c> datasource.</param>
    /// <param name = "_isInterCompanyOrder">Whether the order is an intercompany order.</param>
    /// <param name = "_returnItem">Whether the item is a return item.</param>
    /// <param name = "_isICPOLineInvoiceMatched">Whether a related intercompany purchase order line was partially or fully invoiced.</param>
    protected void interCompanySetPriceDiscountLineAccess(SalesLine      _salesLine,
                                                          FormDataSource _salesLine_ds,
                                                          boolean        _isInterCompanyOrder,
                                                          boolean        _returnItem,
                                                          boolean        _isICPOLineInvoiceMatched)
    {
        if (_isInterCompanyOrder || _returnItem)
        {
            InterCompanyEndpointActionPolicy interCompanyEndpointActionPolicy = salesTable.interCompanyEndpointActionPolicy();
            _salesLine_ds.object (fieldNum(SalesLine, SalesPrice    )).allowEdit(interCompanyEndpointActionPolicy.EditPrice    && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, PriceUnit     )).allowEdit(interCompanyEndpointActionPolicy.EditPrice    && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LineAmount    )).allowEdit(interCompanyEndpointActionPolicy.EditPrice    && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, SalesMarkup   )).allowEdit(interCompanyEndpointActionPolicy.EditPrice    && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LineDisc      )).allowEdit(interCompanyEndpointActionPolicy.EditDiscount && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LinePercent   )).allowEdit(interCompanyEndpointActionPolicy.EditDiscount && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, MultiLnDisc   )).allowEdit(interCompanyEndpointActionPolicy.EditDiscount && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, MultiLnPercent)).allowEdit(interCompanyEndpointActionPolicy.EditDiscount && !_isICPOLineInvoiceMatched);
        }
        else
        {
            _salesLine_ds.object (fieldNum(SalesLine, SalesPrice    )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, PriceUnit     )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LineAmount    )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries
                                                                                    && !_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, SalesMarkup   )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LineDisc      )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, LinePercent   )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, MultiLnDisc   )).allowEdit(!_isICPOLineInvoiceMatched);
            _salesLine_ds.object (fieldNum(SalesLine, MultiLnPercent)).allowEdit(!_isICPOLineInvoiceMatched);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySetLineAccess</Name>
				<Source><![CDATA[
    public void interCompanySetLineAccess(SalesLine              _salesLine,
                                          LogisticsLocation      _location      = null,
                                          LogisticsPostalAddress _postalAddress = null,
                                          Object                 _address       = null,
                                          Object                 _lineAddress   = null)
    {
        FormDataSource                      location_ds;
        FormDataSource                      postalAddress_ds;

        boolean                             isInterCompanyOrder        = salesTable.isInterCompanyOrder();
        boolean                             returnItem                 = salesTable.returnItem();
        boolean                             isICPOLineInvoiceMatched   = _salesLine.isInterCompanyOrderLineInvoiceMatched();
        boolean                             isDDPOLineInvoiceMatched   = _salesLine.isDropShipmentPOLineInvoiceMatched();
        boolean                             isRelatedPOLineInvoiceMatched = isICPOLineInvoiceMatched || isDDPOLineInvoiceMatched;

        if (FormDataUtil::getFormDataSource(_salesLine))
        {
            FormDataSource salesLine_ds = FormDataUtil::getFormDataSource(_salesLine);
            if (_location && FormDataUtil::getFormDataSource(_location))
            {
                location_ds  = FormDataUtil::getFormDataSource(_location);
            }
            if (_postalAddress && FormDataUtil::getFormDataSource(_postalAddress))
            {
                postalAddress_ds = FormDataUtil::getFormDataSource(_postalAddress);
            }

            if ((isInterCompanyOrder && _salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
            ||   returnItem)
            {
                salesLine_ds.object(fieldNum(SalesLine,SalesQty               )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,ExpectedRetQty         )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,SalesUnit              )).allowEdit(false);
            }
            else
            {
                salesLine_ds.object(fieldNum(SalesLine,SalesQty               )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries
                                                                                           && !isRelatedPOLineInvoiceMatched);
                salesLine_ds.object(fieldNum(SalesLine,ExpectedRetQty         )).allowEdit(!isRelatedPOLineInvoiceMatched);
                salesLine_ds.object(fieldNum(SalesLine,SalesUnit              )).allowEdit(_salesLine.LineDeliveryType == LineDeliveryType::OrderLine && !isRelatedPOLineInvoiceMatched);
            }
            if (isInterCompanyOrder
            &&  salesTable.InterCompanyDirectDeliveryOrig
            &&  _salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
            {
                salesLine_ds.object(fieldNum(SalesLine,OverDeliveryPct        )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,UnderDeliveryPct       )).allowEdit(false);
            }
            else
            {
                salesLine_ds.object(fieldNum(SalesLine,OverDeliveryPct        )).allowEdit(true);
                salesLine_ds.object(fieldNum(SalesLine,UnderDeliveryPct       )).allowEdit(true);
            }

            if (isInterCompanyOrder && _salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
            {
                salesLine_ds.object(fieldNum(SalesLine,DeliveryDateControlType)).allowEdit(true);
                salesLine_ds.object(fieldNum(SalesLine,ReceiptDateRequested   )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,ShippingDateRequested  )).allowEdit(false);

                salesLine_ds.object(fieldNum(SalesLine,DeliveryPostalAddress  )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,DeliveryName           )).allowEdit(false);
                if (postalAddress_ds)
                {
                    postalAddress_ds.allowEdit(false);
                }
                if (location_ds)
                {
                    location_ds.allowEdit(false);
                }

                if (_address)
                {
                    _address                                                    .enabled  (false);
                }
                if (_lineAddress)
                {
                    _lineAddress                                                .enabled  (false);
                }
            }
            else
            {
                salesLine_ds.object(fieldNum(SalesLine,DeliveryDateControlType)).allowEdit(true);
                salesLine_ds.object(fieldNum(SalesLine,ReceiptDateRequested   )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
                salesLine_ds.object(fieldNum(SalesLine,ShippingDateRequested  )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);

                if (postalAddress_ds)
                {
                    postalAddress_ds.allowEdit(true);
                }
                if (location_ds)
                {
                    location_ds.allowEdit(true);
                }

                salesLine_ds.object(fieldNum(SalesLine, DeliveryName)).allowEdit(!returnItem);
                if (salesLine_ds.object(fieldNum(SalesLine,DeliveryPostalAddress)))
                {
                    salesLine_ds.object(fieldNum(SalesLine, DeliveryPostalAddress)).allowEdit(!returnItem && !isRelatedPOLineInvoiceMatched);
                }

                if (_address)
                {
                    _address                                                    .enabled  (true);
                }
                if (_lineAddress)
                {
                    _lineAddress                                                .enabled  (true);
                }
            }

            if ((salesTable.InterCompanyDirectDelivery
              && _salesLine.RecId
              && _salesLine.InventRefTransId
              && SalesLine::findInventTransId(_salesLine.InventRefTransId).InterCompanyInventTransId)
            ||   returnItem)
            {
                salesLine_ds.object(fieldNum(SalesLine,ReceiptDateConfirmed   )).allowEdit(false);
                salesLine_ds.object(fieldNum(SalesLine,ShippingDateConfirmed  )).allowEdit(false);
            }
            else
            {
                salesLine_ds.object(fieldNum(SalesLine,ReceiptDateConfirmed   )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
                salesLine_ds.object(fieldNum(SalesLine,ShippingDateConfirmed  )).allowEdit(_salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            }

            this.interCompanySetPriceDiscountLineAccess(_salesLine, salesLine_ds, isInterCompanyOrder, returnItem, isICPOLineInvoiceMatched);

            boolean isLineWithMultipleDeliveries = _salesLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries;
            salesLine_ds.object(fieldNum(SalesLine, SalesDeliverNow)).allowEdit(_salesLine.DeliveryType != TradeLineDlvType::DropShip
                                                                                && !isLineWithMultipleDeliveries
                                                                                && !_salesLine.returnItem());
            salesLine_ds.object(fieldNum(SalesLine, DeliveryType)).allowEdit(!isLineWithMultipleDeliveries);
            salesLine_ds.object(fieldNum(SalesLine, SourcingVendAccount)).allowEdit(!isLineWithMultipleDeliveries);

            this.adjustLineAccessBasedOnItem(_salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccount</Name>
				<Source><![CDATA[
    CustInvoiceAccount  invoiceAccount(CustInvoiceAccount  _invoiceAccount = invoiceAccount)
    {
        invoiceAccount = _invoiceAccount;
        return invoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvanced</Name>
				<Source><![CDATA[
    boolean isAdvanced(boolean _advancedStartup = advancedStartup)
    {
        advancedStartup = _advancedStartup;

        return advancedStartup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemPotencyEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets whether the specified item is potency enabled.
    /// </summary>
    /// <param name="_itemId">
    ///     The ID of the item selected.
    /// </param>
    /// <returns>
    ///     true if the item is potency-enabled; otherwise, false.
    /// </returns>
    protected boolean isItemPotencyEnabled(ItemId _itemId)
    {
        boolean enabled = false;

        if (_itemId)
        {
            if (itemPotencyPricingEnabled.exists(_itemId))
            {
                enabled = itemPotencyPricingEnabled.lookup(_itemId);
            }
            else
            {
                enabled = (InventTable::find(_itemId).pdsBaseAttributeId != '');
                itemPotencyPricingEnabled.insert(_itemId, enabled);
            }
        }
        return enabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>languageId</Name>
				<Source><![CDATA[
    CustLanguageId  languageId(CustLanguageId _languageId = languageId)
    {
        languageId = _languageId;
        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    DataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    private IdentifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueElementName
    IdentifierName lastValueElementName()
    {
        return formStr(SalesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueType
    private UtilElementType lastValueType()
    {
        return UtilElementType::Form;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueUserId
    private UserId lastValueUserId()
    {
        return curUserId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkActive</Name>
				<Source><![CDATA[
    boolean linkActive()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInterfaceName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the class name for special processing needed for templates.
    /// </summary>
    /// <returns>
    ///     The class name.
    /// </returns>
    public ClassName mcrInterfaceName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustFormResearchAfterDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the form must be researched after deleting the currently selected order line.
    /// </summary>
    /// <param name="_salesLine">
    /// The currently selected sales order line.
    /// </param>
    /// <param name="_anyMarked">
    /// Specifies if any records are marked on the form datasource.
    /// </param>
    /// <returns>
    /// true for order lines with multiple deliveries; otherwise, false.
    /// </returns>
    public boolean mustFormResearchAfterDelete(SalesLine _salesLine, boolean _anyMarked = false)
    {
        // <GEEU>
        #ISOCountryRegionCodes

        boolean ret = _salesLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL, #isoHU, #isoCZ, #isoLT, #isoLV, #isoEE]))
        {
            ret = ret || (_salesLine.CreditNoteInternalRef_PL && !_anyMarked);
        }

        return ret;
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void  new(Common _source)
    {
        if (_source.TableId == tableNum(SalesTable))
        {
            salesTable                  = _source as SalesTable;
        }
        itemPotencyPricingEnabled   = new Map(Types::String, Types::Integer);

        this.interCompanyClearCache();
        lineInstanceCache = SalesTableFormLineInstanceCache::construct();

        xSysLastValue::getLast(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRContactPersonID</Name>
				<Source><![CDATA[
    public ContactPersonId parmMCRContactPersonID(ContactPersonId _contactPersonId = contactPersonId)
    {
        contactPersonId = _contactPersonId;
        return contactPersonId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRIsExchange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and returns the class' exchange flag.
    /// </summary>
    /// <param name="_mcrIsExchange">
    ///     The value to set the class' exchange flag.
    /// </param>
    /// <returns>
    ///     The class' exchange flag.
    /// </returns>
    public NoYes parmMCRIsExchange(NoYes  _mcrIsExchange = mcrIsExchange)
    {
        mcrIsExchange = _mcrIsExchange;
        return mcrIsExchange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROriginalDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and gets the original delivery mode.
    /// </summary>
    /// <param name="_dlvMode">
    ///     The value to set the class' delivery mode.
    /// </param>
    /// <returns>
    ///     The class' delivery mode.
    /// </returns>
    public CustDlvModeId  parmMCROriginalDlvMode(CustDlvModeId  _dlvMode = dlvMode)
    {
        dlvMode = _dlvMode;
        return dlvMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROriginalSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and returns the original sales Id.
    /// </summary>
    /// <param name="_originalSalesId">
    ///     The value of the original sales id.
    /// </param>
    /// <returns>
    ///     The original sales id.
    /// </returns>
    public SalesId parmMCROriginalSalesId(SalesId  _originalSalesId = originalSalesId)
    {
        originalSalesId = _originalSalesId;
        return originalSalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRSmmCampaignId</Name>
				<Source><![CDATA[
    public smmCampaignId parmMCRSmmCampaignId(smmCampaignId _smmCampaignId = smmCampaignId)
    {
        smmCampaignId = _smmCampaignId;
        return smmCampaignId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRSmmTMCallListID</Name>
				<Source><![CDATA[
    public smmTMCallListID parmMCRSmmTMCallListID(smmTMCallListID _smmTMCallListID = smmTMCallListID)
    {
        smmTMCallListID = _smmTMCallListID;
        return smmTMCallListID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRSourceId</Name>
				<Source><![CDATA[
    public MCRSourceID  parmMCRSourceId(MCRSourceID  _mcrSourceID = mcrSourceID)
    {
        mcrSourceID = _mcrSourceID;
        return mcrSourceID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnStatus</Name>
				<Source><![CDATA[
    public ReturnStatusHeader parmReturnStatus(ReturnStatusHeader _returnStatus = returnStatus)
    {
        returnStatus = _returnStatus;

        return returnStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetHeaderAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the editable property of the process industries related sales table header fields.
    /// </summary>
    public void pdsSetHeaderAccess()
    {
        salesTable_ds.object(fieldNum(SalesTable, PdsBatchAttribAutoRes)).allowEdit(salesTable.canEditPdsBatchAttribAutoRes());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetLineAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the editable property of the process industries related sales table line fields.
    /// </summary>
    /// <param name="_salesLine">
    /// The <c>SalesLine</c> record for which to set the fields.
    /// </param>
    public void pdsSetLineAccess(SalesLine _salesLine)
    {
        FormDataSource  ds = FormDataUtil::getFormDataSource(_salesLine);

        ds.object(fieldNum(SalesLine, PdsBatchAttribAutoRes)).allowEdit(_salesLine.canEditPdsBatchAttribAutoRes());
        ds.object(fieldNum(SalesLine, PdsExcludeFromRebate)).allowEdit(lineInstanceCache.getPdsAllowEditRebate(_salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetLineAccessKeepSalesQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the editable property of the process industries related fields on the sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The <c>SalesLine</c> record for which to set the fields.
    /// </param>
    public void pdsSetLineAccessKeepSalesQty(SalesLine _salesLine)
    {
        FormDataSource ds = FormDataUtil::getFormDataSource(_salesLine);
        boolean salesQtyAllowEdit = ds.object(fieldNum(SalesLine, SalesQty)).allowEdit();
        
        this.pdsSetLineAccess(_salesLine);

        if (!salesQtyAllowEdit)
        {
            ds.object(fieldNum(SalesLine, SalesQty)).allowEdit(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCreateLineAllowed_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a sales order line creation is allowed.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales order line.
    /// </param>
    /// <param name="_returnValue">
    /// The result of the <c>createLineAllowed</c> method.
    /// </param>
    /// <returns>
    /// True if it is allowed; otherwise, false.
    /// </returns>
    public boolean postCreateLineAllowed_BR(SalesLine _salesLine,
                                            boolean _returnValue = 0)
    {
        if (salesTable.salesTable_BR().InvoiceRefRecID_BR)
        {
            _returnValue = false;
        }

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDeleteLineAllowed_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a sales order line deletion is allowed.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales order line.
    /// </param>
    /// <param name="_returnValue">
    /// The result of the <c>deleteLineAllowed</c> method.
    /// </param>
    /// <returns>
    /// True if it is allowed; otherwise, false.
    /// </returns>
    public boolean postDeleteLineAllowed_BR(SalesLine _salesLine,
                                            boolean _returnValue = 0)
    {
        if (salesTable.salesTable_BR().InvoiceRefRecID_BR)
        {
            _returnValue = false;
        }

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEditHeaderAllowed_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a sales order header edition is allowed.
    /// </summary>
    /// <param name="_returnValue">
    /// The result of the <c>editHeaderAllowed</c> method.
    /// </param>
    /// <returns>
    /// True if it is allowed; otherwise, false.
    /// </returns>
    public boolean postEditHeaderAllowed_BR(boolean _returnValue = 0)
    {
        if (salesTable.salesTable_BR().InvoiceRefRecID_BR)
        {
            _returnValue = false;
        }

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEditLineAllowed_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a sales order line edition is allowed.
    /// </summary>
    /// <param name="_returnValue">
    /// The result of the <c>editLineAllowed</c> method.
    /// </param>
    /// <returns>
    /// True if it is allowed; otherwise, false.
    /// </returns>
    public boolean postEditLineAllowed_BR(boolean _returnValue = 0)
    {
        if (salesTable.salesTable_BR().InvoiceRefRecID_BR)
        {
            _returnValue = false;
        }

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>project</Name>
				<Source><![CDATA[
    boolean project()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    ProjId  projId(ProjId  _projId = projId)
    {
        projId = _projId;
        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>querySalesLine</Name>
				<Source><![CDATA[
    Query querySalesLine(Query querySalesLine)
    {
        querySalesLine = this.hideReturnReservationLine(querySalesLine);
        return querySalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>querySalesTable</Name>
				<Source><![CDATA[
    Query querySalesTable(Query querySalesTable)
    {
        return querySalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculatePotencyPricingCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Recalculate the potency cached values of the selected sales line.
    /// </summary>
    /// <param name="_salesLineRefRecId">
    ///     Record ID of the sales line currently selected.
    /// </param>
    /// <param name="_itemId">
    ///     Item ID as found on the sales line record specified by <paramref name="_salesLineRefRecId"/>.
    /// </param>
    public void recalculatePotencyPricingCache(SalesLineRefRecId _salesLineRefRecId, ItemId _itemId)
    {
        if (_salesLineRefRecId && this.shouldCalculatePotencyPricing(_itemId))
        {
            this.initPotencyCacheMap();

            //passing the recId as the buffer is fetched on the client
            pdsPricingCalculatedCache.insert(_salesLineRefRecId, SalesLine::getSalesLinePotencyPricingDetails(_salesLineRefRecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshDeliverySchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the delivery schedule when the order or delivery line was modified.
    /// </summary>
    /// <param name="_salesLine">
    /// The changed sales order line.
    /// </param>
    /// <param name="_resetPriceOnOrderLine">
    /// A Boolean value that indicates whether to recalculate the price on the order line.
    /// </param>
    /// <remarks>
    /// This method is overloaded on the <c>SalesTableForm_DlvScheduleSyncEnabled</c> class. When this
    /// method is called on this base class, it does nothing.
    /// </remarks>
    void refreshDeliverySchedule(SalesLine _salesLine, boolean _resetPriceOnOrderLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>replacementOrder</Name>
				<Source><![CDATA[
    boolean replacementOrder(boolean _replacementOrder = replacementOrder)
    {
        replacementOrder = _replacementOrder;
        return replacementOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetSalesLine</Name>
				<Source><![CDATA[
    public void resetSalesLine(SalesLine _salesLine)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            MCRSalesLine mcrSalesLine = newlyCreatedSalesLine.mcrSalesLine();
            mcrSalesLine.SourceId = _salesLine.mcrSalesLine().SourceId;
            newlyCreatedSalesLine.mcrPackMCRSalesLine(mcrSalesLine);
        }

        LineNum lineNumber = _salesLine.LineNum;
        _salesLine.data(newlyCreatedSalesLine);
        _salesLine.LineNum = lineNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnItemNum</Name>
				<Source><![CDATA[
    SalesReturnItemNum  returnItemNum(SalesReturnItemNum  _returnItemNum = returnItemNum)
    {
        returnItemNum = _returnItemNum;
        return returnItemNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine_Create</Name>
				<Source><![CDATA[
    public void salesLine_Create(SalesLine _salesLine)
    {
        this.setNewlyCreatedSalesLine(_salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine_validateWrite</Name>
				<Source><![CDATA[
    boolean salesLine_validateWrite(SalesLine _salesLine, InventDim _inventDim)
    {
        boolean     ret = true;

        if (!_salesLine.RecId && this.useAlternativeItem())
        {
            ret = !_salesLine.createAlternativeItem(_inventDim, newlyCreatedSalesLine);
        }

        if (ret
            && _salesLine.SalesQty
            && _salesLine.Reservation == ItemReservation::Automatic
            && _salesLine.isStocked()
            && !_salesLine.mcrSalesLineDropShipment().DropShipment)
        {
            SalesQty salesQty = _salesLine.SalesQty;
            ret = InventMovement::setAutoReserving(_salesLine);
            if (ret && salesQty != _salesLine.SalesQty)
            {
                SalesLine::modifySalesQty(_salesLine,_inventDim);
            }
            //
            // rewrite the inventory dimension here
            //
            else if (ret && _inventDim.InventDimId != _salesLine.InventDimId)
            {
                _inventDim.data(_salesLine.inventDim());
            }
        }

        // In case override price dialog start first and in waiting stage, make sure salesLine.QtyOrdered is correct when datasouce leave action get started and blocked dialog.
        if (ret && _salesLine.calcQtyOrdered() != _salesLine.QtyOrdered)
        {
            SalesLine::modifySalesQty(_salesLine, _inventDim);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine_Write</Name>
				<Source><![CDATA[
    void salesLine_Write(SalesLine salesLine)
    {
        if (salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            InventMovement::bufferSetRemainQty(salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable</Name>
				<Source><![CDATA[
    SalesTable  salesTable(SalesTable  _salesTable = salesTable)
    {
        salesTable     = _salesTable;
        salesTable_ds  = FormDataUtil::getFormDataSource(_salesTable);
        salesTableType = salesTable.type();

        isInterCompanyPurchaseOrderInvoiceMatched = salesTable.isInterCompanyPOInvoiceMatched();

        lineInstanceCache = SalesTableFormLineInstanceCache::construct();
        this.interCompanyClearCache();
        shouldEstimateBeCalculated      = false;
        shouldEstimateBeCalculatedIsSet = false;
        pdsPricingCalculatedCache       = null;
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>SalesTable_BR</c> parameter.
    /// </summary>
    /// <param name="_salesTable_BR">
    /// <c>SalesTable_BR</c> table buffer
    /// </param>
    /// <returns>
    ///    The value of the <c>SalesTable_BR</c> parameter.
    /// </returns>
    public SalesTable_BR salesTable_BR(SalesTable_BR _salesTable_BR = salesTable_BR)
    {
        salesTable_BR     = _salesTable_BR;
        salesTable_BR_ds  = FormDataUtil::getFormDataSource(_salesTable_BR);

        return salesTable_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewlyCreatedSalesLine</Name>
				<Source><![CDATA[
    protected void setNewlyCreatedSalesLine(SalesLine _newlyCreatedSalesLine)
    {
        newlyCreatedSalesLine.data(_newlyCreatedSalesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTouched</Name>
				<Source><![CDATA[
    void setTouched(SalesTable _salesTable)
    {
        if (_salesTable.Touched == NoYes::Yes)
        {
            return;
        }

        // We're only caching the shouldEstimateBeCalculated flag related to the SalesTable class member.
        if (_salesTable.SalesId != salesTable.SalesId
            && _salesTable.custTable_CustAccount().shouldEstimateBeCalculated())
        {
            _salesTable.Touched = NoYes::Yes;
            return;
        }

        if (!shouldEstimateBeCalculatedIsSet)
        {
            shouldEstimateBeCalculated      = _salesTable.custTable_CustAccount().shouldEstimateBeCalculated();
            shouldEstimateBeCalculatedIsSet = true;
        }

        if (shouldEstimateBeCalculated)
        {
            _salesTable.Touched = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculatePotencyPricing</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the specified item ID should have potency pricing information calculated.
    /// </summary>
    /// <param name="_itemId">
    ///     Item ID to determine whether potency pricing information should be calculated.
    /// </param>
    /// <returns>
    ///     true if the item is potency-pricing enabled; otherwise, false.
    /// </returns>
    protected boolean shouldCalculatePotencyPricing(ItemId _itemId)
    {
        return (#PDSPotencyEnabled && _itemId && this.isItemPotencyEnabled(_itemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsDisplayRouteCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the Route associated with the Sales order, if applicable.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <param name="_refreshCache">
    /// A Boolean value that indicates whether to cache should be refreshed for the sales order record; optional.
    /// </param>
    /// <returns>
    /// The Route code if there is only one associated with the order, otherwise an empty string or "Multiple".
    /// </returns>
    public TMSRouteCode tmsDisplayRouteCode(SalesTable _salesTable, boolean _refreshCache = false)
    {
        SalesId             key = _salesTable.SalesId;
        TMSRouteCode        tmsDisplayRoute;

        if (key)
        {
            if (!mapTmsDisplayRoute)
            {
                mapTmsDisplayRoute = new Map(Types::String, Types::String);
            }

            if (!_refreshCache && mapTmsDisplayRoute.exists(key))
            {
                tmsDisplayRoute = mapTmsDisplayRoute.lookup(key);
            }
            else
            {
                tmsDisplayRoute = _salesTable.tmsDisplayRoute();
                mapTmsDisplayRoute.insert(key, tmsDisplayRoute);
            }
        }

        return tmsDisplayRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean  unpack(container  packedClass)
    {
        boolean ret;

        if (typeOf(conPeek(packedClass,1)) != Types::Integer)
        {
            advancedStartup = conPeek(packedClass,1);
            ret = true;
        }
        else
        {
            Integer version = conPeek(packedClass,1);

            switch (version)
            {
                case #CurrentVersion:
                    [version, #CurrentList] = packedClass;
                    ret = true;
                    break;
                default:
                    ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAlternativeItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Controls whether the item in question should be replaced with alternative item set up in the Item
    ///    details form.
    /// </summary>
    /// <returns>
    ///    True.
    /// </returns>
    /// <remarks>
    ///    As a rule the alternative item setup made in the Item details form should be used.In special cases,
    ///    in example for return orders, this default behavior can be overridden.
    /// </remarks>
    public boolean useAlternativeItem()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPotencyCache</Name>
				<Source><![CDATA[
    private static container buildPotencyCache(SalesId _salesId)
    {
        PDSSalesLinePricingCalculation  salesPricingCalculation;
        SalesLine                       salesLine;
        InventTable                     inventTable;

        // The container will be in the format: [pdsPricingCalculatedId, pdsPricingCalculatedLineAmount, pdsPricingCalculatedUnitPrice]
        Map pdsPricingCalculatedCache = new Map(extendedTypeId2Type(extendedTypeNum(SalesLineRefRecId)), Types::Container);

        while select RecId from salesLine
            where salesLine.SalesId == _salesId
        exists join inventTable
            where inventTable.ItemId == salesLine.ItemId &&
                    inventTable.pdsBaseAttributeId != ''
        exists join salesPricingCalculation
            where salesPricingCalculation.SalesLine == salesLine.RecId
        {
            pdsPricingCalculatedCache.insert(salesLine.RecId, SalesLine::getSalesLinePotencyPricingDetails(salesLine.RecId));
        }

        return pdsPricingCalculatedCache.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    // <remarks>
    // Add a post-method handler for returning the right value when extending the <c>SalesTableFormId</c> enumeration.
    // </remarks>
    public static SalesTableForm  construct(SalesTableFormId  _salesTableFormId, Common _source)
    {
        SalesTableForm      salesTableForm;

        switch (_salesTableFormId)
        {
            case  SalesTableFormId::MCRCampaign          : return new MCRSalesTableForm_Campaign            (_source);
            case  SalesTableFormId::MCRTelemarketing     : return new MCRSalesTableForm_TM                  (_source);

            case SalesTableFormId::Journal          : salesTableForm = new SalesTableForm_Journal               (_source); break;
            case SalesTableFormId::Project          : salesTableForm = new SalesTableForm_Project               (_source); break;
            case SalesTableFormId::InterCompany     : salesTableForm = new SalesTableForm_InterCompany          (_source); break;
            case SalesTableFormId::ProjectSalesItem : salesTableForm = new SalesTableForm_ProjectSalesItem      (_source); break;
            case SalesTableFormId::ReturnOrder      : salesTableForm = new SalesTableForm_Return                (_source); break;
            case SalesTableFormId::DeliverySchedule : salesTableForm = new SalesTableForm_DeliverySchedule      (_source); break;
            default                                 : salesTableForm = new SalesTableForm_DlvScheduleSyncEnabled(_source); break;
        }

        return salesTableForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementLinkServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an agreement link for the given <c>SalesLine</c>.
    /// </summary>
    /// <param name="_salesLine">
    /// The currently selected <c>SalesLine</c> record.
    /// </param>
    /// <param name="_agreementLine">
    /// The <c>AgreementLine</c> to be linked to the given <c>SalesLine</c>.
    /// </param>
    public static void createAgreementLinkServer(SalesLine _salesLine, AgreementLine _agreementLine)
    {
        // Update release line fields using agreement line settings
        _salesLine.initFromAgreementLine(_agreementLine);

        // Remove all PriceDiscChangePolicies as now release line is under agreement control
        _salesLine.clearAllPriceDiscChangePolicies();

        // When the user manually creates a link to an agreement line, then also enable automatic (re)linking of agreement lines
        _salesLine.AgreementSkipAutoLink = NoYes::No;

        // Update line
        _salesLine.update();

        // Create relation entity between released sales line and agreement line
        _salesLine.type().associateWithAgreementLine();

        if (_salesLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            AgreementLineReleasedLine agreementLineReleasedSalesLine = AgreementLineReleasedLine::findBySalesLine(_salesLine);
            if (agreementLineReleasedSalesLine)
            {
                // Create relation entities to agreement line
                // for all delivery lines
                agreementLineReleasedSalesLine.linkSalesDeliverySchedule();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void  main(Args  args)
    {
        if (args.parmEnumType() == enumNum(SalesTableMode))
        {
            new MenuFunction(menuitemDisplayStr(SalesTable), MenuItemType::Display).run(args);
        }
        else
        {
            new MenuFunction(menuitemDisplayStr(SalesTable), MenuItemType::Display).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCompleteMarkupTransCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Begins the process of order completion, if order completion is allowed.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales order record on which to begin the process of completion.
    /// </param>
    public static void mcrCompleteMarkupTransCalc(SalesTable _salesTable)
    {
        // only calc the total if the order is in an open status.
        //       All other statuses do not need to recalculate the coupon amount.
        if (_salesTable.SalesStatus == SalesStatus::Backorder)
        {
            ttsbegin;
            _salesTable.selectForUpdate(true);
            
            // Calculate total discount
            _salesTable.updateFinalDisc();

            // Update the estimated amount if needed.
            _salesTable.setEstimate();
            _salesTable.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrEnableOrderHoldsButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order holds button on the sales order form should be enabled or disabled.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record used to determine whether the order holds button
    /// should be enabled or disabled.
    /// </param>
    /// <returns>
    /// true when the order holds button should be enabled; otherwise, false.
    /// </returns>
    public static boolean mcrEnableOrderHoldsButton(SalesTable _salesTable)
    {
        SalesLine                   salesLine;
        MCRSalesLineDropShipment    mcrSalesLineDropShipment;

        boolean enable = _salesTable.SalesStatus == SalesStatus::Backorder;

        if (enable)
        {
            //Order holds button should be disabled when there is already
            //a purchase order create through direct delivery.
            select firstonly RecId from salesLine
                where salesLine.SalesId == _salesTable.SalesId
                exists join mcrSalesLineDropShipment
                where mcrSalesLineDropShipment.SalesLine == salesLine.RecId
                && (mcrSalesLineDropShipment.DropShipStatus == MCRDropShipStatus::POCreated
                    || mcrSalesLineDropShipment.DropShipStatus == MCRDropShipStatus::POReleased
                    || mcrSalesLineDropShipment.DropShipStatus == MCRDropShipStatus::POShipped);
            enable = salesLine.RecId == 0;
        }

        return enable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrEnableOrderHoldsButtonInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Order hold is not allowed if the order is part of an IC chain or marked for IC autocreation,
    /// but if somehow an order hold already exists allow button to be clicked so hold can be removed.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record used to determine whether the order holds button.
    /// </param>
    /// <returns>
    /// True when the order holds button should be enabled; otherwise, false.
    /// </returns>
    public static boolean mcrEnableOrderHoldsButtonInterCompany(SalesTable _salesTable)
    {
        boolean enable = true;

		if (!_salesTable.MCROrderStopped
			&& (_salesTable.InterCompanyAutoCreateOrders
                || _salesTable.isInterCompanyOrder()
				|| _salesTable.existInterCompanySales()))
        {
            enable = false;
        }

        return enable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPromptHoldOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays a form to manage hold codes for the active sales order
    ///     meant for sales form and list page.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales order record used to initialize the prompt.
    /// </param>
    public static void mcrPromptHoldOrder(SalesTable _salesTable)
    {
        Args args = new Args();

        args.record(_salesTable);

        FormRun formRun = new MenuFunction(menuitemDisplayStr(MCRHoldCodeTransSOCreate),
                                           MenuItemType::Display).create(args);
        formRun.run();
        formRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrShowOrderRecap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>MCRSalesOrderRecap</c> form for the passed sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order for which this method opens the <c>MCRSalesOrderRecap</c> form.
    /// </param>
    /// <returns>
    /// The args passed back from the <c>MCRSalesOrderRecap</c> form.
    /// </returns>
    public static Args mcrShowOrderRecap(SalesTable  _salesTable)
    {
        MCRSalesOrderRecapConfigure mcrSalesOrderRecapConfigure = new MCRSalesOrderRecapConfigure();

        Args recapArgs = new Args();
        recapArgs.name(formStr(MCRSalesOrderRecap));
        recapArgs.record(_salesTable);

        boolean showModifyOrderButton;
        RetailSalesTableButtonStatusContext context = RetailSalesTableButtonStatusContext::current();

        if (context != null && RetailSalesTableShareModifyButtonStatusToMCRSalesOrderRecapFlight::instance().isEnabled())
        {
            showModifyOrderButton = context.parmIsModifyButtonEnabled();
        }
        else
        {
            showModifyOrderButton = _salesTable.SalesStatus != SalesStatus::Canceled;
        }

        // Modify button will not visible for Cancelled orders
        mcrSalesOrderRecapConfigure.parmShowModifyOrderButton(showModifyOrderButton);
        recapArgs.parmObject(mcrSalesOrderRecapConfigure);
        FormRun recapFormRun = classfactory.formRunClass(recapArgs);
        recapFormRun.run();
        recapFormRun.wait();

        return recapArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesCreateOrder_WriteServer</Name>
				<Source><![CDATA[
    public static void salesCreateOrder_WriteServer(
        SalesTable              _salesTable,
        SalesAgreementId        _salesAgreementId,
        boolean                 _replacementOrder,
        boolean                 _copyRMALines,
        boolean                 _copyTPAddress,
        LogisticsLocationRecId  _fromTPLocationRecId
        )
    {
        SalesAgreementHeader        salesAgreementHeader;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>
        // <GEECZ>
        SalesTableSymbol            salesTableSymbol;
        // </GEECZ>

        ttsbegin;

        if (_salesTable.ProjId)
        {
            _salesTable.initFromProjInvoiceTable();

            if (!_salesTable.Payment)
            {
                _salesTable.Payment = CustTable::find(_salesTable.CustAccount).PaymTermId;
            }
        }

        if (_salesAgreementId)
        {
            salesAgreementHeader = SalesAgreementHeader::findAgreementId(_salesAgreementId);
            _salesTable.MatchingAgreement = salesAgreementHeader.RecId;
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                SalesAgreementHeaderExt_RU salesAgreementHeaderExt = SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(salesAgreementHeader.RecId);

                SalesTable_RU salesTableRU = _salesTable.salesTable_RU();
                salesTableRU.AgreementHeaderExt_RU = salesAgreementHeaderExt.RecId;
                _salesTable.packSalesTable_RU(salesTableRU);

                _salesTable.DefaultDimension = _salesTable.copyDimension(salesAgreementHeader.DefaultDimension);
            }
            // </GEERU>
        }

        if (_replacementOrder
            && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            MCRReturnSalesTable mcrReturnSalesTable = _salesTable.mcrReturnSalesTable();
            mcrReturnSalesTable.IsExchange = NoYes::Yes;
            _salesTable.mcrPackMCRReturnSalesTable(mcrReturnSalesTable);
        }

        _salesTable.insert();

        // <GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
        {
            salesTableSymbol.initFromCompanyBankAccount(_salesTable.RecId);
            if (salesTableSymbol.SalesTable)
            {
                salesTableSymbol.insert();
            }
        }
        // </GEECZ>
        if (salesAgreementHeader.RecId)
        {
            salesAgreementHeader.createAgreementReleaseHeaderMatch(_salesTable);
        }

        if (_replacementOrder)
        {
            _salesTable.copyRMALines(SalesTable::findReturnItemNum(_salesTable.ReturnItemNum), _copyRMALines);
        }

        if (_copyTPAddress && _fromTPLocationRecId)
        {
            _salesTable.ShipCarrierPostalAddress = LogisticsPostalAddress::addressRecIdFromLocationRecId(_fromTPLocationRecId);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtSetupContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>PrintMgmtSetupContext</c> object that is used to display print management settings.
    /// </summary>
    /// <returns>
    /// The <c>PrintMgmtSetupContext</c> object.
    /// </returns>
    public PrintMgmtSetupContext printMgmtSetupContext()
    {
        PrintMgmtSetupContext setupContext = new PrintMgmtSetupContext();

        setupContext.addHierarchyContext(PrintMgmtHierarchyType::Sales, PrintMgmtNodeType::SalesTable, this.salesDocumentTypes());
        setupContext.addHierarchyContext(PrintMgmtHierarchyType::Invent, PrintMgmtNodeType::SalesTable, this.inventDocumentTypes());
        setupContext.parmReferencedTableBuffer(salesTable_ds.cursor());

        return setupContext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesDocumentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves sales related document types for print management settings.
    /// </summary>
    /// <returns>
    /// The sales related document types for print management settings.
    /// </returns>
    protected List salesDocumentTypes()
    {
        #ISOCountryRegionCodes

        List salesDocs  = new List(Types::Enum);

        salesDocs.addEnd(PrintMgmtDocumentType::SalesOrderConfirmation);
        salesDocs.addEnd(PrintMgmtDocumentType::SalesOrderInvoice);
        salesDocs.addEnd(PrintMgmtDocumentType::SalesOrderPackingSlip);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            salesDocs.addEnd(PrintMgmtDocumentType::SalesOrderInvoice4Paym_RU);
        }
        // </GEERU>

        return salesDocs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDocumentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves inventory related document types for print management settings.
    /// </summary>
    /// <returns>
    /// The inventory related document types for print management settings.
    /// </returns>
    protected List inventDocumentTypes()
    {
        List inventDocs  = new List(Types::Enum);

        inventDocs.addEnd(PrintMgmtDocumentType::InventPickList);

        return inventDocs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesAgreementHeaderForReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the sales agreement header for replacement order.
    /// </summary>
    /// <returns>
    /// An instance of <c>SalesAgreementHeader</c>.
    /// </returns>

    internal SalesAgreementHeader getSalesAgreementHeaderForReturnOrder()
    {
        SalesAgreementHeader	salesAgreementHeader;
        SalesTable              salesTableLocal;

        select firstonly salesAgreementHeader
            join salesTableLocal
                where salesAgreementHeader.recid == salesTableLocal.MatchingAgreement
                    && salesTableLocal.ReturnItemNum == returnItemNum
                    && salesTableLocal.SalesType == SalesType::ReturnItem;

        return salesAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMcrOrderCompletionEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if MCR order completion is enabled.
    /// </summary>
    /// <returns>
    /// true if order completion is enabled; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public boolean isMcrOrderCompletionEnabled()
    {
        if (this.checkMCRChannelUserExists() == UnknownNoYes::No)
        {
            return false;
        }
        
        RetailMCRChannelTable channelForCurrentOrder = RetailMCRChannelTable::findChannelBySalesTable(salesTable);
        RetailMCRChannelTable channelForCurrentUser = RetailMCRChannelTable::findForCurrentUser();

        boolean allowOrderCompletionForCommerceEnabledOrder = channelForCurrentUser.ChannelType == RetailChannelType::MCRCallCenter && RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName());
        boolean ret = channelForCurrentOrder.mcrEnableOrderCompletion || allowOrderCompletionForCommerceEnabledOrder;

        if (ret && salesTable.InterCompanyOrder)
        {
            ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableRetailChannelEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Decides whether channel can be edited or not.
    /// </summary>
    /// <param name="_custAccount">Customer account associated with order.</param>
    /// <param name="_isOrderEditMode">True, if order is already created.</param>
    /// <returns>true if channel can be edited; otherwise, false.</returns>
    internal boolean enableRetailChannelEdit(CustAccount _custAccount, boolean _isOrderEditMode)
    {
        return RetailMCRChannelTable::findForCurrentUser() // User editing must be a call center user
            && (!_isOrderEditMode || RetailMCRChannelTable::findRecId(SalesTable.retailSalesTable().OriginChannel))
            && _custAccount
            && RetailCustTable::find(_custAccount).B2BCustomerHierarchyNode; // B2B customer must be selected
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInventoryFieldsOnChannelSelection</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates channel related inventory properties based on channel selection.
    /// </summary>
    /// <param name="_channelId">
    ///     Channel id affecting the inventory fields.
    /// </param>
    internal void populateInventoryFieldsOnChannelSelection(RefRecId _channelId)
    {
        RetailChannelTable channel = RetailChannelTable::findByRecId(_channelId);
        if (channel)
        {
            SalesTable.InventLocationId  = channel.inventLocation;
            SalesTable.InventSiteId = InventLocation::find(SalesTable.InventLocationId).InventSiteId;
            SalesTable.CurrencyCode = channel.Currency;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMCRChannelUserExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if a MCRChannelUser exists for the current user and caches the result on session level.
    /// </summary>
    /// <returns>UnknownNoYes::Yes if a MCRChannelUser exists for the current user.</returns>
    private UnknownNoYes checkMCRChannelUserExists()
    {
        if (MCRChannelUserExists == UnknownNoYes::Unknown)
        {
            MCRChannelUserExists = MCRChannelUser::find() ? UnknownNoYes::Yes : UnknownNoYes::No;
        }
        return MCRChannelUserExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAllowSalesLineEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not user should be allowed to edit a given sales line.
    /// Criteria for not allow editing is the following:
    /// - If order completion is enabled for the call center and the order is complete, all sales lines are locked.
    /// - Or a line is invoiced.
    /// </summary>
    /// <param name = "_salesTable">A SalesTable record.</param>
    /// <param name = "_salesLine">The SalesLine to be checked.</param>
    /// <param name = "_retailSalesLine">The RetailSalesLine associated with _salesLine.</param>
    /// <returns>True if a line should be allow edit; otherwise, false.</returns>
    public boolean shouldAllowSalesLineEdit(SalesTable _salesTable, SalesLine _salesLine, RetailSalesLine _retailSalesLine)
    {
        boolean ret = true;

        if (this.isMcrOrderCompletionEnabled() && !_salesTable.MCROrderStopped && !salesTable.InterCompanyOrder)
        {
            // Order is complete, price/discount should be locked
            ret = false;
        }
        // If the line is either partially invoiced or fully invoiced, price/discount should be locked.
        // Using SalesStatus as the first check so that fully invoiced stocked & non-stocked items are removed from the calculation (fulfillment status only works on stocked products).
        // For stocked products, check fulfillment status for partially invoiced orders.
        else if (_salesLine.SalesStatus == SalesStatus::Invoiced ||
                 _retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::PartiallyInvoiced)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesLineEditAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not user should be allowed to edit a given sales line.
    /// </summary>
    /// <param name = "_salesTable">A SalesTable record.</param>
    /// <param name = "_salesLine">The SalesLine to be checked.</param>
    /// <param name = "_retailSalesLine">The RetailSalesLine associated with _salesLine.</param>
    /// <returns>True if a line should be allow edit; otherwise, false.</returns>
    public boolean isSalesLineEditAllowed(SalesTable _salesTable, SalesLine _salesLine, RetailSalesLine _retailSalesLine)
    {
        boolean shouldAllowEdit;
        // For retail orders, check whether lines are allowed to edit or not.
        shouldAllowEdit = this.shouldAllowSalesLineEdit(_salesTable, _salesLine, _retailSalesLine);

        return shouldAllowEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetChannelUserExists</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void resetChannelUserExists()
    {
        MCRChannelUserExists = UnknownNoYes::Unknown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetChannelWhenCustomerModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Channnel and other associated properties with channel should be reset if customer is modified.
    /// </summary>
    internal void resetChannelWhenCustomerModified(str _custAccount)
    {
        //Below code should execute only if feature B2b2b feature is enabled
        if (RetailEnableB2b2bAndEnhanceB2bOrdersFeature::isEnabled() && RetailMCRChannelTable::findForCurrentUser())
        {
            RetailCustTable retailCustTable = RetailCustTable::find(_custAccount);
            salesTable_ds.object(fieldNum(SalesTable, RetailChannelTable)).allowEdit(retailCustTable && retailCustTable.B2BCustomerHierarchyNode);
            salesTable_ds.object(fieldNum(SalesTable, RetailChannelTable)).visible(retailCustTable && retailCustTable.B2BCustomerHierarchyNode);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>