<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PcModelingLibrary</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PcModelingLibrary
{
    #PC
    // A component hierarchy must be at most 5 levels deep below the root; thus the max is 6:
    #define.MaxLevel(6)
    #define.ErrorLevel(#MaxLevel + 1) //number above Max Level

    #define.maxCueLevelJump(3)

    const public int ColumnsUpperLimit = 10;
    const public int ColumnsLowerLimit = 1;
    const public int ColumnsDefault    = 1;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>attributeDefaultBoolValueLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a lookup for the selection of true and false values.
    /// </summary>
    /// <param name="_caller">
    ///    The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    ///    A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///    A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeDefaultBoolValueLookup(FormControl _caller, boolean _doLookup = true)
    {
        EcoResTextValue valueRecords;

        //check if True/False stub records exist
        ttsbegin;
        select firstonly valueRecords where valueRecords.TextValue == queryValue(#True);
        if (!valueRecords)
        {
            valueRecords.TextValue = queryValue(#True);
            valueRecords.insert();
        }
        select firstonly valueRecords where valueRecords.TextValue == queryValue(#False);
        if (!valueRecords)
        {
            valueRecords.TextValue =  queryValue(#False);
            valueRecords.insert();
        }
        ttscommit;

        Query query = new Query();
        QueryBuildDataSource dataSource = query.addDataSource(tableNum(EcoResTextValue), tableStr(EcoResTextValue));
        dataSource.addRange(fieldNum(EcoResTextValue, TextValue)).value(queryValue(#True));
        dataSource.addRange(fieldNum(EcoResTextValue, TextValue)).value(queryValue(#False));
        dataSource.addGroupByField(fieldNum(EcoResTextValue, TextValue));
        dataSource.fields().addField(fieldNum(EcoResTextValue, RecId), SelectionField::Count);

        SysTableLookup lookup = SysTableLookup::newParameters(tableNum(EcoResTextValue), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResTextValue, TextValue));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeDefaultTextValueLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for the selection of values contained in a text enumeration domain.
    /// </summary>
    /// <param name="_caller">
    /// The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_domain">
    /// The domain that contains the values.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeDefaultTextValueLookup(FormControl _caller, EcoResAttributeType _domain)
    {
        Query query = new Query();
        QueryBuildDataSource dataSourcePrime = query.addDataSource(tableNum(PCSolverTextValue), tableStr(PCSolverTextValue));
        QueryBuildDataSource dataSource = dataSourcePrime.addDataSource(tableNum(EcoResTextValue), tableStr(EcoResTextValue));
        dataSource.joinMode(JoinMode::InnerJoin);
        dataSource.addLink(fieldNum(PCSolverTextValue, TextValue),fieldNum(EcoResTextValue, RecId));

        dataSource = dataSource.addDataSource(tableNum(EcoResEnumerationAttributeTypeValue), tableStr(EcoResEnumerationAttributeTypeValue));
        dataSource.addRange(fieldNum(EcoResEnumerationAttributeTypeValue, AttributeType)).value(queryValue(_domain.RecId));
        dataSource.joinMode(JoinMode::InnerJoin);
        dataSource.addLink(fieldNum(EcoResTextValue, RecId),fieldNum(EcoResEnumerationAttributeTypeValue, Value));

        SysTableLookup lookup = SysTableLookup::newParameters(tableNum(PCSolverTextValue), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(PCSolverTextValue, Value));

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeDefaultIntegerValueLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for the selection of values contained in a integer enumeration domain.
    /// </summary>
    /// <param name="_caller">
    /// The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_domain">
    /// The domain that contains the values.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeDefaultIntegerValueLookup(FormControl _caller, EcoResAttributeType _domain)
    {
        Query query = new Query();
        QueryBuildDataSource dataSource = query.addDataSource(tableNum(EcoResIntValue), tableStr(EcoResIntValue)); 
        dataSource = dataSource.addDataSource(tableNum(EcoResEnumerationAttributeTypeValue), tableStr(EcoResEnumerationAttributeTypeValue));
		dataSource.joinMode(JoinMode::InnerJoin);
        dataSource.addLink(fieldNum(EcoResIntValue, RecId), fieldNum(EcoResEnumerationAttributeTypeValue, Value));
        dataSource.addRange(fieldNum(EcoResEnumerationAttributeTypeValue, AttributeType)).value(queryValue(_domain.RecId));

        SysTableLookup lookup = SysTableLookup::newParameters(tableNum(EcoResIntValue), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResIntValue, IntValue));

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeDefaultEnumValueLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for the selection of values contained in a enumeration domain.
    /// </summary>
    /// <param name="_caller">
    /// The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_domain">
    /// The domain that contains the values.
    /// </param>
    /// <param name="_doLookup">
    /// A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeDefaultEnumValueLookup(FormControl _caller, EcoResAttributeType _domain, boolean _doLookup = true)
    {
        SysTableLookup sysTableLookup;

        if (_domain.DataType == AttributeDataType::Integer)
        {
            sysTableLookup = PCModelingLibrary::attributeDefaultIntegerValueLookup(_caller, _domain);
        }
        else
        {
            sysTableLookup = PCModelingLibrary::attributeDefaultTextValueLookup(_caller, _domain);
        }

		if (_doLookup)
		{
            sysTableLookup.performFormLookup();
		}

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeDefaultValueLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for the selection of values contained in the specified domain.
    /// </summary>
    /// <param name="_caller">
    /// The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_domain">
    /// The domain that contains the values.
    /// </param>
    /// <param name="_doLookup">
    /// A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeDefaultValueLookup(FormControl _caller, EcoResAttributeType _domain, boolean _doLookup = true)
    {
        AttributeDataType   datatype = _domain.DataType;
        SysTableLookup      lookup;
        switch (datatype)
        {
            case AttributeDataType::Integer:
            case AttributeDataType::Text:
                if (_domain.IsEnumeration)
                {
                    lookup = PCModelingLibrary::attributeDefaultEnumValueLookup(_caller, _domain, _doLookup);
                }
                else
                {
                    lookup = new SysTableLookup();
                }
                break;
            case AttributeDataType::TrueFalse:
                lookup = PCModelingLibrary::attributeDefaultBoolValueLookup(_caller, _doLookup);
                break;
            case AttributeDataType::Decimal:
                lookup = new SysTableLookup();
                break;
            default:
                lookup = PCModelingLibrary::createAttributeValueLookupDefault(_caller, _domain);
        }
        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAttributeValueLookupDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a lookup for the default selection of values contained in the specified domain.
    /// </summary>
    /// <param name="_caller">
    ///     The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_domain">
    ///     The domain that contains the values.
    /// </param>
    /// <param name="_doLookup">
    ///     A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///     A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    [Replaceable]
    protected static SysTableLookup createAttributeValueLookupDefault(FormControl _caller, EcoResAttributeType _domain, boolean _doLookup = true)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeLookupQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query to be used for attribute lookups.
    /// </summary>
    /// <param name = "_component">The component that owns the attributes.</param>
    /// <returns>The query to be used for lookups.</returns>
    private static Query attributeLookupQuery(PCClass _component)
    {
        Query query = new Query();
        QueryBuildDataSource dataSourcePrime = query.addDataSource(tableNum(EcoResAttribute), tableStr(EcoResAttribute));
        QueryBuildDataSource dataSource  = dataSourcePrime.addDataSource(tableNum(EcoResCategoryAttribute), tableStr(EcoResCategoryAttribute));
        dataSource.joinMode(JoinMode::InnerJoin);
        dataSource.addLink(fieldNum(EcoResAttribute, RecId), fieldNum(EcoResCategoryAttribute, Attribute), tableStr(EcoResAttribute));
        dataSource.addRange(fieldNum(EcoResCategoryAttribute, Category)).value(queryValue(_component.RecId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a lookup for the selection of attributes of the specified component.
    /// </summary>
    /// <param name="_caller">
    ///    The <c>FormControl</c> that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_component">
    ///    The component that owns the attributes.
    /// </param>
    /// <param name="_doLookup">
    ///    A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///    A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup attributeLookup(FormControl _caller, PCClass _component, boolean _doLookup = true)
    {
        Query query = PCModelingLibrary::attributeLookupQuery(_component);

        SysTableLookup lookup = SysTableLookup::newParameters(tableNum(EcoResAttribute), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResAttribute, Name));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeLookupReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates a lookup for the selection of attribute record IDs of the specified component.
    /// </summary>
    /// <param name = "_caller">
    ///   The form control that will receive the chosen value from the lookup.
    /// </param>
    /// <param name = "_component">
    ///   The component that owns the attributes.
    /// </param>
    /// <returns>
    ///   A lookup attribute reference.
    /// </returns>
    internal static SysReferenceTableLookup getAttributeLookupReference(FormControl _caller, PCClass _component)
    {
        Query query = PCModelingLibrary::attributeLookupQuery(_component);

        SysReferenceTableLookup lookup = SysReferenceTableLookup::newParameters(tableNum(EcoResAttribute), _caller, true);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResAttribute, Name));

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeLookupReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and performs a lookup for the selection of attribute record IDs of the specified component.
    /// </summary>
    /// <param name="_caller">
    ///    The form control that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_component">
    ///    The component that owns the attributes.
    /// </param>
    /// <returns>
    ///    The selected <c>EcoResAttribute</c> record from the lookup.
    /// </returns>
    public static EcoResAttribute attributeLookupReference(FormControl _caller, PCClass _component)
    {
        SysReferenceTableLookup lookup = PCModelingLibrary::getAttributeLookupReference(_caller, _component);
        EcoResAttribute selectedAttribute = lookup.performFormLookup();

        return selectedAttribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeTypeLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for a selection of different attribute types by their name.
    /// </summary>
    /// <param name="_caller">
    /// The <c>FormControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    /// A Boolean value that indicates whether the lookup must be started.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value from the lookup.
    /// </returns>
    public static SysTableLookup attributeTypeLookup(FormControl _caller, boolean _doLookup = true)
    {
        SysTableLookup  lookup;
        Query           query;
        QueryBuildDataSource dataSource;

        query       = new Query();
        dataSource  = query.addDataSource(tableNum(EcoResAttributeType), tableStr(EcoResAttributeType));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::Integer));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::Text));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::TrueFalse));
        dataSource.fields().addField(fieldNum(EcoResAttributeType, DataType));

        lookup = SysTableLookup::newParameters(tableNum(EcoResAttributeType), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResAttributeType, Name));
        lookup.addLookupMethod(tableMethodStr(EcoResAttributeType, editProductConfigurationType));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeTypeReferenceLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for a selection of different attribute types by their name.
    /// </summary>
    /// <param name="_callerControl">
    /// The <c>FormReferenceControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <returns>
    /// A <c>SysTableLookup</c> object that represents the value from the lookup.
    /// </returns>
    public static EcoResAttributeType attributeTypeReferenceLookup(FormReferenceControl _callerControl)
    {
        SysReferenceTableLookup lookup;
        Query                   query = PCModelingLibrary::attributeTypeReferenceQuery();

        lookup = SysReferenceTableLookup::newParameters(tableNum(EcoResAttributeType), _callerControl, true);
        lookup.addLookupfield(fieldNum(EcoResAttributeType, Name));
        lookup.addLookupMethod(tableMethodStr(EcoResAttributeType, editProductConfigurationType));

        lookup.parmQuery(query);

        return lookup.performFormLookup() as EcoResAttributeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeTypeReferenceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup query for a selection of different attribute types usable in product configuration.
    /// </summary>
    /// <returns>
    /// A query object.
    /// </returns>
    protected static Query attributeTypeReferenceQuery()
    {
        Query                   query;
        QueryBuildDataSource    dataSource;

        query       = new Query();
        dataSource  = query.addDataSource(tableNum(EcoResAttributeType), tableStr(EcoResAttributeType));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::Integer));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::Text));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::TrueFalse));
        dataSource.addRange(fieldNum(EcoResAttributeType, DataType)).value(queryValue(AttributeDataType::Decimal));
        dataSource.fields().addField(fieldNum(EcoResAttributeType, DataType));
        dataSource.fields().addField(fieldNum(EcoResAttributeType, Name));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attributeTypeReferenceValidate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a specific record is a valid attribute type for Product Configuration.
    /// </summary>
    /// <param name="_domain">
    ///    The domain record to validate.
    /// </param>
    /// <returns>
    ///    True if the record is a valid constraint-based product master; otherwise, false.
    /// </returns>
    public static boolean attributeTypeReferenceValidate(EcoResAttributeType _domain)
    {
        Query       query = PCModelingLibrary::attributeTypeReferenceQuery();
        QueryRun    queryRun;

        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(EcoResAttributeType)), fieldNum(EcoResAttributeType, RecId)).value(queryValue(_domain.RecId));

        queryRun = new QueryRun(query);

        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a lookup for the selection of product configuration components.
    /// </summary>
    /// <param name="_caller">
    ///    The form control that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    ///    A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///    A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup componentLookup(FormControl _caller, boolean _doLookup = true)
    {
        SysTableLookup  lookup;
        Query           query;
        QueryBuildDataSource dataSource;
        EcoResCategoryHierarchy hierarchy = PCModelingLibrary::findOrCreateCategoryHierarchy();

        query       = new Query();
        dataSource  = query.addDataSource(tableNum(PCClass), tableStr(PCClass));
        dataSource.addOrderByField(fieldNum(PCClass, NestedSetRight));
        dataSource.addRange(fieldNum(PCClass, CategoryHierarchy)).value(queryValue(hierarchy.RecId));

        lookup = SysTableLookup::newParameters(tableNum(PCClass), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(PCClass, Name));
        lookup.addLookupMethod(tableMethodStr(EcoResCategory, description));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentReferenceLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a reference lookup for the selection of product configuration components.
    /// </summary>
    /// <param name="_callerControl">
    /// The form reference control that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    /// A Boolean value that indicates whether to start the lookup.
    /// </param>
    /// <returns>
    /// A <c>SysReferenceTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysReferenceTableLookup componentReferenceLookup(FormReferenceControl _callerControl, boolean _doLookup = true)
    {
        SysReferenceTableLookup     lookup;
        Query                       query = PCModelingLibrary::componentReferenceLookupQuery();

        lookup = SysReferenceTableLookup::newParameters(tableNum(PCClass), _callerControl);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(PCClass, Name));
        lookup.addLookupMethod(tableMethodStr(EcoResCategory, description));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentReferenceLookupQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a query that is compatible for lookup of components.
    /// </summary>
    /// <returns>
    ///    A query object.
    /// </returns>
    private static Query componentReferenceLookupQuery()
    {
        Query                   query;
        QueryBuildDataSource    dataSource;
        EcoResCategoryHierarchy hierarchy = PCModelingLibrary::findOrCreateCategoryHierarchy();

        query       = new Query();
        dataSource  = query.addDataSource(tableNum(PCClass), tableStr(PCClass));
        dataSource.addOrderByField(fieldNum(PCClass, NestedSetRight));
        dataSource.addRange(fieldNum(PCClass, CategoryHierarchy)).value(queryValue(hierarchy.RecId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentReferenceValidate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a specific record is a valid Product Configuration component.
    /// </summary>
    /// <param name="_component">
    ///    The component record to validate.
    /// </param>
    /// <returns>
    ///    True if the record is a valid component; otherwise, false.
    /// </returns>
    public static boolean componentReferenceValidate(PCClass _component)
    {
        Query       query = PCModelingLibrary::componentReferenceLookupQuery();
        QueryRun    queryRun;

        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(PCClass)), fieldNum(PCClass, RecId)).value(queryValue(_component.RecId));

        queryRun = new QueryRun(query);

        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constraintBasedItemLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a lookup for the selection of items that are compatible with the product configuration.
    /// </summary>
    /// <param name="_caller">
    ///    The <c>FormControl</c> object that will receive the specified value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    ///    A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///    A <c>SysTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysTableLookup constraintBasedItemLookup(FormControl _caller, boolean _doLookup = true)
    {
        SysTableLookup          lookup;
        Query                   query;
        QueryBuildDataSource    dataSourceItem;
        QueryBuildDataSource    dataSourceProductMaster;
        QueryBuildDataSource    dataSourceSupplyType;
        str                     rangeValue;

        query       = new Query();
        dataSourceItem  = query.addDataSource(tableNum(InventTable), tableStr(InventTable));
        dataSourceProductMaster  = dataSourceItem.addDataSource(tableNum(EcoResProductMaster), tableStr(EcoResProductMaster));
        dataSourceProductMaster.addLink(fieldNum(InventTable, Product), fieldNum(EcoResProductMaster, RecId),tableStr(InventTable));
        dataSourceProductMaster.addRange(fieldNum(EcoResProductMaster, ProductType)).value(queryValue(EcoResProductType::Item));
        rangeValue = queryValue(EcoResVariantConfigurationTechnologyType::ConstraintBased);
        dataSourceProductMaster.addRange(fieldNum(EcoResProductMaster, VariantConfigurationTechnology)).
        value(rangeValue);

        dataSourceSupplyType  = dataSourceItem.addDataSource(tableNum(InventItemSetupSupplyType), tableStr(InventItemSetupSupplyType));
        dataSourceSupplyType.addLink(fieldNum(InventTable, ItemId), fieldNum(InventItemSetupSupplyType, ItemId),tableStr(InventTable));
        dataSourceSupplyType.addLink(fieldNum(InventTable, DataAreaId), fieldNum(InventItemSetupSupplyType, ItemDataAreaId),tableStr(InventTable));

        lookup = SysTableLookup::newParameters(tableNum(InventTable), _caller);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(InventTable,ItemId));
        lookup.addLookupMethod(tableMethodStr(InventTable,defaultProductName));
        lookup.addLookupMethod(tableMethodStr(InventTable,itemGroupId));
        lookup.addLookupfield(fieldNum(InventTable,NameAlias));
        lookup.addLookupfield(fieldNum(InventTable,ItemType));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constraintBasedProductMasterLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a lookup to select the products that are compatible with the product configuration.
    /// </summary>
    /// <param name="_formReferenceControl">
    ///    The <c>FormReferenceControl</c> object that will receive the chosen value from the lookup.
    /// </param>
    /// <param name="_doLookup">
    ///    A Boolean value that indicates whether the lookup should be started.
    /// </param>
    /// <returns>
    ///    A <c>SysReferenceTableLookup</c> object that represents the value lookup.
    /// </returns>
    public static SysReferenceTableLookup constraintBasedProductMasterLookup(FormReferenceControl _formReferenceControl, boolean _doLookup = true)
    {
        SysReferenceTableLookup lookup;
        Query                   query = PCModelingLibrary::constraintBasedProductMasterLookupQuery();

        lookup = SysReferenceTableLookup::newParameters(tableNum(EcoResProductMaster), _formReferenceControl);
        lookup.parmQuery(query);
        lookup.addLookupfield(fieldNum(EcoResProductMaster,   DisplayProductNumber));
        lookup.addLookupfield(fieldNum(EcoResProductMaster,   SearchName));

        if (_doLookup)
        {
            lookup.performFormLookup();
        }

        return lookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constraintBasedProductMasterLookupQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a query that fetches constraint-based product masters.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>Query</c> class.
    /// </returns>
    private static Query constraintBasedProductMasterLookupQuery()
    {
        Query                   query;
        QueryBuildDataSource    dataSource;
        str                     rangeValue;

        query       = new Query();

        dataSource  = query.addDataSource(tableNum(EcoResProductMaster), tableStr(EcoResProductMaster));
        dataSource.addRange(fieldNum(EcoResProductMaster, ProductType)).value(queryValue(EcoResProductType::Item));

        rangeValue = queryValue(EcoResVariantConfigurationTechnologyType::ConstraintBased);
        dataSource.addRange(fieldNum(EcoResProductMaster, VariantConfigurationTechnology)).value(rangeValue);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constraintBasedProductMasterValidate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a specific record is a valid product master with constraint-based variance configuration technology.
    /// </summary>
    /// <param name="_product">
    ///    The product record to validate.
    /// </param>
    /// <returns>
    ///    True if the record is a valid constraint-based product master; otherwise, false.
    /// </returns>
    public static boolean constraintBasedProductMasterValidate(EcoResProduct _product)
    {
        Query       query = PCModelingLibrary::constraintBasedProductMasterLookupQuery();
        QueryRun    queryRun;

        SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(EcoResProductMaster)), fieldNum(EcoResProductMaster, RecId)).value(queryValue(_product.RecId));

        queryRun = new QueryRun(query);

        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>containingProductConfigurationModels</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a set of product models that contain the specified component in their component tree.
    /// </summary>
    /// <param name="_component">
    ///    The component that is contained in the product configuration models.
    /// </param>
    /// <param name="_productModelsSet">
    ///    The set of records that will be populated with the records of the
    ///    <c>PCProductConfigurationModel</c> table; optional.
    /// </param>
    /// <returns>
    ///    A set of records of the <c>PCProductConfigurationModel</c> table.
    /// </returns>
    public static Set containingProductConfigurationModels(PCClass _component, Set _productModelsSet = null)
    {
        PCProductConfigurationModel model;
        PCClass                     parentComponent;
        PCSubComponent              subComponent;
        Set productModelsSet;

        if (_productModelsSet == null)
        {
            productModelsSet = new Set(Types::Record);
        }
        else
        {
            productModelsSet = _productModelsSet;
        }

        while select model
        where model.RootComponentClass == _component.RecId
        {
            if (!productModelsSet.in(model))
            {
                productModelsSet.add(model);
            }
        }

        while select RecId from subComponent
        where subComponent.ChildComponentClass  == _component.RecId
        join  parentComponent
        where subComponent.ParentComponentClass == parentComponent.RecId
        {
            PCModelingLibrary::containingProductConfigurationModels(parentComponent, productModelsSet);
        }

        return productModelsSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countAttributeAllocations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of template lines that contain at least one allocation to the specified
    ///    attribute.
    /// </summary>
    /// <param name="_attribute">
    ///    The specified attribute to use in the search.
    /// </param>
    /// <returns>
    ///    A
    ///    <c>
    ///       container
    ///    </c>
    ///     with:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>The number of BOM line templates that contain at least one allocation to the specified
    ///          attribute.</description>
    ///       </item>
    ///       <item>
    ///          <description>The number of route operation line templates that contain at least one allocation to
    ///          the specified attribute.</description>
    ///       </item>
    ///    </list>
    ///     .
    /// </returns>
    /// <remarks>
    /// Add a post-method handler for returning the right value when extending the <c>PCRequirement</c> enumeration.
    /// </remarks>
    public static container countAttributeAllocations(EcoResAttribute _attribute)
    {
        EcoResCategoryAttribute     categoryAttribute;
        PCTemplateCategoryAttribute templateCategoryAttribute;
        PCTemplateComponent         templateComponent_BomLines;
        PCTemplateComponent         templateComponent_RouteLines;

        //count the BOM Lines with allocations to this attribute
        select  count(RecId) from templateComponent_BomLines
        exists  join  RecId from templateCategoryAttribute
            where   templateComponent_BomLines.RecId == templateCategoryAttribute.TemplateComponent
            &&      (   templateComponent_BomLines.Requirement == PCRequirement::ProductRequirement
                    ||  templateComponent_BomLines.Requirement == PCRequirement::SubComponent)
        exists  join  RecId from categoryAttribute
            where   categoryAttribute.Attribute == _attribute.RecId
            &&      templateCategoryAttribute.CategoryAttribute == categoryAttribute.RecId;

        //count the Operation Lines with allocation to this attribute
        select  count(RecId) from templateComponent_RouteLines
        exists  join  RecId from templateCategoryAttribute
            where   templateComponent_RouteLines.RecId == templateCategoryAttribute.TemplateComponent
            &&      templateComponent_RouteLines.Requirement == PCRequirement::ActivityRequirement
        exists  join  RecId from categoryAttribute
            where   categoryAttribute.Attribute == _attribute.RecId
            &&      templateCategoryAttribute.CategoryAttribute == categoryAttribute.RecId;

        return [templateComponent_BomLines.RecId, templateComponent_RouteLines.RecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createComponent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a product configuration component with all the related and required records.
    /// </summary>
    /// <param name="_componentName">
    ///    The name of the component to create.
    /// </param>
    /// <param name="_description">
    ///    The description of the component to create.
    /// </param>
    /// <returns>
    ///    The created record in the <c>PCClass</c> table.
    /// </returns>
    /// <remarks>
    ///    Always use this method to create a component.
    /// </remarks>
    public static PCClass createComponent(EcoResCategoryName _componentName, EcoResCategoryDescription _description = '')
    {
        PCClass component;

        ttsbegin;

        PCModelingLibrary::initCategory(component);

        component.Name              = _componentName;
        component.insert();

        EcoResCategoryTranslation::createOrUpdateCategoryTranslation(component.RecId, component.Name, _description, "", SystemParameters::getSystemLanguageId());

        ttscommit;

        return component;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEditProductConfigurationModel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new product configuration model record or updates an existing record with the same name
    ///    with the specified details.
    /// </summary>
    /// <param name="_modelName">
    ///    The name of the model to create or update.
    /// </param>
    /// <param name="_description">
    ///    The description to give to the model.
    /// </param>
    /// <param name="_existingRootComponentName">
    ///    The name of an existing component to attach to the model as a root component.
    /// </param>
    /// <param name="_newRootComponentName">
    ///    The name of the new root component to create.
    /// </param>
    /// <param name="_model">
    ///    An existing record of a product configuration model; optional.
    /// </param>
    /// <param name="_solverStrategy">
    ///    The solver strategy.
    /// </param>
    /// <param name="_columns">
    ///    The maximum number of columns to use when displaying the product configuration.
    /// </param>
    /// <returns>
    ///    The created or updated record of the <c>PCProductConfigurationModel</c> table.
    /// </returns>
    public static PCProductConfigurationModel createEditProductConfigurationModel(
        PCName                        _modelName,
        PCDescription                 _description,
        EcoResCategoryName            _existingRootComponentName,
        EcoResCategoryName            _newRootComponentName,
        PCProductConfigurationModel   _model = null,
        PCSolverStrategy              _solverStrategy = PCSolverStrategy::Default,
        PCRuntimeDialogMaxNoOfColumns _columns = ColumnsDefault)
    {
        PCProductConfigurationModel             model;
        PCProductConfigurationModelTranslation  modelTranslation;
        PCClass                                 component;

        ttsbegin;
        if (_model != null)
        {
            model = PCProductConfigurationModel::find(_model.RecId, true);
        }

        if (_existingRootComponentName)
        {
            component = PCClass::findByName(_existingRootComponentName);
            if (!component)
            {
                throw error(strFmt("@SYS31594", _existingRootComponentName, tablePName(PCClass)));
            }
        }
        else if (_newRootComponentName)
        {
            component = PCModelingLibrary::createComponent(_newRootComponentName);
        }
        else
        {
            component = PCModelingLibrary::createComponent(_modelName + #NewRootComponentSufix);
        }
        model.selectForUpdate(true);
        model.Name               = _modelName;
        model.RootComponentClass = component.RecId;
        model.SolverStrategy     = _solverStrategy;
        model.Columns            = _columns;
        model.write();
        modelTranslation = PCProductConfigurationModelTranslation::findByModelAndLanguage(model.RecId,SystemParameters::getSystemLanguageId(), true);
        modelTranslation.ProductConfigurationModel  = model.RecId;
        modelTranslation.Name                       = model.Name;
        modelTranslation.Description                = _description;
        modelTranslation.Language                   = SystemParameters::getSystemLanguageId();
        modelTranslation.write();
        ttscommit;

        return model;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIconList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an image list based on the embedded resources to use as icons for the product configuration
    ///    component trees.
    /// </summary>
    /// <returns>
    ///    An image list that has the respective icons for the tree.
    /// </returns>
    public static Imagelist createIconList()
    {
        Imagelist   imagelist;

        imagelist = new Imagelist( Imagelist::smallIconWidth() , Imagelist::smallIconHeight() );

        imagelist.add( new Image(11346) );   //Component Icon
        imagelist.add( new Image(11346));    //SubComponents
        imagelist.add( new Image(7730));    //Logical requirement

        return imagelist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubComponentRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the product requirement that is related to the specified sub-component.
    /// </summary>
    /// <param name="_subComponent">
    ///    The sub-component that will contain the requirements.
    /// </param>
    /// <returns>
    ///    The created requirements record for the sub-component.
    /// </returns>
    public static PCTemplateComponent createSubComponentRequirements(PCSubComponent _subComponent)
    {
        PCSubComponentRequirement   requirement;
        PCTemplateComponent         templateComponent;

        ttsbegin;
        templateComponent.initValue();
        templateComponent.ComponentClass = _subComponent.ParentComponentClass;
        templateComponent.Requirement = PCRequirement::SubComponent;
        templateComponent.insert();

        requirement.SubComponent = _subComponent.RecId;
        requirement.TemplateComponent = templateComponent.RecId;
        requirement.insert();

        ttscommit;

        return templateComponent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRelatedAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the attribute for the specified category hierarchy.
    /// </summary>
    /// <param name="_categoryAttribute">
    ///    The category attribute that refers to the attribute to delete.
    /// </param>
    public static void deleteRelatedAttribute(EcoResCategoryAttribute _categoryAttribute)
    {
        EcoResAttribute attribute;
        ttsbegin;
        attribute = EcoResAttribute::find(_categoryAttribute.Attribute, true);
        attribute.delete();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateAttributeName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the duplicate tag to the specified name.
    /// </summary>
    /// <param name="_name">
    ///    A name to which to add the duplicate tag.
    /// </param>
    /// <param name="_new">
    ///    A <c>NoYes</c> enumeration value that indicates whether a new duplicate name should be returned.
    /// </param>
    /// <returns>
    ///    The duplicated name.
    /// </returns>
    public static Name duplicateAttributeName(Name _name, NoYes _new)
    {
        EcoResAttribute     attribute;
        Name                duplicateName;
        EcoResCategoryName  strNumber;
        int                 curNum;
        int                 maxNum = 0;
        int                 duplicateNameLength;

        #PC

        duplicateName = strFmt("@SYS309930", _name, #Duplicate);

        duplicateNameLength = (strLen(duplicateName)+1);

        while select Name from attribute
            where attribute.Name like (duplicateName + '*')
        {
            strNumber = subStr(attribute.Name, duplicateNameLength, strLen(attribute.Name));

            curNum = str2int(strNumber);

            if (curNum > maxNum)
            {
                maxNum = curNum;
            }
        }

        if (_new == NoYes::Yes)
        {
            duplicateName = duplicateName + int2str(maxNum + 1);
        }
        else
        {
            duplicateName = duplicateName + int2str(maxNum);
        }

        return duplicateName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateCategoryName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the duplicate tag to the specified category.
    /// </summary>
    /// <param name="_name">
    ///    The name of a category to which to add the duplicate tag.
    /// </param>
    /// <param name="_new">
    ///    A <c>NoYes</c> enumeration value that indicates whether a new duplicate name should be returned.
    /// </param>
    /// <returns>
    ///    The duplicated name.
    /// </returns>
    public static EcoResCategoryName duplicateCategoryName(EcoResCategoryName _name, NoYes _new)
    {
        EcoResCategory      category;
        Name                duplicateName;
        EcoResCategoryName  strNumber;
        int                 curNum;
        int                 maxNum = 0;
        int                 duplicateNameLength;

        #PC

        duplicateName = strFmt("@SYS309930", _name, #Duplicate);

        duplicateNameLength = (strLen(duplicateName)+1);

        while select Name from category
            where category.Name like (duplicateName + '*')
        {
            strNumber = subStr(category.Name, duplicateNameLength, strLen(category.Name));

            curNum = str2int(strNumber);

            if (curNum > maxNum)
            {
                maxNum = curNum;
            }
        }

        if (_new == NoYes::Yes)
        {
            duplicateName = duplicateName + int2str(maxNum + 1);
        }
        else
        {
            duplicateName = duplicateName + int2str(maxNum);
        }

        return duplicateName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateModelName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the duplicate tag to a product configuration model name.
    /// </summary>
    /// <param name="_name">
    ///    A product configuration model name.
    /// </param>
    /// <returns>
    ///    The duplicated name.
    /// </returns>
    public static PCName duplicateModelName(PCName _name)
    {
        PCProductConfigurationModel model;
        PCName                      duplicateName;
        PCName                      strNumber;
        int                         curNum;
        int                         maxNum = 0;
        int                         duplicateNameLength;

        #PC

        duplicateName = strFmt("@SYS309930", _name, #Duplicate);

        duplicateNameLength = (strLen(duplicateName)+1);

        while select Name from model
            where model.Name like (duplicateName + '*')
        {
            strNumber = subStr(model.Name, duplicateNameLength, strLen(model.Name));

            curNum = str2int(strNumber);

            if (curNum > maxNum)
            {
                maxNum = curNum;
            }
        }

        return duplicateName + int2str(maxNum + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateTemplateConfigurationName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the duplicate tag to the specified name.
    /// </summary>
    /// <param name="_name">
    ///    The new name for the record.
    /// </param>
    /// <param name="_new">
    ///    A <c>NoYes::Yes</c> value if a new duplicate name must be returned; a <c>NoYes::No</c> value if the
    ///    last created name is returned.
    /// </param>
    /// <returns>
    ///    The duplicated name.
    /// </returns>
    public static Name duplicateTemplateConfigurationName(PCName _name, NoYes _new)
    {
        PCTemplateConfiguration templateConfiguration;
        PCName                  duplicateName;
        PCName                  strNumber;
        int                     curNum;
        int                     maxNum = 0;
        int                     duplicateNameLength;

        #PC

        duplicateName = strFmt("@SYS309930", _name, #Duplicate);

        duplicateNameLength = (strLen(duplicateName)+1);

        while select Name from templateConfiguration
            where templateConfiguration.Name like (duplicateName + '*')
        {
            strNumber = subStr(templateConfiguration.Name, duplicateNameLength, strLen(templateConfiguration.Name));

            curNum = str2int(strNumber);

            if (curNum > maxNum)
            {
                maxNum = curNum;
            }
        }

        if (_new == NoYes::Yes)
        {
            duplicateName = duplicateName + int2str(maxNum + 1);
        }
        else
        {
            duplicateName = duplicateName + int2str(maxNum);
        }

        return duplicateName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableCheckBoxAndGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables check box and group form controls.
    /// </summary>
    /// <param name="_checkbox">
    /// The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_group">
    /// The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    public static void enableCheckBoxAndGroup
    (
        FormCheckBoxControl _checkbox,
        FormGroupControl    _group
    )
    {
        _checkbox.value(1);
        _checkbox.checked(true);
        _group.enabled(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existReferencesForComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether references to the specified record of the <c>PCClass</c> table exist.
    /// </summary>
    /// <param name="_component">
    /// The component to check the references.
    /// </param>
    /// <returns>
    /// A container with Boolean values for references in the <c>PCProductConfigurationModel</c> and
    /// <c>PCSubComponent</c> tables.
    /// </returns>
    public static container existReferencesForComponent(PCClass _component)
    {
        PCProductConfigurationModel         pcProductConfigurationModel;
        PCSubComponent                      pcSubComponent;

        select firstonly RecId from pcProductConfigurationModel
            where pcProductConfigurationModel.RootComponentClass        == _component.RecId;
        select firstonly RecId from pcSubComponent
            where pcSubComponent.ChildComponentClass                    == _component.RecId;

        return
            [   (pcProductConfigurationModel.RecId != 0),
                (pcSubComponent.RecId != 0)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAttributeByName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an attribute of the specified component by the specified name.
    /// </summary>
    /// <param name="_component">
    ///    The component that contains the attribute.
    /// </param>
    /// <param name="_name">
    ///    The name of the attribute to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>EcoResCategoryAttribute</c> table.
    /// </returns>
    public static EcoResCategoryAttribute  findAttributeByName(PCClass _component, Name _name)
    {
        EcoResAttribute attribute;
        EcoResCategoryAttribute categoryAttribute;

        select  firstonly RecId from attribute
        where   attribute.Name == _name
        join    firstonly RecId from categoryAttribute
        where   categoryAttribute.Attribute == attribute.RecId
        &&      categoryAttribute.Category == _component.RecId;

        return categoryAttribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateCategoryHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the category hierarchy that is associated with the product configuration or creates one if it
    ///    does not exist.
    /// </summary>
    /// <returns>
    ///    The <c>EcoResCategoryHierarchy</c> record of the category hierarchy that is associated with the
    ///    product configuration.
    /// </returns>
    public static EcoResCategoryHierarchy findOrCreateCategoryHierarchy()
    {
        EcoResCategoryHierarchy ecoResCategoryHierarchy;

        //one may be created under a different company name (translated) - need to search by modifier alone.
        select firstonly ecoResCategoryHierarchy
            where ecoResCategoryHierarchy.HierarchyModifier == EcoResCategoryHierarchyModifier::Component;

        if (ecoResCategoryHierarchy)
        {
            return ecoResCategoryHierarchy;
        }
        else
        {
            return (EcoResCategoryHierarchy::findOrCreateCategoryHierarchy("@SYS184044", EcoResCategoryHierarchyModifier::Component));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateModifierCondition</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds or creates a condition that is associated with the specified attribute modifier.
    /// </summary>
    /// <param name="_modifier">
    ///    The modifier that is associated with the condition.
    /// </param>
    /// <returns>
    ///    A record in the <c>PCExpressionConstraint</c> table that is related to the specified modifier.
    /// </returns>
    public static PCApplicationControlConstraint findOrCreateModifierCondition(EcoResComponentControl _modifier)
    {
        PCApplicationControlConstraint  condition;
        PCExpressionConstraint          constraint;

        select firstonly    condition
            where   condition.ComponentControl == _modifier.RecId
        join firstonly      constraint
            where   condition.ConditionExpressionConstraint == constraint.RecId;

        if (condition.RecId != 0)
        {
            return condition;
        }
        else
        {
            ttsbegin;
            constraint.insert();
            condition.ComponentControl = _modifier.RecId;
            condition.ConditionExpressionConstraint = constraint.RecId;
            condition.insert();
            ttscommit;

            return condition;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttributeModifier</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the record in the <c>EcoResComponentControl</c> table that is associated with the provided
    ///    attribute and that matches the specified modifier type.
    /// </summary>
    /// <param name="_attribute">
    ///    The attribute that contains the modifier.
    /// </param>
    /// <param name="_modifierType">
    ///    The modifier type of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>EcoResComponentControl</c> table; otherwise, an empty record.
    /// </returns>
    public static EcoResComponentControl getAttributeModifier(EcoResCategoryAttribute _attribute, EcoResModifierType _modifierType, boolean _forUpdate = false)
    {
        EcoResComponentControl modifier;

        modifier.selectForUpdate(_forUpdate);

        select  firstonly modifier
        where   modifier.CategoryAttribute  == _attribute.RecId
        &&      modifier.Modifier           == _modifierType;

        return modifier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCueDataSourceActiveRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through the parent forms until it can find a compatible record.
    /// </summary>
    /// <param name="_formCaller">
    /// The caller object.
    /// </param>
    /// <param name="_tableNumber">
    /// The ID of the table to retrieve.
    /// </param>
    /// <param name="_traverseLevels">
    /// The number of parent levels that the algorithm can traverse.
    /// </param>
    /// <returns>
    /// A record of the selected table or the <c>null</c> value if no record is found.
    /// </returns>
    public static Common getCueDataSourceActiveRecord(
        FormRun _formCaller,
        int _tableNumber,
        int _traverseLevels = #maxCueLevelJump)
    {
        int     numberOfDatasource;
        int     dataSourceIndex;
        Object  objectDataSource;
        Common  cursor;

        numberOfDatasource = _formCaller.dataSourceCount();
        for (dataSourceIndex=1; dataSourceIndex<=numberOfDataSource; dataSourceIndex++)
        {
            objectDataSource = _formCaller.dataSource(dataSourceIndex);
            cursor = objectDataSource.cursor();
            if (cursor.TableId == tableNum(PCProductConfigurationModel))
            {
                return cursor;
            }
        }
        //nothing found so far, proceed to a level above
        if (_formCaller.args() && _formCaller.args().caller() && _traverseLevels > 0 )
        {
            return PCModelingLibrary::getCueDataSourceActiveRecord(_formCaller.args().caller(), _tableNumber, _traverseLevels - 1);
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoboxNeverShowAgain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if a particular dialog box was set by the user not to display again.
    /// </summary>
    /// <param name="_owner">
    ///    The registered owner of the dialog box.
    /// </param>
    /// <returns>
    ///    true if the user has chosen the specified dialogbox not to display again.
    /// </returns>
    public static boolean infoboxNeverShowAgain(str _owner)
    {
        BoxFormOnce box = BoxFormOnce::construct();
        int     version;
        boolean showForm;

        box.parmOwner(_owner);
        xSysLastValue::getLast(box);

        //show form is always true until the user picks "Don't show this again"
        [version, showForm] = box.pack();
        return !showForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a component record for product configuration.
    /// </summary>
    /// <param name="_component">
    /// The buffer of the <c>PCClass</c> table to initialize.
    /// </param>
    public static void initCategory(PCClass _component)
    {
        EcoResCategory countNestedSet;
        EcoResCategoryHierarchy hierarchy;

        hierarchy = PCModelingLibrary::findOrCreateCategoryHierarchy();
        select maxof(NestedSetRight), maxof(NestedSetLeft), maxof(Level) from countNestedSet
            where countNestedSet.CategoryHierarchy == hierarchy.RecId;

        _component.ParentCategory    = EcoResCategory::getRoot(hierarchy.RecId).RecId;
        _component.CategoryHierarchy = hierarchy.RecId;
        _component.Level             = countNestedSet.Level + 1;
        _component.NestedSetLeft     = countNestedSet.NestedSetLeft  + 1;
        _component.NestedSetRight    = countNestedSet.NestedSetRight + 1;
        _component.IsActive          = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAttributeNameValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given name is a valid name for an attribute.
    /// </summary>
    /// <param name="_component">
    /// The component that contains the attribute.
    /// </param>
    /// <param name="_attribute">
    /// The attribute record containing the name to validate.
    /// </param>
    /// <param name="_displayError">
    /// true if an error should be displayed in case the name is not valid; otherwise, false.
    /// </param>
    /// <returns>
    /// true if the name is valid; otherwise, false.
    /// </returns>
    public static boolean isAttributeNameValid(PCClass _component, EcoResAttribute _attribute, boolean _displayError = true)
    {
        EcoResAttribute         attribute;
        EcoResCategoryAttribute categoryAttribute;
        boolean                 ret = true;

        //
        //Product configuration requires unique attribute names for a given component.
        //
        select  firstonly RecId     from    attribute                   //find me the first attribute
        where   attribute.Name      ==      _attribute.Name             //whose name is the same as mine
        &&      attribute.RecId     !=      _attribute.RecId            //but the recId is different from mine
        join    RecId from categoryAttribute                            //that a category attribute
        where   categoryAttribute.Attribute == attribute.RecId          //is reffering to
        &&      categoryAttribute.Category  == _component.RecId;         //and that belongs to the same category

        if (attribute.RecId) //if it exists
        {
            if (_displayError)
            {
                error(strFmt("@SYS130227", "@SYS131880", _attribute.Name, "@SYS77030", "@SYS7399"));
            }
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemReferencedInPCTemplates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified item is used in a product configuration template for BOM lines.
    /// </summary>
    /// <param name="_item">
    ///    The <c>InventTable</c> record to check.
    /// </param>
    /// <returns>
    ///    true if the record is referenced in a product configuration template; otherwise, false.
    /// </returns>
    public static boolean isItemReferencedInPCTemplates(InventTable _item)
    {
        PCTemplateAttribute         itemIdTemplateAttribute;
        PCTemplateComponent         templateComponent;
        PCTemplateConstant          constantValueAllocation;
        EcoResTextValue             textValue;
        boolean                     ret = false;
        PCTemplateFind              templateFind = PCTemplateFind::construct();

        itemIdTemplateAttribute = templateFind.findTemplateAttributeByTableIdAndFieldId(tableNum(BOM), fieldNum(BOM, ItemId));

        if (itemIdTemplateAttribute)
        {
            select  firstonly RecId from constantValueAllocation
                where   constantValueAllocation.TemplateAttribute == itemIdTemplateAttribute.RecId
            join RecId from templateComponent
                where   templateComponent.RecId == constantValueAllocation.TemplateComponent
                &&      templateComponent.LegalEntity == CompanyInfo::current()
            exists  join RecId from textValue
                where   constantValueAllocation.ConstantValue == textValue.RecId
                &&      textValue.TextValue == _item.ItemId;

            return (constantValueAllocation.RecId != 0);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the component is a parent of or equal to a specified component.<paramref
    /// name="_parentComponentRecId" />.
    /// </summary>
    /// <param name="_componentRecId">
    /// The record ID of the component.
    /// </param>
    /// <param name="_parentComponentRecId">
    /// The record ID of the parent to check.
    /// </param>
    /// <returns>
    /// true if the component is a parent; otherwise, false.
    /// </returns>
    protected static boolean isParent(RefRecId _componentRecId, RefRecId _parentComponentRecId)
    {
        PCSubComponent  parentSubComponent;
        boolean         ret;

        if (_parentComponentRecId == _componentRecId)
        {
            ret = true;
        }
        else
        {
            while select ParentComponentClass from parentSubComponent
                    where parentSubComponent.ChildComponentClass == _parentComponentRecId
            {
                if (PCModelingLibrary::isParent(_componentRecId, parentSubComponent.ParentComponentClass))
                {
                    ret = true;
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSolverNameValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the given solver name is valid for an attribute in the that contains component.
    /// </summary>
    /// <param name="_component">
    /// The component that contains the attribute.
    /// </param>
    /// <param name="_solverVariable">
    /// An attribute record of the solver variable that contains the solver name to validate.
    /// </param>
    /// <param name="_displayError">
    /// A Boolean value that indicates whether an error must be displayed in case the name is not valid.
    /// </param>
    /// <returns>
    /// true if the name is valid; otherwise, false.
    /// </returns>
    public static boolean isSolverNameValid(PCClass _component, PCSolverVariable _solverVariable, boolean _displayError = true)
    {
        EcoResAttribute         attribute;
        EcoResCategoryAttribute categoryAttribute;
        PCSolverVariable        solverVariable;
        boolean                 ret = true;

        // Check if a component with the same solver name exists:
        select firstonly RecId from solverVariable
            where   solverVariable.Name     == _solverVariable.Name &&
                    solverVariable.RecId    != _solverVariable.RecId
                join RecId from attribute
                    where attribute.RecId == solverVariable.Attribute
                        join RecId from categoryAttribute
                            where   categoryAttribute.Attribute == attribute.RecId &&
                                    categoryAttribute.Category  == _component.RecId;

        if (solverVariable.RecId != 0 && solverVariable.RecId != _solverVariable.RecId)
        {
            if (_displayError)
            {
                error("@SYS313116");
            }
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUsedAsDefaultValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the enumeration value is used as a default in a product configuration model.
    /// </summary>
    /// <param name="_enumerationValue">
    /// The enumeration value to check.
    /// </param>
    /// <returns>
    /// true if the enumeration value is used as a default; otherwise, false.
    /// </returns>
    public static boolean isUsedAsDefaultValue(EcoResEnumerationAttributeTypeValue _enumerationValue)
    {
        PCSolverTextValue           solverTextValue = PCSolverTextValue::findByTextValue(_enumerationValue.Value);
        EcoResAttribute             attribute;
        EcoResCategoryAttribute     categoryAttribute;
        EcoResAttributeDefaultValue attributeDefaultValue;
        EcoResTextValue             defaultTextValue;

        if (!_enumerationValue || !solverTextValue)
        {
            return false;
        }

        //select the first component attribute
        select  firstonly RecId from categoryAttribute
            where categoryAttribute.Modifier    == EcoResCategoryAttributeModifier::Component
        join RecId, Name from attribute
            where   categoryAttribute.Attribute == attribute.RecId
        //that has this domain
        &&      attribute.AttributeType     == _enumerationValue.AttributeType
        //and contains a default value
        join RecId, Value from attributeDefaultValue
            where   attributeDefaultValue.Attribute == attribute.RecId
        //which has a solver value defined
        join RecId, TextValue from defaultTextValue
            where   defaultTextValue.RecId      == attributeDefaultValue.Value
        //and matches this one
        &&      defaultTextValue.TextValue  == queryValue(solverTextValue.Value);

        return (categoryAttribute.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads a form from an existing object in the AOT.
    /// </summary>
    /// <param name="_formName">
    /// The AOT name of the form.
    /// </param>
    /// <param name="_record">
    /// The record to pass to the form as an argument.
    /// </param>
    /// <param name="_caller">
    /// The form that will call the new form.
    /// </param>
    /// <param name="_doRun">
    /// true if the form should be launched immidiately; otherwise, false.
    /// </param>
    /// <param name="_modal">
    /// true if the form should be made modal; otherwise, false.
    /// </param>
    /// <param name="_initalArgs">
    /// The initial <c>Args</c> object to pass on to the loaded form.
    /// </param>
    /// <returns>
    /// The <c>FormRun</c> object of the generated form.
    /// </returns>
    public static FormRun loadForm(str _formName, Common _record = null, Object _caller = null, boolean _doRun = true, boolean _modal = false, Args _initalArgs = null)
    {
        Args        args = new Args();
        FormRun     formRun;

        if (_initalArgs)
        {
            args = _initalArgs;
        }
        if (_record)
        {
            args.record(_record);
        }

        if (_caller)
        {
            args.caller(_caller);
        }

        args.name(_formName);
        formRun = classfactory.formRunClass(args);

        if (_doRun)
        {
            formRun.run();
            if (_modal)
            {
                formRun.wait();
            }
            else
            {
                formRun.detach();
            }
        }

        return  formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxNumberOfSubComponentChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts maximum number of children af any sub tree of the component class
    /// specified by the <paramref name="_parentClass"/> table record parameter, including itself.
    /// </summary>
    /// <param name="_parentClass">
    /// The PCClass table record for which the number of children will be counted.
    /// </param>
    /// <param name="_subComponent">
    /// The buffer for the sub-component record.
    /// </param>
    /// <param name="_parentLevel">
    /// The position of the parent in the hierarchy; optional.
    /// </param>
    /// <returns>
    /// The maximum number of children of any sub tree of the record in table PCClass specified by the
    /// <paramref name="_parentClass"/> parameter, also counting the parents of the record in table
    /// PCClass specified by the <paramref name="_parentLevel"/> parameter, and itself.
    /// </returns>
    public static int maxNumberOfSubComponentChildren(PCClass _parentClass,  PCSubComponent _subComponent, int _parentLevel = 0)
    {
        PCSubComponent  childSub;
        PCClass         childClass;
        int             maxLevel = _parentLevel + 1;

        if (
            (_parentLevel > #MaxLevel) ||
            (_parentClass.RecId == _subComponent.ParentComponentClass))
        {
            return #ErrorLevel;
        }

        while select RecId from childSub
        where   childSub.ParentComponentClass == _parentClass.RecId
        join    childClass
        where   childSub.ChildComponentClass == childClass.RecId
        {
            maxLevel = max(maxLevel, PCModelingLibrary::maxNumberOfSubComponentChildren(childClass, _subComponent, _parentLevel + 1));
            if (maxLevel > #MaxLevel)
            {
                return #ErrorLevel;
            }
        }

        return maxLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfSubComponentParents</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the number of parents of the component class specified by the <paramref name="_childClass"/>
    /// table record parameter, including itself.
    /// </summary>
    /// <param name="_childClass">
    /// The PCClass table record for which the number of parents will be counted.
    /// </param>
    /// <param name="_subComponent">
    /// The buffer for the sub-component record.
    /// </param>
    /// <param name="_childLevel">
    /// The position of the child in the hierarchy; optional.
    /// </param>
    /// <returns>
    /// The number of parents of the record in table PCClass specified by the <paramref name="_parentClass"/>
    /// parameter, also counting <paramref name="_childLevel"/>, and itself.
    /// </returns>
    public static int numberOfSubComponentParents(PCClass _childClass, PCSubComponent _subComponent, int _childLevel = 0)
    {
        PCSubComponent  parentSub;
        PCClass         parentClass;
        int             level = _childLevel + 1;

        if (
            (_childLevel > #MaxLevel) ||
            (_childClass.RecId == _subComponent.ChildComponentClass))
        {
            return #ErrorLevel;
        }

        while select RecId from parentSub
        where   parentSub.ChildComponentClass == _childClass.RecId
        join    parentClass
        where   parentSub.ParentComponentClass == parentClass.RecId
        {
            level = PCModelingLibrary::numberOfSubComponentParents(parentClass, _subComponent, _childLevel + 1);
            if (level > #MaxLevel)
            {
                return #ErrorLevel;
            }
        }

        return level;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or removes the active status of the specified product model version.
    /// </summary>
    /// <param name="_version">
    ///    The product model version to enable.
    /// </param>
    /// <param name="_doActivate">
    ///    A Boolean value that indicates whether the version is to be set as active.
    /// </param>
    public static void setActive(PCProductModelVersion _version, boolean _doActivate)
    {
        if (!_doActivate && _version.IsActive)
        {
            _version.IsActive = NoYes::No;
        }
        else
        {
            if (_version.isApproved() == NoYes::No)
            {
                error("@SYS26246");
            }
            else
            {
                _version.IsActive = NoYes::Yes;
                if (!PCModelingLibrary::validateVersionDate(_version))
                // can't be set to active
                {
                    _version.IsActive = NoYes::No;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAttributeModifier</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or deletes a modifier of the specified type, depending on the specified value.
    /// </summary>
    /// <param name="_attribute">
    ///    The attribute that contains the modifier.
    /// </param>
    /// <param name="_set">
    ///    A Boolean value that indicates whether the modifier should be created.
    /// </param>
    /// <param name="_value">
    ///    The current value when the <paramref name="_set" /> parameter is true.
    /// </param>
    /// <param name="_modifierType">
    ///    The modifier type of the record to create or delete.
    /// </param>
    /// <returns>
    ///    <c>NoYes::Yes</c> if the category has a modifier of the type that is specified in the <paramref
    ///    name="_modifierType" /> parameter; otherwise, the <c>NoYes::No</c> enumeration value.
    /// </returns>
    public static NoYes setAttributeModifier(EcoResCategoryAttribute _attribute, boolean _set, NoYes _value, EcoResModifierType _modifierType)
    {
        EcoResComponentControl currentModifier;

        if (_set)
        {
            ttsbegin;
            currentModifier = PCModelingLibrary::getAttributeModifier(_attribute, _modifierType, true);
            if (_value == NoYes::No)
            {
                if (currentModifier)
                {
                    currentModifier.delete();
                }
            }
            else
            {
                if (!currentModifier)
                {
                    currentModifier.Modifier = _modifierType;
                    currentModifier.CategoryAttribute = _attribute.RecId;
                    currentModifier.insert();
                }
            }
            ttscommit;
            return  _value;
        }
        else
        {
            //do not mark it as selected for update
            currentModifier = PCModelingLibrary::getAttributeModifier(_attribute, _modifierType, false);
            if (currentModifier)
            {
                return NoYes::Yes;
            }
            else
            {
                return NoYes::No;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVersionApprover</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or removes the approve status of the specified product model version.
    /// </summary>
    /// <param name="_version">
    ///    The product model version to approve.
    /// </param>
    /// <param name="_doApprove">
    ///    A Boolean value that indicates whether to set the version as approved; otherwise, false.
    /// </param>
    /// <param name="_workerRecId">
    ///    The record ID of the worker that approves the version.
    /// </param>
    /// <remarks>
    ///    The state of the version is always set to inactive when modifying the approver.
    /// </remarks>
    public static void setVersionApprover(PCProductModelVersion _version, boolean _doApprove, PCApprover _workerRecId)
    {
        PCProductModelVersionApprover   approver;
        PCProductModelVersion           version;

        ttsbegin;
        version = PCProductModelVersion::find(_version.RecId, true);
        version.IsActive = NoYes::No;
        version.update();
        if (!_doApprove)
        {
            delete_from approver where approver.ProductModelVersion == _version.RecId;
        }
        else
        {
            //since PC is company independent, so the workers are too
            if (HcmWorkerLookup::newOnlyActiveEmployees().validateWorker(_workerRecId))
            {
                //the version may be approved already
                approver = PCProductModelVersionApprover::findByProductModelVersion(_version.RecId, true);
                approver.Approver = _workerRecId;
                approver.ProductModelVersion = _version.RecId;
                approver.write();
            }
            else
            {
                //only active workers may approve this
                error(strFmt("@SYS39817", HcmWorker::find(_workerRecId).PersonnelNumber));
            }
        }
        ttscommit;

        if (FormDataUtil::getFormDataSource(_version))
        {
            FormDataUtil::getFormDataSource(_version).research(true);
        }
        else
        {
            _version.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadBoolAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for a Boolean field from the specified template binding if it exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_boolValue">
    ///    The <c>FormCheckboxControl</c> object that will receive the value if the allocation is set to a
    ///    constant value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    /// <returns>
    ///    The name of the attribute if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadBoolAllocation(   PCClass _component,
                                                    PCTemplateAttributeBinding _templateAttributeBinding,
                                                    FormCheckBoxControl _boolValue,
                                                    FormStringControl _stringContainer,
                                                    FormCheckBoxControl _checkbox,
                                                    FormRadioControl _radioButtons,
                                                    FormGroupControl _group)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;

        if (_templateAttributeBinding)
        {
            PCModelingLibrary::enableCheckBoxAndGroup(_checkbox, _group);

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                _radioButtons.selection(PCAllocation::Value);
                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                _boolValue.visible(true);
                _stringContainer.visible(false);
                _boolValue.value(EcoResBooleanValue::find(templateConstant.ConstantValue).BooleanValue);
            }
            else
            {
                _radioButtons.selection(PCAllocation::Attribute);
                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                _boolValue.visible(false);
                _stringContainer.visible(true);

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                _stringContainer.text(attribute.Name);
            }
        }
        return _stringContainer.text();
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadDateTimeAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for a <c>dateTime</c> field from the specified template bindingif it
    ///    exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_dateValue">
    ///    The <c>FormDateControl</c> object that receives the value if the allocation is to a constant value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    /// <returns>
    ///    The name of the attribute if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadDateTimeAllocation( PCClass _component,
                                                PCTemplateAttributeBinding _templateAttributeBinding,
                                                FormDateControl _dateValue,
                                                FormStringControl _stringContainer,
                                                FormCheckBoxControl _checkbox,
                                                FormRadioControl _radioButtons,
                                                FormGroupControl _group)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResDateTimeValue             dateTimeValue;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;
        utcdatetime                     utcValue;

        if (_templateAttributeBinding)
        {
            PCModelingLibrary::enableCheckBoxAndGroup(_checkbox, _group);

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                _radioButtons.selection(PCAllocation::Value);
                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                _dateValue.visible(true);
                _stringContainer.visible(false);
                utcValue = EcoResDateTimeValue::find(templateConstant.ConstantValue).DateTimeValue;
                _dateValue.dateValue(DateTimeUtil::date(utcValue));
            }
            else
            {
                _radioButtons.selection(PCAllocation::Attribute);
                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                _dateValue.visible(false);
                _stringContainer.visible(true);

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                _stringContainer.text(attribute.Name);
            }
        }
        return _stringContainer.text();
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadEnumAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for a enumeration field from the specified template binding if it exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_enumValue">
    ///    The <c>FormComboboxControl</c> object that receives the value if the allocation is set to a
    ///    constant value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    /// <returns>
    ///    The name of the attribute if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadEnumAllocation( PCClass _component,
                                            PCTemplateAttributeBinding _templateAttributeBinding,
                                            FormComboBoxControl _enumValue,
                                            FormStringControl _stringContainer,
                                            FormCheckBoxControl _checkbox,
                                            FormRadioControl _radioButtons,
                                            FormGroupControl _group)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;

        if (_templateAttributeBinding)
        {
            PCModelingLibrary::enableCheckBoxAndGroup(_checkbox, _group);

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                _radioButtons.selection(PCAllocation::Value);
                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                _enumValue.visible(true);
                _stringContainer.visible(false);
                _enumValue.selection(EcoResIntValue::find(templateConstant.ConstantValue).IntValue);
            }
            else
            {
                _radioButtons.selection(PCAllocation::Attribute);
                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                _enumValue.visible(false);
                _stringContainer.visible(true);

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                _stringContainer.text(attribute.Name);
            }
        }
        return _stringContainer.text();
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadFloatAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for a float field from the specified template binding if it exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_floatValue">
    ///    The <c>FormRealControl</c> object that receives the value if the allocation is set to a constant
    ///    value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    /// <returns>
    ///    The name of the attribute if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadFloatAllocation(    PCClass _component,
                                                PCTemplateAttributeBinding _templateAttributeBinding,
                                                FormRealControl _floatValue,
                                                FormStringControl _stringContainer,
                                                FormCheckBoxControl _checkbox,
                                                FormRadioControl _radioButtons,
                                                FormGroupControl _group)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResFloatValue                floatValue;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;

        if (_templateAttributeBinding)
        {
            PCModelingLibrary::enableCheckBoxAndGroup(_checkbox, _group);

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                _radioButtons.selection(PCAllocation::Value);
                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                _floatValue.visible(true);
                _stringContainer.visible(false);
                _floatValue.realValue(EcoResFloatValue::find(templateConstant.ConstantValue).FloatValue);
            }
            else
            {
                _radioButtons.selection(PCAllocation::Attribute);
                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                _floatValue.visible(false);
                _stringContainer.visible(true);

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                _stringContainer.text(attribute.Name);
            }
        }
        return _stringContainer.text();
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadIntAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for an integer field from the specified template binding if it exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_intValue">
    ///    The <c>FormIntControl</c> object that receives the value if the allocation is set to a constant
    ///    value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that will be marked as checked if a binding exists.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that will be set to enabled if a binding exists.
    /// </param>
    /// <returns>
    ///    The name of the attribute if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadIntAllocation(  PCClass _component,
                                            PCTemplateAttributeBinding _templateAttributeBinding,
                                            FormIntControl _intValue,
                                            FormStringControl _stringContainer,
                                            FormCheckBoxControl _checkbox,
                                            FormRadioControl _radioButtons,
                                            FormGroupControl _group)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;

        if (_templateAttributeBinding)
        {
            PCModelingLibrary::enableCheckBoxAndGroup(_checkbox, _group);

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                _radioButtons.selection(PCAllocation::Value);
                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                _intValue.visible(true);
                _stringContainer.visible(false);
                _intValue.value(EcoResIntValue::find(templateConstant.ConstantValue).IntValue);
            }
            else
            {
                _radioButtons.selection(PCAllocation::Attribute);
                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                _intValue.visible(false);
                _stringContainer.visible(true);

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                _stringContainer.text(attribute.Name);
            }
        }
        return _stringContainer.text();
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateLoadStringAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the allocation value for a string field from the specified template binding, if it exists.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateAttributeBinding">
    ///    The allocation binding of the field.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that receives the name of the attribute if the allocation is to
    ///    an attribute; otherwise it will receive the constant value; optional.
    /// </param>
    /// <param name="_checkbox">
    ///    The <c>FormCheckboxControl</c> object that is marked as checked if a binding exists; optional.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c> value if
    ///    the allocation is of type attribute; otherwise it will be set to the <c>PCAllocation::Value</c>
    ///    value; optional.
    /// </param>
    /// <param name="_group">
    ///    The <c>FormGroupControl</c> object that is set to enabled if a binding exists; optional.
    /// </param>
    /// <returns>
    ///    The name of the attribute, if the allocation binds to an attribute; otherwise, the string
    ///    representation of the constant value.
    /// </returns>
    public static str templateLoadStringAllocation(   PCClass _component,
                                                PCTemplateAttributeBinding _templateAttributeBinding,
                                                FormStringControl _stringContainer = null,
                                                FormCheckBoxControl _checkbox = null,
                                                FormRadioControl _radioButtons = null,
                                                FormGroupControl _group = null)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResTextValue                 textValue;
        EcoResAttribute                 attribute;
        EcoResCategoryAttribute         categoryAttribute;

        str                             retVal;

        if (_templateAttributeBinding)
        {
            if (_checkbox)
            {
                _checkbox.value(1);
                _checkbox.checked(true);
            }
            if (_group)
            {
                _group.enabled(true);
            }

            if (_templateAttributeBinding.getInstanceRelationType() == tableStr(PCTemplateConstant))
            {
                if (_radioButtons)
                {
                    _radioButtons.selection(PCAllocation::Value);
                }

                templateConstant = _templateAttributeBinding as PCTemplateConstant;
                retVal = EcoResTextValue::find(templateConstant.ConstantValue).TextValue;
            }
            else
            {
                if (_radioButtons)
                {
                    _radioButtons.selection(PCAllocation::Attribute);
                }

                templateAttribute = _templateAttributeBinding as PCTemplateCategoryAttribute;

                select  firstonly RecId, Name from attribute
                join    firstonly RecId from categoryAttribute
                where   categoryAttribute.Attribute == attribute.RecId
                &&      categoryAttribute.Category  == _component.RecId
                &&      categoryAttribute.RecId     == templateAttribute.CategoryAttribute;

                retVal = attribute.Name;
            }

            if (_stringContainer)
            {
                _stringContainer.text(retVal);
            }
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveBoolAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for a Boolean field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_boolValue">
    ///    The <c>FormCheckboxControl</c> object that contains the value if the allocation is set to a
    ///    constant value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    public  static void templateSaveBoolAllocation(  PCClass _component,
                                                    PCTemplateComponent _templateComponent,
                                                    PCTemplateAttribute _fieldReference,
                                                    FormCheckBoxControl _boolValue,
                                                    FormStringControl _stringContainer,
                                                    FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResBooleanValue              booleanValue;

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            booleanValue.BooleanValue   = _boolValue.value();
            booleanValue.insert();
            templateConstant.ConstantValue = booleanValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = PCModelingLibrary::findAttributeByName(_component, _stringContainer.text()).RecId;
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveDateTimeAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for a <c>dateTime</c> field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_dateValue">
    ///    The <c>FormDateControl</c> object that contains the value if the allocation is set to a constant
    ///    value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    public static void templateSaveDateTimeAllocation(  PCClass _component,
                                                        PCTemplateComponent _templateComponent,
                                                        PCTemplateAttribute _fieldReference,
                                                        FormDateControl _dateValue,
                                                        FormStringControl _stringContainer,
                                                        FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResDateTimeValue             utcValue;

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            utcValue.DateTimeValue =  DateTimeUtil::newDateTime(_dateValue.dateValue(), 0);
            utcValue.insert();
            templateConstant.ConstantValue = utcValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = PCModelingLibrary::findAttributeByName(_component, _stringContainer.text()).RecId;
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveEnumAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for an enumeration field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_enumValue">
    ///    The <c>FormComboboxControl</c> object that contains the value if the allocation is set to a
    ///    constant value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c> value if
    ///    the allocation is of the attribute type; otherwise it will be set to the <c>PCAllocation::Value</c>
    ///    enumeration value.
    /// </param>
    public static void templateSaveEnumAllocation(  PCClass _component,
                                                    PCTemplateComponent _templateComponent,
                                                    PCTemplateAttribute _fieldReference,
                                                    FormComboBoxControl _enumValue,
                                                    FormStringControl _stringContainer,
                                                    FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResIntValue                  intValue;

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            intValue.IntValue   = _enumValue.selection();
            intValue.insert();
            templateConstant.ConstantValue = intValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = PCModelingLibrary::findAttributeByName(_component, _stringContainer.text()).RecId;
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveFloatAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for a float field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_floatValue">
    ///    The <c>FormRealControl</c> object that contains the value if the allocation is set to a constant
    ///    value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    public static void templateSaveFloatAllocation( PCClass _component,
                                                    PCTemplateComponent _templateComponent,
                                                    PCTemplateAttribute _fieldReference,
                                                    FormRealControl _floatValue,
                                                    FormStringControl _stringContainer,
                                                    FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResFloatValue                floatValue;

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            floatValue.FloatValue   = _floatValue.realValue();
            floatValue.insert();
            templateConstant.ConstantValue = floatValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = PCModelingLibrary::findAttributeByName(_component, _stringContainer.text()).RecId;
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveIntAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for an integer field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_intValue">
    ///    The <c>FormIntControl</c> object that contains the value if the allocation is set to a constant
    ///    value.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    public static void templateSaveIntAllocation(   PCClass _component,
                                                    PCTemplateComponent _templateComponent,
                                                    PCTemplateAttribute _fieldReference,
                                                    FormIntControl _intValue,
                                                    FormStringControl _stringContainer,
                                                    FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResIntValue                  intValue;

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            intValue.IntValue   = _intValue.value();
            intValue.insert();
            templateConstant.ConstantValue = intValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = PCModelingLibrary::findAttributeByName(_component, _stringContainer.text()).RecId;
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSaveStringAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the allocation value for a string field for the specified template binding.
    /// </summary>
    /// <param name="_component">
    ///    The component that owns the allocation.
    /// </param>
    /// <param name="_templateComponent">
    ///    The container of field allocations for the component.
    /// </param>
    /// <param name="_fieldReference">
    ///    The reference to the existing table field.
    /// </param>
    /// <param name="_stringContainer">
    ///    The <c>FormStringControl</c> object that contains the name of the attribute if the allocation is
    ///    set to an attribute; otherwise it contains the constant value.
    /// </param>
    /// <param name="_radioButtons">
    ///    The <c>FormRadioControl</c> object that will be set to the <c>PCAllocation::Attribute</c>
    ///    enumeration value if the allocation is of the attribute type; otherwise it will be set to the
    ///    <c>PCAllocation::Value</c> enumeration value.
    /// </param>
    public static void templateSaveStringAllocation(  PCClass _component,
                                                PCTemplateComponent _templateComponent,
                                                PCTemplateAttribute _fieldReference,
                                                FormStringControl _stringContainer,
                                                FormRadioControl _radioButtons)
    {
        PCTemplateConstant              templateConstant;
        PCTemplateCategoryAttribute     templateAttribute;
        EcoResTextValue                 textValue;

        RefRecId    findAttributeByName(Name name)
        {
            EcoResAttribute attribute;
            EcoResCategoryAttribute categoryAttribute;

            select  firstonly RecId from attribute
            where   attribute.Name == name
            join    firstonly RecId from categoryAttribute
            where   categoryAttribute.Attribute == attribute.RecId
            &&      categoryAttribute.Category == _component.RecId;

            return categoryAttribute.RecId;
        }

        //it's the same for any type of allocation
        templateConstant.TemplateComponent = _templateComponent.RecId;
        templateAttribute.TemplateComponent = _templateComponent.RecId;

        if (_radioButtons.selection() == PCAllocation::Value)
        {
            textValue.TextValue = _stringContainer.text();
            textValue.insert();
            templateConstant.ConstantValue = textValue.RecId;
            templateConstant.TemplateAttribute = _fieldReference.RecId;
            templateConstant.insert();
        }
        else
        {
            templateAttribute.CategoryAttribute = findAttributeByName(_stringContainer.text());
            templateAttribute.TemplateAttribute = _fieldReference.RecId;
            templateAttribute.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateSetEnabledStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled status of the supplied controls from the template forms.
    /// </summary>
    /// <param name="_enabled">
    ///    A Boolean value that indicates whether the controls should be enabled and editable.
    /// </param>
    /// <param name="_group">
    ///    An instance of the <c>FormGroupControl</c> control class that should be changed in the enabled
    ///    status.
    /// </param>
    /// <param name="_radioButtons">
    ///    An instance of the <c>FormRadioControl</c> control class that should be changed in the editable
    ///    status.
    /// </param>
    public static void templateSetEnabledStatus( boolean _enabled, FormGroupControl _group, FormRadioControl _radioButtons)
    {
        _group.allowEdit(_enabled);
        _radioButtons.enabled(_enabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAttributeNameAgainstOMLSyntax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates an attribute name against the syntax of the Optima modeling language.
    /// </summary>
    /// <param name="_attributeName">
    ///    An attribute name.
    /// </param>
    /// <returns>
    ///    true if the attribute name is valid; otherwise, false.
    /// </returns>
    public static boolean validateAttributeNameAgainstOMLSyntax(PCName _attributeName)
    {
        int               infologLineCount = infologLine() + 1;
        boolean           ret = true;
        InteropPermission interopPermission = new InteropPermission(InteropKind::ClrInterop); // needed for server calls to some .NET APIs
        interopPermission.assert();

        try
        {
            ret = Microsoft.Dynamics.Ax.Frameworks.Controls.ProductConfiguration.Configurator::ValidateAttributeName(_attributeName);

            if (!ret)
            {
                ret = checkFailed("@SYS315896");
            }
        }
        catch (Exception::CLRError)
        {
            //remove the infolog 'Clr static invocation error'
            infolog.cut(infologLineCount);

            //The product model contains an error
            ret = checkFailed("@SYS315896");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAttributeTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the value in the <paramref name="_valueStr"/> parameter is compatible with the domain specified in the <paramref name="_domain"/> parameter.
    /// </summary>
    /// <param name="_domain">
    /// The domain used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value tested for compatibility.
    /// </param>
    /// <returns>
    /// true if the value is valid within the domain; otherwise, false.
    /// </returns>
    public static boolean validateAttributeTypeValue(EcoResAttributeType _domain, str _valueStr)
    {
        boolean ret;

        if (!_valueStr)
        {
            return true;
        }
        if (!_domain)
        {
            return false;
        }

        switch (_domain.DataType)
        {
            case AttributeDataType::Integer:
                ret = PCModelingLibrary::validateIntegerAttributeTypeValue(_domain, _valueStr);
                break;
            case AttributeDataType::TrueFalse:
                ret = PCModelingLibrary::validateBooleanAttributeTypeValue(_domain, _valueStr);
                break;
            case AttributeDataType::Text:
                ret = PCModelingLibrary::validateEnumAttributeTypeValue(_domain, _valueStr);
                break;
            case AttributeDataType::Decimal:
                ret = PCModelingLibrary::validateEnumAttributeTypeValue(_domain, _valueStr);
                break;
            default:
                ret = PCModelingLibrary::validateAttributeTypeValueDefault(_domain, _valueStr);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAttributeTypeValueDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates compatibility test default value is compatible with the domain.
    /// </summary>
    /// <param name="_domain">
    /// The domain used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value tested for compatibility.
    /// </param>
    /// <returns>
    ///     true if the default value is valid within the domain; otherwise, false.
    /// </returns>
    [Replaceable]
    protected static boolean validateAttributeTypeValueDefault(EcoResAttributeType _domain, str _valueStr)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBooleanAttributeTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the Boolean value in the <paramref name="_valueStr"/> parameter is compatible with the domain specified in <paramref name="_domain"/>.
    /// </summary>
    /// <param name="_domain">
    /// The domain used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value tested for compatibility.
    /// </param>
    /// <returns>
    /// true if the value is the string true or false; otherwise, false.
    /// </returns>
    public static boolean validateBooleanAttributeTypeValue(EcoResAttributeType _domain, str _valueStr)
    {
        return ((_valueStr == #True) || (_valueStr == #False));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateChangeAttributeVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prompts the user to authorize the visibility attribute to be changed if it is mandatory and does
    ///    not have a default value.
    /// </summary>
    /// <param name="_categoryAttribute">
    ///    The specified attribute to be hidden.
    /// </param>
    /// <param name="_hidden">
    ///    The value of the <c>NoYes::Yes</c> enumeration if the attribute is to be hidden.
    /// </param>
    /// <returns>
    ///    true if the user authorized the action or has chosen not to be prompted again.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The function was called without a record.
    /// </exception>
    public static boolean validateChangeAttributeVisibility(EcoResCategoryAttribute _categoryAttribute, NoYes _hidden)
    {
        #xppTexts
        boolean         allowChange     = true;
        boolean         isMandatory     = false;
        boolean         hasDefault      = false;
        EcoResAttribute attribute;

        str owner       = "@SYS309647";
        str heading     = "@SYS309651"
            + #newline
            + #newline
            + "@SYS309652"
            + #newline;

        if (!_categoryAttribute)
        {
            throw error(Error::missingRecord(funcName()));
        }

        if (_hidden == NoYes::No)
        {
            return allowChange;
        }

        //don't do the processing at all times, just until the user presses "don't show again"
        if (!PCModelingLibrary::infoboxNeverShowAgain(owner))
        {
            attribute   =   EcoResAttribute::find(_categoryAttribute.Attribute);
            hasDefault  =   (attribute.pcGetSetDefaultValue(false, '') != '');
            isMandatory =   (NoYes::Yes == PCModelingLibrary::setAttributeModifier( _categoryAttribute, false, NoYes::No, EcoResModifierType::Mandatory));

            if (!hasDefault && isMandatory)
            {
                //shows up until the user clicks "do not show me again"
                allowChange = (DialogButton::Yes ==  Box::yesNoOnce(owner, heading, DialogButton::No, owner));
            }
        }

        return allowChange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDecimalAttributeTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the text value in <paramref name="_valueStr"/> is compatible with the domain specified in <paramref name="_domain"/>.
    /// </summary>
    /// <param name="_domain">
    /// The domain used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value tested for compatibility.
    /// </param>
    /// <returns>
    /// true if the value exists in the domain; otherwise, false.
    /// </returns>
    public static boolean validateDecimalAttributeTypeValue(EcoResAttributeType _domain, str _valueStr)
    {
        EcoResEnumerationAttributeTypeValue    enumAttributeTypeValue;
        EcoResTextValue                 textValue;
        AttributeValueText              inputValue = _valueStr;
        PCSolverTextValue               solverValue;

        if ( _domain.IsEnumeration )
        {
            select  firstonly RecId from enumAttributeTypeValue
            where   enumAttributeTypeValue.AttributeType  == _domain.RecId
            join    RecId from textValue
            where   textValue.RecId         == enumAttributeTypeValue.Value
            join    RecId from solverValue
            where   solverValue.TextValue   == textValue.RecId
            &&      solverValue.Value       == queryValue(inputValue);

            return (enumAttributeTypeValue.RecId != 0);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prompts the user to authorize an attribute to be deleted if it is being used as allocation.
    /// </summary>
    /// <param name="_attribute">
    ///    The specified attribute to be deleted.
    /// </param>
    /// <returns>
    ///    true if the user authorized the action or has chosen not to be prompted again.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The function was called without a record.
    /// </exception>
    public static boolean validateDeleteAttribute(EcoResAttribute _attribute)
    {
        #xppTexts
        boolean allowChange = true;
        int64   countBomLines;
        int64   countOprLines;

        str owner       = "@SYS309655";
        str heading     = "@SYS309656"
            + #newline
            + "@SYS309657"
            + #newline
            + #newline
            + "@SYS309658"
            + #newline;

        if (!_attribute)
        {
            throw error(Error::missingRecord(funcName()));
        }

        //don't do the processing at all times, just until the user presses "don't show again"
        if (!PCModelingLibrary::infoboxNeverShowAgain(owner))
        {
            [countBomLines, countOprLines] = PCModelingLibrary::countAttributeAllocations(_attribute);
            if ((countBomLines > 0) || (countOprLines > 0))
            {
                //shows up until the user clicks "do not show me again"
                allowChange = (DialogButton::Yes ==  Box::yesNoOnce(owner, heading, DialogButton::No, owner));
            }
        }

        return allowChange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified item can be deleted by not being referenced in product
    ///    configuration templates.
    /// </summary>
    /// <param name="_item">
    ///    The <c>InventTable</c> record to validate.
    /// </param>
    /// <returns>
    ///    true if the record can be deleted; otherwise, false.
    /// </returns>
    public static boolean validateDeleteItem(InventTable _item)
    {
        boolean     itemIsUsed = PCModelingLibrary::isItemReferencedInPCTemplates(_item);
        boolean     ret = true;

        if (itemIsUsed)
        {
            ret = checkFailed(strFmt("@SYS312447", _item.ItemId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEnumAttributeTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the text value in <paramref name="_valueStr"/> is compatible with the domain specified in <paramref name="_domain"/>.
    /// </summary>
    /// <param name="_domain">
    /// The domain used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value tested for compatibility.
    /// </param>
    /// <returns>
    /// true if the value exists in the domain; otherwise, false.
    /// </returns>
    public static boolean validateEnumAttributeTypeValue(EcoResAttributeType _domain, str _valueStr)
    {
        EcoResEnumerationAttributeTypeValue    enumAttributeTypeValue;
        EcoResTextValue                 textValue;
        AttributeValueText              inputValue = _valueStr;
        PCSolverTextValue               solverValue;

        if ( _domain.IsEnumeration )
        {
            select firstonly RecId from enumAttributeTypeValue
                where enumAttributeTypeValue.AttributeType == _domain.RecId
                join RecId from textValue
                    where textValue.RecId == enumAttributeTypeValue.Value
                    join RecId from solverValue
                        where solverValue.TextValue == textValue.RecId
                            && solverValue.Value == inputValue;

            return (enumAttributeTypeValue.RecId != 0);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEnumerationValueAgainstOMLSyntax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a solver value against the syntax of the Optima modeling language.
    /// </summary>
    /// <param name="_solverValue">
    ///    A solver value.
    /// </param>
    /// <returns>
    ///    true if the solver value is valid; otherwise, false.
    /// </returns>
    public static boolean validateEnumerationValueAgainstOMLSyntax(PCSolverValue _solverValue)
    {
        InteropPermission   interopPermission;    //needed for server calls to some .NET APIs

        boolean                 ret = true;
        int                     infologLineCount    =   infologLine() + 1;

        interopPermission   = new InteropPermission(InteropKind::ClrInterop);
        interopPermission.assert();

        try
        {
            ret = Microsoft.Dynamics.Ax.Frameworks.Controls.ProductConfiguration.Configurator::ValidateEnumerationValue(_solverValue);

            if (!ret)
            {
                ret = checkFailed("@SYS315897");
            }
        }
        catch (Exception::CLRError)
        {
            //remove the infolog 'Clr static invocation error'
            infolog.cut(infologLineCount);

            //The product model contains an error
            ret = checkFailed("@SYS315897");
        }
        //reverting introp permission
        CodeAccessPermission::revertAssert();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIntegerAttributeTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the specified integer value is compatible with the specified domain.
    /// </summary>
    /// <param name="_domain">
    /// The domain that is used for validation.
    /// </param>
    /// <param name="_valueStr">
    /// The value to test for compatibility.
    /// </param>
    /// <param name="_showBoundError">
    /// A Boolean value that indicates whether a boundary error must be shown in the information log.
    /// </param>
    /// <returns>
    /// true if the value is a valid integer and is in the bounds of the domain; otherwise, false.
    /// </returns>
    public static boolean validateIntegerAttributeTypeValue(EcoResAttributeType _domain, str _valueStr, boolean _showBoundError = true)
    {
        EcoResBoundedAttributeTypeValue    bounds;
        EcoResIntValue              upperBound;
        EcoResIntValue              lowerBound;
        boolean ret = true;
        int     value = str2int(_valueStr);

        //confirm the parsing was successful
        if (int2str(value) != _valueStr)
        {
            return false;
        }

        select  firstonly RecId from bounds
        where   bounds.AttributeType == _domain.RecId
            join    RecId, IntValue from upperBound
            where   upperBound.RecId == bounds.UpperBound
            join    RecId, IntValue from lowerBound
            where   lowerBound.RecId == bounds.LowerBound;

        // if the integer has bounds
        if ( lowerBound.RecId != 0 || upperBound.RecId != 0 )
        {
            // bounded integer validation
            ret =  ((upperBound.IntValue >= value) && (lowerBound.IntValue <= value));
            if (!ret && _showBoundError)
            {
                error(strFmt("@SYS183856", _valueStr, int2str(lowerBound.IntValue),  int2str(upperBound.IntValue)));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOMLIdentifier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the specified string contains only the enabled characters for product configuration.
    /// </summary>
    /// <param name="_identifier">
    /// The identifier string to test.
    /// </param>
    /// <param name="_displayError">
    /// A Boolean value that indicates whether an error message should be displayed if the validation fails.
    /// </param>
    /// <returns>
    /// true if the identifier string does not contain unauthorized characters; otherwise, false.
    /// </returns>
    public static boolean validateOMLIdentifier(str _identifier, boolean _displayError = true)
    {
        // interop permission to allow clr code execution
        InteropPermission interopPermission = new InteropPermission(InteropKind::ClrInterop);

        // the regular expression definition
        str regex = '([a-z]|[A-Z]|_)([a-z]|[A-Z]|[0-9]|_)*';

        // the regular expression object
        System.Text.RegularExpressions.Regex reg;

        // the matching object
        System.Text.RegularExpressions.Match mat;

        // the value for the capture
        System.String capture;

        // asserts the clr interop permission
        interopPermission.assert();

        reg = new System.Text.RegularExpressions.Regex(regex);

        // tests the string against the regular expression
        mat = reg.Match(_identifier);

        // gets the value of the matching
        capture = mat.get_Value();

        // tests if there was at least one match
        if (mat.get_Success())
        {
            // tests if the match is equal to the variable name
            if (capture.Equals(_identifier))
            {
                return true;
            }
        }

        if (_displayError)
        {
            error(strFmt("@SYS94968", _identifier, "@SYS153038"));
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProductForVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the product associated with the supplied product model version is compatible with
    ///    constraint-based configuration.
    /// </summary>
    /// <param name="_version">
    ///    The product model version to check.
    /// </param>
    /// <returns>
    ///    true if the product is compatible with constraint-based configuration; otherwise, false.
    /// </returns>
    public static boolean validateProductForVersion(PCProductModelVersion _version)
    {
        EcoResProductMaster productMaster;

        productMaster = EcoResProductMaster::find(_version.ProductMaster);

        if (!productMaster.isConstraintBased())
        {
            return checkFailed("@SYS304654");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSubComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the given parent component class in <paramref name="_parentClass"/> may contain the component class in <paramref name="_childClass"/>.
    /// </summary>
    /// <param name="_parentClass">
    /// The class that will be the parent component class.
    /// </param>
    /// <param name="_childClass">
    /// The class that will be the sub-component class.
    /// </param>
    /// <param name="_subComponent">
    /// The buffer for the sub-component record.
    /// </param>
    /// <returns>
    /// true if the component can be a sub-component.
    /// </returns>
    public static boolean validateSubComponent(PCClass _parentClass, PCClass _childClass, PCSubComponent _subComponent)
    {
        RefRecId        originalChild = _subComponent.ChildComponentClass;
        boolean         ret           = true;

        // False on invalid arguments
        if ((_parentClass.RecId == 0) || (_childClass.RecId == 0)
        )
        {
            ret = false;
            return ret;
        }

        ret = !PCModelingLibrary::isParent(_childClass.RecId, _parentClass.RecId);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVersionDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or removes the active status of the specified product model version.
    /// </summary>
    /// <param name="_version">
    ///    The product model version to start.
    /// </param>
    /// <param name="_showError">
    ///    A Boolean value that indicates whether an error message is to be shown if the version is not valid.
    /// </param>
    /// <returns>
    ///    true if the version is valid; otherwise, false.
    /// </returns>
    public static boolean validateVersionDate(PCProductModelVersion _version, boolean _showError = true)
    {
        PCProductModelVersion version;
        boolean isDateIntervalValid     = (_version.ValidFrom <= _version.ValidTo);
        boolean isActiveNonconflicting  = true;

        if (!isDateIntervalValid)
        {
            if (_showError)
            {
                error("@SYS128234");
            }
            return false;
        }

        if (_version.IsActive)
        {
            //validate overlap within the same model
            select firstonly ProductMaster, Model, ValidFrom, ValidTo from version
            where   version.RecId != _version.RecId
            &&      version.IsActive == NoYes::Yes
            &&      version.Model    == _version.Model
            &&      version.ProductMaster  == _version.ProductMaster
            // Is the version interval not entirely before or after then we have overlaps
            &&      !(version.ValidFrom > _version.ValidTo
                        || version.ValidTo < _version.ValidFrom);

            isActiveNonconflicting = (version.RecId == 0);

            if (isActiveNonconflicting)
            {
                //validate overlap for all models using the same item
                select firstonly ProductMaster, Model, ValidFrom, ValidTo from version
                where   version.RecId != _version.RecId
                &&      version.IsActive == NoYes::Yes
                &&      version.ProductMaster  == _version.ProductMaster
                // Is the version interval not entirely before or after then we have overlaps
                &&      !(version.ValidFrom > _version.ValidTo
                            || version.ValidTo < _version.ValidFrom);

                isActiveNonconflicting = (version.RecId == 0);
            }
        }

        if (_showError && !isActiveNonconflicting)
        {
            error(strFmt("@SYS23313", version.getSetProduct(false, ''), version.getProductConfigurationModel().Name, date2StrUsr(version.ValidFrom, DateFlags::FormatAll), date2StrUsr(version.ValidTo, DateFlags::FormatAll)));
        }
        //there are no overlap dates
        return isActiveNonconflicting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prompts the user to authorize the modification of an attribute if it is being used as an allocation.
    /// </summary>
    /// <param name="_attribute">
    ///    The specified attribute that is to be modified.
    /// </param>
    /// <returns>
    ///    true if the user has authorized the action, or if the user has chosen not to be prompted again;
    ///    otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The function was called without a record.
    /// </exception>
    public static boolean validateWriteAttribute(EcoResAttribute _attribute)
    {
        #xppTexts
        boolean allowChange = true;
        int64   countBomLines;
        int64   countOprLines;

        str owner       = "@SYS309659";
        str heading     = "@SYS309660"
            + #newline
            + "@SYS309661"
            + #newline
            + #newline
            + "@SYS309662"
            + #newline;

        if (!_attribute)
        {
            //user is inserting new
            return true;
        }

        //don't do the processing at all times, just until the user presses "don't show again"
        if (!PCModelingLibrary::infoboxNeverShowAgain(owner))
        {
            [countBomLines, countOprLines] = PCModelingLibrary::countAttributeAllocations(_attribute);
            if ((countBomLines > 0) || (countOprLines > 0))
            {
                //shows up until the user clicks "do not show me again"
                allowChange = (DialogButton::Yes ==  Box::yesNoOnce(owner, heading, DialogButton::No, owner));
            }
        }

        return allowChange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAttributeSolverValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that solver value is specified on attribute type if needed.
    /// </summary>
    /// <param name = "_attribute">An attribute to validate.</param>
    /// <returns>
    ///     true if solver value is specified or is not needed; otherwise, false.
    /// </returns>
    public static boolean validateAttributeSolverValue(EcoResAttribute _attribute)
    {
        EcoResAttributeType ecoResAttributeType = EcoResAttributeType::find(_attribute.AttributeType);

        if (PCModelingLibrary::checkAttributeDataTypeSolverValue(ecoResAttributeType))
        {
            return checkFailed(strFmt("@SCM:PCEnumAttributeTypeMissingSolverValue", ecoResAttributeType.Name));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAttributeDataTypeSolverValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that solver value is specified on attribute type if needed.
    /// </summary>
    /// <param name = "_ecoResAttributeType">
    ///     An attribute to validate.
    /// </param>
    /// <returns>
    ///     Returns true if solver value is specified or is not needed; otherwise, false.
    /// </returns>
    protected static boolean checkAttributeDataTypeSolverValue(EcoResAttributeType _ecoResAttributeType)
    {
        return _ecoResAttributeType.IsEnumeration
            && _ecoResAttributeType.DataType == AttributeDataType::Text
            && !EcoResEnumerationAttributeTypeValue::existForAttributeTypeWithSolverValue(_ecoResAttributeType.RecId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>