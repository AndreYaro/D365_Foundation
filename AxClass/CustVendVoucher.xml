<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendVoucher</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class is used to provide logic for customer and vendor voucher.
/// </summary>
abstract class CustVendVoucher implements PaymCalendarIDerivationSource, PaymCalendarIBankAddress
{
    Common common;

    CustVendPaymentSched custVendPaymSched;
    CustPaymSched custPaymSched;
    VendPaymSched vendPaymSched;

    CustVendPaymentSchedLine custVendPaymSchedLine;
    CustPaymSchedLine custPaymSchedLine;
    VendPaymSchedLine vendPaymSchedLine;

    CustVendInvoiceJour custVendInvoiceJour;
    CustInvoiceJour custInvoiceJour;
    VendInvoiceJour vendInvoiceJour;
    CustVendTrans postCustVendTrans;

    boolean hasVendInvoiceDisbursements;
    
    CustVendTrans relatedCustTrans;
    CustVendAC accountNum;
    CustVendAC orderAccount;
    CurrencyCode currencyCode;
    ExchRate exchRate;
    ExchRate exchRateSecondary;
    ReportingCurrencyExchRate reportingCurrencyExchRate;
    ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecondary;
    ExchRate reportingCurrencyCrossRate;
    NoYes triangulation;
    AmountCur amountCur;
    AmountMST amountMST;
    FixedExchRate fixedExchRate;
    DimensionDefault defaultDimension;
    LedgerTransTxt transTxtType;
    PostingProfile postingProfile;
    PaymTermId paymTermId;
    SettlementType settlementType;
    boolean isCashPayment;
    boolean requireGLPostingPriorToSettlement;
    Approved approved;
    HcmApprover approver;
    InvoiceId invoiceId;
    CustVendNegInstId negotiableInstrumentId;
    CustVendNegInstStatus negotiableInstrumentStatus;
    CustVendNegInstSeqNum negotiableInstrumentSequenceNum;
    CashDiscCode cashDiscCode;
    TransDate cashDiscDate;
    AmountCur cashDiscAmount;
    DueDate dueDate;
    BankDiscNoticeDeadline bankDiscNoticeDeadline;
    Voucher voucher;
    Num formLetter;
    PaymReference paymReference;
    BankAccountID bankReference;
    CustVendPaymStatus paymStatus;
    LanguageId languageId;
    TypeOfCreditmaxCheck typeOfCreditmaxCheck;
    PaymMode paymMode;
    PaymSpec paymSpec;
    PaymId paymId;
    private FinTagRecId finTag;
    BankThirdPartyAccountId thirdPartyBankAccountId;
    CompanyBankAccountId companyBankAccountId;
    AmountMSTSecondary reportingCurrencyAmount;
    CashDiscBaseDate cashDiscBaseDate;

    TransactionTextLarge transTxt;
    TransDate transDate;
    LedgerTransType transType;
    Voucher transVoucher;
    TransDate documentDate;
    RefRecId accountingEventReference;
    DocumentNum documentNum;
    NoYes prePayment;
    Cancelled cancelledPayment;
    LedgerDimensionAccount cancelledLedgerDimension;

    LedgerPostingType ledgerPostingType;
    LedgerDetailLevel ledgerDetailLevel;

    BankCentralBankPurposeCode bankCentralBankPurposeCode;
    BankCentralBankPurposeText bankCentralBankPurposeText;

    NoYesCombo invoiceProject;

    NoYes bypassCreditCheck;

    TransactionTextLarge localTransactionTxt;

    boolean isSalesTaxPayment;
    ReasonRefRecID reasonRefRecID;
    boolean isReimbursement;

    // <GBR>
    AmountCur finInterestAmount;
    AmountCur fineAmount;
    CustInterestCode_BR interestCode;
    CustFineCode_BR fineCode;
    TaxWithholdType_BR taxWithholdType;
    // </GBR>

    // <GEERU>
    AmountMSTSecondary amountMSTSecond;
    BankCurrencyTransferId_RU currencyTransferId;
    AmountCur amountCurFixed;
    SalesInvoicePostingType_RU salesInvoicePostingType;
    AmountCur taxAgentVATAmount;
    container ledgerBalances;
    AmountCur postedAmountCur;
    amountMST postedAmountMST;
    CommProfileType_RU commProfileType;
    LedgerDimensionDefaultAccount fixedInvoiceTransLedgerDimension;
    // </GEERU>
    // <GIN>
    AmountCur taxWithholdAmount;
    AmountCur taxWithholdBank;
    AmountCur taxWithhold;
    AmountCur taxWithholdAmountOrigin;
    AmountCur taxWithholdAmountForeignTrans;
    boolean checkStatus;
    boolean checkBank;
    boolean taxWitholdSettled;
    boolean checkCentralizedPayment;
    TaxInformationRecId_IN tanNumber;
    AmountCur custVendWHTAmount;
    AmountCur totalWHTBankAmount;
    AmountCur gtaAmount;
    NoYes settlementGTA;
    RefRecId taxComponentLoc;
    AmountCur taxWithholdDiscAmount;
    RefRecId taxWithholdTransRecId;
    RefRecId custInvoiceTransRecId;
    boolean isTDSApplicable;
    boolean isTCSApplicable;
    // </GIN>

    // <GTE>
    Map taxDocumentLedgerVoucherMap;
    // </GTE>

    SysModule module;

    #ISOCountryRegionCodes
    RefRecId custBillingClassification;
    boolean isInvoicePosted;
    TransDate exchangeRateDate;
    boolean isCalledFromSplitPayment;

    LedgerJournalTrans_Customs_IT   customsTrans;
    boolean                         isItalyEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculatePostedMultipleBalanceAmounts_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total of the multiple posted balance amount based on
    /// the specific currency code and the object of <c>CurrencyExchangeHelper</c>.
    /// </summary>
    /// <param name = "_curencyCode">The transaction currency originating the conversion.</param>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> class which manages calculations between currencies.</param>
    /// <returns>A container of AmountCur and AmountMst.</returns>
    private container calculatePostedMultipleBalanceAmounts_RU(CurrencyCode _curencyCode, CurrencyExchangeHelper _currencyExchangeHelper)
    {
        int i;
        boolean correction;
        AmountCur balanceValue;
        AmountCur retAmountCur;
        amountMST retAmountMst;
        for (i = 1; i<=conLen(ledgerBalances); i++)
        {
            [correction, balanceValue] = conPeek(ledgerBalances, i);
            retAmountCur += balanceValue;
            retAmountMST += _currencyExchangeHelper.calculateTransactionToAccounting(
                    _curencyCode,
                    balanceValue,
                    true
            );
        }
        return [retAmountCur, retAmountMst];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupProjTransactionTextContext</Name>
				<Source><![CDATA[
    private void setupProjTransactionTextContext(TransactionTextContext _transactionTextContext)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && 
            ProjInvoiceDefaultDescriptionFixFlight::instance().isEnabled() &&
            custVendInvoiceJour)
        {
            ProjInvoiceJour projInvoiceJour = ProjInvoiceJour::findRecId(custVendInvoiceJour.RecId);

            if (projInvoiceJour)
            {
                ProjProposalJour projProposalJour = ProjProposalJour::find(projInvoiceJour.ProposalId, false);
                ProjInvoiceTable projInvoiceTable = ProjInvoiceTable::find(projInvoiceJour.ProjInvoiceProjId);

                _transactionTextContext.setTableBuffer(projInvoiceJour);
                _transactionTextContext.setTableBuffer(projProposalJour);
                _transactionTextContext.setTableBuffer(projInvoiceTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the invoice by account, invoice id, and transaction date.
    /// </summary>
    /// <param name = "_custVendAC">Customer account or vendor account.</param>
    /// <param name = "_invoiceId">The invoiceId to be checked.</param>
    /// <param name = "_transDate">The transaction date, optional.</param>
    /// <returns>True in current abstract class.</returns>
    protected boolean checkInvoice(CustVendAC _custVendAC,
                                   InvoiceId _invoiceId,
                                   TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverdueJournal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if overdue journal exists, then takes the date of last journal and
    /// validates that overdue debt amount on that date will not be changed by posting.
    /// </summary>
    /// <param name="_custVendTrans">
    /// <c>CustVendTrans</c> record being checked.
    /// </param>
    /// <returns>
    /// True if check succeed(overdue debt will not change); Otherwise fase.
    /// </returns>
    /// <remarks>
    /// This check can be disabled by unmarking validate checkbox on <c>OverdueJournalSettings_W</c> form.
    /// </remarks>
    protected boolean checkOverdueJournal_W(CustVendTrans _custVendTrans)
    {
        #isoCountryRegionCodes
        boolean ret = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) && invoiceId && !this.postingProfileSettlement())
        {
            //in case of payment sched specified duedate on transaction is the minimum due date in payment sched, so all other lines of payment sched are valid
            ret = OverdueJournalSettings_W::canTransactionBePosted(_custVendTrans, _custVendTrans.TransDate, _custVendTrans.DueDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if account number is not empty.
    /// </summary>
    /// <returns>True if it's not empty, otherwise false.</returns>
    public boolean checkParameters()
    {
        boolean ok = true;

        if (! accountNum)
        {
            ok = checkFailed(strFmt("@SYS17167", accountNum));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copys cash discounts by table id and record id.
    /// </summary>
    /// <param name = "_fromTableId">The copy from table id.</param>
    /// <param name = "_fromRecId">The copy from record id.</param>
    /// <param name = "_toTableId">The copy to table id.</param>
    /// <param name = "_toRecId">The copy to record id.</param>
    protected void copyCashDisc(TableId _fromTableId,
                                RecId _fromRecId,
                                TableId _toTableId,
                                RecId _toRecId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>copySpecTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether <c>SpecTrans</c> entries should be copied.
    /// </summary>
    /// <returns>True if <c>SpecTrans</c> should be copied; false otherwise.</returns>
    protected boolean copySpecTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates invoice journal by custTrans or vendTrans.
    /// </summary>
    /// <param name = "custVendTrans">The custTrans or vendTrans to create invoice journal.</param>
    protected void createInvoiceJournal(CustVendTrans custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates invoice transactions by custInvoiceJour or vendInvoiceJour.
    /// </summary>
    /// <param name = "_custVendInvoiceJour">The custInvoiceJour and vendInvoiceJour to create invoice trans.</param>
    protected void createInvoiceTrans(CustVendInvoiceJour _custVendInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymScheduleSpecifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates payment schedule specifications by custTrans or vendTrans.
    /// </summary>
    /// <param name = "_custVendTrans">The custTrans or vendTrans to create payment schedule specifications.</param>
    void createPaymScheduleSpecifications(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates open transactions.
    /// </summary>
    /// <param name = "_custVendTrans">The custTrans or vendTrans to create open transactions.</param>
    /// <returns>Subclass <c>CustVendTransOpen</c> method value.</returns>
    abstract protected CustVendTransOpen createTransOpen(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransOpenLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Open transaction lines for an invoice.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// A <c>CustVendTransOpen</c> table buffer.
    /// </param>
    protected void createTransOpenLine(CustVendTransOpen _custVendTransOpen)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the custVendTable.
    /// </summary>
    /// <returns>A <c>CustVendTable</c> table buffer.</returns>
    abstract CustVendTable custVendTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDefaultTextForLedgerPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default text for ledger payments where the journal text is unset.
    /// </summary>
    /// <param name = "_ledgerJournalTransTxt">The transaction text for the journal.</param>
    /// <param name = "_ledgerPostingJournal">The ledger posting journal to use for ledger posting.</param>
    /// <param name = "_ledgerJournalType">The journal type of the ledger posting journal.</param>
    /// <returns>The default text for ledger payments.</returns>
    [HookableAttribute(false)]
    private TransactionTextLarge findDefaultTextForLedgerPayment(
        LedgerJournalTransTxt _ledgerJournalTransTxt,
        LedgerVoucher _ledgerPostingJournal,
        LedgerJournalType _ledgerJournalType)
    {
        TransactionTextLarge defaultTxt = _ledgerJournalTransTxt;
        Num formLetterLocal = formLetter;

        if (transType == LedgerTransType::Payment && _ledgerJournalTransTxt == '')
        {
            this.parmFormLetter(enum2str(_ledgerJournalType));

            defaultTxt = this.setTransactionTxt(
                this.parmLanguageId(),
                _ledgerPostingJournal.lastVoucher(),
                _ledgerPostingJournal.lastTransDate(),
                this.getPaymentLedgerTransactionTxt());

            this.parmFormLetter(formLetterLocal);
        }

        return defaultTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDefaultTextForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default text for payments where the journal text is unset.
    /// </summary>
    /// <param name = "_ledgerJournalTransTxt">The transaction text for the journal.</param>
    /// <param name = "_ledgerPostingJournal">The ledger posting journal to use for ledger posting.</param>
    /// <param name = "_ledgerJournalType">The journal type of the ledger posting journal.</param>
    /// <returns>The default text for payments.</returns>
    [HookableAttribute(false)]
    private TransactionTextLarge findDefaultTextForPayment(
        LedgerJournalTransTxt _ledgerJournalTransTxt,
        LedgerVoucher _ledgerPostingJournal,
        LedgerJournalType _ledgerJournalType)
    {
        TransactionTextLarge defaultTxt = _ledgerJournalTransTxt;
        Num formLetterLocal = formLetter;

        if (transType == LedgerTransType::Payment && _ledgerJournalTransTxt == '')
        {
            this.parmFormLetter(enum2str(_ledgerJournalType));

            defaultTxt = this.setTransactionTxt(
                this.parmLanguageId(),
                _ledgerPostingJournal.lastVoucher(),
                _ledgerPostingJournal.lastTransDate(),
                this.getPaymentTransactionTxt());

            this.parmFormLetter(formLetterLocal);
        }

        return defaultTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the postal address associated with the bank account.
    /// </summary>
    /// <returns>
    /// The <c>LogisticsPostalAddress</c> record that represents the postal address.
    /// </returns>
    public LogisticsPostalAddress getBankPostalAddress()
    {
        CustTable custTable;
        CustBankAccount custBankAccount;
        VendTable vendTable;
        VendBankAccount vendBankAccount;
        LogisticsPostalAddress logisticsPostalAddress;

        switch (module)
        {
            case SysModule::Cust:
                custTable = CustTable::find(accountNum);
                custBankAccount = CustBankAccount::find(accountNum, custTable.BankAccount);

                logisticsPostalAddress = LogisticsLocationEntity::location2PostalAddress(custBankAccount.Location);
                break;

            case SysModule::Vend:
                vendTable = VendTable::find(accountNum);
                vendBankAccount = VendBankAccount::find(accountNum, vendTable.BankAccount);

                logisticsPostalAddress = LogisticsLocationEntity::location2PostalAddress(vendBankAccount.Location);
                break;

            default:
                break;
        }

        return logisticsPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCommon_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Return the Common Buffer passed in the Construct
    /// </summary>
    /// <returns>
    /// Returns the Common Buffer assigned
    /// </returns>
    public Common getCommon_IN()
    {
        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer or vendor name.
    /// </summary>
    /// <returns>Return the name.</returns>
    protected Name getCustVendName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentLedgerTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets payment ledger transaction text.
    /// </summary>
    /// <returns>Return a subclass method value.</returns>
    protected abstract LedgerTransTxt getPaymentLedgerTransactionTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets payment transaction text.
    /// </summary>
    /// <returns>Return a subclass method value.</returns>
    protected abstract LedgerTransTxt getPaymentTransactionTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrimaryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the postal address associated to the third party entity.
    /// </summary>
    /// <returns>
    /// The <c>LogisticsPostalAddress</c> record that represents the postal address.
    /// </returns>
    public LogisticsPostalAddress getPrimaryPostalAddress()
    {
        CustTable custTable;
        VendTable vendTable;
        LogisticsPostalAddress logisticsPostalAddress;

        switch (module)
        {
            case SysModule::Cust:
                custTable = CustTable::find(accountNum);

                return custTable.postalAddress();

            case SysModule::Vend:
                vendTable = VendTable::find(accountNum);

                return vendTable.postalAddress();

            default:
                break;
        }

        // Return empty buffer
        return logisticsPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionTxt_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method sets class variables to be used in the setTransactionTxt and then return the trasaction text setup according
    /// to the ledgerTransTxt base enum
    /// </summary>
    /// <param name="_custVendAccountNum">
    /// Account num from the customer/vendor
    /// </param>
    /// <param name="_custVendWHTCode">
    /// Withholding tax code from the transaction
    /// </param>
    /// <param name="_invoiceId">
    /// InvoiceId from original invoice
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher whose transaction text refers to
    /// </param>
    /// <returns>
    /// Transaction text setup according to the ledgerTransTxt base enum
    /// </returns>
    public TransTxt getTransactionTxt_BR(CustVendAC _custVendAccountNum, TaxWithholdCode _custVendWHTCode, InvoiceId _invoiceId, LedgerVoucher _ledgerVoucher)
    {
        formLetter = this.parmFormLetter(_invoiceId);

        if (this is VendVoucherTaxWithhold || this is CustVoucherTaxWithhold)
        {
            taxWithholdType = TaxWithholdTable::find(_custVendWHTCode).TaxWithholdType_BR;
        }

        return this.setTransactionTxt(this.parmLanguageId(), _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWithholdAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate and return the withhold amount.
    /// </summary>
    /// <param name="_common">
    /// A source table buffer.
    /// </param>
    /// <param name="_sourceTableId">
    /// Reference number of the table.
    /// </param>
    /// <param name="_sourceRecId">
    /// Record id of the record in the source table.
    /// </param>
    /// <param name="_ledgerPostingJournal">
    /// A <c>LedgerVoucher</c> object.
    /// </param>
    /// <returns>
    /// Returns the withhold amount.
    /// </returns>
    public TaxWithholdAmountCur getWithholdAmount_IN(Common _common,
                                                     TableId _sourceTableId,
                                                     RecId _sourceRecId,
                                                     LedgerVoucher _ledgerPostingJournal)
    {
        CustVendTrans custVendTransToCancel;
        BankChequeTable bankChequeTable;
        BankAccountTrans bankAccountTrans;
        BankDeposit bankDeposit;
        CustTrans custTransLocal;
        TaxWithholdAmountCur taxAmount;
        LedgerJournalTrans ledgerJournalTransCopy;
        LedgerPostingType ledgerPostingTypeLocal;
        LedgerJournalTrans ledgerJournalTransLoc;
        LedgerJournalType ledgerJournalType;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        if (TaxWithholdParameters_IN::checkTaxParameters() &&
            _common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTransLoc = _common;
            ledgerJournalType = ledgerJournalTransLoc.ledgerJournalTable().JournalType;
            switch (ledgerJournalType)
            {
                case LedgerJournalType::BankChequeReversal:
                    bankChequeTable = BankChequeTable::find(ledgerJournalTransLoc.parmOffsetAccount(), ledgerJournalTransLoc.BankChequeNum);

                    custVendTransToCancel = BankChequeCancel::findCustVendTransForCheque(bankChequeTable);

                    bankAccountTrans = BankAccountTrans::findByAccountIDAndChequeNum(bankChequeTable.AccountID,bankChequeTable.ChequeNum);

                    ledgerPostingTypeLocal = ledgerPostingType;

                    select VendTransId from ledgerJournalTransCopy
                        where ledgerJournalTransCopy.VendTransId == custVendTransToCancel.RecId;

                    ledgerJournalTransTaxExt = ledgerJournalTransCopy.ledgerJournalTransTaxExtensionIN();

                    if (ledgerJournalTransTaxExt.tdsGroup)
                    {
                        ledgerPostingType = LedgerPostingType::TDS_IN;
                    }
                    else if (ledgerJournalTransTaxExt.tcsGroup)
                    {
                        taxAmount = TaxWithholdTrans_IN::getWithholdTaxAmount(bankChequeTable.Voucher,
                                                                          bankAccountTrans.TransDate,
                                                                          custVendTransToCancel.AccountNum);
                        ledgerPostingType = LedgerPostingType::TCS_IN;
                    }
                    this.taxWithholdReversal_IN(bankChequeTable.Voucher,
                                                bankAccountTrans.TransDate,
                                                _sourceTableId,
                                                _sourceRecId,
                                                _ledgerPostingJournal,
                                                transDate);
                    break;

                case LedgerJournalType::BankDepositPaymCancel:
                    select DepositNum, RefRecId, Voucher from bankDeposit
                        where bankDeposit.DepositNum == ledgerJournalTransLoc.BankDepositNum;

                    select RecId,AccountNum from custTransLocal
                        where custTransLocal.RecId == bankDeposit.RefRecId;
                    bankAccountTrans = BankAccountTrans::findByDepositNum(bankDeposit.DepositNum);
                    ledgerPostingTypeLocal = ledgerPostingType;

                    select Voucher, BankDepositNum, TransDate from ledgerJournalTransCopy
                        where ledgerJournalTransCopy.Voucher == bankDeposit.Voucher
                           && ledgerJournalTransCopy.BankDepositNum == bankDeposit.DepositNum;

                    ledgerJournalTransTaxExt = ledgerJournalTransCopy.ledgerJournalTransTaxExtensionIN();

                    if (ledgerJournalTransTaxExt.tdsGroup)
                    {
                        ledgerPostingType = LedgerPostingType::TDS_IN;
                    }
                    else if (ledgerJournalTransTaxExt.tcsGroup)
                    {
                        if (BankParameters::find().RequireDepositCancelJour)
                        {
                            taxAmount = TaxWithholdTrans_IN::getWithholdTaxAmount(bankDeposit.Voucher,
                                                                              bankAccountTrans.TransDate,
                                                                              custTransLocal.AccountNum);
                        }
                        ledgerPostingType = LedgerPostingType::TCS_IN;
                    }
                    this.taxWithholdReversal_IN(bankDeposit.Voucher,
                                                ledgerJournalTransCopy.TransDate,
                                                _sourceTableId,
                                                _sourceRecId,
                                                _ledgerPostingJournal,
                                                transDate);
                    break;
                default :
                    break;
            }
            ledgerPostingType = ledgerPostingTypeLocal;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialise values.
    /// </summary>
    /// <param name = "_accountNum">The account number.</param>
    /// <param name = "_amountCur">The amountCur.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_transTxtType">The transaction text type.</param>
    /// <param name = "_defaultDimension">The default dimension.</param>
    /// <param name = "_postingProfile">The posting profile.</param>
    /// <param name = "_ledgerPostingType">The ledger posting type.</param>
    /// <param name = "_paymTermId">The payment term id.</param>
    /// <param name = "_settlementType">The settlement type.</param>
    /// <param name = "_approver">The approver.</param>
    /// <param name = "_approved">The approved person.</param>
    /// <param name = "_invoiceId">The invoice id.</param>
    /// <param name = "_cashDiscDate">The cash discount date.</param>
    /// <param name = "_cashDiscAmount">The cash discount amount.</param>
    /// <param name = "_dueDate">The due date.</param>
    /// <param name = "_common">The table buffer.</param>
    /// <param name = "_typeOfCreditmaxCheck">The type of credit max check.</param>
    /// <param name = "_cashDiscCode">The cash discount code.</param>
    /// <param name = "_orderAccount">The order account.</param>
    /// <param name = "_negInstId">The negotiable instrument id.</param>
    /// <param name = "_fixedExchRate">The fixed exchange rate.</param>
    protected void init(
        CustVendAC _accountNum,
        AmountCur _amountCur,
        CurrencyCode _currencyCode,
        LedgerTransTxt _transTxtType,
        DimensionDefault _defaultDimension = 0,
        PostingProfile _postingProfile = '',
        LedgerPostingType _ledgerPostingType = LedgerPostingType::None,
        PaymTermId _paymTermId = '',
        SettlementType _settlementType = SettlementType::None,
        HcmApprover _approver = HcmWorker::userId2Worker(curUserId()),
        Approved _approved = _approver ? NoYes::Yes : NoYes::No,
        InvoiceId _invoiceId = '',
        TransDate _cashDiscDate = dateNull(),
        AmountCur _cashDiscAmount = 0,
        TransDate _dueDate = dateNull(),
        Common _common = common,
        TypeOfCreditmaxCheck _typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance,
        CashDiscCode _cashDiscCode = '',
        CustVendAC _orderAccount = '',
        CustVendNegInstId _negInstId = '',
        FixedExchRate _fixedExchRate = NoYes::No)
    {
        // <GIN>
        TaxTrans taxTransLoc;
        LedgerJournalTrans ledgerJournalTransLoc;
        TaxTrans_W taxTransLoc_W;
        // </GIN>
        common = _common;
        typeOfCreditmaxCheck = _typeOfCreditmaxCheck;
        accountNum = _accountNum;
        orderAccount = _orderAccount ? _orderAccount : _accountNum;
        currencyCode = _currencyCode;
        amountCur = _amountCur;
        defaultDimension = _defaultDimension;
        transTxtType = _transTxtType;
        postingProfile = _postingProfile;
        ledgerPostingType = _ledgerPostingType;
        paymTermId = _paymTermId;
        settlementType = _settlementType;
        approver = _approver;
        approved = _approved;
        invoiceId = _invoiceId;
        cashDiscDate = _cashDiscDate;
        cashDiscAmount = _cashDiscAmount;
        cashDiscCode = _cashDiscCode;
        dueDate = _dueDate;
        negotiableInstrumentId = _negInstId;
        fixedExchRate = _fixedExchRate;

        // <GIN>
        if (TaxParameters::isCustomsEnable_IN()
            && common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTransLoc = common as LedgerJournalTrans;

            if (ledgerJournalTransLoc.Cancel)
            {
                select sum(CustomsDuty_IN) from taxTransLoc_W
                    join RecId from taxTransLoc
                    where taxTransLoc_W.TaxTrans == taxTransLoc.RecId
                       && taxTransLoc.SourceTableId == ledgerJournalTransLoc.TableId
                       && taxTransLoc.SourceRecId == ledgerJournalTransLoc.RecId;

                TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTransLoc);

                // Customs Duty does not hit the Customer or Vendor balance, hence Vendor/Customer balance dedcuting the customsDuty amount
                amountCur = amountCur - CurrencyHelper_IN::customsCurAmount_IN(taxTransLoc_W.CustomsDuty_IN,
                                                                      ledgerJournalTransLoc.CurrencyCode,
                                                                      transTaxInformation.CustomsTariffDirection,
                                                                      ledgerJournalTransLoc.TransDate);
            }
            else
            {
                // Original 'amountCur' [invoiceamount] is including Taxes. We are getting the taxes removed from it..
                amountCur = TaxUncommitted_IN::getVendorBalanceForCustoms_IN(amountCur, common);
            }
        }
        // </GIN>

        this.setBuffer();

        ledgerDetailLevel = LedgerDetailLevel::AsDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCashRegisterFiscalTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new Cash Register Transaction from Payment Transaction.
    /// </summary>
    /// <param name = "_custVendTransCash">Current transaction.</param>
    protected void initCashRegisterFiscalTrans_W(CustVendTrans _custVendTransCash)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustVendTrans</c> map.
    /// </summary>
    /// <param name="custVendTrans">
    /// The map that contains the value of the vendor transaction or customer transaction.
    /// </param>
    /// <param name="_ledgerPostingJournal">
    /// The ledger posting journal to use for ledger posting.
    /// </param>
    /// <param name="_useSubLedger">
    /// A Boolean value that indicates whether the subledger is being used; optional.
    /// </param>
    protected void initCustVendTrans(
        CustVendTrans custVendTrans,
        LedgerVoucher _ledgerPostingJournal,
        boolean _useSubLedger = false)
    {
        // <GIN>
        int sign = 1;
        CustVendTrans_W custVendTrans_W;
        // </GIN>
        LedgerVoucherObject ledgerPostingReference;
        CurrencyExchangeHelper currencyExchangeHelper;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        custVendTrans.clear();
        custVendTrans.AccountNum = accountNum;
        custVendTrans.DefaultDimension = defaultDimension;
        custVendTrans.Invoice = invoiceId;

        custVendTrans.NegInstId = negotiableInstrumentId;

        if (negotiableInstrumentId ||
           negotiableInstrumentStatus == CustVendNegInstStatus::Invoiced)
        {
            custVendTrans.NegInstId = negotiableInstrumentId;
            custVendTrans.NegInstStatus = negotiableInstrumentStatus;
            custVendTrans.NegInstSeqNum = negotiableInstrumentSequenceNum;
        }

        // use the current ledger posting reference for most defaulting
        ledgerPostingReference = _ledgerPostingJournal.findLedgerVoucherObject();

        custVendTrans.TransDate = transDate;
        custVendTrans.DueDate = dueDate;
        custVendTrans.euroTriangulation = triangulation;
        custVendTrans.FixedExchRate = fixedExchRate;
        custVendTrans.ExchRate = exchRate;
        custVendTrans.ExchRateSecond = exchRateSecondary;
        custVendTrans.ReportingCurrencyExchRate = reportingCurrencyExchRate;
        custVendTrans.ReportingCurrencyExchRateSecondary = reportingCurrencyExchRateSecondary;
        custVendTrans.ReportingCurrencyCrossRate = reportingCurrencyCrossRate;

        custVendTrans.CurrencyCode = currencyCode;
        custVendTrans.Approver = approver;
        custVendTrans.Approved = approved;
        custVendTrans.PaymMode = paymMode;
        custVendTrans.PaymSpec = paymSpec;
        custVendTrans.PaymId = paymId;

        if (custVendTrans.TableId == tableNum(VendTrans)
            && custVendTrans.PostingProfile
            && custVendTrans.Approved
            && !custVendTrans.Arrival)
        {
            LedgerDimensionDefaultAccount summaryAccount = VendLedgerAccounts::summaryLedgerDimension(custVendTrans.AccountNum, postingProfile);

            custVendTrans.SummaryAccountId = MainAccount::findByLedgerDimension(summaryAccount).MainAccountId;
        }

        custVendTrans.PaymReference = paymReference;

        custVendTrans.CashDiscBaseDate = cashDiscBaseDate;
        custVendTrans.PaymTermId = paymTermId;

        custVendTrans.CashDiscCode = cashDiscCode;
        custVendTrans.ThirdPartyBankAccountId = thirdPartyBankAccountId;
        custVendTrans.CompanyBankAccountId = companyBankAccountId;

        custVendTrans.TransType = this.parmTransType();

        if (custVendTrans.TransType == LedgerTransType::None)
        {
            custVendTrans.TransType = ledgerPostingReference.parmTransactionTypeDefault();
        }

        custVendTrans.AccountingEvent = this.parmAccountingEventReference();
        custVendTrans.Voucher = ledgerPostingReference.parmReferenceNumber();
        custVendTrans.Prepayment = prePayment;

        custVendTrans.DocumentNum = documentNum;
        custVendTrans.DocumentDate = documentDate;

        custVendTrans.ReasonRefRecId = reasonRefRecID;

        // If the amount, which is the total invoice amount, is zero, then the amountMST and amountCur also must be zero
        if (amountCur)
        {
            if (_useSubLedger)
            {
                // <GIN>
                if (TaxWithholdParameters_IN::checkTaxParameters())
                {
                    if (isTCSApplicable
                        && TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled())
                    {
                        amountCur += this.roundedOffAmount(taxWithholdAmount);
                    }
                    else
                    {
                        amountCur += taxWithholdAmount;
                    }
                }
                // </GIN>

                custVendTrans.AmountMST = CurrencyExchangeHelper::mstAmount(amountCur, currencyCode, transDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecondary);
            }
            else
            {
                // <GEERU>
                if (ledgerBalances)
                {
                    custVendTrans.AmountMST = CurrencyExchangeHelper::amount(postedAmountMST, Ledger::accountingCurrency());
                }
                else
                {
                    // </GEERU>
                    custVendTrans.AmountMST = CurrencyExchangeHelper::amount(ledgerPostingReference.lastAmountMST(), Ledger::accountingCurrency());
                    // <GEERU>
                }
                // </GEERU>
            }
        }
        else
        {
            custVendTrans.AmountMST = 0;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            custVendTrans.AmountMST += CurrencyExchangeHelper::mstAmount(taxAgentVATAmount, custVendTrans.CurrencyCode, transDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecondary);
        }
        // </GEERU>

        if (this.parmSalesTaxPayment_TH()
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            custVendTrans.AmountCur = 0;
        }
        else
        {
            if (amountCur)
            {
                if (_useSubLedger)
                {
                    custVendTrans.AmountCur = amountCur;
                }
                else
                {
                    // <GEERU>
                    if (ledgerBalances)
                    {
                        custVendTrans.AmountCur = CurrencyExchangeHelper::amount(postedAmountCur, custVendTrans.CurrencyCode);
                    }
                    else
                    {
                        // </GEERU>
                        custVendTrans.AmountCur = CurrencyExchangeHelper::amount(ledgerPostingReference.lastAmountCur(), custVendTrans.CurrencyCode);
                        // <GEERU>
                    }
                    // </GEERU>
                }
            }
            else
            {
                custVendTrans.AmountCur = 0;
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                custVendTrans.AmountCur += taxAgentVATAmount;
            }
            // </GEERU>
        }

        // <GEERU>
        if (countryRegion_RU && amountCurFixed)
        {
            custVendTrans.AmountCur = amountCurFixed;
            custVendTrans.AmountMST = CurrencyExchangeHelper::mstAmount(amountCurFixed, custVendTrans.CurrencyCode, transDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecondary, true);
        }
        // </GEERU>

        this.initCustVendTransReportingCurrency(custVendTrans);

        // retrieve a specific ledger posting reference for the correction
        ledgerPostingReference = _ledgerPostingJournal.findLedgerVoucherObject(
            transVoucher == '' ? custVendTrans.Voucher : transVoucher,
            transDate == dateNull() ? custVendTrans.TransDate : transDate);

        custVendTrans.Correct = ledgerPostingReference.parmIsCorrectionDefault();

        // <GIN>
        custVendTrans_W = custVendTrans.CustVendTrans::getCustVendTrans_W();
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (ledgerPostingType == LedgerPostingType::VendBalance)
            {
                sign = -1;
            }

            if (isTDSApplicable)
            {
                custVendTrans_W.tdsAmount_IN = taxWithholdAmount + taxWithholdBank + taxWithhold + custVendWHTAmount;

                //tdsAmount is positive for vendor and negative for customer.
                custVendTrans_W.tdsAmount_IN = abs(custVendTrans_W.tdsAmount_IN) * sign * -1;

                custVendTrans_W.TaxWithholdAmountOrigin_IN = taxWithholdAmountOrigin * sign;
            }
            else if (isTCSApplicable)
            {
                custVendTrans_W.tcsAmount_IN = taxWithholdAmount + taxWithholdBank + taxWithhold + custVendWHTAmount;

                //tcsAmount is positive for customer and negative for vendor.
                custVendTrans_W.tcsAmount_IN = abs(custVendTrans_W.tcsAmount_IN) * sign;

                custVendTrans_W.TaxWithholdAmountOrigin_IN = taxWithholdAmountOrigin * sign;
            }
        }
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && TaxParameters::checkTaxParameters_IN()
            && custVendTrans.TransType == LedgerTransType::Tax
            && custVendTrans.TableId == tableNum(VendTrans_W))
        {
            custVendTrans_W.gtaAmount_IN = gtaAmount;
            custVendTrans_W.Settlement_IN = settlementGTA;
            custVendTrans_W.TaxComponentTable_IN = taxComponentLoc;
        }
        custVendTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        // </GIN>

        this.initInvoiceJournal(custVendTrans);
        this.initFromPostingProfile(custVendTrans, postingProfile);

        if (custVendTrans.TableId == tableNum(VendTrans)
            && custVendTrans.PostingProfile
            && custVendTrans.Approved
            && !custVendTrans.Arrival)
        {
            LedgerDimensionDefaultAccount summaryAccount = VendLedgerAccounts::summaryLedgerDimension(custVendTrans.AccountNum, postingProfile);

            custVendTrans.SummaryAccountId = MainAccount::findByLedgerDimension(summaryAccount).MainAccountId;
        }

        // Assign the invoice project bit
        //custVendTrans.InvoiceProject = this.parmInvoiceProject();

        // <GEERU>
        if (countryRegion_RU)
        {
            custVendTrans_W = custVendTrans.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.CorrectReporting_RU = custVendTrans.Correct;
            custVendTrans_W.CommProfileType_RU  = commProfileType;
            custVendTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        }
        // </GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custVendTrans.BankCentralBankPurposeCode = bankCentralBankPurposeCode;
            custVendTrans.BankCentralBankPurposeText = bankCentralBankPurposeText;
        }
        this.parmRelatedCustTrans(custVendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransReportingCurrency</Name>
				<Source><![CDATA[
    protected void initCustVendTransReportingCurrency(CustVendTrans _custVendTrans)
    {
        CustVendTransReportingCurrencyInitializer initializer = CustVendTransReportingCurrencyInitializer::newForTransaction(_custVendTrans);

        CurrencyCode reportingCurrency = initializer.getReportingCurrencyForTransaction();

        if (reportingCurrency != ''
            && _custVendTrans.CurrencyCode != '')
        {
            if (reportingCurrencyAmount)
            {
                // Sets reporting currency amount if fixed asset journal is manual sets the reporting currency amount and calculate the reporting currency cross rate.
                ReportingCurrencyExchRate reportingRateFromAmount = CurrencyExchange::calculateExchangeRate(
                    _custVendTrans.AmountCur,
                    reportingCurrencyAmount);

                _custVendTrans.ReportingCurrencyAmount = reportingCurrencyAmount;
                _custVendTrans.ReportingCurrencyExchRate = reportingRateFromAmount;
                _custVendTrans.ReportingCurrencyCrossRate = reportingRateFromAmount;
            }
            else
            {
                initializer.calculateReportingCurrencyAmount();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize values from custVendTran.
    /// </summary>
    /// <param name = "_custVendTrans">The custTrans to initialize.</param>
    public void parmRelatedCustTrans(CustVendTrans _custVendTrans = relatedCustTrans)
    {
        relatedCustTrans = _custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinTag</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public FinTagRecId parmFinTag(FinTagRecId _finTag = finTag)
    {
        finTag = _finTag;
        return finTag ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize values from posting profile.
    /// </summary>
    /// <param name = "custVendTrans">The custTrans or vendTrans to initialize.</param>
    /// <param name = "_postingProfile">The posting profile to initialize.</param>
    abstract protected void initFromPostingProfile(CustVendTrans custVendTrans,
                                                   PostingProfile _postingProfile)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize values from invoice journal.
    /// </summary>
    /// <param name = "custVendTrans">The custTrans or vendTrans to initialize.</param>
    protected void initInvoiceJournal(CustVendTrans custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize values from ledger posting.
    /// </summary>
    /// <param name = "_ledgerPostingJournal">The ledger posting journal.</param>
    protected void initLedgerPosting(LedgerVoucher _ledgerPostingJournal)
    {
        PaymTerm localPaymTerm;
        PaymCalendarProcessor paymCalendarProcessor;
        PaymentDueDateUpdatePolicy updatePolicy;

        if (_ledgerPostingJournal == null)
        {
            throw error("@SYS19386");
        }

        this.initTransDate(_ledgerPostingJournal);

        if ((cashDiscDate == dateNull()) && (cashDiscAmount || cashDiscCode))
        {
            // only update if it wasn't previously set
            cashDiscDate = CashDisc::cashDiscDate(cashDiscCode, transDate);
        }

        localPaymTerm = PaymTerm::find(paymTermId);
        
        this.initDueDate(localPaymTerm);

        updatePolicy = this.parmModuleType() == PaymCalendarModuleType::Customer ? localPaymTerm.CustomerUpdateDueDate : localPaymTerm.VendorUpdateDueDate;
        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)) && (updatePolicy != PaymentDueDateUpdatePolicy::NoUpdate))
        {
            paymCalendarProcessor = PaymCalendarProcessor::construct();
            dueDate = paymCalendarProcessor.adjustDate(dueDate, updatePolicy, this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the due date.
    /// </summary>
    /// <param name = "_paymTerm">
    ///     The <c>PaymTerm</c> table buffer used to calculate the due date.
    /// </param>
    protected void initDueDate(PaymTerm _paymTerm)
    {
        if (dueDate == dateNull())
        {
            // only update if it wasn't previously set
            dueDate = _paymTerm.due(transDate, this.custVendTable().PaymDayId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the transaction date.
    /// </summary>
    /// <param name = "_ledgerPostingJournal">The ledger posting journal.</param>
    protected void initTransDate(LedgerVoucher _ledgerPostingJournal)
    {
        // only update if it wasn't previously set
        if (transDate == dateNull())
        {
            // only update if it wasn't previously set
            transDate = _ledgerPostingJournal.lastTransDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountBelowCreditMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decide if is amount below credit max.
    /// </summary>
    /// <param name = "_typeOfCreditmaxCheck">The type of credit max check.</param>
    /// <returns>Returns a subclass value.</returns>
    abstract protected boolean isAmountBelowCreditMax(TypeOfCreditmaxCheck _typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCreatePaymSched_Continuity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>CustTransOpen</c> records based on payment schedule related
    /// to the continuity lines on the order that is related to the
    /// invoice that is passed in.
    /// Assumptions: There is no payment schedule on the sales order
    /// </summary>
    /// <param name="_custVendTrans">
    /// The customer / vendor transaction Id used to create the open transaction for.
    /// </param>
    /// <returns>
    /// true if <c>CustTransOpen</c> records are created; otherwise, false.
    /// </returns>
    boolean mcrCreatePaymSched_Continuity(CustVendTrans _custVendTrans)
    {
        CustInvoiceJour custInvoiceJourlocal;
        CustInvoiceTrans custInvoiceTrans;
        SalesTable salesTable;
        SalesLine salesLine;
        MCRContinuityCustHeader mcrContinuityCustHeader;
        PaymSchedCalc paymSchedCalc;
        AmountCur contAmt;
        AmountCur nonContAmt;
        CustTransOpen custTransOpen;
        boolean schedProcessed = false;

        if (custVendInvoiceJour
            && custVendInvoiceJour.TableId == tableNum(CustInvoiceJour)
            && isConfigurationkeyEnabled(configurationKeyNum(MCRContinuity)))
        {
            custInvoiceJourlocal = CustInvoiceJour::findRecId(custVendInvoiceJour.RecId);
            if (custInvoiceJourlocal.SalesId)
            {
                salesTable = SalesTable::find(custInvoiceJourlocal.SalesId);
                if (salesTable && salesTable.mcrSalesTable().ContinuityOrder)
                {
                    while select InventTransId, SalesId, SalesQty from salesLine
                        where salesLine.SalesId == salesTable.SalesId
                        join InventTransId, BillUpFront, PaymentScheduleId, RecId, TableId from mcrContinuityCustHeader // To be sure it's a continuity line
                        where mcrContinuityCustHeader.InventTransId == salesLine.InventTransId
                            && mcrContinuityCustHeader.BillUpFront
                            && mcrContinuityCustHeader.PaymentScheduleId
                        exists join custInvoiceTrans // To be sure it's invoiced
                        where custInvoiceTrans.InventTransId == salesLine.InventTransId
                            && custInvoiceTrans.InvoiceId == custInvoiceJourlocal.InvoiceId
                            // If this is a partial invoice, ignore payment schedule
                            && custInvoiceTrans.Qty == salesLine.SalesQty
                    {
                        select firstonly custVendPaymSched
                            where custVendPaymSched.ExtTableId == mcrContinuityCustHeader.TableId &&
                                    custVendPaymSched.ExtRecId == mcrContinuityCustHeader.RecId &&
                                    custVendPaymSched.Name == mcrContinuityCustHeader.PaymentScheduleId;

                        paymSchedCalc = PaymSchedCalc::construct(custVendPaymSched);
                        contAmt += paymSchedCalc.mcrInitFromCustInvoice_Continuity(custVendInvoiceJour);

                        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
                        {
                            paymSchedCalc.createCustVendTransaction(_custVendTrans, exchRate);
                        }

                        schedProcessed = true;
                    }

                    // Only use this logic to post remaining amounts if a schedule has already processed
                    // Otherwise this is a bill up front w/out a schedule, which should use standard posting logic
                    if (schedProcessed && contAmt < _custVendTrans.AmountCur)
                    {
                        nonContAmt = _custVendTrans.AmountCur - contAmt;

                        if (nonContAmt)
                        {
                            custTransOpen = this.createTransOpen(_custVendTrans);
                            custTransOpen.AmountCur = nonContAmt;
                            custTransOpen.AmountMST = CurrencyExchangeHelper::curAmount2CurAmount(nonContAmt, _custVendTrans.CurrencyCode, CompanyInfoHelper::standardCurrency());
                            custTransOpen.insert();
                        }
                    }
                }
            }
        }

        return schedProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLedgerDimensionAndDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Merges the default account of the ledger dimension and the default dimensions to create a ledger
    ///    dimension.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The default account of the ledger dimension.
    /// </param>
    /// <param name="_defaultDimension">
    ///    The default dimensions.
    /// </param>
    /// <returns>
    ///    A ledger dimension.
    /// </returns>
    protected LedgerDimensionAccount mergeLedgerDimensionAndDefaultDimension(
        LedgerDimensionDefaultAccount _ledgerDimension,
        DimensionDefault _defaultDimension)
    {
        LedgerDimensionAccount mergedLedgerDimension;
        List dimensionSources;

        dimensionSources = new List(Types::Class);

        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_defaultDimension));
        mergedLedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_ledgerDimension, dimensionSources);

        // If mergedLedgerDimension is a non-zero value then we know it was valid for an existing account structure.
        // If not then we execute the validation so we can get a warning message.
        if (mergedLedgerDimension == 0)
        {
            LedgerDimensionValidation::validateDefaultAccount(_ledgerDimension, Ledger::current());
        }

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreateCustVendTrans_IT</Name>
				<Source><![CDATA[
    private boolean isCreateCustVendTrans_IT()
    {
        return !customsTrans || customsTrans.ledgerJournalTable_Customs().CustomsDebt == CustomsDebt_IT::Customs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsTrans_IT</Name>
				<Source><![CDATA[
    public LedgerJournalTrans_Customs_IT parmCustomsTrans_IT(LedgerJournalTrans_Customs_IT _customsTrans = customsTrans)
    {
        customsTrans = _customsTrans;
        return customsTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new class.
    /// </summary>
    protected void new()
    {
        isItalyEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingEventReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the accounting event reference.
    /// </summary>
    /// <param name = "_accountingEventReference">The accounting event reference.</param>
    /// <returns>The accounting event reference.</returns>
    public RefRecId parmAccountingEventReference(RefRecId _accountingEventReference = accountingEventReference)
    {
        accountingEventReference = _accountingEventReference;

        return accountingEventReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the amountCur.
    /// </summary>
    /// <param name = "_amountCur">The amountCur.</param>
    /// <returns>Returns the amountCur.</returns>
    public AmountCur parmAmountCur(AmountCur _amountCur = amountCur)
    {
        amountCur = _amountCur;

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountCurFixed_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the amountCur fixed.
    /// </summary>
    /// <param name = "_amountCurFixed">The amountCur fixed.</param>
    /// <returns>Returns the amountCur fixed.</returns>
    public AmountCur parmAmountCurFixed_RU(AmountCur _amountCurFixed = amountCurFixed)
    {
        amountCurFixed = _amountCurFixed;

        return amountCurFixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the amountMST.
    /// </summary>
    /// <param name = "_amountMST">The amountMST.</param>
    /// <returns>Returns the amountMST.</returns>
    public AmountMST parmAmountMST(AmountMST _amountMST = amountMST)
    {
        amountMST = _amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the approved.
    /// </summary>
    /// <param name = "_approved">The approved.</param>
    /// <returns>Returns the approved.</returns>
    public Approved parmApproved(Approved _approved = approved)
    {
        approved = _approved;

        return approved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmApprover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the approver.
    /// </summary>
    /// <param name = "_approver">The approver.</param>
    /// <returns>Returns the approver.</returns>
    public HcmApprover parmApprover(HcmApprover _approver = approver)
    {
        approver = _approver;

        return approver;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankCentralBankPurposeCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bank central bank purpose code.
    /// </summary>
    /// <param name = "_bankCentralBankPurposeCode">The bank central bank purpose code.</param>
    public void parmBankCentralBankPurposeCode(BankCentralBankPurposeCode _bankCentralBankPurposeCode)
    {
        bankCentralBankPurposeCode = _bankCentralBankPurposeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankCentralBankPurposeText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bank central bank purpose text.
    /// </summary>
    /// <param name = "_bankCentralBankPurposeText">The sets bank central bank purpose text.</param>
    public void parmBankCentralBankPurposeText(BankCentralBankPurposeText _bankCentralBankPurposeText)
    {
        bankCentralBankPurposeText = _bankCentralBankPurposeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankCurrencyTransferId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets currency transfer id.
    /// </summary>
    /// <param name = "_currencyTransferId">The currency transfer id.</param>
    /// <returns>Returns currency transfer id.</returns>
    public BankCurrencyTransferId_RU parmBankCurrencyTransferId_RU(BankCurrencyTransferId_RU _currencyTransferId = currencyTransferId)
    {
        currencyTransferId = _currencyTransferId;

        return currencyTransferId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets customer billing classification.
    /// </summary>
    /// <param name = "_custBillingClassification">The customer billing classification.</param>
    /// <returns>>Returns the customer billing classification.</returns>
    public RefRecId parmBillingClassification(RefRecId _custBillingClassification = custBillingClassification)
    {
        custBillingClassification = _custBillingClassification;

        return custBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBypassCreditCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bypass credit check.
    /// </summary>
    /// <param name = "_bypassCreditCheck">The bypass credit check.</param>
    /// <returns>Returns the bypass credit check.</returns>
    public NoYes parmBypassCreditCheck(NoYes _bypassCreditCheck = bypassCreditCheck)
    {
        bypassCreditCheck = _bypassCreditCheck;

        return bypassCreditCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCancelledPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cancelled payment.
    /// </summary>
    /// <param name = "_cancelledPayment">The cancelled payment.</param>
    /// <returns>Returns the cancelled payment.</returns>
    public NoYes parmCancelledPayment(Cancelled _cancelledPayment = cancelledPayment)
    {
        cancelledPayment = _cancelledPayment;

        return cancelledPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCancelledLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cancelled ledger dimension.
    /// </summary>
    /// <param name = "_cancelledLedgerDimension">The cancelled ledger dimension.</param>
    /// <returns>Returns the cancelled ledger dimension.</returns>
    public LedgerDimensionAccount parmCancelledLedgerDimension(LedgerDimensionAccount _cancelledLedgerDimension = cancelledLedgerDimension)
    {
        cancelledLedgerDimension = _cancelledLedgerDimension;

        return cancelledLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cash discount amount.
    /// </summary>
    /// <param name = "_cashDiscAmount">The cash discount amount.</param>
    /// <returns>Returns the cash discount amount.</returns>
    public CashDiscAmount parmCashDiscAmount(CashDiscAmount _cashDiscAmount = cashDiscAmount)
    {
        cashDiscAmount = _cashDiscAmount;

        return cashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashDiscCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cash discount code.
    /// </summary>
    /// <param name = "_cashDiscCode">The cash discount code.</param>
    /// <returns>Returns the cash discount code.</returns>
    public CashDiscCode parmCashDiscCode(CashDiscCode _cashDiscCode = cashDiscCode)
    {
        cashDiscCode = _cashDiscCode;

        return cashDiscCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cash discount date.
    /// </summary>
    /// <param name = "_cashDiscdate">The cash discount date.</param>
    /// <returns>Returns the cash discount date.</returns>
    public CashDiscdate parmCashDiscDate(CashDiscdate _cashDiscdate = cashDiscDate)
    {
        cashDiscDate = _cashDiscdate;

        return cashDiscDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashDiscBaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets cash discount base date.
    /// </summary>
    /// <param name = "_cashDiscBaseDate">The cash discount base date.</param>
    /// <returns>Returns the cash discount base date.</returns>
    public CashDiscBaseDate parmCashDiscBaseDate(CashDiscBaseDate _cashDiscBaseDate = cashDiscBaseDate)
    {
        cashDiscBaseDate = _cashDiscBaseDate;

        return cashDiscBaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCashPayment</Name>
				<Source><![CDATA[
    public boolean parmIsCashPayment(boolean _isCashPayment = isCashPayment)
    {
        isCashPayment = _isCashPayment;
        return isCashPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckBank_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets check bank.
    /// </summary>
    /// <param name = "_checkBank">The check bank.</param>
    /// <returns>Returns the check bank.</returns>
    public boolean parmCheckBank_IN(boolean _checkBank = checkBank)
    {
        checkBank = _checkBank;

        return checkBank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckCentralizedPayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets check centralized payment.
    /// </summary>
    /// <param name = "_checkCentralizedPayment">The check centralized payment.</param>
    /// <returns>Returns the check centralized payment.</returns>
    public boolean parmCheckCentralizedPayment_IN(boolean _checkCentralizedPayment = checkCentralizedPayment)
    {
        checkCentralizedPayment = _checkCentralizedPayment;

        return checkCentralizedPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckStatus_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets check status.
    /// </summary>
    /// <param name = "_checkStatus">The check status.</param>
    /// <returns>Returns the check status.</returns>
    public boolean parmCheckStatus_IN(boolean _checkStatus = checkStatus)
    {
        checkStatus = _checkStatus;

        return checkStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCommon_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the common table for Russia.
    /// </summary>
    /// <param name = "_common">The common table.</param>
    /// <returns>Returns value of common.</returns>
    public Common parmCommon_RU(Common _common = common)
    {
        common = _common;

        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets company bank account id.
    /// </summary>
    /// <param name = "_companyBankAccountId">The company bank account id.</param>
    /// <returns>Returns the company bank account id.</returns>
    public CompanyBankAccountId parmCompanyBankAccountId(CompanyBankAccountId _companyBankAccountId = companyBankAccountId)
    {
        companyBankAccountId = _companyBankAccountId;

        return companyBankAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCommProfileType_RU</Name>
				<Source><![CDATA[
    public CommProfileType_RU parmCommProfileType_RU(CommProfileType_RU _commProfileType = commProfileType)
    {
        commProfileType = _commProfileType;
        return commProfileType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets currency code.
    /// </summary>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <returns>Returns the currency code.</returns>
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = currencyCode)
    {
        currencyCode = _currencyCode;

        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceTransRecId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets customer invoice trans recId.
    /// </summary>
    /// <param name = "_custInvoiceTransRecId">The customer invoice trans recId.</param>
    /// <returns>Returns the customer invoice trans recId.</returns>
    public RefRecId parmCustInvoiceTransRecId_IN(RefRecId _custInvoiceTransRecId = custInvoiceTransRecId)
    {
        custInvoiceTransRecId = _custInvoiceTransRecId;

        return custInvoiceTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets customer or vender invoice journal.
    /// </summary>
    /// <param name = "_custVendInvoiceJour">The customer or vender invoice journal.</param>
    /// <returns>Returns the customer or vender invoice journal.</returns>
    CustVendInvoiceJour parmCustVendInvoiceJour(CustVendInvoiceJour _custVendInvoiceJour = custVendInvoiceJour)
    {
        custVendInvoiceJour = _custVendInvoiceJour;

        return custVendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendNegInstStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets negotiable instrument status.
    /// </summary>
    /// <param name = "_negotiableInstrumentStatus">The negotiable instrument status.</param>
    /// <returns>Returns the negotiable instrument status.</returns>
    CustVendNegInstStatus parmCustVendNegInstStatus(CustVendNegInstStatus _negotiableInstrumentStatus = negotiableInstrumentStatus)
    {
        negotiableInstrumentStatus = _negotiableInstrumentStatus;

        return negotiableInstrumentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendWHT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets customer or vender WHT amount.
    /// </summary>
    /// <param name = "_custVendWHTAmount">The customer or vender WHT amount.</param>
    /// <returns>Returns the customer or vender WHT amount.<</returns>
    public AmountCur parmCustVendWHT_IN(AmountCur _custVendWHTAmount = custVendWHTAmount)
    {
        custVendWHTAmount = _custVendWHTAmount;

        return custVendWHTAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets document date.
    /// </summary>
    /// <param name = "_documentDate">The document date.</param>
    /// <returns>Returns the document date.</returns>
    public DocumentDate parmDocumentDate(DocumentDate _documentDate = documentDate)
    {
        documentDate = _documentDate;

        return documentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets document number.
    /// </summary>
    /// <param name = "_documentNum">The document number.</param>
    /// <returns>Returns the document number.</returns>
    public DocumentNum parmDocumentNum(DocumentNum _documentNum = documentNum)
    {
        documentNum = _documentNum;

        return documentNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets dueDate.
    /// </summary>
    /// <param name = "_dueDate">The dueDate.</param>
    /// <returns>Returns the dueDate.</returns>
    public DueDate parmDueDate(DueDate _dueDate = dueDate)
    {
        dueDate = _dueDate;

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets exchange rate date.
    /// </summary>
    /// <param name = "_exchangeRateDate">The exchange rate date.</param>
    /// <returns>Returns the exchange rate date.</returns>
    public TransDate parmExchangeRateDate(TransDate _exchangeRateDate = exchangeRateDate)
    {
        exchangeRateDate = _exchangeRateDate;

        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets exchange rate.
    /// </summary>
    /// <param name = "_exchRate">The exchange rate.</param>
    /// <returns>Returns the exchange rate.</returns>
    public ExchRate parmExchRate(ExchRate _exchRate = exchRate)
    {
        exchRate = _exchRate;

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets exchange rate secondary.
    /// </summary>
    /// <param name = "_exchRateSecondary">The exchange rate secondary.</param>
    /// <returns>Returns the exchange rate secondary.</returns>
    public ExchRate parmExchRateSecondary(ExchRate _exchRateSecondary = exchRateSecondary)
    {
        exchRateSecondary = _exchRateSecondary;

        return exchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets fine amount for Brazil.
    /// </summary>
    /// <param name = "_fineAmount">The fine amount.</param>
    /// <returns>Returns the fine amount.</returns>
    public AmountCur parmFineAmount_BR(AmountCur _fineAmount = fineAmount)
    {
        fineAmount = _fineAmount;

        return fineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFineCode_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets fine code for Brazil.
    /// </summary>
    /// <param name = "_fineCode">The fine code.</param>
    /// <returns>Returns the fine code.</returns>
    public CustFineCode_BR parmFineCode_BR(CustFineCode_BR _fineCode = fineCode)
    {
        fineCode = _fineCode;

        return fineCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinInterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets fine interest amount for Brazil.
    /// </summary>
    /// <param name = "_finInterestAmount">The fine interest amount.</param>
    /// <returns>Returns the fine interest amount.</returns>
    public AmountCur parmFinInterestAmount_BR(AmountCur _finInterestAmount = finInterestAmount)
    {
        finInterestAmount = _finInterestAmount;

        return finInterestAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets fixed exchange rate.
    /// </summary>
    /// <param name = "_fixedExchRate">The fixed exchange rate.</param>
    /// <returns>Returns the fixed exchange rate.</returns>
    public FixedExchRate parmFixedExchRate(FixedExchRate _fixedExchRate = fixedExchRate)
    {
        fixedExchRate = _fixedExchRate;

        return fixedExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets form letter.
    /// </summary>
    /// <param name = "_formLetter">The form letter.</param>
    /// <returns>Returns the form letter.</returns>
    public Num parmFormLetter(Num _formLetter = formLetter)
    {
        formLetter = _formLetter;

        return formLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGTAAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets GTA amount for India.
    /// </summary>
    /// <param name = "_gtaAmount">The GTA amount.</param>
    /// <returns>Returns the GTA amount.</returns>
    public AmountCur parmGTAAmount_IN(AmountCur _gtaAmount = gtaAmount)
    {
        gtaAmount = _gtaAmount;

        return gtaAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterestCode_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets interest code for Brazil.
    /// </summary>
    /// <param name = "_interestCode">The interest code.</param>
    /// <returns>Returns the interest code.</returns>
    public CustInterestCode_BR parmInterestCode_BR(CustInterestCode_BR _interestCode = interestCode)
    {
        interestCode = _interestCode;

        return interestCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets invoice id.
    /// </summary>
    /// <param name = "_invoiceId">The invoice id.</param>
    /// <returns>Returns the invoice id.</returns>
    public InvoiceId parmInvoiceId(InvoiceId _invoiceId = invoiceId)
    {
        invoiceId = _invoiceId;

        return invoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCalledFromSplitPayment_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is called from split payment.
    /// </summary>
    /// <param name = "_isCalledFromSplitPayment">If it is called from split payment.</param>
    /// <returns>True if it is called from split payment.</returns>
    public boolean parmIsCalledFromSplitPayment_IT(boolean _isCalledFromSplitPayment = isCalledFromSplitPayment)
    {
        isCalledFromSplitPayment = _isCalledFromSplitPayment;
        return isCalledFromSplitPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is invoice project.
    /// </summary>
    /// <param name = "_invoiceProject">If it is invoice project.</param>
    /// <returns>True if it is invoice project.</returns>
    public NoYesCombo parmInvoiceProject(NoYesCombo _invoiceProject = invoiceProject)
    {
        invoiceProject = _invoiceProject;

        return invoiceProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInvoicePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is posted invoice.
    /// </summary>
    /// <param name = "_isInvoicePosted">If it is posted invoice.</param>
    /// <returns>True if it is posted invoice.</returns>
    public boolean parmIsInvoicePosted(boolean _isInvoicePosted = isInvoicePosted)
    {
        isInvoicePosted = _isInvoicePosted;

        return isInvoicePosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets language id.
    /// </summary>
    /// <param name = "_languageId">The language id.</param>
    /// <returns>Returns the language id.</returns>
    public LanguageId parmLanguageId(LanguageId _languageId = languageId)
    {
        languageId = _languageId;

        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerBalances_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets or gets container of balances which should be posted to ledger.
    /// </summary>
    /// <param name="_value">
    ///    New value.
    /// </param>
    /// <returns>
    ///   Current value.
    /// </returns>
    /// <remarks>
    ///    Property stores container of containers like [[creditCorrection1, balance1], [creditCorrection2, balance2], ...]
    /// where
    ///    creditCorrectionN - is a sign of credit correction for n-th balance,
    ///    balanceN - is a value of n-th balance in transaction currency.
    /// </remarks>
    public container parmLedgerBalances_RU(container _value = ledgerBalances)
    {
        ledgerBalances = _value;

        return ledgerBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDetailLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets ledger detail level.
    /// </summary>
    /// <param name = "_ledgerDetailLevel">The ledger detail level.</param>
    /// <returns>Returns the ledger detail level.</returns>
    public LedgerDetailLevel parmLedgerDetailLevel(LedgerDetailLevel _ledgerDetailLevel = ledgerDetailLevel)
    {
        ledgerDetailLevel = _ledgerDetailLevel;

        return ledgerDetailLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets ledger posting type.
    /// </summary>
    /// <param name = "_ledgerPostingType">The ledger posting type.</param>
    /// <returns>Returns the ledger posting type.</returns>
    public LedgerPostingType parmLedgerPostingType(LedgerPostingType _ledgerPostingType = ledgerPostingType)
    {
        ledgerPostingType = _ledgerPostingType;

        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the module used by the payment calendar source interface methods.
    /// </summary>
    /// <param name="_module">
    /// The system module.
    /// </param>
    protected void parmModule(SysModule _module)
    {
        module = _module;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets module type.
    /// </summary>
    /// <returns>Returns the module type.</returns>
    public PaymCalendarModuleType parmModuleType()
    {
        switch (module)
        {
            case SysModule::Cust:
            case SysModule::Project:
                return PaymCalendarModuleType::Customer;

            case SysModule::Vend:
                return PaymCalendarModuleType::Vendor;

            default :
                return PaymCalendarModuleType::Customer; // Return null value
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the payment id.
    /// </summary>
    /// <param name = "_paymId">The payment id.</param>
    /// <returns>Returns the payment id.</returns>
    public PaymId parmPaymId(PaymId _paymId = paymId)
    {
        paymId = _paymId;

        return paymId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets payment mode.
    /// </summary>
    /// <param name = "_paymMode">The payment mode.</param>
    /// <returns>Returns the payment mode.</returns>
    public PaymMode parmPaymMode(PaymMode _paymMode = paymMode)
    {
        paymMode = _paymMode;

        return paymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets payment reference.
    /// </summary>
    /// <param name = "_paymReference">The payment reference.</param>
    /// <returns>Returns the payment reference.</returns>
    public PaymReference parmPaymReference(PaymReference _paymReference = paymReference)
    {
        paymReference = _paymReference;

        return paymReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets special payment.
    /// </summary>
    /// <param name = "_paymSpec">The special payment.</param>
    /// <returns>Returns the special payment.</returns>
    public PaymSpec parmPaymSpec(PaymSpec _paymSpec = paymSpec)
    {
        paymSpec = _paymSpec;

        return paymSpec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermDataAreaId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets payment term data area id.
    /// </summary>
    /// <returns>Returns the payment term data area id.</returns>
    public DataAreaId parmPaymTermDataAreaId()
    {
        if (common.RecId)
        {
            return common.DataAreaId;
        }
        else
        {
            return curext();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets payment term id.
    /// </summary>
    /// <param name = "_paymTermId">The payment term id.</param>
    /// <returns>Returns the payment term id.</returns>
    public PaymTermId parmPaymTermId(PaymTermId _paymTermId = paymTermId)
    {
        paymTermId = _paymTermId;

        return paymTermId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets posting profile.
    /// </summary>
    /// <param name = "_postingProfile">The posting profile.</param>
    /// <returns>Returns the posting profile.</returns>
    public PostingProfile parmPostingProfile(PostingProfile _postingProfile = postingProfile)
    {
        postingProfile = _postingProfile;

        return postingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is prePayment.
    /// </summary>
    /// <param name = "_prePayment">If it is prePayment.</param>
    /// <returns>Yes if it is prePayment.</returns>
    public NoYes parmPrePayment(NoYes _prePayment = prePayment)
    {
        prePayment = _prePayment;

        return prePayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reason reference recID.
    /// </summary>
    /// <param name = "_reasonRefRecID">The reason reference recID.</param>
    /// <returns>Returns the reason reference recID.</returns>
    public ReasonRefRecID parmReasonRefRecID(ReasonRefRecID _reasonRefRecID = reasonRefRecID)
    {
        reasonRefRecID = _reasonRefRecID;

        return reasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reporting currency exchange rate.
    /// </summary>
    /// <param name = "_reportingCurrencyExchRate">The reporting currency exchange rate.</param>
    /// <returns>Returns the reporting currency exchange rate.</returns>
    public ReportingCurrencyExchRate parmReportingCurrencyExchRate(ReportingCurrencyExchRate _reportingCurrencyExchRate = reportingCurrencyExchRate)
    {
        reportingCurrencyExchRate = _reportingCurrencyExchRate;

        return reportingCurrencyExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reporting currency exchange rate secondary.
    /// </summary>
    /// <param name = "_reportingCurrencyExchRateSecondary">The reporting currency exchange rate secondary.</param>
    /// <returns>Returns the reporting currency exchange rate secondary.</returns>
    public ReportingCurrencyExchRateSecondary parmReportingCurrencyExchRateSecondary(ReportingCurrencyExchRateSecondary _reportingCurrencyExchRateSecondary = reportingCurrencyExchRateSecondary)
    {
        reportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondary;

        return reportingCurrencyExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reporting currency cross rate.
    /// </summary>
    /// <param name = "_reportingCurrencyCrossRate">The reporting currency cross rate.</param>
    /// <returns>Returns the reporting currency cross rate.</returns>
    [SysObsolete('This method has been obsoleted with the move to dual currency. Please use the reporting currency exchange rate parm methods instead.', false, 30\6\2020)]
    public ExchRate parmReportingCurrencyCrossRate(ExchRate _reportingCurrencyCrossRate = reportingCurrencyCrossRate)
    {
        reportingCurrencyCrossRate = _reportingCurrencyCrossRate;

        return reportingCurrencyCrossRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRequireGLPostingPriorToSettlement</Name>
				<Source><![CDATA[
    public boolean parmRequireGLPostingPriorToSettlement(boolean _requireGLPostingPriorToSettlement = requireGLPostingPriorToSettlement)
    {
        requireGLPostingPriorToSettlement = _requireGLPostingPriorToSettlement;

        return requireGLPostingPriorToSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesInvoicePostingType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets sales invoice posting type for Russia.
    /// </summary>
    /// <param name = "_salesInvoicePostingType">The sales invoice posting type.</param>
    /// <returns>Returns the sales invoice posting type.</returns>
    public SalesInvoicePostingType_RU parmSalesInvoicePostingType_RU(SalesInvoicePostingType_RU _salesInvoicePostingType = salesInvoicePostingType)
    {
        salesInvoicePostingType = _salesInvoicePostingType;

        return salesInvoicePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTaxPayment_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is sales tax payment.
    /// </summary>
    /// <param name = "_isSalesTaxPayment">If it is sales tax payment.</param>
    /// <returns>True if it is sales tax payment.</returns>
    public boolean parmSalesTaxPayment_TH(boolean _isSalesTaxPayment = isSalesTaxPayment)
    {
        isSalesTaxPayment = _isSalesTaxPayment;

        return isSalesTaxPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlement_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is settlement GTA.
    /// </summary>
    /// <param name = "_settlementGTA">If it is settlement GTA.</param>
    /// <returns>Yes if it is settlement GTA.</returns>
    public NoYesId parmSettlement_IN(NoYesId _settlementGTA = NoYes::No)
    {
        settlementGTA = _settlementGTA;

        return _settlementGTA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets settlement type.
    /// </summary>
    /// <param name = "_settlementType">The settlement type.</param>
    /// <returns>Returns the settlement type.</returns>
    public SettlementType parmSettlementType(SettlementType _settlementType = settlementType)
    {
        settlementType = _settlementType;

        return settlementType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxAgentVATAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method gets or sets amount of vat to be added to transaction for VAT tax Agent transactions
    /// </summary>
    /// <param name="_taxAgentVATAmount">
    /// Amount to be added
    /// </param>
    /// <returns>
    /// Amount to be added
    /// </returns>
    public AmountCur parmTaxAgentVATAmount_RU(AmountCur _taxAgentVATAmount = taxAgentVATAmount)
    {
        taxAgentVATAmount = _taxAgentVATAmount;

        return taxAgentVATAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxComponent_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets location tax component for India.
    /// </summary>
    /// <param name = "_taxComponentLoc">The location tax component.</param>
    /// <returns>Returns the location tax component.</returns>
    public RefRecId parmTaxComponent_IN(RefRecId _taxComponentLoc = taxComponentLoc)
    {
        taxComponentLoc = _taxComponentLoc;

        return taxComponentLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithhold_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold.
    /// </summary>
    /// <param name = "_taxWithhold">The tax withhold.</param>
    /// <returns>Returns the tax withhold.</returns>
    public AmountCur parmTaxWithhold_IN(AmountCur _taxWithhold = taxWithhold)
    {
        taxWithhold = _taxWithhold;

        return taxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold amount.
    /// </summary>
    /// <param name = "_taxWithholdAmount">The tax withhold amount.</param>
    /// <returns>Returns the tax withhold amount.</returns>
    public AmountCur parmTaxWithholdAmount_IN(AmountCur _taxWithholdAmount = taxWithholdAmount)
    {
        taxWithholdAmount = _taxWithholdAmount;

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdAmountOriginCur_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold amount origin.
    /// </summary>
    /// <param name = "_taxWithholdAmountOrigin">The tax withhold amount origin.</param>
    /// <returns>Returns the tax withhold amount origin.</returns>
    public AmountCur parmTaxWithholdAmountOriginCur_IN(AmountCur _taxWithholdAmountOrigin = taxWithholdAmountOrigin)
    {
        taxWithholdAmountOrigin = _taxWithholdAmountOrigin;

        return taxWithholdAmountOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdBank_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold bank.
    /// </summary>
    /// <param name = "_taxWithholdBank">The tax withhold bank.</param>
    /// <returns>Returns the tax withhold bank.</returns>
    public AmountCur parmTaxWithholdBank_IN(AmountCur _taxWithholdBank = taxWithholdBank)
    {
        taxWithholdBank = _taxWithholdBank;

        return taxWithholdBank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdTransRecId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold trans recId.
    /// </summary>
    /// <param name = "_taxWithholdTransRecId">The tax withhold trans recId.</param>
    /// <returns>Returns the tax withhold trans recId.</returns>
    public RefRecId parmTaxWithholdTransRecId_IN(RefRecId _taxWithholdTransRecId = taxWithholdTransRecId)
    {
        taxWithholdTransRecId = _taxWithholdTransRecId;

        return taxWithholdTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWitholdSettled_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withold settled.
    /// </summary>
    /// <param name = "_taxWitholdSettled">The tax withold settled.</param>
    /// <returns>Returns the tax withold settled.</returns>
    public boolean parmTaxWitholdSettled_IN(boolean _taxWitholdSettled = taxWitholdSettled)
    {
        taxWitholdSettled = _taxWitholdSettled;

        return taxWitholdSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThirdPartyBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets third party bank account id.
    /// </summary>
    /// <param name = "_thirdPartyBankAccountId">The third party bank account id.</param>
    /// <returns>Returns the third party bank account id.</returns>
    public BankThirdPartyAccountId parmThirdPartyBankAccountId(BankThirdPartyAccountId _thirdPartyBankAccountId = thirdPartyBankAccountId)
    {
        thirdPartyBankAccountId = _thirdPartyBankAccountId;

        return thirdPartyBankAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets transaction date.
    /// </summary>
    /// <param name = "_transDate">The transaction date.</param>
    /// <returns>Returns the transaction date.</returns>
    TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets transaction txt.
    /// </summary>
    /// <param name = "_transTxt">The transaction txt.</param>
    /// <returns>Returns the transaction txt.</returns>
    TransactionTextLarge parmTransTxt(TransactionTextLarge _transTxt = transTxt)
    {
        transTxt = _transTxt;

        return transTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets transaction type.
    /// </summary>
    /// <param name = "_transType">The transaction type.</param>
    /// <returns>Returns the transaction type.</returns>
    LedgerTransType parmTransType(LedgerTransType _transType = transType)
    {
        transType = _transType;

        return transType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets transaction voucher.
    /// </summary>
    /// <param name = "_transVoucher">The transaction voucher.</param>
    /// <returns>Returns the transaction voucher.</returns>
    Voucher parmTransVoucher(Voucher _transVoucher = transVoucher)
    {
        transVoucher = _transVoucher;

        return transVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTriangulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets triangulation.
    /// </summary>
    /// <param name = "_triangulation">The triangulation.</param>
    /// <returns>Returns the triangulation.</returns>
    EUROTriangulation parmTriangulation(EUROTriangulation _triangulation = triangulation)
    {
        triangulation = _triangulation;

        return triangulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTypeOfCreditmaxCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets type of credit max check.
    /// </summary>
    /// <param name = "_typeOfCreditmaxCheck">The type of credit max check.</param>
    /// <returns>Returns the type of credit max check.</returns>
    public TypeOfCreditmaxCheck parmTypeOfCreditmaxCheck(TypeOfCreditmaxCheck _typeOfCreditmaxCheck = typeOfCreditmaxCheck)
    {
        typeOfCreditmaxCheck = _typeOfCreditmaxCheck;

        return typeOfCreditmaxCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets voucher.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    /// <returns>Returns the voucher.</returns>
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHTCentralizedPayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets total WHT bank amount.
    /// </summary>
    /// <param name = "_totalWHTBankAmount">The total WHT bank amount.</param>
    /// <returns>Returns the total WHT bank amount.</returns>
    public AmountCur parmWHTCentralizedPayment_IN(AmountCur _totalWHTBankAmount = totalWHTBankAmount)
    {
        totalWHTBankAmount += _totalWHTBankAmount;

        return totalWHTBankAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsReimbursement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the voucher part of the reimbursement process.
    /// </summary>
    /// <param name = "_isReimbursement">Is voucher reimbursement.</param>
    /// <returns>True if reimbursement, false otherwise.</returns>
    public boolean parmIsReimbursement(boolean _isReimbursement = isReimbursement)
    {
        isReimbursement = _isReimbursement;
        return isReimbursement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the reporting currency amount.
    /// </summary>
    /// <param name="_reportingCurrencyAmount">
    /// The new value of the parameter reportingCurrencyAmount; optional.
    /// </param>
    /// <returns>
    ///  The current value of parameter reportingCurrencyAmount.
    /// </returns>
    public AmountMSTSecondary parmReportingCurrencyAmount(AmountMSTSecondary _reportingCurrencyAmount = reportingCurrencyAmount)
    {
        reportingCurrencyAmount = _reportingCurrencyAmount;
        return reportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts the customer or vendor voucher.
    /// </summary>
    /// <param name="_ledgerPostingJournal">
    /// The ledger posting journal to use for ledger posting.
    /// </param>
    /// <param name="_custVendTrans">
    /// The Map object that contains the value of vendor transaction or customer transaction.
    /// </param>
    /// <param name="_approval">
    /// The Boolean value that indicates the status for approval; optional.
    /// </param>
    /// <param name="_euroTriangulation">
    /// The Europe triangulation value in a drop-down list; optional.
    /// </param>
    /// <param name="_withHoldTaxType">
    /// A Boolean value that indicates whether there is withholding tax; optional.
    /// </param>
    /// <param name="_useSubLedger">
    /// A Boolean value that indicates whether the SubLedger is being used; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// Validation failed after the execution of the validate method.
    /// </exception>
    public void post(
        LedgerVoucher _ledgerPostingJournal,
        CustVendTrans _custVendTrans,
        NoYes _approval = NoYes::No,
        UnknownNoYes _euroTriangulation = Currency::noYes2UnknownNoYes(triangulation),
        boolean _withHoldTaxType = false,
        boolean _useSubLedger = false)
    {
        #ISOCountryRegionCodesVendInv_W
        SpecTransManager specTransManager;
        CustVendTransOpen custVendTransOpenCash;
        CustVendTrans custVendTransCash;
        CustVendTransOpen custVendTransOpen;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        CustVendTransData custVendTransData;
        boolean postingProfileSettlement;
        NoYes tmpInvoiceProject;
        Tax1099Amount tmpTax1099Amount;
        Tax1099StateAmount tmpTax1099StateAmount;
        Tax1099FieldsRecId tmpTax1099FieldsRecId;
        Tax1099State tmpTax1099State;
        InvoiceReleaseDate tmpInvoiceReleaseDate;
        ReleaseDateComment tmpReleaseDateComment;
        SpecTrans specTransLoc;
        CustVendTransOpen custVendTransOpenLoc;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerJournalTrans ledgerJournalTrans;
        boolean contSchedProcessed = false;
        // <GEERU>
        PurchTable purchTable;
        EmplAccount_RU emplAccount;
        InventProfileType_RU inventProfileType;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
        // </GEERU>

        boolean isW = SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W);
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;

        this.hasVendInvoiceDisbursements = false;

        // <GEEU>
        boolean enableAdvanceHolders = EmplParameters_RU::enableAdvanceHolders();
        // </GEEU>
        
        RecId tmpTax1099BoxDetailRecId;
        BankTransactionTypes bankTransactionTypes;
        Debug::assert(_custVendTrans.DataAreaId == curext());

        postingProfileSettlement = this.postingProfileSettlement();
        _custVendTrans.AccountNum = accountNum;

        this.initLedgerPosting(_ledgerPostingJournal);

        if (!this.validate())
        {
            throw error("@SYS21533");
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            inventProfileType = custVendInvoiceJour.CustVendInvoiceJour::getInventProfileType_RU();
        }
        // </GEERU>

        ttsbegin;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && this.parmIsCalledFromSplitPayment_IT())
        {
            localTransactionTxt = "@AccountsReceivable:SplitPayment";
        }
        else
        {
            localTransactionTxt = this.setTransactionTxt(this.parmLanguageId(), _ledgerPostingJournal.lastVoucher(), _ledgerPostingJournal.lastTransDate());
        }

        if (localTransactionTxt == '')
        {
            localTransactionTxt = transTxt;
        }

        if (!_useSubLedger && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            bankTransactionTypes = JournalizingDefinitionManagerBank::convertLedgerJourTypeToBankTransTypes(ledgerJournalTrans.ledgerJournalTable().JournalType);
        }

        ledgerVoucherTransObject = this.createLedgerVoucherTransObject(_useSubLedger,
                                                                       ledgerDimensionMerged,
                                                                       ledgerJournalTrans,
                                                                       _ledgerPostingJournal,
                                                                       _custVendTrans);

        // <GEERU><GEEU>
        if (enableAdvanceHolders && common)
        {
            if (common.TableId == tableNum(PurchTable))
            {
                purchTable = common;
                emplAccount = purchTable.purchTable_W().EmplAccount_RU;
            }
            else if (common.TableId == tableNum(VendInvoiceInfoTable))
            {
                if (isW)
                {
                    localVendInvoiceInfoTable = common;
                    vendInvoiceInfoTable_W = localVendInvoiceInfoTable.vendInvoiceInfoTable_W();
                    emplAccount = vendInvoiceInfoTable_W.EmplAccount_RU;
                }
            }
        }
        // </GEERU></GEEU>
        // <GEERU>
        boolean isRU = countryRegion_RU &&
                        (salesInvoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute ||
                            inventProfileType == InventProfileType_RU::Bailee ||
                            inventProfileType == InventProfileType_RU::CommissionPrincipalAgent ||
                            (_custVendTrans.TableId == tableNum(VendTrans) &&
                                inventProfileType == InventProfileType_RU::CommissionAgent));

        if (_approval == NoYes::Yes || isRU)
        // </GEERU>
        {
            if (_custVendTrans.TableId == tableNum(VendTrans))
            {
                _custVendTrans = VendTrans::findAccountVoucherDate(custVendInvoiceJour.InvoiceAccount, custVendInvoiceJour.LedgerVoucher, custVendInvoiceJour.InvoiceDate);
                custVendTransOpen = VendTrans::find(_custVendTrans.RecId).transOpen();

                if (_approval == NoYes::Yes && !isRU
                    && InvoiceJournalPaymentScheduleFeature::isEnabled())
                {
                    this.initCustVendPaymSched(_ledgerPostingJournal);

                    if (this.shouldCreateCustVendTransForPaymSched(_custVendTrans))
                    {
                        //Delete the <c>VendTransOpen</c>,<c>VendTransCashDisc</c> records and recreate using payment schedule.
                        if (custVendTransOpen)
                        {
                            VendTransCashDisc vendTransCashDisc;
                            delete_from vendTransCashDisc
                                where vendTransCashDisc.RefTableId == custVendTransOpen.TableId &&
                                      vendTransCashDisc.RefRecId == custVendTransOpen.recId;

                            custVendTransOpen.selectForUpdate(true);
                            custVendTransOpen.delete();
                        }
                        _custVendTrans.selectForUpdate(true);
                        this.createCustVendTransForPaymSched(_custVendTrans);
                
                        custVendTransOpen = VendTrans::find(_custVendTrans.RecId).transOpen();
                    }
                }

                if (TaxWithholdParameters_IN::checkTaxParameters()
                    && _approval == NoYes::Yes
                    && _useSubLedger)
                {
                    [_custVendTrans, custVendTransOpen] = this.updateVendTrans_IN(_custVendTrans, custVendTransOpen);
                }
            }
        }
        else
        {
            // Store the invoice project variable and then assign it back to the
            // custVendTrans object after being initialised
            tmpInvoiceProject = _custVendTrans.InvoiceProject;

            //Store 1099 tax information in variables and then restore after the
            //custVendTrans object is initialized.
            if (_custVendTrans.TableId == tableNum(VendTrans))
            {
                tmpTax1099Amount = _custVendTrans.Tax1099Amount;
                tmpTax1099StateAmount = _custVendTrans.Tax1099StateAmount;
                tmpTax1099FieldsRecId = _custVendTrans.Tax1099Fields;
                tmpTax1099State = _custVendTrans.Tax1099State;
                tmpInvoiceReleaseDate = _custVendTrans.InvoiceReleaseDate;
                tmpReleaseDateComment = _custVendTrans.ReleaseDateComment;

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    tmpTax1099BoxDetailRecId = _custVendTrans.Tax1099RecId;
                }
            }

            this.initCustVendTrans(_custVendTrans, _ledgerPostingJournal, _useSubLedger);

            // Assign back
            _custVendTrans.InvoiceProject = tmpInvoiceProject;

            // Assign billing classification
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _custVendTrans.TableId == tableNum(CustTrans))
            {
                _custVendTrans.CustBillingClassification = custBillingClassification;
            }

            if (_custVendTrans.TableId == tableNum(VendTrans))
            {
                if (_custVendTrans.TransType != LedgerTransType::Payment)
                {
                    _custVendTrans.Tax1099Amount = tmpTax1099Amount;
                    _custVendTrans.Tax1099StateAmount = tmpTax1099StateAmount;
                    _custVendTrans.Tax1099Fields = tmpTax1099FieldsRecId;
                    _custVendTrans.Tax1099State = tmpTax1099State;
                    _custVendTrans.InvoiceReleaseDate = tmpInvoiceReleaseDate;
                    _custVendTrans.ReleaseDateComment = tmpReleaseDateComment;

                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                    {
                        _custVendTrans.Tax1099RecId = tmpTax1099BoxDetailRecId;
                    }
                }
                else
                {
                    _custVendTrans.Tax1099Amount = 0.00;
                    _custVendTrans.Tax1099StateAmount = 0.00;
                    _custVendTrans.Tax1099Fields = 0;
                    _custVendTrans.Tax1099State = '';
                }
            }

            if (!_withHoldTaxType && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
            {
                if (custVendInvoiceJour)
                {
                    _custVendTrans.TaxInvoiceId = CustVendInvoiceJour::findTaxInvoiceNumFromJournal_MX(custVendInvoiceJour);
                }
                else if (common)
                {
                    switch (common.TableId)
                    {
                        case tableNum(LedgerJournalTrans) :
                            specTransLoc = SpecTrans::findBySpec(common.company(), common.TableId, common.RecId);
                            if (specTransLoc.RefTableId == tableNum(CustTransOpen))
                            {
                                custVendTransOpenLoc = CustTransOpen::find(specTransLoc.RefRecId);
                                _custVendTrans.TaxInvoiceId = CustTrans::find(custVendTransOpenLoc.RefRecId).TaxInvoiceSalesId;
                            }
                            else if (specTransLoc.RefTableId == tableNum(VendTransOpen))
                            {
                                custVendTransOpenLoc = VendTransOpen::find(specTransLoc.RefRecId);
                                _custVendTrans.TaxInvoiceId = VendTrans::find(custVendTransOpenLoc.RefRecId).TaxInvoicePurchId;
                            }
                            break;
                    }
                }
            }

            postCustVendTrans = _custVendTrans;

            if (BrazilParameters::isEnabled())
            {
                _custVendTrans.Txt = localTransactionTxt;

                if (!_custVendTrans.Txt)
                {
                    _custVendTrans.Txt = this.findDefaultTextForPayment(
                        ledgerJournalTrans.Txt,
                        _ledgerPostingJournal,
                        ledgerJournalTrans.ledgerJournalTable().JournalType);
                }
            }
            else
            {
                _custVendTrans.Txt = this.findDefaultTextForPayment(
                    ledgerJournalTrans.Txt,
                    _ledgerPostingJournal,
                    ledgerJournalTrans.ledgerJournalTable().JournalType);
            
                if (!_custVendTrans.Txt)
                {
                    _custVendTrans.Txt = localTransactionTxt;
                }
            }

            if (!_custVendTrans.Txt && (common.TableId == tableNum(CustInvoiceTable)))
            {
                _custVendTrans.Txt =  "@SYS23028";
            }
                        
            if (transType == LedgerTransType::Payment && !ledgerJournalTrans.Txt)
            {
                if (_custVendTrans.Txt != ledgerVoucherTransObject.parmText())
                {
                    ledgerVoucherTransObject.parmText(_custVendTrans.Txt);
                    _ledgerPostingJournal.findLedgerVoucherObject().updateTrans(ledgerVoucherTransObject);
                }
            }
         
            // <GEERU>
            if ( _custVendTrans.Invoice &&
                 (! countryRegion_RU || ! postingProfileSettlement))
            // </GEERU>
            {
                if (! custVendInvoiceJour)
                {
                    if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                        && ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TaxWithholdCode != '')
                        || this.checkInvoice(accountNum, _custVendTrans.Invoice, transDate))
                    {
                        this.createInvoiceJournal(_custVendTrans);
                        this.createInvoiceTrans(custVendInvoiceJour);

                        if (InvoiceJournalPaymentScheduleFeature::isEnabled()
                            && custVendInvoiceJour.PaymentSched
                            && _custVendTrans.tableId == tableNum(VendTrans)
                            && ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::VendInvoiceRegister)
                        {
                            custVendInvoiceJour.CustVendinvoiceJour::createPaymentSched();
                        }
                    }
                }
            }

            this.initCustVendPaymSched(_ledgerPostingJournal);

            if (this.shouldCreateCustVendTrans())
            {
                this.createCustVendTrans(_custVendTrans);

                if (this.shouldCreateCustVendTransOpen(_custVendTrans))
                {
                    custVendTransOpen = this.createCustVendTransOpen(_custVendTrans);
                }
            }
        }

        // <GEEPL>
        if (!this.checkOverdueJournal_W(_custVendTrans))
        {
            throw error("@SYS21533");
        }
        // </GEEPL>

        //handle possible Italian split payment before the settlement
        if (this.shouldPostSplitPayment_IT(_custVendTrans))
        {
            if (TaxSplitPaymentPost_IT::postSplitPaymentWithDimensionDefault(custVendInvoiceJour, _ledgerPostingJournal, defaultDimension))
            {
                _custVendTrans.reread();
                custVendTransOpen.reread();
            }
        }

        //handle possible cashpayment or settlements if it's not a 0 transaction
        custVendTransData = CustVendTransData::construct(_custVendTrans);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custVendTransData.parmBankTransactionTypes(bankTransactionTypes);
        }

        if ((!_custVendTrans.AmountCur && this.parmIsCashPayment()))
        {
            // Ready to post to GL because the invoice amount is zero and is marked for cash payment, so settlement is not required.
            _ledgerPostingJournal.end();
        }

        if (!postingProfileSettlement)
        {
            if (_custVendTrans.AmountCur || _custVendTrans.AmountMST)
            {
                boolean settleCashPayment = false;
                LedgerJournalType journalType = ledgerJournalTrans.ledgerJournalTable().JournalType;

                if (VendInvoiceRegisterPostWithoutSettleV2Flight::instance().isEnabled())
                {
                    settleCashPayment = (!CustVendPaymJourNoCashPaymentFlight::instance().isEnabled()
                            || (journalType != LedgerJournalType::CustPayment && journalType != LedgerJournalType::Payment))
                        && journalType != LedgerJournalType::PurchaseLedger
                        && this.shouldSettleCashPayment(_custVendTrans, paymTermId, emplAccount);
                }
                else
                {
                    settleCashPayment = (!CustVendPaymJourNoCashPaymentFlight::instance().isEnabled()
                            || (journalType != LedgerJournalType::CustPayment && journalType != LedgerJournalType::Payment))
                        && this.shouldSettleCashPayment(_custVendTrans, paymTermId, emplAccount);
                }
                // <GEERU><GEEU>
                if (settleCashPayment)
                // </GEERU></GEEU>
                {
                    // <GEERU><GEEU>
                    if (emplAccount)
                    {
                        custVendTransCash = custVendTransData.updateEmplAccount_RU(_ledgerPostingJournal,
                                                                                   ledgerPostingType,
                                                                                   cashDiscAmount,
                                                                                   cashDiscDate,
                                                                                   emplAccount,
                                                                                   EmplParameters_RU::find().PostingProfile,
                                                                                   exchRate,
                                                                                   exchRateSecondary,
                                                                                   !_useSubLedger);
                    }
                    else
                    {
                        // </GEERU></GEEU>
                        custVendTransCash = custVendTransData.updateCashDisc(paymTermId,
                                                                             _ledgerPostingJournal,
                                                                             ledgerPostingType,
                                                                             cashDiscAmount,
                                                                             cashDiscDate);
                        // <GEERU><GEEU>
                    }
                    // </GEERU></GEEU>
    
                    if (this.parmIsCashPayment())
                    {
                        // Post the invoice to GL so settlement code can get the dimensions
                        _ledgerPostingJournal.end();
                    }

                    if (custVendTransCash.RecId)
                    {
                        custVendTransOpenCash = this.createTransOpen(custVendTransCash);
                        custVendTransOpenCash.insert();

                        specTransManager = SpecTransManager::newFromSpec(_custVendTrans);

                        specTransManager.insert(custVendTransOpen.DataAreaId,
                                                custVendTransOpen.TableId,
                                                custVendTransOpen.RecId,
                                                CustVendTransOpenData::construct(custVendTransOpen).remainAmountCashDisc(),
                                                _custVendTrans.CurrencyCode);

                        specTransManager.insert(custVendTransOpen.DataAreaId,
                                                custVendTransOpen.TableId,
                                                custVendTransOpenCash.RecId,
                                                CustVendTransOpenData::construct(custVendTransOpenCash).remainAmountCashDisc(),
                                                CustVendTransOpenData::construct(custVendTransOpenCash).custVendTrans().CurrencyCode);

                        custVendTransData.updateOffsetVoucher(SettlementType::SelectedTransact,
                                                              _ledgerPostingJournal,
                                                              _custVendTrans);

                        this.initCashRegisterFiscalTrans_W(custVendTransCash);
                    }
                }
                else
                {
                    if (Settlement::isSettlementSpecified(settlementType))
                    {
                        if (this.copySpecTrans())
                        {
                            if (this.parmRequireGLPostingPriorToSettlement())
                            {
                                _ledgerPostingJournal.end();
                            }
                            specTransManager = SpecTransManager::newFromSpec(common);

                            if (custVendPaymSched && (_custVendTrans || _custVendTrans.AmountMST))
                            {
                                this.createPaymScheduleSpecifications(_custVendTrans);
                            }
                            else
                            {
                                if (_custVendTrans.Invoice)
                                {
                                    specTransManager.insert(custVendTransOpen.DataAreaId,
                                                            custVendTransOpen.TableId,
                                                            custVendTransOpen.RecId,
                                                            custVendTransOpen.AmountCur,
                                                            _custVendTrans.CurrencyCode);
                                }
                                else
                                {
                                    specTransManager.insert(custVendTransOpen.DataAreaId,
                                                            custVendTransOpen.TableId,
                                                            custVendTransOpen.RecId,
                                                            custVendTransOpen.AmountCur,
                                                            _custVendTrans.CurrencyCode,
                                                            NoYes::Yes);
                                }
                            }
                        }

                        if (!isConfigurationkeyEnabled(configurationKeyNum(Retail)) || (!(this.rboPayment() && _custVendTrans.Invoice)))
                        {
                            // <GEERU>
                            if (countryRegion_RU)
                            {
                                custVendTransData.updateOffsetVoucher(settlementType,
                                                                      _ledgerPostingJournal,
                                                                      common,
                                                                      true,
                                                                      settlementType == SettlementType::OpenTransact ?
                                                                            DimSettlementType_RU::Auto :
                                                                            DimSettlementType_RU::Manual
                                                                      );
                            }
                            else
                            {
                                // </GEERU>
                                custVendTransData.updateOffsetVoucher(settlementType,
                                                                        _ledgerPostingJournal,
                                                                        common);
                                // <GEERU>
                            }
                            // </GEERU>
                        }
                    }
                }
            }
            else
            {
                specTransManager = SpecTransManager::newFromSpec(common, false);
                specTransManager.deleteAll();
                
                if (this.parmRequireGLPostingPriorToSettlement())
                {
                    //
                    // Posting to gl when amount is zero and invoice is not set to cash payment when parmRequireGLPostingPriorToSettlement is true
                    // If invoice was set to cash payment with zero amount we would have already posted to gl and we would not enter this code path
                    // use case - covers the posting invoice of a credit note with settle voucher set to designated transactions where voucher amount is zero
                    //
                    _ledgerPostingJournal.end();
                }
            }
        }

        this.sendBusinessEventsForPosting();

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxDocumentLedgerVoucherMap = custVendTransData.getTaxDocumentLedgerVoucherMap();
        }
        // </GTE>
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendTrans_IN</Name>
				<Source><![CDATA[
    protected container updateVendTrans_IN(VendTrans _vendTrans, VendTransOpen _vendTransOpen)
    {
        return [_vendTrans, _vendTransOpen];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendPaymSched</Name>
				<Source><![CDATA[
    protected void initCustVendPaymSched(LedgerVoucher _ledgerPostingJournal)
    {
        if (custVendInvoiceJour)
        {
            select firstonly custVendPaymSched
                    where custVendPaymSched.ExtTableId  == custVendInvoiceJour.TableId  &&
                          custVendPaymSched.ExtRecId    == custVendInvoiceJour.RecId    &&
                          custVendPaymSched.Name        == custVendInvoiceJour.PaymentSched;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSettleCashPayment</Name>
				<Source><![CDATA[
    internal boolean shouldSettleCashPayment(
        CustVendTrans _custVendTrans,
        PaymTermId _paymTermId,
        EmplAccount_RU _emplAccount)
    {
        return (PaymTerm::isCashAccount(_paymTermId) || _emplAccount)
            && _custVendTrans.AmountCur != 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create an instance of <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name = "_useSubLedger">A Boolean value that indicates whether the SubLedger is being used.</param>
    /// <param name = "_ledgerDimensionMerged">The <c>LedgerDimensionAccount</c> ledger account record.</param>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <param name = "_ledgerPostingJournal">The ledger posting journal to use for ledger posting.</param>
    /// <param name = "_custVendTrans">The Map object that contains the value of vendor transaction or customer transaction.</param>
    /// <returns>The instance of <c>LedgerVoucherTransObject</c> class.</returns>
    protected LedgerVoucherTransObject createLedgerVoucherTransObject(boolean _useSubLedger,
                                         LedgerDimensionAccount _ledgerDimensionMerged,
                                         LedgerJournalTrans _ledgerJournalTrans,
                                         LedgerVoucher _ledgerPostingJournal,
                                         CustVendTrans _custVendTrans)
    {
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        AmountMST amountMstLoc;
        TaxWithholdAmountCur taxAmount;
        InventProfileType_RU inventProfileType;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
        // <GIN>
        LedgerJournalType ledgerJournalType;
        // </GIN>

        if (_useSubLedger)
        {
            return ledgerVoucherTransObject;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            inventProfileType = custVendInvoiceJour.CustVendInvoiceJour::getInventProfileType_RU();
        }
        // </GEERU>
        
        if (this.parmCancelledPayment() && this.parmCancelledLedgerDimension())
        {
            _ledgerDimensionMerged = this.parmCancelledLedgerDimension();
        }
        else
        {
            LedgerDimensionDefaultAccount ledgerDimensionDefault = this.summaryLedgerDimension();
            select firstonly _ledgerJournalTrans
                where _ledgerJournalTrans.TableId == common.TableId
                    && _ledgerJournalTrans.RecId == common.RecId;
            _ledgerDimensionMerged = this.mergeLedgerDimensionAndDefaultDimension(ledgerDimensionDefault, defaultDimension);
        }

        ledgerVoucherObject = _ledgerPostingJournal.findLedgerVoucherObject();

        if (_custVendTrans != null)
        {
            ledgerVoucherObject.parmDocumentDate(_custVendTrans.DocumentDate);
            ledgerVoucherObject.parmDocumentNumber(_custVendTrans.DocumentNum);
        }

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                    Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                    this.parmExchangeRateDate() ? this.parmExchangeRateDate() : ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(exchRate);
        exchangeRateHelper.parmExchangeRate2(exchRateSecondary);
        exchangeRateHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(reportingCurrencyExchRateSecondary);
        amountMstLoc = this.parmAmountMST();

        if (amountMstLoc == 0)
        {
            amountMstLoc = exchangeRateHelper.calculateTransactionToAccounting(currencyCode, amountCur, true);
        }

        if (this.parmSalesTaxPayment_TH() && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        ledgerVoucherObject,
                        ledgerPostingType,
                        _ledgerDimensionMerged,
                        currencyCode,
                        amountMstLoc,
                        0);
        }
        else
        {
            // <GIN>
            this.createTaxAmountDiffEntryForProjDeduction_IN(
                ledgerVoucherObject,
                exchangeRateHelper);

            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                boolean isForeignLedgerJournalTrans = false;
                taxWithholdAmountForeignTrans = 0;

                AmountCur amountCurLoc = amountCur;

                if (_ledgerJournalTrans && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    VendTable vendTable = VendTable::find(accountNum);
                    isForeignLedgerJournalTrans = vendTable && (vendTable.isForeign() || _ledgerJournalTrans.CurrencyCode != Ledger::accountingCurrency());
                }

                // Checking if the journal is posted thru tax adjustment, do not add withholdTax to Vendor amount.
                if (_ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TaxWithholdCode == '')
                {
                    ledgerJournalType = this.setAmount_IN(_ledgerPostingJournal);
                }

                if (BankParameters::checkParameters_IN() &&
                            (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
                            ledgerJournalType == LedgerJournalType::BankDepositPaymCancel))
                {
                    taxAmount = this.getWithholdAmount_IN(common, _custVendTrans.TableId, _custVendTrans.RecId, _ledgerPostingJournal);
                    amountCur += taxAmount;
                    taxWithholdAmountForeignTrans += taxAmount;
                }

                if (!_ledgerJournalTrans || !isForeignLedgerJournalTrans)
                {
                    if (amountCur != amountCurLoc)
                    {
                        amountMstLoc = exchangeRateHelper.calculateTransactionToAccounting(currencyCode, amountCur, true);
                    }
                }
                else if (taxWithholdAmountForeignTrans)
                {
                    CurrencyExchangeHelper exchangeRateHelperLoc = CurrencyExchangeHelper::construct();
                    exchangeRateHelperLoc.parmLedgerRecId(exchangeRateHelper.parmLedgerRecId());
                    exchangeRateHelperLoc.parmExchangeDate(exchangeRateHelper.parmExchangeDate());
                    exchangeRateHelperLoc.parmExchangeRate1(exchangeRateHelper.parmExchangeRate1());
                    exchangeRateHelperLoc.parmExchangeRate2(exchangeRateHelper.parmExchangeRate2());
                    exchangeRateHelperLoc.parmReportingExchangeRate1(exchangeRateHelper.parmReportingExchangeRate1());
                    exchangeRateHelperLoc.parmReportingExchangeRate2(exchangeRateHelper.parmReportingExchangeRate2());

                    // Below logic is calculating the WHT amount with TDS exchange rate.
                    // To make sure the accounting and reporting balance when TDS exchange rate is different form transaction exchange rate.
                    amountMstLoc = exchangeRateHelperLoc.calculateTransactionToAccounting(currencyCode, amountCurLoc, true);
                    reportingCurrencyAmount = exchangeRateHelperLoc.calculateTransactionCurrencyToReportingCurrency(currencyCode, amountCurLoc);

                    exchangeRateHelperLoc.parmExchangeRate1(TaxExchangeRateHelper::getTDSExchangeRate_IN(_ledgerJournalTrans.CurrencyCode, _ledgerJournalTrans.TransDate));
                    exchangeRateHelperLoc.parmReportingExchangeRate1(TaxExchangeRateHelper::getTDSExchangeRateRep_IN(_ledgerJournalTrans.CurrencyCode, Ledger::reportingCurrency(), _ledgerJournalTrans.TransDate));

                    amountMstLoc += exchangeRateHelperLoc.calculateTransactionToAccounting(currencyCode, taxWithholdAmountForeignTrans, true);
                    reportingCurrencyAmount += exchangeRateHelperLoc.calculateTransactionCurrencyToReportingCurrency(currencyCode, taxWithholdAmountForeignTrans);
                }
            }
            // </GIN>

            this.setAssetLeaseTypes(ledgerVoucherObject, _ledgerJournalTrans);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                        ledgerVoucherObject,
                        ledgerPostingType,
                        _ledgerDimensionMerged,
                        currencyCode,
                        amountCur,
                        amountMstLoc,
                        exchangeRateHelper);

            if (reportingCurrencyAmount)
            {
                ledgerVoucherTransObject.parmReportingCurrencyAmount(reportingCurrencyAmount);
            }

            if (!amountCur && !amountMstLoc)
            {
                ledgerVoucherObject.parmSkipZeroAmountCheck(true);
            }

            // <GEERU>
            if ((common) && (common.TableId == tableNum(LedgerJournalTrans)) &&
                        _ledgerPostingJournal.findLedgerVoucherObject().ledgerBondClient_RU())
            {
                ledgerVoucherTransObject.parmSourceTableId(common.TableId);
                ledgerVoucherTransObject.parmSourceRecId(common.RecId);
            }
            else
            {
                // </GEERU>
                ledgerVoucherTransObject.parmSourceTableId(_custVendTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(_custVendTrans.RecId);
                // <GEERU>
            }
            // </GEERU>
        }

        // for prepayments the posting to the customer summary account needs a relationship to
        // TaxTrans as the P&L for the tax.
        if (_ledgerJournalTrans && _ledgerJournalTrans.Prepayment)
        {
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
        }

        ledgerVoucherTransObject.parmLedgerDetailLevel(ledgerDetailLevel);
        ledgerVoucherTransObject.parmPaymentReference(paymReference);
        ledgerVoucherTransObject.parmReasonRefRecID(reasonRefRecID);

        if (_custVendTrans)
        {
            ledgerVoucherTransObject.parmPaymMode(_custVendTrans.PaymMode);
        }

        if (localTransactionTxt == '')
        {
            localTransactionTxt = this.findDefaultTextForLedgerPayment(
                        _ledgerJournalTrans.Txt,
                        _ledgerPostingJournal,
                        _ledgerJournalTrans.ledgerJournalTable().JournalType);

            ledgerVoucherTransObject.parmDiscardLastTransTxt(false);
        }
        else
        {
            ledgerVoucherTransObject.parmDiscardLastTransTxt(true);
        }

        ledgerVoucherTransObject.parmTransTxt(localTransactionTxt);
        ledgerVoucherTransObject.parmFinTag(finTag);

        if (LedgerParameters::find().TransactionReversalCorrection && this.parmCancelledPayment())
        {
            ledgerVoucherTransObject.parmCorrect(true);
        }

        if (this.parmCancelledPayment() || this.parmIsReimbursement())
        {
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && _ledgerJournalTrans.Cancel == NoYes::Yes)
        {
            boolean isTransactionReversalCorrectionOn = LedgerParameters::find().TransactionReversalCorrection == NoYes::Yes;

            if (isTransactionReversalCorrectionOn && _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval)
            {
                ledgerVoucherTransObject.parmIsCorrection(_ledgerJournalTrans.correct());
            }
            else
            {
                ledgerVoucherTransObject.parmIsCorrection(isTransactionReversalCorrectionOn);
            }
        }

        if (isItalyEnabled && customsTrans)
        {
            CustomsVoucher_IT::newFromParameters(customsTrans,
                    LedgerPostingController::newForLedgerPostingJournal(_ledgerPostingJournal), ledgerVoucherTransObject, true).run();
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerVoucherTransObject.parmIgnoreAllocation(true);
        }
        // </GIN>

        // <GEERU>
        if (! countryRegion_RU ||
                    _custVendTrans.TableId != tableNum(CustTrans) ||
                    (salesInvoicePostingType != SalesInvoicePostingType_RU::GoodsInRoute &&
                    inventProfileType != InventProfileType_RU::CommissionPrincipalAgent &&
                    inventProfileType != InventProfileType_RU::Bailee))
        {
            if (ledgerBalances)
            {
                this.postMultipleBalances_RU(_ledgerPostingJournal, ledgerVoucherTransObject, exchangeRateHelper);
            }
            else
            {
                // </GEERU>
                _ledgerPostingJournal.addTrans(ledgerVoucherTransObject);
                // <GEERU>
            }
        }

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxAmountDiffEntryForProjDeduction_IN</Name>
				<Source><![CDATA[
    private void createTaxAmountDiffEntryForProjDeduction_IN(
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        if (TaxParameters::checkTaxParameters_IN())
        {
            AmountCur taxAmountCur;
            AmountMST taxAmountMST;
            Amount taxAmountRep;
            [taxAmountCur, taxAmountMST, taxAmountRep] = this.getTaxForProjDeduction_IN();

            if (taxAmountCur)
            {
                AmountMST taxAmountMSTOrig = _exchangeRateHelper.calculateTransactionToAccounting(currencyCode, taxAmountCur, true);
                AmountMST taxAmountMSTDiff = taxAmountMST - taxAmountMSTOrig;

                Amount taxAmountRepDiff;

                if (Ledger::reportingCurrency())
                {
                    Amount taxAmountRepOrig = _exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(currencyCode, taxAmountCur);
                    taxAmountRepDiff = taxAmountRep - taxAmountRepOrig;
                }
                else
                {
                    taxAmountRepDiff = 0;
                }

                LedgerPostingType ledgerPostingTypeAdj = taxAmountMSTDiff > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss;

                LedgerVoucherTransObject ledgerVoucherTransObjectAdj = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerVoucherObject,
                        ledgerPostingTypeAdj,
                        this.getLedgerDimensionForTaxGainLossAccount(taxAmountMSTDiff),
                        currencyCode,
                        taxAmountMSTDiff,
                        taxAmountRepDiff);

                _ledgerVoucherObject.addTrans(ledgerVoucherTransObjectAdj);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxGainLossAccount</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getLedgerDimensionForTaxGainLossAccount(Amount _taxAmountMSTDiff)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType accountType;

        if (_taxAmountMSTDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::UnrealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::UnrealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            currencyCode,
            accountType);

        return this.mergeLedgerDimensionAndDefaultDimension(defaultAccount, defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxForProjDeduction_IN</Name>
				<Source><![CDATA[
    private container getTaxForProjDeduction_IN()
    {
        AmountCur totalTaxAmountPreBill;
        AmountMST totalTaxAmountPreBillMST;
        Amount totalTaxAmountPreBillRep;

        if (custVendInvoiceJour.TableId == tableNum(ProjInvoiceJour)
            && TaxParameters::checkTaxParameters_IN()
            && TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ProjInvoiceJour projInvoiceJour = ProjInvoiceJour::findRecId(custVendInvoiceJour.RecId);

            TaxEngineProjOnAcctJourHeader onAcctJourHeader = TaxEngineProjOnAcctJourHeader::findOrCreateByProjInvoiceJour(projInvoiceJour);
            ITaxDocument taxDocumentObject = TaxBusinessService::getTaxDocumentBySource(onAcctJourHeader.TableId, onAcctJourHeader.RecId);

            if (taxDocumentObject)
            {
                ProjInvoiceOnAcc projInvoiceOnAcc;
                ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
                ProjOnAccTransSale projOnAccTransSale;
                ProjOnAccTrans projOnAccTrans;
                while select projInvoiceOnAcc
                    where projInvoiceOnAcc.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceOnAcc.InvoiceDate == projInvoiceJour.InvoiceDate
                    join projInvoiceOnAccDetail
                        where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId
                    join projOnAccTransSale
                        where projOnAccTransSale.RecId == projInvoiceOnAccDetail.SaleRefRecId
                    join projOnAccTrans
                        where projOnAccTrans.TransId == projOnAccTransSale.TransId
                            && projOnAccTrans.TransactionOrigin == ProjOrigin::Deduction
                            && projOnAccTrans.PSAIsOnAccount == NoYes::Yes
                {
                    ITaxDocumentLine taxDocumentLineObject = taxDocumentObject.findLineBySource(projInvoiceOnAcc.TableId, projInvoiceOnAcc.RecId);
                    if (taxDocumentLineObject
                        && !taxDocumentLineObject.priceInclTax()) // if tax included, tax exchange rate diff would be handled with deduction line amount together.
                    {
                        AmountCur taxAmountPreBill = taxDocumentLineObject.getLineTax().amountTransactionCurrency();
                        AmountMST taxAmountPreBillMST = taxDocumentLineObject.getLineTax().amountAccountingCurrency();
                        Amount taxAmountPreBillRep = taxDocumentLineObject.getLineTax().amountReportingCurrency();

                        totalTaxAmountPreBill += taxAmountPreBill;
                        totalTaxAmountPreBillMST += taxAmountPreBillMST;
                        totalTaxAmountPreBillRep += taxAmountPreBillRep;
                    }
                }
            }
        }
        return [totalTaxAmountPreBill, totalTaxAmountPreBillMST, totalTaxAmountPreBillRep];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should create the customer or vendor transaction.
    /// </summary>
    /// <returns>
    /// true when the customer vendor transaction should be created; otherwise false.
    /// </returns>
    protected boolean shouldCreateCustVendTrans()
    {
        boolean	shouldCreateCustVendTrans = true;

        if (isItalyEnabled)
        {
            shouldCreateCustVendTrans = this.isCreateCustVendTrans_IT();
        }

        return shouldCreateCustVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the customer or vendor transaction.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that will be created.
    /// </param>
    protected void createCustVendTrans(CustVendTrans _custVendTrans)
    {
        if (this.shouldCreateCustVendTransForPaymSched(_custVendTrans))
        {
            this.createCustVendTransForPaymSched(_custVendTrans);
        }
        else if (this.shouldCreateCustVendTransForPaymentDisbursement_PS(_custVendTrans))
        {
            this.createCustVendTransForPaymentDisbursement_PS(_custVendTrans);
        }
        else
        {
            this.createCustVendTransInsertCustVendTrans(_custvendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateCustVendTransForPaymSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should create the customer or vendor transactions for payment schedule.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that will be used to determine if it should be split for a payment schedule.
    /// </param>
    /// <returns>
    /// true when the customer or vendor transactions should be created for the payment schedule.
    /// </returns>
    protected boolean shouldCreateCustVendTransForPaymSched(CustVendTrans _custVendTrans)
    {
        boolean shouldCreateCustVendTransForPaymSched;

        if (custVendPaymSched
            && (_custVendTrans.AmountCur || _custVendTrans.AmountMST)
            && _custVendTrans.TransType != LedgerTransType::PurchAdvanceApplication
            && !isCalledFromSplitPayment
            && !(RetailSkipPaymScheduleForCashAndCarryTransactionsFlight::instance().isEnabled()
                && CustVendVoucher::isRetailCashAndCarryTransaction(custVendInvoiceJour)))
        {
            shouldCreateCustVendTransForPaymSched = true;
        }

        return shouldCreateCustVendTransForPaymSched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransForPaymSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer or vendor transaction for a payment schedule.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that is used split for a payment schedule.
    /// </param>
    protected void createCustVendTransForPaymSched(CustVendTrans _custVendTrans)
    {
        this.setPaymSchedId(_custVendTrans, custVendPaymSched.Name);

        PaymSchedCalc paymSchedCalc = PaymSchedCalc::construct(custVendPaymSched, custVendPaymSchedLine);
        if (custVendInvoiceJour)
        {
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                paymSchedCalc.parmTaxWithholdAmount_IN(taxWithholdAmount);
                if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled())
                {
                    // Actual the parmTaxWithholdType_IN should be set anyway in theory, but just enable the code
                    // when feature management is enabled for avoiding any unexpected impact.
                    if (isTCSApplicable)
                    {
                        paymSchedCalc.parmTaxWithholdType_IN(TaxWithholdCodeType_IN::TCS);
                    }
                    else if (isTDSApplicable)
                    {
                        paymSchedCalc.parmTaxWithholdType_IN(TaxWithholdCodeType_IN::TDS);
                    }
                }
            }
            paymSchedCalc.initFromCustVendInvoiceJour(custVendInvoiceJour);
        }

        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
        {
            paymSchedCalc.createCustVendTransaction(_custVendTrans, _custVendTrans.exchRateCurToMst());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateCustVendTransForPaymentDisbursement_PS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should create customer or vendor transaction for payment disbursement.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that will be used to determine if it should be split for a payment disbursement.
    /// </param>
    /// <returns>
    /// true when the customer or vendor transactions should be created for the payment disbursement.
    /// </returns>
    protected boolean shouldCreateCustVendTransForPaymentDisbursement_PS(CustVendTrans _custVendTrans)
    {
        boolean shouldCreateCustVendTransForPaymentDisbursement_PS;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custVendInvoiceJour && (_custVendTrans.AmountCur || _custVendTrans.AmountMST))
        {
            if (this.hasVendInvoiceDisbursements)
            {
                shouldCreateCustVendTransForPaymentDisbursement_PS = true;
            }
            else
            {
                CustVendPaymentDisbursement custVendPaymentDisbursement = this.findCustVendPaymentDisbursement_PS(custVendInvoiceJour);
                if (custVendPaymentDisbursement)
                {
                    shouldCreateCustVendTransForPaymentDisbursement_PS = true;
                }
            }
        }

        return shouldCreateCustVendTransForPaymentDisbursement_PS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendPaymentDisbursement_PS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the customer or vendor payment disbursement.
    /// </summary>
    /// <param name = "_custVendInvoiceJour">The customer or vendor invoice journal.</param>
    /// <returns>The customer or vendor payment disbursement.</returns>
    protected CustVendPaymentDisbursement findCustVendPaymentDisbursement_PS(CustVendInvoiceJour _custVendInvoiceJour)
    {
        CustVendPaymentDisbursement custVendPaymentDisbursement;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custVendPaymentDisbursement = CustVendPaymentDisbursement::find(
                _custVendInvoiceJour.TableId,
                _custVendInvoiceJour.RecId).data();
        }

        return custVendPaymentDisbursement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransForPaymentDisbursement_PS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the customer or vendor transaction for payment disbursement.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that is used to determine the payment disbursement customer or vendor transaction.
    /// </param>
    protected void createCustVendTransForPaymentDisbursement_PS(CustVendTrans _custVendTrans)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            CustVendPaymentDisbursement custVendPaymentDisbursement = this.findCustVendPaymentDisbursement_PS(custVendInvoiceJour);

            CustVendPaymentDisbursementCalc paymDisbursementCalc = CustVendPaymentDisbursementCalc::construct(custVendInvoiceJour);
            paymDisbursementCalc.initFromCustVendInvoiceJour(custVendInvoiceJour);
            paymDisbursementCalc.initFromCustVendPaymentDisbursement(custVendPaymentDisbursement);
            paymDisbursementCalc.createCustVendTransaction(_custVendTrans, exchRate);
            if (custVendPaymentDisbursement.TableId == tableNum(VendPaymentDisbursement))
            {
                VendPaymentDisbursement::deleteByVendInvoiceJourRecId(custVendInvoiceJour.RecId);
                this.hasVendInvoiceDisbursements = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransInsertCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer or vendor transaction and perform the actual insert to the database.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that will be inserted to the database.
    /// </param>
    protected void createCustVendTransInsertCustVendTrans(CustVendTrans _custVendTrans)
    {
        _custVendTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should create customer or vendor open transaction.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction that is used to determine if the open customer or vendor transaction should be created.
    /// </param>
    /// <returns>
    /// true when the customer or vendor open transaction should be created; otherwise false.
    /// </returns>
    protected boolean shouldCreateCustVendTransOpen(CustVendTrans _custVendTrans)
    {
        boolean shouldCreateCustVendTransOpen;

        if (!this.shouldCreateCustVendTransForPaymSched(_custVendTrans) && !this.shouldCreateCustVendTransForPaymentDisbursement_PS(_custVendTrans))
        {
            boolean postingProfileSettlement = this.postingProfileSettlement();
            if ((_custVendTrans.AmountCur || _custVendTrans.AmountMST)
                && !postingProfileSettlement
                && (!(_custVendTrans.TransType == LedgerTransType::PurchAdvanceApplication && custVendPaymSched) || isInvoicePosted))
            {
                shouldCreateCustVendTransOpen = true;
            }
        }

        return shouldCreateCustVendTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer or vendor open transaction.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The customer or vendor transaction.
    /// </param>
    /// <returns>
    /// The created customer or vendor open transaction.
    /// </returns>
    protected CustVendTransOpen createCustVendTransOpen(CustVendTrans _custVendTrans)
    {
        CustVendTransOpen custVendTransOpen = this.createTransOpen(_custVendTrans);
        this.createCustVendTransInsertCustVendTransOpen(custVendTransOpen, _custVendTrans);

        Debug::assert(_custVendTrans.company() == custVendTransOpen.company());

        this.createTransOpenLine(custVendTransOpen);

        this.createCustVendTransCashDisc(custVendTransOpen);

        return custVendTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransInsertCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer or vendor open transaction and perform the actual insert to the database.
    /// </summary>
    /// <param name = "_custVendTransOpen">The customer or vendor open transaction that will be inserted to the database.
    /// </param>
    /// <param name = "_custVendTrans">The customer or vendor transaction that was inserted to the database.
    /// </param>
    protected void createCustVendTransInsertCustVendTransOpen(CustVendTransOpen _custVendTransOpen, CustVendTrans _custVendTrans)
    {
        _custVendTransOpen.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer or vendor transaction cash discounts.
    /// </summary>
    /// <param name = "_custVendTransOpen">The customer or vendor open transaction.</param>
    protected void createCustVendTransCashDisc(CustVendTransOpen _custVendTransOpen)
    {
        if (common)
        {
            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                // exclude withholding tax
                amountCur = amountCur - taxWithholdDiscAmount;
            }
            // </GIN>
          
            VendTransCashDisc vendTransCashDisc;
            CustTransCashDisc custTransCashDisc;
            int cashDiscDays;
            switch (common.TableId)
            {
                case tableNum(LedgerJournalTrans) :
                    this.copyCashDisc(common.TableId, common.RecId, _custVendTransOpen.TableId, _custVendTransOpen.RecId);

                    _custVendTransOpen.setCashDisc(transDate);
                    _custVendTransOpen.update();
                    break;

                case tableNum(PurchTable),
                    tableNum(VendInvoiceInfoTable) :
                    if(cashDiscCode)
                    {
                        cashDiscDays = CashDisc::cashDiscDate(cashDiscCode, transDate) - transDate;

                        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
                        {
                            vendTransCashDisc = vendTransCashDisc.calcCashDisc(
                                    _custVendTransOpen.company(),
                                    currencyCode,
                                    LedgerJournalCashDiscService::baseAmountCashDisc(
                                        ModuleCustVend::Vend,
                                        CustVendTransCashDisc::amountExclTax(amountCur, -custVendInvoiceJour.SumTax),
                                        -custVendInvoiceJour.SumTax,
                                        CashDisc::find(cashDiscCode).Percent),
                                    dueDate,
                                    cashDiscDate - cashDiscDays,
                                    cashDiscCode,
                                    _custVendTransOpen.TableId,
                                    _custVendTransOpen.RecId);
                        }

                        vendTransCashDisc.CashDiscAmount = cashDiscAmount;
                        vendTransCashDisc.CashDiscdate   = cashDiscDate;
                        vendTransCashDisc.update();

                        _custVendTransOpen.reread();
                        _custVendTransOpen.setCashDisc(cashDiscDate);
                        _custVendTransOpen.update();
                    }
                    break;

                case tableNum(SalesTable),
                    tableNum(CustInvoiceTable),
                    tableNum(ProjInvoiceJour) :
                    if(cashDiscCode)
                    {
                        cashDiscDays = CashDisc::cashDiscDate(cashDiscCode, transDate) - transDate;

                        // <GIN>
                        if (TaxParameters::checkTaxParameters_IN() &&
                                        CustParameters::find().CashDiscVAT)
                        {
                            custTransCashDisc = custTransCashDisc.calcCashDisc(
                                            _custVendTransOpen.company(),
                                            currencyCode,
                                            LedgerJournalCashDiscService::baseAmountCashDisc(
                                                ModuleCustVend::Cust,
                                                CustVendTransCashDisc::amountExclTax(amountCur, custVendInvoiceJour.SumTax),
                                                custVendInvoiceJour.SumTax,
                                                CashDisc::find(cashDiscCode).Percent),
                                            dueDate,
                                            cashDiscDate - cashDiscDays,
                                            cashDiscCode,
                                            _custVendTransOpen.TableId,
                                            _custVendTransOpen.RecId);

                            custTransCashDisc.CashDiscAmount = cashDiscAmount;
                            custTransCashDisc.CashDiscdate   = cashDiscDate;
                            custTransCashDisc.update();
                        }
                        else
                        {
                            // </GIN>
                            using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
                            {
                                custTransCashDisc.calcCashDisc(
                                            _custVendTransOpen.company(),
                                            currencyCode,
                                            LedgerJournalCashDiscService::baseAmountCashDisc(
                                                ModuleCustVend::Cust,
                                                CustVendTransCashDisc::amountExclTax(amountCur, custVendInvoiceJour.SumTax),
                                                custVendInvoiceJour.SumTax,
                                                CashDisc::find(cashDiscCode).Percent),
                                            dueDate,
                                            cashDiscDate - cashDiscDays,
                                            cashDiscCode,
                                            _custVendTransOpen.TableId,
                                            _custVendTransOpen.RecId);
                            }
                            // <GIN>
                        }
                        // </GIN>

                        _custVendTransOpen.setCashDisc(cashDiscDate);
                        _custVendTransOpen.reread();
                        _custVendTransOpen.update();
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfileSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if posting profile is custSettlement or vendSettlement.
    /// </summary>
    /// <returns>True if LedgerPostingType is custSettlement or vendSettlement, otherwise false.</returns>
    protected boolean postingProfileSettlement()
    {
        boolean postingProfileSettlement;

        postingProfileSettlement = (this.parmLedgerPostingType() == LedgerPostingType::CustSettlement ||
                                    this.parmLedgerPostingType() == LedgerPostingType::VendSettlement);

        return postingProfileSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMultipleBalances_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Posts multiple ledger transactions for counteragent balance change.
    /// </summary>
    /// <param name="_ledgerPostingJournal">
    ///    Posting journal.
    /// </param>
    /// <param name="_transactionTemplate">
    ///   Template of tansaction to post.
    /// </param>
    /// <param name="_currencyExchangeHelper">
    ///    Currency conversion parameters.
    /// </param>
    private void postMultipleBalances_RU(LedgerVoucher _ledgerPostingJournal, LedgerVoucherTransObject _transactionTemplate, CurrencyExchangeHelper _currencyExchangeHelper)
    {
        LedgerUtils_RU::postAmountsByTemplate(_ledgerPostingJournal.findLedgerVoucherObject(), ledgerBalances, _transactionTemplate, _currencyExchangeHelper);
        [postedAmountCur, postedAmountMST] = this.calculatePostedMultipleBalanceAmounts_RU(_transactionTemplate.parmCurrencyCode(), _currencyExchangeHelper);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts SecCur_RU for Russia.
    /// </summary>
    /// <param name = "_ledgerPostingJournal">The ledgerPostingJournal.</param>
    /// <param name = "_costAmountSecCur">The costAmountSecCur.</param>
    public void postSecCur_RU(LedgerVoucher _ledgerPostingJournal,
                              CostAmountSecCur_RU _costAmountSecCur)
    {
        #ISOCountryRegionCodesVendInv_W
        LedgerDimensionDefaultAccount defaultAccount;
        LedgerPostingType postingType;
        EmplAccount_RU emplAccount;
        PurchTable purchTable;

        VendInvoiceInfoTable localVendInvoiceInfoTable;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;

        if (!this.isAmountBelowCreditMax(typeOfCreditmaxCheck))
        {
            throw error("@SYS21533");
        }

        if (VendParameters::find().UsePurchConsumpAccount_RU)
        {
            return;
        }

        if (common.TableId == tableNum(PurchTable))
        {
            purchTable = common;
            emplAccount = purchTable.purchTable_W().EmplAccount_RU;
        }
        else if (common.TableId == tableNum(VendInvoiceInfoTable))
        {
            localVendInvoiceInfoTable = common;
            vendInvoiceInfoTable_W = localVendInvoiceInfoTable.vendInvoiceInfoTable_W();
            emplAccount = vendInvoiceInfoTable_W.EmplAccount_RU;
        }

        if (emplAccount)
        {
            defaultAccount = EmplLedgerAccounts_RU::summaryLedgerDimension(emplAccount);
            postingType = LedgerPostingType::EmplPayment_RU;
        }
        else
        {
            defaultAccount = PaymTerm::find(paymTermId).CashLedgerDimension;
            postingType = ledgerPostingType;
        }

        if (!defaultAccount)
        {
            defaultAccount = this.summaryLedgerDimension();
        }

        _ledgerPostingJournal.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(
            _ledgerPostingJournal.findOrCreateReferenceSecCur_RU(),
            postingType,
            this.mergeLedgerDimensionAndDefaultDimension(defaultAccount, defaultDimension),
            currencyCode,
            -_costAmountSecCur,
            NoYes::No));

        _ledgerPostingJournal.restoreReferenceSecCur_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// If there is a payment against the Invoice.
    /// </summary>
    /// <returns>A boolean value.</returns>
    public boolean rboPayment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseCentralizedPaymentWHT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the withholding tax on centralized payment.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdCalculation_IN</c> buffer.
    /// </param>
    /// <param name="_cancelDate">
    /// The cancellation date.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    protected void reverseCentralizedPaymentWHT_IN(
        TaxWithholdTrans_IN _taxWithholdTrans,
        TransDate _cancelDate,
        Voucher _voucher)
    {
        TaxWithholdTrans_IN taxWithholdTransLoc;

        changecompany(_taxWithholdTrans.company())
        {
            ttsbegin;
            select forupdate taxWithholdTransLoc
                where taxWithholdTransLoc.RecId == _taxWithholdTrans.RecId;
            if (taxWithholdTransLoc)
            {
                taxWithholdTransLoc.TransactionReversal = NoYes::Yes;
                taxWithholdTransLoc.doUpdate();
            }
            ttscommit;
            _taxWithholdTrans.SettlementVoucher = '';
            _taxWithholdTrans.copyTaxWithholdTrans(_taxWithholdTrans, _voucher, _cancelDate, -1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseJournalEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the journal entry information.
    /// </summary>
    /// <param name="_oldVoucher">
    /// The old voucher information.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    /// <param name="_taxWithholdTrans">
    /// The tax withhold trans.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher information.
    /// </param>
    protected void reverseJournalEntry_IN(Voucher _oldVoucher,
                                          TransDate _transDate,
                                          TableId _tableId,
                                          RecId _recId,
                                          TaxWithholdTrans_IN _taxWithholdTrans,
                                          LedgerVoucher _ledgerVoucher)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherTransObject postingTransaction;

        while select generalJournalAccountEntry
            where generalJournalAccountEntry.PostingType == LedgerPostingType::LedgerJournal
                && generalJournalAccountEntry.PaymentReference == ''
            join Ledger, RecId from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                   && generalJournalEntry.AccountingDate == _transDate
            exists join RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                   && subledgerVoucherGeneralJournalEntry.Voucher == _oldVoucher
        {
            _ledgerVoucher.parmVoucherSeriesCode(NumberSequenceTable::find(NumberSeqReference::findReference(extendedTypeNum(TDSTCSVoucherReversal_IN)).NumberSequenceId).NumberSequence);

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                                        generalJournalEntry.Ledger,
                                        generalJournalEntry.AccountingDate);

            exchangeRateHelper.parmExchangeRate1(generalJournalAccountEntry.getAccountingExchangeRate());
            exchangeRateHelper.parmReportingExchangeRate1(generalJournalAccountEntry.getSecondaryExchangeRate());

            postingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                            _ledgerVoucher.findLedgerVoucherObject(),
                                                            generalJournalAccountEntry.PostingType,
                                                            generalJournalAccountEntry.LedgerDimension,
                                                            generalJournalAccountEntry.TransactionCurrencyCode,
                                                            -generalJournalAccountEntry.TransactionCurrencyAmount,
                                                            exchangeRateHelper);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);

            // Add transaction to LedgerVoucher
            _ledgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseWHTAsPerCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the withhlding tax as per the company.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans_IN</c> buffer.
    /// </param>
    /// <param name="_tableId">
    /// Reference number of the table.
    /// </param>
    /// <param name="_recId">
    /// Record id in the table.
    /// </param>
    /// <param name="_cancelDate">
    /// The cancellation date.
    /// </param>
    /// <param name="_ledgerPostingJournal">
    /// A <c>LedgerVoucher</c> object.
    /// </param>
    protected void reverseWHTAsPerCompany_IN(TaxWithholdTrans_IN _taxWithholdTrans,
                                             TableId _tableId,
                                             RecId _recId,
                                             TransDate _cancelDate,
                                             LedgerVoucher _ledgerPostingJournal)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        TaxWithholdTrans_IN taxWithholdTransLoc;
        LedgerDimensionAccount basSettlementDimAccount;
        CurrencyExchangeHelper exchangeRateHelper;

        basSettlementDimAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(_taxWithholdTrans.LedgerDimension, defaultDimension);
        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_taxWithholdTrans.company()).RecId),
                                                                     _ledgerPostingJournal.findLedgerVoucherObject().parmAccountingDate());
        _taxWithholdTrans.TaxWithholdAmountCur = _taxWithholdTrans.AdjustedTaxWithholdAmount ?
                                                _taxWithholdTrans.AdjustedTaxWithholdAmount : _taxWithholdTrans.TaxWithholdAmountCur;
        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                             _ledgerPostingJournal.findLedgerVoucherObject(),
                                             ledgerPostingType,
                                             basSettlementDimAccount,
                                             _taxWithholdTrans.CurrencyCode,
                                             -_taxWithholdTrans.TaxWithholdAmountCur,
                                             exchangeRateHelper);
        ledgerVoucherTransObject.parmSourceTableId(_tableId);
        ledgerVoucherTransObject.parmSourceRecId(_recId);
        ledgerVoucherTransObject.parmLedgerDetailLevel(ledgerDetailLevel);
        ledgerVoucherTransObject.parmPaymentReference(paymReference);
        ledgerVoucherTransObject.parmPaymMode(this.parmPaymMode());
        ledgerVoucherTransObject.parmTransTxt(this.parmTransTxt());
        ledgerVoucherTransObject.parmFinTag(this.parmFinTag());
        _ledgerPostingJournal.addTrans(ledgerVoucherTransObject);

        ttsbegin;
        select forupdate taxWithholdTransLoc
            where taxWithholdTransLoc.RecId == _taxWithholdTrans.RecId;
        if (taxWithholdTransLoc)
        {
            taxWithholdTransLoc.TransactionReversal = NoYes::Yes;
            taxWithholdTransLoc.doUpdate();
            ttscommit;
            _taxWithholdTrans.copyTaxWithholdTrans(taxWithholdTransLoc, _ledgerPostingJournal.findLedgerVoucherObject().parmReferenceNumber(), _cancelDate, -1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets current amount of transaction.
    /// </summary>
    /// <param name="_ledgerPostingJournal">
    /// The instance of the <c>Ledgervoucher</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerJournalType</c> class.
    /// </returns>
    public LedgerJournalType setAmount_IN(LedgerVoucher _ledgerPostingJournal)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        LedgerJournalType ledgerJournalType;

        if (this.parmCheckStatus_IN())
        {
            amountCur = taxWithhold + totalWHTBankAmount ? (amountCur + taxWithhold + totalWHTBankAmount) : amountCur;
            taxWithholdAmountForeignTrans += taxWithhold + totalWHTBankAmount;
        }
        else if (common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTransLoc = common;
            ledgerJournalType = ledgerJournalTransLoc.ledgerJournalTable().JournalType;
            taxWithholdAmount = TaxWithholdJournal_IN::setDirection(taxWithholdAmount, ledgerJournalTransLoc);
        }

        // If tax liability on payment enabled, and ledger journal trans is marked as interim, do not call this method to deduct tax amount from amount
        boolean shouldWHTExcludeFromAmountCur;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = ledgerJournalTransLoc.ledgerJournalTransTaxExtensionIN();
        shouldWHTExcludeFromAmountCur = !(TaxWithholdGroupHeading::find(ledgerJournalTransTaxExtensionIN.TCSGroup).TaxLiabilityOnPayment_IN
            && LedgerJournalTrans::isCustomerPaymentByAccounts(ledgerJournalTransLoc));

        if (taxWithholdAmount)
        {
            if (shouldWHTExcludeFromAmountCur)
            {
                if (isTCSApplicable
                    && common.TableId != tableNum(LedgerJournalTrans)
                    && TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled()) // In this case, it should add rounded TCS.
                {
                    amountCur = amountCur + this.roundedOffAmount(taxWithholdAmount);
                }
                else
                {
                    amountCur = amountCur + taxWithholdAmount;
                }
            }
            taxWithholdDiscAmount = taxWithholdAmount;
            taxWithholdAmountForeignTrans = taxWithholdAmountForeignTrans + taxWithholdAmount;
        }

        if (checkBank)
        {
            if (shouldWHTExcludeFromAmountCur)
            {
                amountCur = amountCur - taxWithholdBank;
            }
            checkBank = false;
            taxWithholdAmountForeignTrans = taxWithholdAmountForeignTrans - taxWithholdBank;
        }

        if (checkCentralizedPayment)
        {
            if (shouldWHTExcludeFromAmountCur)
            {
                amountCur = amountCur + totalWHTBankAmount;
            }
            checkCentralizedPayment = false;
            taxWithholdAmountForeignTrans = taxWithholdAmountForeignTrans + totalWHTBankAmount;
        }

        return ledgerJournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets buffer.
    /// </summary>
    abstract protected void setBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invoice journal.
    /// </summary>
    /// <param name = "_custVendInvoiceJour">The custVendInvoiceJour to set.</param>
    public void setInvoiceJournal(CustVendInvoiceJour _custVendInvoiceJour)
    {
        custVendInvoiceJour = _custVendInvoiceJour;
        triangulation = custVendInvoiceJour.Triangulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creatingTransactionTxtContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating the transaction text context.
    /// </summary>
    /// <param name = "_transTxtType">
    /// The transaction text type.
    /// </param>
    /// <param name = "_transactionTextContext">
    /// The <c>TransactionTextContext</c> instance that was created for the <c>LedgerTransTxt</c> value.
    /// </param>
    delegate void creatingTransactionTxtContext(LedgerTransTxt _transTxtType, TransactionTextContext _transactionTextContext)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCreatingTransactionTxtContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Raises the event for creating the transaction text context.
    /// </summary>
    /// <param name = "_transTxtType">
    /// The transaction text type.
    /// </param>
    /// <param name = "_transactionTextContext">
    /// The <c>TransactionTextContext</c> instance that was created for the <c>LedgerTransTxt</c> value.
    /// </param>
    protected void onCreatingTransactionTxtContext(LedgerTransTxt _transTxtType, TransactionTextContext _transactionTextContext)
    {
        this.creatingTransactionTxtContext(_transTxtType, _transactionTextContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new <c>TransactionTxt</c> class instance.
    /// </summary>
    /// <param name = "_languageId">
    ///     The languageId.
    /// </param>
    /// <param name = "_referenceNumber">
    ///     The reference number.
    /// </param>
    /// <param name = "_date">
    ///     The transaction date.
    /// </param>
    /// <param name = "_transTxtType">
    ///     The transaction text type.
    /// </param>
    /// <returns>
    ///     An instance of <c>TransactionTxt</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final TransactionTxt initializeTransactionTxt(
        LanguageId _languageId,
        Voucher _referenceNumber,
        TransDate _date,
        LedgerTransTxt _transTxtType = transTxtType)
    {
        CustInvoiceJour custInvoiceJourLocal;

        TransactionTxt transactionTxt = TransactionTxt::construct();

        transactionTxt.setType(_transTxtType);
        transactionTxt.setVoucher(_referenceNumber);
        transactionTxt.setDate(_date);
        transactionTxt.setFormLetter(formLetter);
        transactionTxt.setKey1(accountNum);
        transactionTxt.setKey2(paymReference);
        transactiontxt.setCustVendName(this.getCustVendName());

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            if (taxWithholdType != TaxWithholdType_BR::Unknown)
            {
                transactionTxt.setKey2(enum2str(taxWithholdType));
            }
        }
        // </GBR>

        transactionTxt.setLanguage(_languageId);

        if (TransactionTextContext::isTypeSupported(_transTxtType))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_transTxtType);

            switch (_transTxtType)
            {
                case LedgerTransTxt::PurchInvoiceLedger :
                case LedgerTransTxt::PurchInvoiceVend :
                case LedgerTransTxt::PurchCreditNoteVend :
                case LedgerTransTxt::PurchCreditNoteLedger :
                    VendInvoiceJour vendInvoiceJourLocal = custVendInvoiceJour;
                    transactionTextContext.setTableBuffer(vendInvoiceJourLocal);

                    if (common.TableId == tableNum(PurchTable))
                    {
                        transactionTextContext.setTableBuffer(common);
                    }
                    break;

                case LedgerTransTxt::SalesCreditNoteCust :
                case LedgerTransTxt::SalesCreditNoteLedger :
                case LedgerTransTxt::SalesInvoiceCust :
                case LedgerTransTxt::SalesInvoiceLedger :
                    custInvoiceJourLocal = custVendInvoiceJour;
                    transactionTextContext.setTableBuffer(custInvoiceJourLocal);

                    if (common.TableId == tableNum(SalesTable))
                    {
                        transactionTextContext.setTableBuffer(common);
                    }
                    break;

                case LedgerTransTxt::CustCreditNoteCust,
                     LedgerTransTxt::CustInvoiceCust :
                    if (custVendInvoiceJour.TableId == tableNum(CustInvoiceJour))
                    {
                        custInvoiceJourLocal = custVendInvoiceJour;
                        CustInvoiceTable custInvoiceTableLocal = CustInvoiceTable::findSourceDocumentHeader(custInvoiceJourLocal.SourceDocumentHeader);
                        transactionTextContext.setTableBuffer(custInvoiceJourLocal);
                        transactionTextContext.setTableBuffer(custInvoiceTableLocal);
                    }
                    if (common.TableId == tableNum(CustInvoiceTable))
                    {
                        transactionTextContext.setTableBuffer(common);
                    }
                    break;
                
                case LedgerTransTxt::CustPaymentCust :
                    CustVendTrans custTransLocal = relatedCustTrans;
                    transactionTextContext.setTableBuffer(custTransLocal);
                    break;

                case LedgerTransTxt::VendPaymentVend :
                    transactionTextContext.setTableBuffer(postCustVendTrans);
                    break;
                case LedgerTransTxt::ProjectInvoiceCust :
                case LedgerTransTxt::ProjectCreditNoteCust :
                    this.setupProjTransactionTextContext(transactionTextContext);
                    break;

            }

            this.onCreatingTransactionTxtContext(_transTxtType, transactionTextContext);

            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets transaction text.
    /// </summary>
    /// <param name = "_languageId">The languageId.</param>
    /// <param name = "_referenceNumber">The reference number.</param>
    /// <param name = "_date">The transaction date.</param>
    /// <param name = "_transTxtType">The transaction text type.</param>
    /// <returns>The value of transaction text.</returns>
    protected TransTxt setTransactionTxt(
        LanguageId _languageId,
        Voucher _referenceNumber,
        TransDate _date,
        LedgerTransTxt _transTxtType = transTxtType)
    {
        TransactionTxt transactionTxt = this.initializeTransactionTxt(_languageId, _referenceNumber, _date, _transTxtType);

        return transactionTxt.txt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>summaryLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summary ledger dimension.
    /// </summary>
    /// <returns>Subclass method value.</returns>
    abstract protected LedgerDimensionDefaultAccount summaryLedgerDimension()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdReversal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the withholding tax amount.
    /// </summary>
    /// <param name="_oldVoucher">
    /// The old voucher number which was posted.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_tableId">
    /// Reference table id.
    /// </param>
    /// <param name="_recId">
    /// Record id of the record.
    /// </param>
    /// <param name="_ledgerPostingJournal">
    /// A <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_cancelDate">
    /// The cancellation date.
    /// </param>
    /// <param name="_isInterCompanyTransaction">
    /// A boolean parameter indicating whether this is an intercompany transaction.
    /// </param>
    public void taxWithholdReversal_IN(Voucher _oldVoucher,
                                       date _transDate,
                                       TableId _tableId,
                                       RecId _recId,
                                       LedgerVoucher _ledgerPostingJournal,
                                       TransDate _cancelDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                       boolean _isInterCompanyTransaction = false)
    {
        VendTransOpen vendTransOpen,vendTransOpenLoc;
        CustTransOpen custTransOpen,custTransOpenLoc;
        CustTrans custTrans,custTransLoc;
        custTrans_W custTrans_W;
        VendTrans vendTrans,vendTransLoc;
        vendTrans_W vendTrans_W;
        RecId refRecId;
        TaxWithholdTrans_IN taxWithholdTransCrossCompany;
        CompanyId currentCompany;
        CompanyId previousCompany;

        while select crosscompany taxWithholdTransCrossCompany
            where (taxWithholdTransCrossCompany.Voucher == _oldVoucher
                || taxWithholdTransCrossCompany.SettlementVoucher == _oldVoucher)
                && taxWithholdTransCrossCompany.TransDate == _transDate
        {
            if (taxWithholdTransCrossCompany.company() != curext())
            {
                this.reverseCentralizedPaymentWHT_IN(taxWithholdTransCrossCompany, _cancelDate, taxWithholdTransCrossCompany.Voucher);
                currentCompany = taxWithholdTransCrossCompany.DataAreaId;

                if (currentCompany != previousCompany && !_isInterCompanyTransaction)
                {
                    this.reverseJournalEntry_IN(_oldVoucher, _transDate, _tableId, _recId, taxWithholdTransCrossCompany, _ledgerPostingJournal);
                    previousCompany = taxWithholdTransCrossCompany.DataAreaId;
                }
            }
            else
            {
                this.reverseWHTAsPerCompany_IN(taxWithholdTransCrossCompany, _tableId, _recId, _cancelDate, _ledgerPostingJournal);
            }
        }

        if (ledgerPostingType == LedgerPostingType::VendBalance)
        {
            select Voucher, RecId from vendTrans
                where vendTrans.Voucher == _oldVoucher;

            while select OffsetRecid, RecId from vendTransLoc
                where vendTransLoc.OffsetRecid == vendTrans.RecId
            {
                select RefRecId from vendTransOpenLoc
                    where vendTransOpenLoc.RefRecId == vendTransLoc.RecId;
                if (vendTransOpenLoc)
                {
                    refRecId = vendTransOpenLoc.RefRecId;
                }
            }
            select firstonly TaxWithholdAmountOrigin_IN, tdsAmount_IN, tcsAmount_IN from vendTrans_W
                where vendTrans_W.VendTrans == refRecId;

            ttsbegin;
            select forupdate vendTransOpen
                where vendTransOpen.RefRecId == refRecId;
            if (vendTransOpen)
            {
                vendTransOpen.TaxWithholdAmountOrigin_IN = vendTrans_W.TaxWithholdAmountOrigin_IN;
                vendTransOpen.tdsAmount_IN = vendTrans_W.tdsAmount_IN;
                vendTransOpen.tcsAmount_IN = vendTrans_W.tcsAmount_IN;
                vendTransOpen.doUpdate();
            }
            ttscommit;
        }

        if (ledgerPostingType == LedgerPostingType::CustBalance)
        {
            select Voucher, RecId from custTrans
                where custTrans.Voucher == _oldVoucher;

            while select OffsetRecid, RecId from custTransLoc
                where custTransLoc.OffsetRecid == custTrans.RecId
            {
                select RefRecId from custTransOpenLoc
                    where custTransOpenLoc.RefRecId == custTransLoc.RecId;
                if (custTransOpenLoc)
                {
                    refRecId = custTransOpenLoc.RefRecId;
                }
            }

            select firstonly TaxWithholdAmountOrigin_IN, tdsAmount_IN, tcsAmount_IN from custTrans_W
                where custTrans_W.CustTrans == refRecId;

            ttsbegin;
            select forupdate custTransOpen
                where custTransOpen.RefRecId == refRecId;
            if (custTransOpen)
            {
                custTransOpen.TaxWithholdAmountOrigin_IN = custTrans_W.TaxWithholdAmountOrigin_IN;
                custTransOpen.tdsAmount_IN = custTrans_W.tdsAmount_IN;
                custTransOpen.tcsAmount_IN = custTrans_W.tcsAmount_IN;
                custTransOpen.doUpdate();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if parameters.
    /// </summary>
    /// <returns>True if valid, false otherwise.</returns>
    public boolean validate()
    {
        boolean ret = true;

        ret = this.checkParameters();

        if (ret && !this.parmBypassCreditCheck() &&
            !this.isAmountBelowCreditMax(typeOfCreditmaxCheck) && !this.postingProfileSettlement())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>CustVendVoucher</c>.
    /// </summary>
    /// <param name = "_module">Parameter of module.</param>
    /// <param name = "_accountNum">Parameter of accountNum.</param>
    /// <param name = "_amount">Parameter of amount.</param>
    /// <param name = "_currencyCode">Parameter of currencyCode.</param>
    /// <param name = "_transTxtType">Parameter of transTxtType.</param>
    /// <param name = "_dimensionDefault">Parameter of module.</param>
    /// <param name = "_postingProfile">Parameter of postingProfile.</param>
    /// <param name = "_posting">Parameter of posting.</param>
    /// <param name = "_paymTermId">Parameter of paymTermId.</param>
    /// <param name = "_settlement">Parameter of settlement.</param>
    /// <param name = "_approver">Parameter of approver.</param>
    /// <param name = "_approved">Parameter of approved.</param>
    /// <param name = "_invoiceId">Parameter of invoiceId.</param>
    /// <param name = "_cashDiscDate">Parameter of cashDiscDate.</param>
    /// <param name = "_cashDiscAmount">Parameter of cashDiscAmount.</param>
    /// <param name = "_dueDate">Parameter of dueDate.</param>
    /// <param name = "_common"Parameter of common.></param>
    /// <returns>New instance of CustVendVoucher.</returns>
    static CustVendVoucher construct(SysModule _module,
                                     CustVendAC _accountNum,
                                     AmountCur _amount,
                                     CurrencyCode _currencyCode,
                                     LedgerTransTxt _transTxtType,
                                     DimensionDefault _dimensionDefault = 0,
                                     PostingProfile _postingProfile = '',
                                     LedgerPostingType _posting = LedgerPostingType::None,
                                     PaymTermId _paymTermId = '',
                                     SettlementType _settlement = SettlementType::None,
                                     HcmApprover _approver = HcmWorker::userId2Worker(curUserId()),
                                     Approved _approved = _approver ? NoYes::Yes : NoYes::No,
                                     InvoiceId _invoiceId = '',
                                     DiscDate _cashDiscDate = dateNull(),
                                     AmountCur _cashDiscAmount = 0,
                                     TransDate _dueDate = dateNull(),
                                     Common _common = null)
    {
        CustVendVoucher custVendVoucher;

        switch (_module)
        {
            case SysModule::Cust :
                custVendVoucher = new CustVoucher();

                custVendVoucher.init(_accountNum,
                    _amount,
                    _currencyCode,
                    _transTxtType,
                    _dimensionDefault,
                    _postingProfile,
                    _posting,
                    _paymTermId,
                    _settlement,
                    _approver,
                    _approved,
                    _invoiceId,
                    _cashDiscDate,
                    _cashDiscAmount,
                    _dueDate,
                    _common);

                if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
                {
                    custVendVoucher.parmModule(SysModule::Cust);
                }
                break;

            case SysModule::Vend :
                custVendVoucher = new VendVoucher();

                custVendVoucher.init(_accountNum,
                    _amount,
                    _currencyCode,
                    _transTxtType,
                    _dimensionDefault,
                    _postingProfile,
                    _posting,
                    _paymTermId,
                    _settlement,
                    _approver,
                    _approved,
                    _invoiceId,
                    _cashDiscDate,
                    _cashDiscAmount,
                    _dueDate,
                    _common);

                if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
                {
                    custVendVoucher.parmModule(SysModule::Vend);
                }
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>CustVoucherProject</c>.
    /// </summary>
    /// <param name = "_accountNum">Parameter of accountNum.</param>
    /// <param name = "_amount">Parameter of amount.</param>
    /// <param name = "_currencyCode">Parameter of currencyCode.</param>
    /// <param name = "_transTxtType">Parameter of transTxtType.</param>
    /// <param name = "_dimension">Parameter of dimension.</param>
    /// <param name = "_postingProfile">Parameter of postingProfile.</param>
    /// <param name = "_posting">Parameter of posting.</param>
    /// <param name = "_paymTermId">Parameter of paymTermId.</param>
    /// <param name = "_settlement">Parameter of settlement.</param>
    /// <param name = "_approver">Parameter of approver.</param>
    /// <param name = "_approved">Parameter of approved.</param>
    /// <param name = "_invoiceNum">Parameter of invoiceNum.</param>
    /// <param name = "_cashDiscDate">Parameter of cashDiscDate.</param>
    /// <param name = "_cashDiscAmount">Parameter of cashDiscAmount.</param>
    /// <param name = "_dueDate">Parameter of dueDate.</param>
    /// <param name = "_common">Parameter of common.</param>
    /// <param name = "_typeOfCreditmaxCheck">Parameter of typeOfCreditmaxCheck.</param>
    /// <param name = "_cashDiscCode">Parameter of cashDiscCode.</param>
    /// <param name = "_orderAccount">Parameter of orderAccount.</param>
    /// <param name = "_fixedExchRate">Parameter of fixedExchRate.</param>
    /// <returns>New instance of CustVoucherProject.</returns>
    static CustVoucherProject constructProject(
        CustVendAC _accountNum,
        AmountCur _amount,
        CurrencyCode _currencyCode,
        LedgerTransTxt _transTxtType,
        DimensionDefault _dimension = 0,
        PostingProfile _postingProfile = '',
        LedgerPostingType _posting = 0,
        PaymTermId _paymTermId = '',
        SettlementType _settlement = SettlementType::None,
        HcmApprover _approver = HcmWorker::userId2Worker(curUserId()),
        Approved _approved = _approver ? NoYes::Yes : NoYes::No,
        InvoiceId _invoiceNum = '',
        DiscDate _cashDiscDate = dateNull(),
        AmountCur _cashDiscAmount = 0,
        TransDate _dueDate = dateNull(),
        Common _common = _common,
        TypeOfCreditmaxCheck _typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance,
        CashDiscCode _cashDiscCode = '',
        CustVendAC _orderAccount = '',
        FixedExchRate _fixedExchRate = NoYes::No)
    {
        CustVoucherProject custVoucherProject = new CustVoucherProject();

        custVoucherProject.init(
            _accountNum,
            _amount,
            _currencyCode,
            _transTxtType,
            _dimension,
            _postingProfile,
            _posting,
            _paymTermId,
            _settlement,
            _approver,
            _approved,
            _invoiceNum,
            _cashDiscDate,
            _cashDiscAmount,
            _dueDate,
            _common,
            _typeOfCreditmaxCheck,
            _cashDiscCode,
            _orderAccount,
            '',
            _fixedExchRate);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucherProject.parmModule(SysModule::Project);
        }

        custVoucherProject.parmLanguageId(CustTable::find(_accountNum).languageId());

        return custVoucherProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructRTax25</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>CustVendVoucher</c> from RTax25.
    /// </summary>
    /// <param name = "_module">Parameter of module.</param>
    /// <param name = "_ledgerVoucher">Parameter of ledgerVoucher.</param>
    /// <param name = "_accountNum">Parameter of accountNum.</param>
    /// <param name = "_amount">Parameter of amount.</param>
    /// <param name = "_currencyCode">Parameter of currencyCode.</param>
    /// <param name = "_transTxtType">Parameter of transTxtType.</param>
    /// <param name = "_defaultDimension">Parameter of defaultDimension.</param>
    /// <param name = "_postingProfile">Parameter of postingProfile.</param>
    /// <param name = "_posting">Parameter of posting.</param>
    /// <param name = "_paymTermId">Parameter of paymTermId.</param>
    /// <param name = "_settlement">Parameter of settlement.</param>
    /// <param name = "_approver">Parameter of approver.</param>
    /// <param name = "_approved">Parameter of approved.</param>
    /// <param name = "_invoiceId">Parameter of invoiceId.</param>
    /// <param name = "_cashDiscDate">Parameter of cashDiscDate.</param>
    /// <param name = "_cashDiscAmount">Parameter of cashDiscAmount.</param>
    /// <param name = "_dueDate">Parameter of dueDate.</param>
    /// <param name = "_common">Parameter of common.</param>
    /// <returns>New instance of CustVendVoucher.</returns>
    public static CustVendVoucher constructRTax25(SysModule _module,
                                                  LedgerVoucher _ledgerVoucher,
                                                  CustVendAC _accountNum,
                                                  AmountCur _amount,
                                                  CurrencyCode _currencyCode,
                                                  LedgerTransTxt _transTxtType,
                                                  DimensionDefault _defaultDimension = 0,
                                                  PostingProfile _postingProfile = '',
                                                  LedgerPostingType _posting = 0,
                                                  PaymTermId _paymTermId = '',
                                                  SettlementType _settlement = SettlementType::None,
                                                  HcmApprover _approver = HcmWorker::userId2Worker(curUserId()),
                                                  Approved _approved = _approver ? NoYes::Yes : NoYes::No,
                                                  InvoiceId _invoiceId = '',
                                                  DiscDate _cashDiscDate = dateNull(),
                                                  AmountCur _cashDiscAmount = 0,
                                                  TransDate _dueDate = dateNull(),
                                                  Common _common = _common)
    {
        RTax25CustVoucher custVoucher;
        RTax25VendVoucher vendVoucher;

        switch (_module)
        {
            case SysModule::Cust:
                custVoucher = new RTax25CustVoucher();
                custVoucher.init(_accountNum,
                                 _amount,
                                 _currencyCode,
                                 _transTxtType,
                                 _defaultDimension,
                                 _postingProfile,
                                 _posting,
                                 _paymTermId,
                                 _settlement,
                                 _approver,
                                 _approved,
                                 _invoiceId,
                                 _cashDiscDate,
                                 _cashDiscAmount,
                                 _dueDate,
                                 _common);
                custVoucher.setTransRef(CustTransRefType::Other, _invoiceId);
                return custVoucher;

            case SysModule::Vend:
                vendVoucher = new RTax25VendVoucher();
                vendVoucher.init(_accountNum,
                                 _amount,
                                 _currencyCode,
                                 _transTxtType,
                                 _defaultDimension,
                                 _postingProfile,
                                 _posting,
                                 _paymTermId,
                                 _settlement,
                                 _approver,
                                 _approved,
                                 _invoiceId,
                                 _cashDiscDate,
                                 _cashDiscAmount,
                                 _dueDate,
                                 _common);
                return vendVoucher;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionFieldId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns field id of defauld dimension field in _common cursor.
    /// </summary>
    /// <param name="_common">
    /// A common cursor which can be one of several tables.
    /// </param>
    /// <returns>
    /// Returns field id of defauld dimension field.
    /// </returns>
    public static FieldId getDefaultDimensionFieldId_RU(Common _common)
    {
        FieldId fieldId;

        switch (_common.TableId)
        {
            case tableNum(PurchTable):
                fieldId = fieldNum(PurchTable, DefaultDimension);
                break;
            case tableNum(SalesTable):
                fieldId = fieldNum(SalesTable, DefaultDimension);
                break;
            case tableNum(VendInvoiceJour):
                fieldId = fieldNum(VendInvoiceJour, DefaultDimension);
                break;
            case tableNum(CustInvoiceJour):
                fieldId = fieldNum(CustInvoiceJour, DefaultDimension);
                break;
            case tableNum(LedgerJournalTrans):
                fieldId = fieldNum(LedgerJournalTrans, DefaultDimension);
                break;
            case tableNum(CustInvoiceTable) :
                fieldId = fieldNum(CustInvoiceTable, DefaultDimension);
                break;
            case tableNum(CustTrans) :
                fieldId = fieldNum(CustTrans, DefaultDimension);
                break;
            case tableNum(VendTrans) :
                fieldId = fieldNum(VendTrans, DefaultDimension);
                break;
        }

        return fieldId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedInvoiceTransLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets fixed invoice trans ledger dimension.
    /// </summary>
    /// <param name = "_fixedInvoiceTransLedgerDimension">Parameter of fixedInvoiceTransLedgerDimension.</param>
    /// <returns>The value of fixedInvoiceTransLedgerDimension.</returns>
    public LedgerDimensionDefaultAccount parmFixedInvoiceTransLedgerDimension_RU(LedgerDimensionDefaultAccount _fixedInvoiceTransLedgerDimension = fixedInvoiceTransLedgerDimension)
    {
        fixedInvoiceTransLedgerDimension = _fixedInvoiceTransLedgerDimension;
        return fixedInvoiceTransLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostSplitPayment_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the split payment posting should be called.
    /// </summary>
    /// <param name="_custVendTrans">A <c>CustTrans</c> or <c>VendTrans</c> record being created during posting.</param>
    /// <returns>true if the split payment posting should be called; otherwise, false.</returns>
    /// <remarks>Split payment should be called when posting sales order, free text invoice, general journal and project invoice.</remarks>
    protected boolean shouldPostSplitPayment_IT(CustVendTrans _custVendTrans)
    {
        return MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration)
            && (custVendInvoiceJour.TableId == tableNum(CustInvoiceJour)
            || custVendInvoiceJour.TableId == tableNum(ProjInvoiceJour))
            && (_custVendTrans.TransType == LedgerTransType::Cust
                || _custVendTrans.TransType == LedgerTransType::Sales
                || _custVendTrans.TransType == LedgerTransType::GeneralJournal
                || _custVendTrans.TransType == LedgerTransType::Project)
           && !isCalledFromSplitPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymSchedId</Name>
				<Source><![CDATA[
    /// <summary>
    /// sets the payment scheduled id for the respective cust/vend trans record.
    /// </summary>
    /// <param name="_custVendTrans">
    /// cust/vend record.
    /// </param>
    /// <param name="_paymSchedId">
    /// payment schedule Id.
    /// </param>
    protected void setPaymSchedId(CustVendTrans _custVendTrans, PaymSchedId _paymSchedId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDocumentLedgerVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax document ledger voucher map.
    /// </summary>
    /// <returns>Tax document ledger voucher map.</returns>
    public Map getTaxDocumentLedgerVoucherMap()
    {
        return taxDocumentLedgerVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendBusinessEventsForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends business events for posting taking place.
    /// </summary>
    protected void sendBusinessEventsForPosting()
    {
        var businessEvent = this.getBusinessEvent();

        if (businessEvent)
        {
            businessEvent.send();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the business event for the voucher posting.
    /// </summary>
    /// <returns>A <c>BusinessEventsBase</c> extension if provided by a derived type; otherwise null.</returns>
    protected BusinessEventsBase getBusinessEvent()
    {
        BusinessEventsBase businessEvent;

        return businessEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffAmount</Name>
				<Source><![CDATA[
    protected AmountCur roundedOffAmount(AmountCur _amount)
    {
        // This method should be overridden by concrete sub-classes.
        return CurrencyExchange::roundWithRuleType(
            _amount,
            this.parmCurrencyCode(),
            CurrencyRoundingRuleType::Amount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailCashAndCarryTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// When RetailCashAndCarryTransaction have been paid on POS there should be no Payment Schedule implications and open balance for the invoiced sales order
    /// </summary>
    /// <param name = "_custVendInvoiceJour">
    /// <c>CustVendInvoiceJour</c> map buffer.
    /// </param>
    /// <returns>
    /// True if order is cash and carry transaction. Else, false.
    /// </returns>
    internal static boolean isRetailCashAndCarryTransaction(CustVendInvoiceJour _custVendInvoiceJour)
    {

        if(_custVendInvoiceJour && _custVendInvoiceJour.TableId == tableNum(CustInvoiceJour))
        {
            SalesTable salesTable=SalesTable::find(CustInvoiceJour::findRecId(_custVendInvoiceJour.RecId).SalesId);

            return salesTable && RetailSalesTableCashAndCarryCache::isRetailCashAndCarrySales(salesTable);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAssetLeaseTypes</Name>
				<Source><![CDATA[
    protected void setAssetLeaseTypes(LedgerVoucherObject _ledgerVoucherObject, LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>