<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>KanbanFindRules</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>KanbanFindRules</c> class provides methods to find the <c>KanbanRule</c> records that apply
///    for a set of specified criteria.
/// </summary>
public class KanbanFindRules
{
    ItemId                      itemId;
    InventDimId                 inventDimId;
    InventDimParm               inventDimParm;
    LegalEntity                 legalEntity;
    LeanProductionFlowRefRecId  leanProdFlowReferenceRecId;
    KanbanRuleRefRecId          kanbanRuleRecId;
    KanbanRuleRefRecId          excludeKanbanRuleRecId;
    PlanActivityRefRecId        lastPlanActivityRecId;
    PlanActivityRefRecId        lastPlanActivityDownStreamRecId;
    PlanActivityRefRecId        firstPlanActivityUpStreamRecId;
    TransDateTime               dateTimeFrom;
    TransDateTime               dateTimeTo;
    boolean                     firstRuleOnly;
    boolean                     includeManufacturing;
    boolean                     includeWithdrawal;
    boolean                     includePickupSemiFinished;
    boolean                     includeReceiveSemiFinished;
    boolean                     includePickupFinished;
    boolean                     includeReceiveFinished;
    boolean                     includeOnHandUpdateReceipt;
    boolean                     includeNotOnHandUpdateReceipt;
    boolean                     skipRuleMayExistCheck;
    LeanReplenishmentStrategy   replenishmentStrategy;
    InventQty                   minimumInventQty;
    InventDim                   inventDim;
    InventDimGroupSetup         inventDimGroupSetup;
    boolean                     inventDimParmInitialized;
    int                         foundResults;
    Map                         mapResult;
    Map                         mapKanbanRuleCoverage;
    List                        listResult;
    Set                         setResult;
    ListEnumerator              listEnumerator;
    KanbanFindRulesCache        kanbanFindRulesCache;
    LeanLocationCache           leanLocationCache;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>add</Name>
				<Source><![CDATA[
/// <summary>
    ///    Adds a <c>KanbanRule</c> record to the list of search results.
    /// </summary>
    /// <param name="_kanbanRule">
    ///    The <c>KanbanRule</c> record to add.
    /// </param>
    /// <param name="_coverageValidFrom">
    ///     The coverage validity starting date time.
    /// </param>
    /// <param name="_coverageValidTo">
    ///     The coverage validity ending date time.
    /// </param>
    /// <param name="_leanRuleCoverageType">
    ///     The rule coverage type.
    /// </param>
    /// <param name="_forceAdd">
    ///     A Boolean value specifying whether it must be evaluated if kanban rule should be added; optional.
    /// </param>
    /// <returns>
    ///    true if the record was added; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The result will not accept duplicates.Optionally, only records related to a specified
    ///    <c>LeanProductionFlowReference</c> record are inserted.
    /// </remarks>
    private boolean add(
        KanbanRule              _kanbanRule,
        LeanRuleActiveDateTime  _coverageValidFrom,
        LeanRuleActiveDateTime  _coverageValidTo,
        KanbanFindRulesCacheCoverageType    _leanRuleCoverageType,
        boolean                             _forceAdd = false)
    {
        KanbanRuleEvent kanbanRuleEvent;

        List        list;
        boolean     result;
        boolean     add = !setResult.in(_kanbanRule.RecId);

        if (add && (_forceAdd || this.mustAdd(_kanbanRule)))
        {
            if (KanbanFindRules::isCoverageValid(_coverageValidFrom,
                                                 _coverageValidTo,
                                                 dateTimeFrom,
                                                 dateTimeTo))
            {
                result = setResult.add(_kanbanRule.RecId);

                if (result)
                {
                    mapKanbanRuleCoverage.insert(_kanbanRule.RecId,[_coverageValidFrom,_coverageValidTo]);

                    if (_kanbanRule.ReplenishmentStrategy == LeanReplenishmentStrategy::Event)
                    {
                        kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(_kanbanRule.RecId);
                    }

                    container mapKey = this.mapKey(_kanbanRule,
                                                   kanbanRuleEvent,
                                                   _leanRuleCoverageType);
                    if (mapResult.exists(mapKey))
                    {
                        list = mapResult.lookup(mapKey);
                    }
                    else
                    {
                        list = new List(Types::Record);
                    }
                    list.addEnd(_kanbanRule);
                    mapResult.insert(mapKey,list);
                    foundResults++;
                }
            }

            // a rule was added or a rule was found that lies in the future
            result =    result
                     || firstRuleOnly;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list object that is the final result of the find operation.
    /// </summary>
    /// <remarks>
    /// The result is a list sorted by a replenishment strategy, minimum event kanban quantity, coverage
    /// type and inventory dimensions.
    /// </remarks>
    protected void finalizeResult()
    {
        int                     replenishStrategy;
        KanbanQuantity          minEventQuantity;
        KanbanFindRulesCacheCoverageType    leanRuleCoverageType;
        LeanRuleActiveDateTime  coverageValidFrom;
        LeanRuleActiveDateTime  coverageValidTo;

        if (   listResult.elements() == 0
            && mapResult.elements()  != 0)
        {
            MapEnumerator me = mapResult.getEnumerator();
            while (me.moveNext())
            {
                [replenishStrategy,minEventQuantity,leanRuleCoverageType] = me.currentKey();
                List list = me.currentValue();

                if (   list
                    && list.elements())
                {
                    if (firstRuleOnly)
                    {
                        ListEnumerator le = list.getEnumerator();
                        le.moveNext();
                        KanbanRule kanbanRule = le.current();

                        // only single rules are cached
                        [coverageValidFrom,coverageValidTo] = mapKanbanRuleCoverage.lookup(kanbanRule.RecId);
                        kanbanFindRulesCache.insertKanbanRule(
                                                this.ruleSearchId(),
                                                this.mustScanAllCoverageTypes() ?
                                                   KanbanFindRulesCacheCoverageType::ScanAll :
                                                   leanRuleCoverageType,
                                                coverageValidFrom,
                                                coverageValidTo,
                                                kanbanRule);

                        listResult.addEnd(kanbanRule);
                        break;
                    }
                    else
                    {
                        listResult.appendList(list);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAllRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds rules with a <c>RuleCoverageType</c> enumeration value of <c>All</c>.
    /// </summary>
    /// <param name="_fetchAhead">
    ///    Boolean value indicating whether unstarted rules should be pre-fetched if a current rule doesnt exist.
    /// </param>
    /// <returns>
    ///    true if one or more records were added to the result; otherwise, false.
    /// </returns>
    private boolean findAllRules(boolean _fetchAhead = true)
    {
        KanbanRule                       kanbanRule;
        LeanCoverage                     leanCoverage;
        LeanCoverageKanbanRule           leanCoverageKanbanRule;
        InventDim                        inventDimSearch;
        boolean                          result;
        LeanRuleCoverageType             leanRuleCoverageType = LeanRuleCoverageType::All;
        KanbanFindRulesCacheCoverageType cacheCoverageType    = KanbanFindRulesCacheCoverageType::All;

        while select forceplaceholders kanbanRule
            order by ReplenishmentStrategy desc
            where  kanbanRule.LegalEntity           == legalEntity
               && (kanbanRule.RecId                 == kanbanRuleRecId
               ||  !kanbanRuleRecId)
               &&  kanbanRule.RecId                 != excludeKanbanRuleRecId
               && (kanbanRule.KanbanType            != LeanKanbanType::Manufacturing
               ||  includeManufacturing)
               && (kanbanRule.KanbanType            != LeanKanbanType::Withdrawal
               ||  includeWithdrawal)
               && (kanbanRule.ReplenishmentStrategy == replenishmentStrategy
               ||  !replenishmentStrategy)
            join tableid from leanCoverage 
                where leanCoverage.RuleCoverageType == leanRuleCoverageType
            #inventDimJoinCoveragePriority(leanCoverage.InventDimId,inventDimSearch,inventDim,inventDimParm)
            join ValidFrom, ValidTo from leanCoverageKanbanRule
                order by ValidFrom asc
                where leanCoverageKanbanRule.KanbanRule  == kanbanRule.RecId
                   && leanCoverageKanbanRule.Coverage    == leanCoverage.RecId
                   && ((leanCoverageKanbanRule.ValidFrom <= dateTimeTo
                   &&  (leanCoverageKanbanRule.ValidTo   >= dateTimeFrom
                   ||  !leanCoverageKanbanRule.ValidTo))
                   ||  ((!dateTimeTo
                   ||    _fetchAhead)
                   &&   leanCoverageKanbanRule.ValidTo   >= dateTimeFrom))
        {
            result = this.add(kanbanRule, leanCoverageKanbanRule.ValidFrom, leanCoverageKanbanRule.ValidTo, cacheCoverageType) || result;
            if (   result
                && !this.mustContinueSearch())
            {
                break;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstKanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the first <c>KanbanRule</c> record that matches the search criteria.
    /// </summary>
    /// <returns>
    ///    A record in the <c>KanbanRule</c> table.
    /// </returns>
    public KanbanRule findFirstKanbanRule()
    {
        firstRuleOnly = true;
        return this.first();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findKanbanRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds kanban rules that match the specified criteria.
    /// </summary>
    /// <param name="_fetchAhead">
    ///     Boolean value indicating whether unstarted rules should be pre-fetched if a current rule doesnt exist.
    /// </param>
    /// <returns>
    ///    A list of record in the <c>KanbanRule</c> table.
    /// </returns>
    /// <remarks>
    ///    The list is in prioritized order, which means rules that match the criteria closest come first.
    /// </remarks>
    public List findKanbanRules(boolean _fetchAhead = true)
    {
        this.initCacheAndResult();

        if (   skipRuleMayExistCheck
            || KanbanFindRules::ruleMayExist(itemId,replenishmentStrategy,kanbanFindRulesCache))
        {
            this.init();

            if (this.mustScanAllCoverageTypes())
            {
                this.findKanbanRulesType(KanbanFindRulesCacheCoverageType::ScanAll);
            }
            else
            {
                // product specific rules
                if (this.mustContinueSearch())
                {
                    this.findKanbanRulesType(KanbanFindRulesCacheCoverageType::Product);
                }

                // product family specific rules
                if (this.mustContinueSearch())
                {
                    this.findKanbanRulesType(KanbanFindRulesCacheCoverageType::ProductFamily);
                }

                // rules for all items
                if (this.mustContinueSearch())
                {
                    this.findKanbanRulesType(KanbanFindRulesCacheCoverageType::All);
                }
            }
            this.finalizeResult();
        }

        return listResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findKanbanRulesType</Name>
				<Source><![CDATA[
/// <summary>
    ///    Finds the kanban rules that match the specified criteria of the coverage type.
    /// </summary>
    /// <param name="_leanRuleCoverageType">
    ///    The cache coverage type.
    /// </param>
    private void findKanbanRulesType(KanbanFindRulesCacheCoverageType _leanRuleCoverageType)
    {
        KanbanRule              kanbanRule;
        LeanRuleActiveDateTime  validDateTimeFrom;
        LeanRuleActiveDateTime  validDateTimeTo;
        boolean                 found                = false;
        boolean                 elementsAdded        = false;
        container               ruleSearchId         = this.ruleSearchId();

        if (firstRuleOnly)
        {
            // Look in the cache
            [found, kanbanRule,validDateTimeFrom,validDateTimeTo] = kanbanFindRulesCache.getKanbanRule(ruleSearchId, _leanRuleCoverageType, dateTimeFrom, dateTimeTo);
            if (kanbanRule)
            {
                this.add(kanbanRule,validDateTimeFrom,validDateTimeTo,_leanRuleCoverageType, true);
            }
        }

        if (!found)
        {
            // Look in the database if there was nothing in the cache
            switch (_leanRuleCoverageType)
            {
                case KanbanFindRulesCacheCoverageType::Product:
                    elementsAdded = this.findProductRules(firstRuleOnly);
                    break;

                case KanbanFindRulesCacheCoverageType::ProductFamily:
                    elementsAdded = this.findProductFamilyRules(firstRuleOnly);
                    break;

                case KanbanFindRulesCacheCoverageType::All:
                    elementsAdded = this.findAllRules(firstRuleOnly);
                    break;
                case KanbanFindRulesCacheCoverageType::ScanAll:
                    elementsAdded = this.findProductRules(firstRuleOnly);
                    elementsAdded = this.findProductFamilyRules(firstRuleOnly) || elementsAdded;
                    elementsAdded = this.findAllRules(firstRuleOnly) || elementsAdded;
                    break;
            }
        }

        if (   firstRuleOnly
            && !kanbanRule
            && !elementsAdded
            && !kanbanFindRulesCache.existKanbanRule(ruleSearchId, _leanRuleCoverageType))
        {
            // If still nothing found, cache empty result
            kanbanFindRulesCache.insertKanbanRule(ruleSearchId, _leanRuleCoverageType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProductFamilyRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the product family rules by using a <c>RuleCoverageType</c> enumeration value of the product
    ///    family.
    /// </summary>
    /// <param name="_fetchAhead">
    ///    A Boolean value that indicates whether rules that are not started are to be pre-fetched if a
    ///    current rule does not exist.
    /// </param>
    /// <returns>
    ///    true if one or more records were added to the result; otherwise, false.
    /// </returns>
    private boolean findProductFamilyRules(boolean _fetchAhead = true)
    {
        KanbanRule                  kanbanRule;
        LeanCoverage                leanCoverage;
        LeanCoverageKanbanRule      leanCoverageKanbanRule;
        InventDim                   inventDimSearch;
        InventDim                   inventDimSearchAllocationLine;
        InventDimParm               inventDimParmAllocationLine;
        ForecastItemAllocationLine  forecastItemAllocationLine;
        boolean                     result;
        LeanRuleCoverageType        leanRuleCoverageType = LeanRuleCoverageType::ProductFamily;
        KanbanFindRulesCacheCoverageType cacheCoverageType = KanbanFindRulesCacheCoverageType::ProductFamily;

        //set item dimension criteria
        InventDim inventDimCriteriaAllocationLine = inventDim.data();
        inventDimCriteriaAllocationLine.clearNotProductDim(this.inventDimGroupSetup());
        inventDimParmAllocationLine.initFromInventDim(inventDimCriteriaAllocationLine);

        //product family specific
        while select forceplaceholders kanbanRule
            order by ReplenishmentStrategy desc
            where   kanbanRule.LegalEntity           == legalEntity
                && (kanbanRule.RecId                 == kanbanRuleRecId
                ||  !kanbanRuleRecId)
                && kanbanRule.RecId                  != excludeKanbanRuleRecId
                && (kanbanRule.KanbanType            != LeanKanbanType::Manufacturing
                ||  includeManufacturing)
                && (kanbanRule.KanbanType            != LeanKanbanType::Withdrawal
                ||  includeWithdrawal)
                && (kanbanRule.ReplenishmentStrategy == replenishmentStrategy
                ||  !replenishmentStrategy)
            join TableId from leanCoverage
                where leanCoverage.RuleCoverageType == leanRuleCoverageType
            #inventDimJoinCoveragePriority(leanCoverage.InventDimId,inventDimSearch,inventDim,InventDimParm)
            join TableId from forecastItemAllocationLine
                where forecastItemAllocationLine.AllocationId == leanCoverage.AllocationId
                   && forecastItemAllocationLine.ItemId       == itemId
            #inventDimJoin(forecastItemAllocationLine.InventDimId,inventDimSearchAllocationLine,inventDimCriteriaAllocationLine,inventDimParmAllocationLine)
            join ValidFrom, ValidTo from leanCoverageKanbanRule
                order by ValidFrom asc
                where leanCoverageKanbanRule.Coverage    == leanCoverage.RecId
                   && leanCoverageKanbanRule.KanbanRule  == kanbanRule.RecId
                   && ((leanCoverageKanbanRule.ValidFrom <= dateTimeTo
                   &&   (leanCoverageKanbanRule.ValidTo  >= dateTimeFrom
                   ||    !leanCoverageKanbanRule.ValidTo))
                   ||  ((!dateTimeTo
                   ||    _fetchAhead)
                   &&   leanCoverageKanbanRule.ValidTo   >= dateTimeFrom))
        {
            result = this.add(kanbanRule, leanCoverageKanbanRule.ValidFrom, leanCoverageKanbanRule.ValidTo, cacheCoverageType) || result;
            if (   result
                && !this.mustContinueSearch())
            {
                break;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProductRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the product rules by using a <c>RuleCoverageType</c> enumeration value of the product.
    /// </summary>
    /// <param name="_fetchAhead">
    ///    A Boolean value that indicates whether rules that are not started are to be pre-fetched if a
    ///    current rule does not exist.
    /// </param>
    /// <returns>
    ///    true if one or more records were added to the result; otherwise, false.
    /// </returns>
    private boolean findProductRules(boolean _fetchAhead = true)
    {
        KanbanRule                  kanbanRule;
        LeanCoverage                leanCoverage;
        LeanCoverageKanbanRule      leanCoverageKanbanRule;
        InventDim                   inventDimSearch;
        boolean                     result;
        LeanRuleCoverageType        leanRuleCoverageType = LeanRuleCoverageType::Product;
        KanbanFindRulesCacheCoverageType cacheCoverageType = KanbanFindRulesCacheCoverageType::Product;

        //product specific
        while select forceplaceholders kanbanRule
            order by ReplenishmentStrategy desc
            where   kanbanRule.LegalEntity           == legalEntity
                && (kanbanRule.RecId                 == kanbanRuleRecId
                ||  !kanbanRuleRecId)
                && kanbanRule.RecId                  != excludeKanbanRuleRecId
                && (kanbanRule.KanbanType            != LeanKanbanType::Manufacturing
                ||  includeManufacturing)
                && (kanbanRule.KanbanType            != LeanKanbanType::Withdrawal
                ||  includeWithdrawal)
                && (kanbanRule.ReplenishmentStrategy == replenishmentStrategy
                ||  !replenishmentStrategy)
            join TableId from leanCoverage
                where  leanCoverage.ItemId           == itemId
                    && leanCoverage.RuleCoverageType == leanRuleCoverageType
            #inventDimJoinCoveragePriority(leanCoverage.InventDimId,inventDimSearch,inventDim,InventDimParm)
            join ValidFrom, ValidTo from leanCoverageKanbanRule
                order by ValidFrom asc
                where leanCoverageKanbanRule.Coverage    == leanCoverage.RecId
                   && leanCoverageKanbanRule.KanbanRule  == kanbanRule.RecId
                   && ((leanCoverageKanbanRule.ValidFrom <= dateTimeTo
                   &&   (leanCoverageKanbanRule.ValidTo  >= dateTimeFrom
                   ||    !leanCoverageKanbanRule.ValidTo))
                   ||  ((!dateTimeTo
                   ||    _fetchAhead)
                   &&   leanCoverageKanbanRule.ValidTo   >= dateTimeFrom))
        {
            result = this.add(kanbanRule, leanCoverageKanbanRule.ValidFrom, leanCoverageKanbanRule.ValidTo, cacheCoverageType) || result;
            if (   result
                && !this.mustContinueSearch())
            {
                break;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>first</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the first <c>KanbanRule</c> record in the result list.
    /// </summary>
    /// <returns>
    /// The first <c>KanbanRule</c> record in the result list.
    /// </returns>
    /// <remarks>
    /// Calls the <c>findKanbanRules</c> method to build the result list.
    /// </remarks>
    public KanbanRule first()
    {
        KanbanRule  kanbanRule;

        if (!listResult)
        {
            this.findKanbanRules();
        }

        if (listResult.elements())
        {
            listEnumerator = listResult.getEnumerator();
            listEnumerator.moveNext();
            kanbanRule = listEnumerator.current();
        }

        return kanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>foundRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of records in the result list.
    /// </summary>
    /// <returns>
    ///    The number of records in the result list.
    /// </returns>
    public int foundRules()
    {
        return listResult ? listResult.elements() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the class variables for the find operation.
    /// </summary>
    private void init()
    {
        mapResult             = new Map(Types::Container,Types::Class);
        mapKanbanRuleCoverage = new Map(Types::Int64,Types::Container);
        setResult             = new Set(typeName2Type(extendedTypeStr(RecId)));
        inventDim             = this.inventDim();
        inventDimGroupSetup   = this.inventDimGroupSetup();
        inventDimParm         = this.inventDimParm();
        legalEntity           = CompanyInfo::current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCacheAndResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the cache and result objects.
    /// </summary>
    private void initCacheAndResult()
    {
        foundResults          = 0;
        listResult           = new List(Types::Record);
        kanbanFindRulesCache = KanbanFindRulesCache::newStandard(classIdGet(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>InventDim</c> record that is used in the find operation.
    /// </summary>
    /// <returns>
    ///    A record in the <c>InventDim</c> table.
    /// </returns>
    private InventDim inventDim()
    {
        if (!inventDim)
        {
            inventDim = InventDim::find(inventDimId);
        }
        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or retrieves an <c>InventDimGroupSetup</c> object.
    /// </summary>
    /// <returns>
    ///    The <c>InventDimGroupSetup</c> object.
    /// </returns>
    private InventDimGroupSetup inventDimGroupSetup()
    {
        if (!inventDimGroupSetup)
        {
            inventDimGroupSetup = InventDimGroupSetup::newItemId(itemId);
        }
        return inventDimGroupSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or retrieves a <c>InventDimParm</c> table buffer.
    /// </summary>
    /// <returns>
    ///    The <c>InventDimParm</c> table buffer.
    /// </returns>
    private InventDimParm inventDimParm()
    {
        InventDimParm   inventDimParmCovPr;

        if (!inventDimParmInitialized)
        {
            inventDimParmCovPr.initCovPrDimension(this.inventDimGroupSetup());
            inventDimParm            = InventDimParm::andParms(inventDimParm,inventDimParmCovPr);
            inventDimParmInitialized = true;
        }
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a container that can be used as a key for the <c>Map</c> of results.
    /// </summary>
    /// <param name="_kanbanRule">
    ///    A <c>KanbanRule</c> record.
    /// </param>
    /// <param name="_kanbanRuleEvent">
    ///    A <c>KanbanRuleEvent</c> record.
    /// </param>
    /// <param name="_leanRuleCoverageType">
    ///    A <c>LeanRuleCoverageType</c> enumeration value.
    /// </param>
    /// <returns>
    ///    A <c>container</c> that can be used as a key for the <c>Map</c> of results.
    /// </returns>
    private container mapKey(
        KanbanRule              _kanbanRule,
        KanbanRuleEvent         _kanbanRuleEvent,
        KanbanFindRulesCacheCoverageType    _leanRuleCoverageType)
    {
        return [-enum2int(_kanbanRule.ReplenishmentStrategy),
                -_kanbanRuleEvent.MinimumEventQuantity,
                _leanRuleCoverageType];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAdd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a specified <c>KanbanRule</c> record must be added to the result list.
    /// </summary>
    /// <param name="_kanbanRule">
    ///    The <c>KanbanRule</c> record to test.
    /// </param>
    /// <returns>
    ///    true if the record must be added; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The method returns false if the kanban rule is not related to the production flow reference.
    /// </remarks>
    protected boolean mustAdd(KanbanRule _kanbanRule)
    {
        boolean                     result = _kanbanRule.RecId != 0;
        KanbanFlow                  kanbanFlow;
        LeanProductionFlowActivity  lastLeanProductionFlowActivity;
        PlanActivity                lastPlanActivity;
        PlanActivity                firstPlanActivity;

        if (   result
            && leanProdFlowReferenceRecId)
        {
            result = leanProdFlowReferenceRecId == _kanbanRule.leanProductionFlowReference().RecId;
        }

        if (   result
            && lastPlanActivityRecId)
        {
            kanbanFlow       = _kanbanRule.kanbanFlow();
            lastPlanActivity = kanbanFlow.lastPlanActivity();
            result           = lastPlanActivity.RecId == lastPlanActivityRecId;
        }

        if (   result
            && lastPlanActivityDownStreamRecId)
        {
            kanbanFlow       = kanbanFlow ? kanbanFlow : _kanbanRule.kanbanFlow();
            lastPlanActivity = lastPlanActivity ? lastPlanActivity : kanbanFlow.lastPlanActivity();
            result           = PlanActivityRelationship::findPlanActivity(lastPlanActivity.RecId,lastPlanActivityDownStreamRecId).RecId != 0;
        }

        if (   result
            && firstPlanActivityUpStreamRecId)
        {
            kanbanFlow        = kanbanFlow ? kanbanFlow : _kanbanRule.kanbanFlow();
            firstPlanActivity = firstPlanActivity ? firstPlanActivity : kanbanFlow.firstPlanActivity();
            result            = PlanActivityRelationship::findPlanActivity(firstPlanActivityUpStreamRecId,firstPlanActivity.RecId).RecId != 0;
        }

        if (result)
        {
            kanbanFlow = kanbanFlow ? kanbanFlow : _kanbanRule.kanbanFlow();
            LeanProductionFlowActivity firstLeanProductionFlowActivity = kanbanFlow.firstLeanProductionFlowActivity();
            result = (firstLeanProductionFlowActivity.PickUpSemiFinished
                                                                         &&  includePickupSemiFinished)
                                                                         || (!firstLeanProductionFlowActivity.PickUpSemiFinished
                                                                         &&  includePickupFinished);
        }

        if (result)
        {
            kanbanFlow                     = kanbanFlow ? kanbanFlow : _kanbanRule.kanbanFlow();
            lastLeanProductionFlowActivity = kanbanFlow.lastLeanProductionFlowActivity();
            result                         =    (lastLeanProductionFlowActivity.ReceiveSemiFinished
                                             &&  includeReceiveSemiFinished)
                                             || (!lastLeanProductionFlowActivity.ReceiveSemiFinished
                                             &&  includeReceiveFinished);
        }

        if (result)
        {
            kanbanFlow                     = kanbanFlow ? kanbanFlow : _kanbanRule.kanbanFlow();
            lastLeanProductionFlowActivity = lastLeanProductionFlowActivity
                                                ? lastLeanProductionFlowActivity
                                                : kanbanFlow.lastLeanProductionFlowActivity();
            boolean onHandUpdateReceipt = lastLeanProductionFlowActivity.onHandUpdateReceive();
            result = (includeOnHandUpdateReceipt
                                           &&  onHandUpdateReceipt)
                                           || (includeNotOnHandUpdateReceipt
                                           &&  !onHandUpdateReceipt);
        }

        if (result)
        {
            if (   minimumInventQty
                && _kanbanRule.ReplenishmentStrategy == LeanReplenishmentStrategy::Event)
            {
                KanbanRuleEvent kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(_kanbanRule.RecId);
                result = kanbanRuleEvent
                                                  && kanbanRuleEvent.MinimumEventQuantity <= minimumInventQty;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustContinueSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the find operation must be continued.
    /// </summary>
    /// <returns>
    /// true if the operation must continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The operation must continue, if no rules have been found yet, all applicable rules should be
    /// retrieved or the find operation is not restricted to event rules only. When all replenishment
    /// strategies are considered or the replenishment strategy is event, the operation must complete all
    /// the steps, because results must be prioritized after the search.
    /// </remarks>
    private boolean mustContinueSearch()
    {
        return    !foundResults
               || !firstRuleOnly
               || !replenishmentStrategy
               || replenishmentStrategy == LeanReplenishmentStrategy::Event;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustScanAllCoverageTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if all rule types need to be scanned in order to find a rule.
    /// </summary>
    /// <returns>
    ///     true if all rule types should be scanned, otherwise false.
    /// </returns>
    private boolean mustScanAllCoverageTypes()
    {
        return   !replenishmentStrategy
               || replenishmentStrategy == LeanReplenishmentStrategy::Event;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
        protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>next</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the next <c>KanbanRule</c> record in the result list.
    /// </summary>
    /// <returns>
    ///    The next <c>KanbanRule</c> record in the result list.
    /// </returns>
    /// <remarks>
    ///    Calls the <c>findKanbanRules</c> method to build the result list.
    /// </remarks>
    public KanbanRule next()
    {
        KanbanRule  kanbanRule;

        if (!listEnumerator)
        {
            kanbanRule = this.first();
        }
        else
        {
            if (listEnumerator.moveNext())
            {
                kanbanRule = listEnumerator.current();
            }
        }

        return kanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTimeFrom</Name>
				<Source><![CDATA[
        public TransDateTime parmDateTimeFrom(TransDateTime _dateTimeFrom = dateTimeFrom)
    {
        dateTimeFrom = _dateTimeFrom;
        return dateTimeFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTimeTo</Name>
				<Source><![CDATA[
        public TransDateTime parmDateTimeTo(TransDateTime _dateTimeTo = dateTimeTo)
    {
        dateTimeTo = _dateTimeTo;
        return dateTimeTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeKanbanRuleRecId</Name>
				<Source><![CDATA[
        public RefRecId parmExcludeKanbanRuleRecId(KanbanRuleRefRecId _excludeKanbanRuleRecId = excludeKanbanRuleRecId)
    {
        excludeKanbanRuleRecId = _excludeKanbanRuleRecId;
        return excludeKanbanRuleRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFirstPlanActivityUpstreamRecId</Name>
				<Source><![CDATA[
        public PlanActivityRefRecId parmFirstPlanActivityUpstreamRecId(RefRecId _firstPlanActivityUpstreamRecId = firstPlanActivityUpStreamRecId)
    {
        firstPlanActivityUpStreamRecId = _firstPlanActivityUpstreamRecId;
        return firstPlanActivityUpStreamRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFirstRuleOnly</Name>
				<Source><![CDATA[
        public boolean parmFirstRuleOnly(boolean _firstRuleOnly = firstRuleOnly)
    {
        firstRuleOnly = _firstRuleOnly;
        return firstRuleOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeManufacturing</Name>
				<Source><![CDATA[
        public boolean parmIncludeManufacturing(boolean _includeManufacturing = includeManufacturing)
    {
        includeManufacturing = _includeManufacturing;
        return includeManufacturing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeNotOnHandUpdateReceipt</Name>
				<Source><![CDATA[
        public boolean parmIncludeNotOnHandUpdateReceipt(boolean _includeNotOnHandUpdateReceipt = includeNotOnHandUpdateReceipt)
    {
        includeNotOnHandUpdateReceipt = _includeNotOnHandUpdateReceipt;
        return includeNotOnHandUpdateReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeOnHandUpdateReceipt</Name>
				<Source><![CDATA[
        public boolean parmIncludeOnHandUpdateReceipt(boolean _includeOnHandUpdateReceipt = includeOnHandUpdateReceipt)
    {
        includeOnHandUpdateReceipt = _includeOnHandUpdateReceipt;
        return includeOnHandUpdateReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludePickupFinished</Name>
				<Source><![CDATA[
        public boolean parmIncludePickupFinished(boolean _includePickupFinished = includePickupFinished)
    {
        includePickupFinished = _includePickupFinished;
        return includePickupFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludePickupSemiFinished</Name>
				<Source><![CDATA[
        public boolean parmIncludePickupSemiFinished(boolean _includePickupSemiFinished = includePickupSemiFinished)
    {
        includePickupSemiFinished = _includePickupSemiFinished;
        return includePickupSemiFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeReceiveFinished</Name>
				<Source><![CDATA[
        public boolean parmIncludeReceiveFinished(boolean _includeReceiveFinished = includeReceiveFinished)
    {
        includeReceiveFinished = _includeReceiveFinished;
        return includeReceiveFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeReceiveSemiFinished</Name>
				<Source><![CDATA[
        public boolean parmIncludeReceiveSemiFinished(boolean _includeReceiveSemiFinished = includeReceiveSemiFinished)
    {
        includeReceiveSemiFinished = _includeReceiveSemiFinished;
        return includeReceiveSemiFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeWithdrawal</Name>
				<Source><![CDATA[
        public boolean parmIncludeWithdrawal(boolean _includeWithdrawal = includeWithdrawal)
    {
        includeWithdrawal = _includeWithdrawal;
        return includeWithdrawal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
        public InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;
        inventDim.clear();
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
        public InventDimParm parmInventDimParm(InventDimParm _inventDimParm = inventDimParm)
    {
        inventDimParm = _inventDimParm;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
        public ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKanbanRuleRecId</Name>
				<Source><![CDATA[
        public RefRecId parmKanbanRuleRecId(RefRecId _kanbanRuleRecId = kanbanRuleRecId)
    {
        kanbanRuleRecId = _kanbanRuleRecId;
        return kanbanRuleRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastPlanActivityDownstreamRecId</Name>
				<Source><![CDATA[
        public PlanActivityRefRecId parmLastPlanActivityDownstreamRecId(RefRecId _lastPlanActivityDownstreamRecId = lastPlanActivityDownStreamRecId)
    {
        lastPlanActivityDownStreamRecId = _lastPlanActivityDownstreamRecId;
        return lastPlanActivityDownStreamRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastPlanActivityRecId</Name>
				<Source><![CDATA[
        public RefRecId parmLastPlanActivityRecId(RefRecId _lastPlanActivityRecId = lastPlanActivityRecId)
    {
        lastPlanActivityRecId = _lastPlanActivityRecId;
        return lastPlanActivityRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanProdFlowReferenceRecId</Name>
				<Source><![CDATA[
        public RefRecId parmLeanProdFlowReferenceRecId(RefRecId _leanProdFlowReferenceRecId = leanProdFlowReferenceRecId)
    {
        leanProdFlowReferenceRecId = _leanProdFlowReferenceRecId;
        return leanProdFlowReferenceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMinimumInventQty</Name>
				<Source><![CDATA[
        public InventQty parmMinimumInventQty(InventQty _minimumInventQty = minimumInventQty)
    {
        minimumInventQty = _minimumInventQty;
        return minimumInventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenishmentStrategy</Name>
				<Source><![CDATA[
        public LeanReplenishmentStrategy parmReplenishmentStrategy(LeanReplenishmentStrategy _replenishmentStrategy = replenishmentStrategy)
    {
        replenishmentStrategy = _replenishmentStrategy;
        return replenishmentStrategy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipRuleMayExistCheck</Name>
				<Source><![CDATA[
        public boolean parmSkipRuleMayExistCheck(boolean _skipRuleMayExistCheck = skipRuleMayExistCheck)
    {
        skipRuleMayExistCheck = _skipRuleMayExistCheck;
        return skipRuleMayExistCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ruleSearchId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a rule search identifier based on the current rule search criteria.
    /// </summary>
    /// <returns>
    ///    A container that contains the identifier.
    /// </returns>
    protected container ruleSearchId()
    {
        return [itemId,
                inventDimId,
                leanProdFlowReferenceRecId,
                kanbanRuleRecId,
                excludeKanbanRuleRecId,
                lastPlanActivityRecId,
                lastPlanActivityDownStreamRecId,
                firstPlanActivityUpStreamRecId,
                replenishmentStrategy,
                minimumInventQty,
                enum2int(includeManufacturing),
                enum2int(includeWithdrawal),
                enum2int(replenishmentStrategy),
                enum2int(includePickupSemiFinished),
                enum2int(includeReceiveSemiFinished),
                enum2int(includePickupFinished),
                enum2int(includeReceiveFinished),
                enum2int(includeOnHandUpdateReceipt),
                enum2int(includeNotOnHandUpdateReceipt)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReplenishmentStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any rule exists for a given replenishment strategy.
    /// </summary>
    /// <param name="_replenishmentStrategy">
    /// The replenishment strategy to check.
    /// </param>
    /// <param name="_kanbanFindRulesCache">
    /// A <c>KanbanFindRulesCache</c> object; optional.
    /// </param>
    /// <returns>
    /// true if an applicable rule may exist; otherwise, false.
    /// </returns>
    private static boolean checkReplenishmentStrategy(
        LeanReplenishmentStrategy _replenishmentStrategy,
        KanbanFindRulesCache      _kanbanFindRulesCache = null)
    {
        KanbanRule              kanbanRule;
        KanbanFindRulesCache    kanbanFindRulesCache = _kanbanFindRulesCache ? _kanbanFindRulesCache : KanbanFindRulesCache::newStandard(classNum(KanbanFindRules));
        boolean                 result;

        container replenishmentStrategySearchId = KanbanFindRulesCache::buildReplenishmentStrategyRuleSearchId(_replenishmentStrategy);
        container containerReplenishmentStrategyCheck = kanbanFindRulesCache.getReplenishmentStrategyCheck(replenishmentStrategySearchId);

        if (containerReplenishmentStrategyCheck != conNull())
        {
            [result] = containerReplenishmentStrategyCheck;
        }
        else
        {
            // check if any rule exists for the requested replenishment strategy
            select firstonly RecId from kanbanRule
                where kanbanRule.ReplenishmentStrategy == _replenishmentStrategy;

            result = kanbanRule.RecId != 0;

            kanbanFindRulesCache.insertReplenishmentStrategyCheck(replenishmentStrategySearchId,result);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>KanbanFindRules</c> class.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>KanbanFindRules</c> class.
    /// </returns>
    /// <remarks>
    ///  Use the following procedure to customize or extend the
    ///  <c>
    ///   KanbanFindRules
    ///  </c>
    ///   class.
    ///  <list type="number">
    ///   <item>
    ///    <description>
    ///    Create a new class that derives from <c>KanbanFindRules</c> .
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Overlayer the <c>construct</c> method on <c>KanbanFindRules</c> so that it returns an instance of
    ///    the derived class.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Override the methods from the <c>KanbanFindRules</c> class that you want to customize or extend in
    ///    your derived class.
    ///    </description>
    ///   </item>
    ///  </list>
    ///
    ///  This procedure helps make sure that your customizations are maintained if the base version of the
    ///  <c>
    ///   KanbanFindRules
    ///  </c>
    ///   class is changed, minimizing code conflicts during an upgrade. For more information, see <see cref="Best Practices for Static Construct Methods" />
    /// </remarks>
    private static KanbanFindRules construct()
    {
        return new KanbanFindRules();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultInventDimParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default <c>InventDimParm</c> table buffer settings.
    /// </summary>
    /// <returns>
    /// A <c>InventDimParm</c> table buffer.
    /// </returns>
    /// <remarks>
    /// By default, all dimensions are enabled and used in the search for rules.To disable specific
    /// inventory dimensions from the search criteria, set their corresponding flag in this buffer to the
    /// <c>NoYes::No</c> enumeration value.
    /// </remarks>
    public static InventDimParm defaultInventDimParm()
    {
        InventDimParm   inventDimParmLocal;

        inventDimParmLocal.setAllInventDim();

        return inventDimParmLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCoverageValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a coverage date time range is valid.
    /// </summary>
    /// <param name="_coverageValidFrom">
    ///    The coverage valid from date time.
    /// </param>
    /// <param name="_coverageValidTo">
    ///    The coverage valid to date time.
    /// </param>
    /// <param name="_dateTimeFrom">
    ///    The searching from date time.
    /// </param>
    /// <param name="_dateTimeTo">
    ///    The searching to date time.
    /// </param>
    /// <returns>
    ///    true if the coverage is valid; otherwise false.
    /// </returns>
    public static boolean isCoverageValid(
        LeanRuleActiveDateTime  _coverageValidFrom,
        LeanRuleActiveDateTime  _coverageValidTo,
        LeanRuleActiveDateTime  _dateTimeFrom,
        LeanRuleActiveDateTime  _dateTimeTo)
    {
        return ((_coverageValidFrom <= _dateTimeTo
             && (_coverageValidTo   >= _dateTimeFrom
             || !_coverageValidTo))
             ||  (!_dateTimeTo
             && _coverageValidTo    >= _dateTimeFrom));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromLeanProductionFlowReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>KanbanFindRules</c> instance with the provided attributes.
    /// </summary>
    /// <param name="_leanProdFlowReferenceRecId">
    ///    The record ID of a <c>LeanProductionFlowReference</c> record that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_itemId">
    ///    The <c>ItemId</c> value the <c>findKanbanRules</c> operation is limited to.
    /// </param>
    /// <param name="_dateTimeFrom">
    ///    A <c>TransDateTime</c> temporal value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_dateTimeTo">
    ///    A <c>TransDateTime</c> temporal value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_inventDimId">
    ///    An <c>InventDimId</c> value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_inventDimParm">
    ///    An <c>InventDimParm</c> table buffer that defines which inventory dimensions should be used in the search.
    /// </param>
    /// <param name="_firstRuleOnly">
    ///    A Boolean value that determines if the search should be stopped when the first rule is found.
    /// </param>
    /// <param name="_includeManufacturing">
    ///    A Boolean value that limits the <c>findKanbanRules</c> to manufacturing rules.
    /// </param>
    /// <param name="_includeWithdrawal">
    ///    A Boolean value that limits the <c>findKanbanRules</c> to withrawal rules.
    /// </param>
    /// <param name="_minimumInventQty">
    ///    The minimum inventory quantity that the rule is applicable for; applies to event rules.
    /// </param>
    /// <returns>
    /// A <c>KanbanFindRules</c> class instance.
    /// </returns>
    public static KanbanFindRules newFromLeanProductionFlowReference(
        RefRecId      _leanProdFlowReferenceRecId,
        ItemId        _itemId,
        TransDateTime _dateTimeFrom,
        TransDateTime _dateTimeTo           = _dateTimeFrom,
        InventDimId   _inventDimId          = '',
        InventDimParm _inventDimParm        = KanbanFindRules::defaultInventDimParm(),
        boolean       _firstRuleOnly        = false,
        boolean       _includeManufacturing = true,
        boolean       _includeWithdrawal    = true,
        InventQty     _minimumInventQty     = 0)
    {
        KanbanFindRules kanbanFindRules = KanbanFindRules::newStandard(_itemId,_dateTimeFrom,_dateTimeTo,_inventDimId,
                                                                       _inventDimParm,_firstRuleOnly,_includeManufacturing,
                                                                       _includeWithdrawal,_minimumInventQty);
        kanbanFindRules.parmLeanProdFlowReferenceRecId(_leanProdFlowReferenceRecId);
        return kanbanFindRules;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>KanbanFindRules</c> instance with the provided attributes.
    /// </summary>
    /// <param name="_itemId">
    ///    The <c>ItemId</c> value the <c>findKanbanRules</c> operation is limited to.
    /// </param>
    /// <param name="_dateTimeFrom">
    ///    A <c>TransDateTime</c> temporal value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_dateTimeTo">
    ///    A <c>TransDateTime</c> temporal value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_inventDimId">
    ///    An <c>InventDimId</c> value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_inventDimParm">
    ///    An <c>InventDimParm</c> table buffer that defines which inventory dimensions should be used in the search.
    /// </param>
    /// <param name="_firstRuleOnly">
    ///    A Boolean value that determines if the search should be stopped when the first rule is found.
    /// </param>
    /// <param name="_includeManufacturing">
    ///    A Boolean value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_includeWithdrawal">
    ///    A Boolean value that limits the <c>findKanbanRules</c> operation.
    /// </param>
    /// <param name="_minimumInventQty">
    ///    The minimum inventory quantity that the rule is applicable for; applies to event rules.
    /// </param>
    /// <returns>
    ///    A <c>KanbanFindRules</c> class instance.
    /// </returns>
    public static KanbanFindRules newStandard(
        ItemId        _itemId,
        TransDateTime _dateTimeFrom,
        TransDateTime _dateTimeTo           = _dateTimeFrom,
        InventDimId   _inventDimId          = '',
        InventDimParm _inventDimParm        = KanbanFindRules::defaultInventDimParm(),
        boolean       _firstRuleOnly        = false,
        boolean       _includeManufacturing = true,
        boolean       _includeWithdrawal    = true,
        InventQty     _minimumInventQty     = 0)
    {
        KanbanFindRules kanbanFindRules = KanbanFindRules::construct();

        kanbanFindRules.parmItemId(_itemId);
        kanbanFindRules.parmInventDimId(_inventDimId);
        kanbanFindRules.parmInventDimParm(_inventDimParm);
        kanbanFindRules.parmDateTimeFrom(_dateTimeFrom);
        kanbanFindRules.parmDateTimeTo(_dateTimeTo);
        kanbanFindRules.parmFirstRuleOnly(_firstRuleOnly);
        kanbanFindRules.parmIncludeManufacturing(_includeManufacturing);
        kanbanFindRules.parmIncludeWithdrawal(_includeWithdrawal);
        kanbanFindRules.parmMinimumInventQty(_minimumInventQty);
        kanbanFindRules.parmIncludePickupSemiFinished(true);
        kanbanFindRules.parmIncludePickupFinished(true);
        kanbanFindRules.parmIncludeReceiveSemiFinished(true);
        kanbanFindRules.parmIncludeReceiveFinished(true);
        kanbanFindRules.parmIncludeOnHandUpdateReceipt(true);
        kanbanFindRules.parmIncludeNotOnHandUpdateReceipt(true);

        return kanbanFindRules;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ruleMayExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any applicable rule may exist.
    /// </summary>
    /// <param name="_itemId">
    /// The item in which to check.
    /// </param>
    /// <param name="_replenishmentStrategy">
    /// The replenishment type to check; optional.
    /// </param>
    /// <param name="_kanbanFindRulesCache">
    /// A <c>KanbanFindRulesCache</c> object; optional.
    /// </param>
    /// <returns>
    /// true if an applicable rule may exist; otherwise, false.
    /// </returns>
    public static boolean ruleMayExist(
        ItemId                      _itemId,
        LeanReplenishmentStrategy   _replenishmentStrategy = 0,
        KanbanFindRulesCache        _kanbanFindRulesCache  = null)
    {
        LeanCoverage                leanCoverage;
        ForecastItemAllocationLine  forecastItemAllocationLine;
        KanbanFindRulesCache        kanbanFindRulesCache = _kanbanFindRulesCache ? _kanbanFindRulesCache : KanbanFindRulesCache::newStandard(classNum(KanbanFindRules));

        // check configuration key
        boolean result = isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing));

        if (result)
        {
            if (_replenishmentStrategy)
            {
                // check if any rule exists for the replenishment strategy
                result = KanbanFindRules::checkReplenishmentStrategy(_replenishmentStrategy,kanbanFindRulesCache);
            }

            if (result)
            {
                container containerItemLeanCoverageCheck = kanbanFindRulesCache.getItemLeanCoverageCheck(_itemId);

                if (containerItemLeanCoverageCheck != conNull())
                {
                    [result] = containerItemLeanCoverageCheck;
                }
                else
                {
                    // check if any rules exist for the item or if at least one rule exists for 'all' items
                    select firstonly RecId from leanCoverage
                        where leanCoverage.ItemId           == _itemId
                           || leanCoverage.RuleCoverageType == LeanRuleCoverageType::All;

                    result = leanCoverage.RecId != 0;

                    if (!result)
                    {
                        // check if the item is part of any forecast allocation group
                        select firstonly RecId from forecastItemAllocationLine
                            where forecastItemAllocationLine.ItemId == _itemId;

                        result = forecastItemAllocationLine.RecId != 0;
                    }

                    kanbanFindRulesCache.insertItemLeanCoverageCheck(_itemId,result);
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanLocationCache</Name>
				<Source><![CDATA[
    public LeanLocationCache parmLeanLocationCache(LeanLocationCache _leanLocationCache = leanLocationCache)
    {
        leanLocationCache = _leanLocationCache;

        return leanLocationCache;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
