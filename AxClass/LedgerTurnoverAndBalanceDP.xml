<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTurnoverAndBalanceDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerTurnoverAndBalanceDP</c> class is the data provider for the
/// <c>LedgerTurnoverAndBalance</c> report.
/// </summary>
[SRSReportQuery(queryStr(LedgerTurnoverAndBalance))]
[SRSReportParameterAttribute(classStr(LedgerTurnoverAndBalanceContract))]
public class LedgerTurnoverAndBalanceDP extends SrsReportDataProviderPreProcessTempDB
{
    LedgerTurnoverAndBalanceTmp             ledgerTurnoverAndBalanceTmp;
    LedgerTurnoverAndBalanceTmpProcessing   ledgerTurnoverAndBalanceTmpProcessing;
    LedgerTurnoverTmpDimensionCriteria      ledgerTurnoverTmpDimensionCriteria;
    AmountMST                               runningTotalOpeningBalanceDebit;
    AmountMST                               runningTotalOpeningBalanceCredit;
    AmountMST                               runningTurnoverInPeriodDebit;
    AmountMST                               runningTurnoverInPeriodCredit;
    AmountMST                               runningClosingBalanceDebit;
    AmountMST                               runningClosingBalanceCredit;
    AmountMST                               runningTurnoverInPeriodInclOpenBalDebit;
    AmountMST                               runningTurnoverInPeriodInclOpenBalCredit;
    TransDate                               fiscalYearStartDate;
    TransDate                               dateFrom, dateTo;
    CurrentOperationsTax                    postingLayer; 
    protected List                          postingLayers;
    LedgerTurnoverAndBalanceContract        contract;
    Map                                     mainAccountsMap;
    Set                                     mainAccountSet;
    private boolean                         printSeparateBalance;
    private boolean                         printClosingTransaction;
    private LedgerRecId                     ledgerRecIdCurrent;
    private container                       postingLayersCont;
    private int                             queryTimeout;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildCustBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the balances for all customer transactions that are posted by using a posting profile.
    /// </summary>
    /// <remarks>
    /// The posting profile is defined by using a summary account designated as a separate balance.
    /// </remarks>
    private void buildCustBalances()
    {
        Query                           query;
        QueryRun                        queryRun;
        QueryBuildDataSource            queryBuildDataSourceTrans;
        CustTrans                       custTrans;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        AmountMST                       balance;
        AmountMST                       debitBalance;
        AmountMST                       creditBalance;
        MainAccountRecId                defaultMainAccountRecId;

        query = new Query();
        queryBuildDataSourceTrans = query.addDataSource(tableNum(CustTrans));
        findOrCreateRange_W(queryBuildDataSourceTrans, fieldNum(CustTrans, TransDate), SysQuery::range(null, dateTo));

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            custTrans = queryRun.get(tableNum(CustTrans));

            custTrans.transactionPerDate(dateTo);

            if (custTrans.TransType == LedgerTransType::ExchAdjustment)
            {
                balance = custTrans.AmountMST - custTrans.SettleAmountMST;
            }
            else
            {
                balance = custTrans.AmountMST - custTrans.SettleAmountMST  + custTrans.ExchAdjustment;
            }

            if (balance != 0.00)
            {
                defaultLedgerDimension  = CustLedgerAccounts::summaryLedgerDimension(custTrans.AccountNum, custTrans.PostingProfile);

                defaultMainAccountRecId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(defaultLedgerDimension);

                if ((custTrans.AmountMST > 0 && custTrans.Correct == NoYes::No)
                    ||(custTrans.AmountMST < 0 && custTrans.Correct == NoYes::Yes))
                {
                    debitBalance = balance;
                    creditBalance = 0.00;
                }
                else
                {
                    debitBalance = 0.00;
                    creditBalance = balance;
                }

                update_recordset ledgerTurnoverAndBalanceTmpProcessing
                    setting CustTransAmountCredit = ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountCredit - creditBalance,
                            CustTransAmountDebit = ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountDebit + debitBalance
                    where ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId == defaultMainAccountRecId &&
                        ledgerTurnoverAndBalanceTmpProcessing.IsSeparateBalanceMainAccount == true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVendBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the balances for all vendor transactions posted by using a posting profile.
    /// </summary>
    /// <remarks>
    /// The posting profile is defined by using a summary account designated as a separate balance.
    /// </remarks>
    private void buildVendBalances()
    {
        Query                           query;
        QueryRun                        queryRun;
        QueryBuildDataSource            queryBuildDataSourceTrans;
        VendTrans                       vendTrans;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        AmountMST                       balance;
        AmountMST                       debitBalance;
        AmountMST                       creditBalance;
        MainAccountRecId                defaultMainAccountRecId;

        query = new Query();
        queryBuildDataSourceTrans = query.addDataSource(tableNum(VendTrans));
        findOrCreateRange_W(queryBuildDataSourceTrans, fieldNum(VendTrans, TransDate), SysQuery::range(null, dateTo));

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            vendTrans = queryRun.get(tableNum(VendTrans));

            vendTrans.transactionPerDate(dateTo);

            if (vendTrans.TransType == LedgerTransType::ExchAdjustment)
            {
                balance = vendTrans.AmountMST - vendTrans.SettleAmountMST;
            }
            else
            {
                balance = vendTrans.AmountMST - vendTrans.SettleAmountMST  + vendTrans.ExchAdjustment;
            }

            if (balance != 0.00)
            {
                defaultLedgerDimension  = VendLedgerAccounts::summaryLedgerDimension(vendTrans.AccountNum, vendTrans.PostingProfile);

                defaultMainAccountRecId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(defaultLedgerDimension);

                if ((vendTrans.AmountMST > 0 && vendTrans.Correct == NoYes::No)
                    ||(vendTrans.AmountMST < 0 && vendTrans.Correct == NoYes::Yes))
                {
                    debitBalance = balance;
                    creditBalance = 0.00;
                }
                else
                {
                    creditBalance = balance;
                    debitBalance = 0.00;
                }

                update_recordset ledgerTurnoverAndBalanceTmpProcessing
                    setting VendTransAmountCredit = ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountCredit - creditBalance,
                            VendTransAmountDebit = ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountDebit + debitBalance
                    where ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId == defaultMainAccountRecId &&
                        ledgerTurnoverAndBalanceTmpProcessing.IsSeparateBalanceMainAccount == true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceByType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a specified <c>LedgerTurnoverTmpBalanceValue</c> table with the balance for a specified
    /// period type and date range.
    /// </summary>
    /// <param name="_tmpBalanceValue">
    /// The <c>LedgerTurnoverTmpBalanceValue</c> table to populate.
    /// </param>
    /// <param name="_dateFrom">
    /// The from date to select the balance.
    /// </param>
    /// <param name="_dateTo">
    /// The to date to select the balance.
    /// </param>
    /// <param name="_periodType">
    /// The type of fiscal period for which to select the balance.
    /// </param>
    /// <param name="_isCredit">
    /// A Boolean value that indicates whether the debit or credit balance is to be selected.
    /// </param>
    private void getBalanceByType(LedgerTurnoverTmpBalanceValue _tmpBalanceValue,
                            TransDate _dateFrom,
                            TransDate _dateTo,
                            container _periodTypeSet)
    {
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        GeneralJournalEntry                     generalJournalEntry;
        DimensionAttributeValueCombination      davc;
        DimensionAttributeLevelValueView        dimensionAttributeLevelValueView, dimAttributeLevelValueViewToJoin;
        FiscalCalendarPeriod                    fiscalCalendarPeriod;
        LedgerTurnoverTmpDimensionCriteria      tmpDimensionCriteriaNoCriteriaEntered;

        tmpDimensionCriteriaNoCriteriaEntered.linkPhysicalTableInstance(ledgerTurnoverTmpDimensionCriteria);

        if (queryTimeout > 0)
        {
            _tmpBalanceValue.queryTimeout(queryTimeout, true);
        }

        insert_recordset _tmpBalanceValue
            (MainAccountRecId, Balance, NumberOfGJAccountEntries, IsCredit, Type)
            select MainAccountRecId
            from ledgerTurnoverAndBalanceTmpProcessing
            group by ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId,
                generalJournalAccountEntry.IsCredit,
                fiscalCalendarPeriod.Type

            // Do the summation for all rows as a single query for the third field
            join sum(AccountingCurrencyAmount), count(RecId), IsCredit from generalJournalAccountEntry

            // Filter by fiscal calendar period
            join Type from fiscalCalendarPeriod
            where
                fiscalCalendarPeriod.Type in _periodTypeSet

            // Filter by main account
            exists join davc
            where
                davc.MainAccount == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId &&
                davc.RecId == generalJournalAccountEntry.LedgerDimension

            // Filter by date and posting layer
            exists join generalJournalEntry
            where
                generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                generalJournalEntry.AccountingDate >= _dateFrom &&
                generalJournalEntry.AccountingDate <= _dateTo &&
                generalJournalEntry.Ledger == ledgerRecIdCurrent &&
                generalJournalEntry.PostingLayer in postingLayersCont &&
                generalJournalEntry.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId

            // Filter by dimension criteria
            notexists join dimensionAttributeLevelValueView
                where dimensionAttributeLevelValueView.ValueCombinationRecId == generalJournalAccountEntry.LedgerDimension
            notexists join ledgerTurnoverTmpDimensionCriteria
                where
                    (ledgerTurnoverTmpDimensionCriteria.DimensionAttributeRecId == dimensionAttributeLevelValueView.DimensionAttribute &&
                    ledgerTurnoverTmpDimensionCriteria.DimensionAttributeValueRecId == dimensionAttributeLevelValueView.AttributeValueRecId)
                    ||
                    (ledgerTurnoverTmpDimensionCriteria.DimensionAttributeRecId == dimensionAttributeLevelValueView.DimensionAttribute &&
                    ledgerTurnoverTmpDimensionCriteria.IsOpenCriteria == NoYes::Yes)

            // Make sure all values with criteria have a value specified (arenâ€™t empty)
            notexists join tmpDimensionCriteriaNoCriteriaEntered
                where tmpDimensionCriteriaNoCriteriaEntered.IsOpenCriteria == NoYes::No

            notexists join dimAttributeLevelValueViewToJoin
                where
                    dimAttributeLevelValueViewToJoin.ValueCombinationRecId == generalJournalAccountEntry.LedgerDimension &&
                    tmpDimensionCriteriaNoCriteriaEntered.DimensionAttributeRecId == dimAttributeLevelValueViewToJoin.DimensionAttribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceByPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the turnover amount fields by using values from the operating and closing type
    /// journal entries for the date range of a report.
    /// </summary>
    private void getBalanceByPeriod()
    {
        container periodTypeSet;
        periodTypeSet += FiscalPeriodType::Operating;
        if (printClosingTransaction)
        {
            periodTypeSet += FiscalPeriodType::Closing;
        }

        LedgerTurnoverTmpBalanceValue ledgerTurnoverTmpBalanceValue;
        this.getBalanceByType(ledgerTurnoverTmpBalanceValue, dateFrom, dateTo, periodTypeSet);

        // Join to get the period balance credit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverInPeriodCredit = ledgerTurnoverTmpBalanceValue.Balance,
                NumberOfGJAccountEntries = ledgerTurnoverTmpBalanceValue.NumberOfGJAccountEntries
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;

        // Join to get the period balance debit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverInPeriodDebit = ledgerTurnoverTmpBalanceValue.Balance,
                NumberOfGJAccountEntries = ledgerTurnoverTmpBalanceValue.NumberOfGJAccountEntries
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;

        if (printClosingTransaction)
        {
            // Join to get the period balance credit for each row
            update_recordset ledgerTurnoverAndBalanceTmpProcessing
                setting ClosingBalanceCredit = ledgerTurnoverTmpBalanceValue.Balance
                join ledgerTurnoverTmpBalanceValue
                    where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                        && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                        && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Closing;

            // Join to get the period balance debit for each row
            update_recordset ledgerTurnoverAndBalanceTmpProcessing
                setting ClosingBalanceDebit = ledgerTurnoverTmpBalanceValue.Balance
                join ledgerTurnoverTmpBalanceValue
                    where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                        && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                        && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Closing;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningAndOperatingBalance</Name>
				<Source><![CDATA[
    private void getOpeningAndOperatingBalance()
    {
        LedgerTurnoverTmpBalanceValue ledgerTurnoverTmpBalanceValue;
        this.getBalanceByType(ledgerTurnoverTmpBalanceValue, fiscalYearStartDate, dateFrom - 1, [ FiscalPeriodType::Opening, FiscalPeriodType::Operating ]);

        // Join to get the period balance credit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting OpeningBalanceCredit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceCreditPeriodStart = ledgerTurnoverTmpBalanceValue.Balance // writing initial value which will be updated in below
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Opening;

        // Join to get the period balance debit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting OpeningBalanceDebit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceDebitPeriodStart = ledgerTurnoverTmpBalanceValue.Balance // writing initial value which will be updated in below
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Opening;

        // Join to get the period balance credit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverPeriodInclOpenBalCredit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceCreditPeriodStart = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCreditPeriodStart + ledgerTurnoverTmpBalanceValue.Balance
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;

        // Join to get the period balance debit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverPeriodInclOpenBalDebit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceDebitPeriodStart = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebitPeriodStart + ledgerTurnoverTmpBalanceValue.Balance
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTurnoverAndBalanceTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries the <c>LedgerTurnoverAndBalanceTmp</c> table and gets the data table reset to the first
    /// record in the table.
    /// </summary>
    /// <returns>
    /// The report data table.
    /// </returns>
    [SRSReportDataSet(tableStr(LedgerTurnoverAndBalanceTmp))]
    public LedgerTurnoverAndBalanceTmp getLedgerTurnoverAndBalanceTmp()
    {
        select ledgerTurnoverAndBalanceTmp;
        return ledgerTurnoverAndBalanceTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the opening balance fields by using values from the opening type journal entries for the
    /// opening period before the from date of a report.
    /// </summary>
    private void getOpeningBalance()
    {
        TransDate openingDate;
        if (fiscalYearStartDate == dateFrom)
        {
            openingDate = dateFrom;
        }
        // If not reporting from the first day of the year the opening balance is from the first day of the year to the day before the report range
        else if (fiscalYearStartDate <= (dateFrom - 1))
        {
            openingDate = dateFrom - 1;
        }

        LedgerTurnoverTmpBalanceValue ledgerTurnoverTmpBalanceValue;
        this.getBalanceByType(ledgerTurnoverTmpBalanceValue, fiscalYearStartDate, openingDate, [ FiscalPeriodType::Opening ]);

        // Join to get the period balance credit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting OpeningBalanceCredit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceCreditPeriodStart = ledgerTurnoverTmpBalanceValue.Balance // writing initial value which will be updated in getIncludingOpeningBalance
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Opening;

         // Join to get the period balance debit for each row
         update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting OpeningBalanceDebit = ledgerTurnoverTmpBalanceValue.Balance,
                OpeningBalanceDebitPeriodStart = ledgerTurnoverTmpBalanceValue.Balance // writing initial value which will be updated in getIncludingOpeningBalance
             join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Opening;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPeriodBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the turnover amount fields by using values from the operating type journal entries for
    /// the date range of a report.
    /// </summary>
    private void getPeriodBalance()
    {
        LedgerTurnoverTmpBalanceValue ledgerTurnoverTmpBalanceValue;
        this.getBalanceByType(ledgerTurnoverTmpBalanceValue, dateFrom, dateTo, [ FiscalPeriodType::Operating ]);

        // Join to get the period balance credit for each row
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverInPeriodCredit = ledgerTurnoverTmpBalanceValue.Balance,
                NumberOfGJAccountEntries = ledgerTurnoverTmpBalanceValue.NumberOfGJAccountEntries
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::Yes
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;

         // Join to get the period balance debit for each row
         update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting TurnoverInPeriodDebit = ledgerTurnoverTmpBalanceValue.Balance,
                NumberOfGJAccountEntries = ledgerTurnoverTmpBalanceValue.NumberOfGJAccountEntries
            join ledgerTurnoverTmpBalanceValue
                where ledgerTurnoverTmpBalanceValue.MainAccountRecId == ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId
                    && ledgerTurnoverTmpBalanceValue.IsCredit == NoYes::No
                    && ledgerTurnoverTmpBalanceValue.Type == FiscalPeriodType::Operating;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerTurnoverAndBalanceTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>LedgerTurnoverAndBalanceTmp</c> temporary table.
    /// </summary>
    private void insertLedgerTurnoverAndBalanceTmp()
    {
        RecordInsertList tmpReportRowRIL = new RecordInsertList(tableNum(LedgerTurnoverAndBalanceTmp), true, true, true, true, true, ledgerTurnoverAndBalanceTmp);

        while select ledgerTurnoverAndBalanceTmpProcessing order by AccountNum
        {
            ledgerTurnoverAndBalanceTmp.clear();
            ledgerTurnoverAndBalanceTmp.AccountNum = ledgerTurnoverAndBalanceTmpProcessing.AccountNum;
            ledgerTurnoverAndBalanceTmp.AccountName = ledgerTurnoverAndBalanceTmpProcessing.AccountName;

            this.initTurnoverAndBalanceValues();

            this.calcTurnoverPeriodInclOpenBal();

            this.calcBalanceOfPeriod();

            this.calcRunningValues();

            // Only save if there is an amount, or we are printing zero balance, or number of transactions for account not zero
            // do not clear the buffer since there are running totals that are needed for the next record
            if (contract.parmPrintZeroBalances()||
                ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebitTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCreditTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebitTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCreditTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl != 0 ||
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl != 0 ||
                ledgerTurnoverAndBalanceTmpProcessing.NumberOfGJAccountEntries != 0)
            {
                tmpReportRowRIL.add(ledgerTurnoverAndBalanceTmp);
            }
        }
        tmpReportRowRIL.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCriteriaTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>LedgerTurnoverTmpDimensionCriteria</c> temporary table.
    /// </summary>
    /// <remarks>
    /// The <c>LedgerTurnoverTmpDimensionCriteria</c> table contains the selection criteria for all dimensions.
    /// </remarks>
    private void populateCriteriaTable()
    {
        MapEnumerator                       controlMapEnum;
        RecId                               dimAttrRecId;
        Map                                 dimRangeMap;
        DimensionValue                      dimensionCriteria;
        Query                               query;
        QueryRun                            queryRun;
        QueryBuildDataSource                qbds;
        NoYes                               yesVariable = NoYes::Yes;
        LedgerTurnoverTmpDimensionCriteria  tmpDimCriteriaExisting;
        DimensionAttribute                  dimensionAttribute;
        NoYes                               isCriteriaFound;

        dimRangeMap = contract.parmDimensionRangeMap();
        controlMapEnum = dimRangeMap.getEnumerator();
        tmpDimCriteriaExisting.linkPhysicalTableInstance(ledgerTurnoverTmpDimensionCriteria);

        while (controlMapEnum.moveNext())
        {
            ledgerTurnoverTmpDimensionCriteria.clear();
            dimAttrRecId = controlMapEnum.currentKey();
            dimensionCriteria = controlMapEnum.currentValue();

            // For any dimension that has criteria specified, loop over the
            // values matching those criteria and shove them into the temp table
            if (dimensionCriteria)
            {
                isCriteriaFound = false;
                query = new Query();
                qbds = query.addDataSource(tableNum(DimensionAttributeValue));
                qbds.addRange(fieldNum(DimensionAttributeValue, DimensionAttribute)).value(queryValue(dimAttrRecId));

                qbds = qbds.addDataSource(tableNum(DimensionAttributeLevelValue));
                qbds.joinMode(JoinMode::ExistsJoin);
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.addLink(fieldNum(DimensionAttributeValue, RecId), fieldNum(DimensionAttributeLevelValue, DimensionAttributeValue));
                qbds.addRange(fieldNum(DimensionAttributeLevelValue, DisplayValue)).value(dimensionCriteria);

                queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    ledgerTurnoverTmpDimensionCriteria.DimensionAttributeRecId = dimAttrRecId;
                    ledgerTurnoverTmpDimensionCriteria.DimensionAttributeValueRecId = queryRun.get(tableNum(DimensionAttributeValue)).RecId;
                    ledgerTurnoverTmpDimensionCriteria.insert();
                    isCriteriaFound = true;
                }
                // if nothing found we still need the dimension in the criteria or no restriction will be done and all records may print
                if (!isCriteriaFound)
                {
                    ledgerTurnoverTmpDimensionCriteria.DimensionAttributeRecId = dimAttrRecId;
                    ledgerTurnoverTmpDimensionCriteria.DimensionAttributeValueRecId = -1;
                    ledgerTurnoverTmpDimensionCriteria.insert();
                }
            }
        }

        // For all dimensions without criteria add a record indicating that no restriction exists. The selects will join against these records to include any value
        insert_recordset ledgerTurnoverTmpDimensionCriteria (DimensionAttributeRecId, IsOpenCriteria)
        select RecId, yesVariable from dimensionAttribute
        notexists join tmpDimCriteriaExisting where
            tmpDimCriteriaExisting.DimensionAttributeRecId == dimensionAttribute.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMainAccount</Name>
				<Source><![CDATA[
    private boolean insertMainAccount(MainAccount _mainAccount, boolean _isTotalAccountSelected)
    {
        boolean isTotalAccountSelected = _isTotalAccountSelected ;
        MainAccount subMainAccount;
        DimensionAttributeValueTotallingCriteria dimAttrValueTotCrit;

        if (_mainAccount.Type == DimensionLedgerAccountType::Total)
        {
            DimensionAttributeValue dimensionAttributeValue = DimensionAttributeValue::findByDimensionAttributeAndValue(
                DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)),
                    _mainAccount.MainAccountId);

            SysDaSearchObject searchObject = LedgerTurnoverAndBalanceDPInsertMainAccountQuery::createSearchObject(subMainAccount, dimensionAttributeValue.RecId);

            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while(searchStatement.findNext(searchObject))
            {
                this.insertTotalAccount(subMainAccount.RecId, _mainAccount.RecId);
                isTotalAccountSelected = true;
            }
        }
        else
        {
            this.insertTotalAccount(_mainAccount.RecId, 0);
        }

        return isTotalAccountSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingLayerSelection</Name>
				<Source><![CDATA[
    private List getPostingLayerSelection()
    {
        List selected = new List(Types::Enum);
  
        if (contract.parmPrintPostingLayers())
        {
            List selectedStr = strSplit(contract.parmPrintPostingLayers(), ';');
            ListEnumerator postingLayerCollectionEnumerator = selectedStr.getEnumerator();

            while (postingLayerCollectionEnumerator.moveNext())
            {
                CurrentOperationsTax currOpertax;
                str currentPostingLayerValue = postingLayerCollectionEnumerator.current();
                selected.addEnd(str2Enum(currOpertax, currentPostingLayerValue));
            }
        }

        return selected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    private void initParameters()
    {
        contract = this.parmDataContract() as LedgerTurnoverAndBalanceContract;

        printSeparateBalance = contract.parmSeparateBalance();
        printClosingTransaction = contract.parmPrintClosingTransactions();
        dateTo = contract.parmToDate();
        dateFrom = contract.parmFromDate();
        postingLayer  = contract.parmPrintPostingLayer();
        postingLayers = this.getPostingLayerSelection();

        fiscalYearStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), dateFrom);

        ledgerRecIdCurrent = Ledger::current();

        mainAccountsMap = new Map(Types::Int64, Types::Class);

        postingLayersCont += postingLayers.elements() ? list2con(postingLayers) : [ contract.parmPrintPostingLayer() ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the report business logic for the <c>LedgerTurnoverAndBalance</c> report.
    /// </summary>
    public void processReport()
    {
        this.initParameters();

        MainAccount mainAccount;
        boolean isTotalAccountSelected;
        if (mainAccountSet)
        {
            SetEnumerator se = mainAccountSet.getEnumerator();
            while (se.moveNext())
            {
                mainAccount = MainAccount::find(se.current());
                isTotalAccountSelected = this.insertMainAccount(mainAccount, isTotalAccountSelected);
            }
        }
        else
        {
            Query accountQuery = this.parmQuery();

            // Only want accounts for a specific chart of accounts
            QueryBuildDataSource queryBuildDataSource = accountQuery.dataSourceTable(tableNum(MainAccount));
            QueryBuildRange range = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(MainAccount, LedgerChartOfAccounts));
            range.value(SysQuery::value(LedgerChartOfAccounts::current()));

            QueryRun accountQueryRun = new QueryRun(accountQuery);

            while (accountQueryRun.next())
            {
                mainAccount = accountQueryRun.get(tableNum(MainAccount)) as MainAccount;
                isTotalAccountSelected = this.insertMainAccount(mainAccount, isTotalAccountSelected);
            }
        }

        RecordInsertList mainAccountRowRIL = new RecordInsertList(tableNum(LedgerTurnoverAndBalanceTmpProcessing), true, true, true, true, true, ledgerTurnoverAndBalanceTmpProcessing);
        MapEnumerator me = mainAccountsMap.getEnumerator();

        while (me.moveNext())
        {
            select firstOnly RecId, MainAccountId from mainAccount
                where mainAccount.RecId == me.currentKey();

            ledgerTurnoverAndBalanceTmpProcessing.clear();
            ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId = mainAccount.RecId;
            ledgerTurnoverAndBalanceTmpProcessing.AccountNum = mainAccount.MainAccountId;
            ledgerTurnoverAndBalanceTmpProcessing.AccountName = MainAccount::getLocalizedName(mainAccount.RecId);

            if (printSeparateBalance)
            {
                ledgerTurnoverAndBalanceTmpProcessing.IsSeparateBalanceMainAccount = MainAccountSeparateBalance::findByMainAccount(mainAccount.RecId).IsSeparateBalanceMainAccount;
            }
            mainAccountRowRIL.add(ledgerTurnoverAndBalanceTmpProcessing);
        }
        mainAccountRowRIL.insertDatabase();

        // Complete the setting of selection criteria for the report
        this.populateCriteriaTable();

        // Retrieve all of the amounts according to the criteria
        if (fiscalYearStartDate == dateFrom)
        {
            this.getOpeningBalance();
        }
        else if (fiscalYearStartDate <= (dateFrom - 1))
        {
            this.getOpeningAndOperatingBalance();
        }

        this.getBalanceByPeriod();

        if (printSeparateBalance)
        {
            this.buildCustBalances();
            this.buildVendBalances();
        }

        this.processTotalAccounts(isTotalAccountSelected, printSeparateBalance);

        this.insertLedgerTurnoverAndBalanceTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceOfPeriod</Name>
				<Source><![CDATA[
    private void calcBalanceOfPeriod()
    {
        // Print separate balance
        if (printSeparateBalance && ledgerTurnoverAndBalanceTmpProcessing.IsSeparateBalanceMainAccount)
        {
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit += ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountDebit +
                                                            ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountDebit;
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit += ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountCredit +
                                                            ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountCredit;
            // Include amount from sub and total accounts
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl += ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountDebitTtl +
                                                            ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountDebitTtl;
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl += ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountCreditTtl +
                                                            ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountCreditTtl;
    
            if (printClosingTransaction)
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit += ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebit;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit -= ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCredit;
    
                // Include amount from sub and total accounts
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl += ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebitTtl;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl -= ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCreditTtl;
            }
        }
        else
        {
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit = ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebit;
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit = ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCredit;
    
            // Include amount from sub and total accounts
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl = ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebitTtl;
            ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl = ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCreditTtl;
    
            if (printClosingTransaction)
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit += ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebit;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit -= ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCredit;
    
                // Include amount from sub and total accounts
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl += ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebitTtl;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl -= ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCreditTtl;
            }
    
            if (!contract.parmPrintOpeningBalance())
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit += ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit += ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit;
    
                // Include amount from sub and total accounts
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl += ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl += ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl;
            }
    
            // Compute the net and zero the offset
            if (ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit > ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit)
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit -= ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit = 0;
            }
            else
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit -= ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit = 0;
            }
    
            // Compute the net and zero the offset
            // Include amount from sub and total accounts
            if (ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl > ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl)
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl -= ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl = 0;
            }
            else
            {
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCreditTtl -= ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl;
                ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebitTtl = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRunningValues</Name>
				<Source><![CDATA[
    private void calcRunningValues()
    {
        // The previous record's running totals must be stored on each record because those totals may need
        // to be shown at the top of a report page as totals "carried over" from the last page
    
        // Opening running totals
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalOpeningBalanceDebit = runningTotalOpeningBalanceDebit;
        runningTotalOpeningBalanceDebit += ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit;
        ledgerTurnoverAndBalanceTmp.RunningTotalOpeningBalanceDebit = runningTotalOpeningBalanceDebit;
    
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalOpeningBalanceCredit = runningTotalOpeningBalanceCredit;
        runningTotalOpeningBalanceCredit += ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit;
        ledgerTurnoverAndBalanceTmp.RunningTotalOpeningBalanceCredit = runningTotalOpeningBalanceCredit;
    
        ledgerTurnoverAndBalanceTmp.NetOpeningBalance = ledgerTurnoverAndBalanceTmp.RunningTotalOpeningBalanceDebit - ledgerTurnoverAndBalanceTmp.RunningTotalOpeningBalanceCredit;
    
        // Turnover running totals
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalTurnoverPeriodDebit = runningTurnoverInPeriodDebit;
        runningTurnoverInPeriodDebit += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebit;
        ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverInPeriodDebit = runningTurnoverInPeriodDebit;
    
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalTurnoverPeriodCredit = runningTurnoverInPeriodCredit;
        runningTurnoverInPeriodCredit += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCredit;
        ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodCredit = runningTurnoverInPeriodCredit;
    
        ledgerTurnoverAndBalanceTmp.NetTurnoverInPeriod = ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverInPeriodDebit - ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodCredit;
    
        // Balance running totals
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalClosingBalanceDebit = runningClosingBalanceDebit;
        runningClosingBalanceDebit += ledgerTurnoverAndBalanceTmp.BalanceOfPeriodDebit;
        ledgerTurnoverAndBalanceTmp.RunningTotalClosingBalanceDebit = runningClosingBalanceDebit;
    
        ledgerTurnoverAndBalanceTmp.PrevRunningTotalClosingBalanceCredit = runningClosingBalanceCredit;
        runningClosingBalanceCredit += ledgerTurnoverAndBalanceTmp.BalanceOfPeriodCredit;
        ledgerTurnoverAndBalanceTmp.RunningTotalClosingBalanceCredit = runningClosingBalanceCredit;
    
        ledgerTurnoverAndBalanceTmp.NetClosingBalance = ledgerTurnoverAndBalanceTmp.RunningTotalClosingBalanceDebit - ledgerTurnoverAndBalanceTmp.RunningTotalClosingBalanceCredit;
    
        // TurnOver with opening running totals
        ledgerTurnoverAndBalanceTmp.PrevRunTotalTurnoverPeriodInclOpenDB = runningTurnoverInPeriodInclOpenBalDebit;
        runningTurnoverInPeriodInclOpenBalDebit += ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebit;
        ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodInclOpenDB = runningTurnoverInPeriodInclOpenBalDebit;
    
        ledgerTurnoverAndBalanceTmp.PrevRunTotalTurnoverPeriodInclOpenCR = runningTurnoverInPeriodInclOpenBalCredit;
        runningTurnoverInPeriodInclOpenBalCredit += ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCredit;
        ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodInclOpenCR = runningTurnoverInPeriodInclOpenBalCredit;
    
        ledgerTurnoverAndBalanceTmp.NetTurnoverPeriodInclOpenBal = ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodInclOpenDB - ledgerTurnoverAndBalanceTmp.RunningTotalTurnoverPeriodInclOpenCR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTurnoverPeriodInclOpenBal</Name>
				<Source><![CDATA[
    private void calcTurnoverPeriodInclOpenBal()
    {
        // Include opening balance in turnover
        if (contract.parmPrintOpeningBalance())
        {
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebit += ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit +
                                                                    ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebit;
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCredit += ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit +
                                                                    ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCredit;
    
            // Include amount from sub and total accounts
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebitTtl += ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl +
                                                                    ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebitTtl;
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCreditTtl += ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl +
                                                                    ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCreditTtl;
        }
        else
        {
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebit += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebit;
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCredit += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCredit;
    
            // Include amount from sub and total accounts
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebitTtl += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebitTtl;
            ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCreditTtl += ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCreditTtl;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAmounts</Name>
				<Source><![CDATA[
    private void clearAmounts(LedgerTurnoverAndBalanceTmpProcessing _turnoverAndBalanceTmpProcessing)
    {
        _turnoverAndBalanceTmpProcessing.BalanceOfPeriod                    = 0;
        _turnoverAndBalanceTmpProcessing.ClosingBalanceCredit               = 0;
        _turnoverAndBalanceTmpProcessing.ClosingBalanceDebit                = 0;
        _turnoverAndBalanceTmpProcessing.CustTransAmountCredit              = 0;
        _turnoverAndBalanceTmpProcessing.CustTransAmountDebit               = 0;
        _turnoverAndBalanceTmpProcessing.OpeningBalanceCredit               = 0;
        _turnoverAndBalanceTmpProcessing.OpeningBalanceDebit                = 0;
        _turnoverAndBalanceTmpProcessing.OpeningBalanceCreditPeriodStart    = 0;
        _turnoverAndBalanceTmpProcessing.OpeningBalanceDebitPeriodStart     = 0;
        _turnoverAndBalanceTmpProcessing.TurnoverInPeriodCredit             = 0;
        _turnoverAndBalanceTmpProcessing.TurnoverInPeriodDebit              = 0;
        _turnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalCredit    = 0;
        _turnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalDebit     = 0;
        _turnoverAndBalanceTmpProcessing.VendTransAmountCredit              = 0;
        _turnoverAndBalanceTmpProcessing.VendTransAmountDebit               = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotalAmounts</Name>
				<Source><![CDATA[
    private void initTotalAmounts()
    {
        update_recordset ledgerTurnoverAndBalanceTmpProcessing
            setting CustTransAmountDebitTtl            = ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountDebit,
                    CustTransAmountCreditTtl           = ledgerTurnoverAndBalanceTmpProcessing.CustTransAmountCredit,
    
                    VendTransAmountDebitTtl            = ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountDebit,
                    VendTransAmountCreditTtl           = ledgerTurnoverAndBalanceTmpProcessing.VendTransAmountCredit,
    
                    OpeningBalanceDebitTtl             = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebit,
                    OpeningBalanceCreditTtl            = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCredit,

                    OpeningBalanceDebitPeriodStartTtl  = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebitPeriodStart,
                    OpeningBalanceCreditPeriodStartTtl = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCreditPeriodStart,
    
                    TurnoverInPeriodDebitTtl           = ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodDebit,
                    TurnoverInPeriodCreditTtl          = ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodCredit,
    
                    TurnoverPeriodInclOpenBalDebitTtl  = ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalDebit,
                    TurnoverPeriodInclOpenBalCreditTtl = ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalCredit,
    
                    ClosingBalanceDebitTtl             = ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebit,
                    ClosingBalanceCreditTtl            = ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTurnoverAndBalanceValues</Name>
				<Source><![CDATA[
    private void initTurnoverAndBalanceValues()
    {
        ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebit;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit = -ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCredit;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitPeriodStart = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebitPeriodStart;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditPeriodStart = -ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCreditPeriodStart;
        ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebit = ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodDebit;
        ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCredit = -ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodCredit;
        ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebit = ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalDebit;
        ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCredit = -ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalCredit;
        ledgerTurnoverAndBalanceTmp.ClosingBalanceDebit = ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebit;
        ledgerTurnoverAndBalanceTmp.ClosingBalanceCredit = -ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCredit;
    
        // Include amount from sub and total accounts
        ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebitTtl;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl = -ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCreditTtl;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitPeriodStartTtl = ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceDebitPeriodStartTtl;
        ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditPeriodStartTtl = -ledgerTurnoverAndBalanceTmpProcessing.OpeningBalanceCreditPeriodStartTtl;
        ledgerTurnoverAndBalanceTmp.TurnoverInPeriodDebitTtl = ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodDebitTtl;
        ledgerTurnoverAndBalanceTmp.TurnoverInPeriodCreditTtl = -ledgerTurnoverAndBalanceTmpProcessing.TurnoverInPeriodCreditTtl;
        ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalDebitTtl = ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalDebitTtl;
        ledgerTurnoverAndBalanceTmp.TurnoverPeriodInclOpenBalCreditTtl = -ledgerTurnoverAndBalanceTmpProcessing.TurnoverPeriodInclOpenBalCreditTtl;
        ledgerTurnoverAndBalanceTmp.ClosingBalanceDebitTtl = ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceDebitTtl;
        ledgerTurnoverAndBalanceTmp.ClosingBalanceCreditTtl = -ledgerTurnoverAndBalanceTmpProcessing.ClosingBalanceCreditTtl;

        this.computeOpeningBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeOpeningBalance</Name>
				<Source><![CDATA[
    private void computeOpeningBalance()
    {
        if (!printSeparateBalance || !ledgerTurnoverAndBalanceTmpProcessing.IsSeparateBalanceMainAccount)
        {
            if (ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit > ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit)
            {
                ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit -= ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit;
                ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit = 0;
            }
            else
            {
                ledgerTurnoverAndBalanceTmp.OpeningBalanceCredit -= ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit;
                ledgerTurnoverAndBalanceTmp.OpeningBalanceDebit = 0;
            }

            if (ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl > ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl)
            {
                ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl -= ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl;
                ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl = 0;
            }
            else
            {
                ledgerTurnoverAndBalanceTmp.OpeningBalanceCreditTtl -= ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl;
                ledgerTurnoverAndBalanceTmp.OpeningBalanceDebitTtl = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTotalAccount</Name>
				<Source><![CDATA[
    private void insertTotalAccount(RecId _mainAccountId, RecId _totalMainAccountId)
    {
        Set totalAccountsSet;
    
        if (mainAccountsMap.exists(_mainAccountId))
        {
            totalAccountsSet = mainAccountsMap.lookup(_mainAccountId);
        }
        else
        {
            totalAccountsSet = new Set(Types::Int64);
        }
    
        totalAccountsSet.add(_totalMainAccountId);
    
        mainAccountsMap.insert(_mainAccountId, totalAccountsSet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTotalAccounts</Name>
				<Source><![CDATA[
    private void processTotalAccounts(boolean _isTotalAccountSelected, boolean _printSeparateBalance)
    {
        LedgerTurnoverAndBalanceTmpProcessing   ledgerTurnoverAndBalanceTmpProcessingTtl;
        Set                                     totalAccountsSet;
        MapEnumerator                           me;
        SetEnumerator                           se;
        RecId                                   mainAccountId, totalAccountId;
        MainAccount                             mainAccount;
        boolean                                 isFirstEntryOfAccount;
    
        this.initTotalAmounts();
    
        if (! _isTotalAccountSelected)
        {
            mainAccountsMap = null;
            return;
        }
    
        me = mainAccountsMap.getEnumerator();
    
        while (me.moveNext())
        {
            mainAccountId = me.currentKey();
    
            select firstOnly ledgerTurnoverAndBalanceTmpProcessing
                where ledgerTurnoverAndBalanceTmpProcessing.MainAccountRecId == mainAccountId;
    
            totalAccountsSet = me.currentValue();
            se = totalAccountsSet.getEnumerator();
    
            isFirstEntryOfAccount = true;
    
            while (se.moveNext())
            {
                totalAccountId = se.current();
                if (totalAccountId == 0) // not total account
                {
                    totalAccountId = mainAccountId;
                }
    
                ttsBegin;
                select firstOnly forUpdate ledgerTurnoverAndBalanceTmpProcessingTtl
                    where ledgerTurnoverAndBalanceTmpProcessingTtl.MainAccountRecId == totalAccountId;
    
                if (ledgerTurnoverAndBalanceTmpProcessingTtl)
                {
                    this.updateTotalAmounts(ledgerTurnoverAndBalanceTmpProcessingTtl, ledgerTurnoverAndBalanceTmpProcessing);
                    if (isFirstEntryOfAccount)
                    {
                        this.updateAmounts(ledgerTurnoverAndBalanceTmpProcessingTtl, ledgerTurnoverAndBalanceTmpProcessing);
                    }
                    ledgerTurnoverAndBalanceTmpProcessingTtl.update();
                }
                else
                {
                    ledgerTurnoverAndBalanceTmpProcessingTtl.data(ledgerTurnoverAndBalanceTmpProcessing);
    
                    if (totalAccountId != mainAccountId) // total account
                    {
                        select firstOnly RecId, MainAccountId from mainAccount
                            where mainAccount.RecId == totalAccountId;
    
                        ledgerTurnoverAndBalanceTmpProcessingTtl.MainAccountRecId   = totalAccountId;
                        ledgerTurnoverAndBalanceTmpProcessingTtl.AccountNum         = mainAccount.MainAccountId;
                        ledgerTurnoverAndBalanceTmpProcessingTtl.AccountName        = MainAccount::getLocalizedName(mainAccount.RecId);
    
                        if (_printSeparateBalance)
                        {
                            ledgerTurnoverAndBalanceTmpProcessingTtl.IsSeparateBalanceMainAccount = MainAccountSeparateBalance::findByMainAccount(mainAccount.RecId).IsSeparateBalanceMainAccount;
                        }
                    }
    
                    if (! isFirstEntryOfAccount) // multiple accounts entries
                    {
                        this.clearAmounts(ledgerTurnoverAndBalanceTmpProcessingTtl);
                    }
    
                    ledgerTurnoverAndBalanceTmpProcessingTtl.insert();
    
                    isFirstEntryOfAccount = false;
                }
                ttsCommit;
            }
        }
    
        delete_from ledgerTurnoverAndBalanceTmpProcessing;
        mainAccountsMap = null;
    
        ledgerTurnoverAndBalanceTmpProcessing = ledgerTurnoverAndBalanceTmpProcessingTtl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmounts</Name>
				<Source><![CDATA[
    private void updateAmounts(LedgerTurnoverAndBalanceTmpProcessing _dest, LedgerTurnoverAndBalanceTmpProcessing _source)
    {
        _dest.ClosingBalanceCredit               += _source.ClosingBalanceCredit;
        _dest.ClosingBalanceDebit                += _source.ClosingBalanceDebit;
        _dest.CustTransAmountCredit              += _source.CustTransAmountCredit;
        _dest.CustTransAmountDebit               += _source.CustTransAmountDebit;
        _dest.OpeningBalanceCredit               += _source.OpeningBalanceCredit;
        _dest.OpeningBalanceDebit                += _source.OpeningBalanceDebit;
        _dest.OpeningBalanceCreditPeriodStart    += _source.OpeningBalanceCreditPeriodStart;
        _dest.OpeningBalanceDebitPeriodStart     += _source.OpeningBalanceDebitPeriodStart;
        _dest.TurnoverInPeriodCredit             += _source.TurnoverInPeriodCredit;
        _dest.TurnoverInPeriodDebit              += _source.TurnoverInPeriodDebit;
        _dest.TurnoverPeriodInclOpenBalCredit    += _source.TurnoverPeriodInclOpenBalCredit;
        _dest.TurnoverPeriodInclOpenBalDebit     += _source.TurnoverPeriodInclOpenBalDebit;
        _dest.VendTransAmountCredit              += _source.VendTransAmountCredit;
        _dest.VendTransAmountDebit               += _source.VendTransAmountDebit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalAmounts</Name>
				<Source><![CDATA[
    private void updateTotalAmounts(LedgerTurnoverAndBalanceTmpProcessing _dest, LedgerTurnoverAndBalanceTmpProcessing _source)
    {
        _dest.ClosingBalanceCreditTtl               += _source.ClosingBalanceCredit;
        _dest.ClosingBalanceDebitTtl                += _source.ClosingBalanceDebit;
        _dest.CustTransAmountCreditTtl              += _source.CustTransAmountCredit;
        _dest.CustTransAmountDebitTtl               += _source.CustTransAmountDebit;
        _dest.OpeningBalanceCreditTtl               += _source.OpeningBalanceCredit;
        _dest.OpeningBalanceDebitTtl                += _source.OpeningBalanceDebit;
        _dest.OpeningBalanceCreditPeriodStartTtl    += _source.OpeningBalanceCreditPeriodStart;
        _dest.OpeningBalanceDebitPeriodStartTtl     += _source.OpeningBalanceDebitPeriodStart;
        _dest.TurnoverInPeriodCreditTtl             += _source.TurnoverInPeriodCredit;
        _dest.TurnoverInPeriodDebitTtl              += _source.TurnoverInPeriodDebit;
        _dest.TurnoverPeriodInclOpenBalCreditTtl    += _source.TurnoverPeriodInclOpenBalCredit;
        _dest.TurnoverPeriodInclOpenBalDebitTtl     += _source.TurnoverPeriodInclOpenBalDebit;
        _dest.VendTransAmountCreditTtl              += _source.VendTransAmountCredit;
        _dest.VendTransAmountDebitTtl               += _source.VendTransAmountDebit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainAccountSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the account identifiers the balances to be calculated for.
    /// </summary>
    /// <param name = "_mainAccountSet">The set of the accounts identifiers; optional.</param>
    /// <returns>The set of the accounts identifiers.</returns>
    public Set parmMainAccountSet(Set _mainAccountSet = mainAccountSet)
    {
        mainAccountSet = _mainAccountSet;
        return mainAccountSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryTimeout</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets/gets the timeout used for the queries
    /// </summary>
    /// <param name = "_queryTimeout">The timeout value to use</param>
    /// <returns>The set timeout value</returns>
    /// <remarks>
    /// If the timeout is 0, the default timeouts are applied
    /// </remarks>
    public int parmQueryTimeout(int _queryTimeout = queryTimeout)
    {
        queryTimeout = _queryTimeout;

        return queryTimeout;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>