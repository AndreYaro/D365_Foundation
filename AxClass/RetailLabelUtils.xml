<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailLabelUtils</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RetailLabelUtils</c> class is used for creating the record in <c>RetailInventItemLabel</c> table.
/// </summary>
class RetailLabelUtils
{
    InventTable     itemBuffer;
    boolean         variantExists;
    boolean         specificOrder;
    RetailQty       shelfLabelCounter;
    RetailQty       itemLabelCounter;
    int             shelfLabelReports;
    int             itemLabelReports;

    int             totalLabelsCreated;

    sysoperationprogress progressWindow;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkLabelSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// <c>_labelType</c>.
    /// </summary>
    /// <param name="_itemId">
    /// ID of the InventTable.ItemId field.
    /// </param>
    /// <param name="_labelType">
    /// <c>RetailLabelTypeBase</c>
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStoreTable.storeId field.
    /// </param>
    void checkLabelSetup(ItemId _itemId, RetailLabelTypeBase _labelType, RetailStoreId _storeId = "")
    {
        RetailInventItemLabelSetup          labelSetup;
        progressWindow = SysOperationProgress::newGeneral('107.avi', "@RET4129", 100);

        if (InventTable::exist(_itemId))
        {
            while select labelSetup
            where   labelSetup.LabelType == _labelType
            &&      labelSetup.ItemId == _itemId
            {
                this.runLabelForRetailLabelTypeBase(_itemId, _labelType, labelSetup, _storeId);
            }
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runLabelForRetailLabelTypeBase</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </summary>
    /// <param name = "_itemId">
    ///     An <c>InventTable</c> item.
    /// </param>
    /// <param name = "_labelType">
    ///     <c>RetailLabelTypeBase</c> enum type.
    /// </param>
    /// <param name = "_labelSetup">
    ///     A <c>RetailInventItemLabelSetup</c> table buffer.
    /// </param>
    /// <param name = "_storeId">
    ///     ID of the <c>RetailStoreTable.storeId</c> field.
    /// </param>
    protected void runLabelForRetailLabelTypeBase(ItemId _itemId, RetailLabelTypeBase _labelType, RetailInventItemLabelSetup _labelSetup, RetailStoreId _storeId = "")
    {
        RetailParameters                rboParameters;
        RetailSharedParameters          retailSharedParameters;
        RetailStoreTable                rboStoreTable;
        RetailChannelTable              channel;
        OMOperatingUnit                 omOperatingUnit;
        Set                             omOperatingUnits;
        SetEnumerator                   omOperatingUnitsEnumerator;
        Set organizationTypes           = new Set(Types::Enum);

        rboParameters = RetailParameters::find();
        retailSharedParameters = RetailSharedParameters::find();

        if (_labelType == RetailLabelTypeBase::ShelfLabel)
        {
            if (_storeId != "")
            {
                rboStoreTable = RetailStoreTable::find(_storeId);
                if (rboStoreTable.RecId && rboStoreTable.generatesShelfLabels == true)
                {
                    this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                }
            }
            else
            {
                switch (retailSharedParameters.ShelfLabelCreation)
                {
                    case RetailLabelCreationBase::AllDistributionMembers :
                        // Filter the organization model to include only operating units effective as of right now.
                        organizationTypes.add(OMInternalOrganizationType::OperatingUnit);
                        omOperatingUnits = OMInternalOrganization::getDescendantsAndSelf(_labelSetup.OMInternalOrganization, _labelSetup.OMHierarchyType, DateTimeUtil::utcNow(), organizationTypes);
                        omOperatingUnitsEnumerator = omOperatingUnits.getEnumerator();
                        while (omOperatingUnitsEnumerator.moveNext())
                        {
                            // For each operating unit...

                            omOperatingUnit = OMOperatingUnit::find(omOperatingUnitsEnumerator.current(), OMOperatingUnitType::RetailChannel);
                            if (omOperatingUnit)
                            {
                                // We have a value of the correct operating unit type...

                                channel = RetailChannelTable::findByOperatingUnitId(omOperatingUnit.RecId);
                                rboStoreTable = RetailStoreTable::findRecId(channel.RecId);
                                if (rboStoreTable.RecId && rboStoreTable.generatesShelfLabels)
                                {
                                    // Run the label for this shelf item ...
                                    this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                                }
                            }
                        }
                        break;
                    case RetailLabelCreationBase::LocalStoreOnly :
                        // For the local store only
                        rboStoreTable = RetailStoreTable::find(retailSharedParameters.LocalStoreId);
                        if (rboStoreTable.RecId && rboStoreTable.generatesShelfLabels == true)
                        {
                            this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                        }
                        break;
                }
            }
        }
        else if (_labelType == RetailLabelTypeBase::ItemLabel)
        {
            if (_storeId != "")
            {
                rboStoreTable = RetailStoreTable::find(_storeId);
                if (rboStoreTable.RecId && rboStoreTable.generatesItemLabels == true)
                {
                    this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                }
            }
            else
            {
                switch (retailSharedParameters.ItemLabelCreation)
                {
                    case RetailLabelCreationBase::AllDistributionMembers :
                        // Filter the organization model to include only operating units effective as of right now.
                        organizationTypes.add(OMInternalOrganizationType::OperatingUnit);
                        omOperatingUnits = OMInternalOrganization::getDescendantsAndSelf(_labelSetup.OMInternalOrganization, _labelSetup.OMHierarchyType, DateTimeUtil::utcNow(), organizationTypes);
                        omOperatingUnitsEnumerator = omOperatingUnits.getEnumerator();
                        while (omOperatingUnitsEnumerator.moveNext())
                        {
                            // For each operating unit...

                            omOperatingUnit = OMOperatingUnit::find(omOperatingUnitsEnumerator.current(), OMOperatingUnitType::RetailChannel);
                            if (omOperatingUnit)
                            {
                                // We have a value of the correct operating unit type...

                                channel = RetailChannelTable::findByOperatingUnitId(omOperatingUnit.RecId);
                                rboStoreTable = RetailStoreTable::findRecId(channel.RecId);
                                if (rboStoreTable.RecId && rboStoreTable.generatesItemLabels)
                                {
                                    // Run the label for this item ...
                                    this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                                }
                            }
                        }
                        break;
                    case RetailLabelCreationBase::LocalStoreOnly :
                        // For the local store only
                        rboStoreTable = RetailStoreTable::find(retailSharedParameters.LocalStoreId);
                        if (rboStoreTable.RecId && rboStoreTable.generatesItemLabels == true)
                        {
                            this.runLabels(rboStoreTable.StoreNumber, _labelSetup);
                        }
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns false if there is no record in <c>InventDimCombination</c> table for the <c>_itemId</c>; else true.
    /// </summary>
    /// <param name="_itemId">
    /// ID of the InventDimCombination.ItemId field.
    /// </param>
    /// <returns>
    /// false if there is no record in <c>InventDimCombination</c> table for the <c>_itemId</c>; else true.
    /// </returns>
    boolean checkVariants(ItemId _itemId)
    {
        InventDimCombination combinations;

        select firstonly combinations
        where combinations.ItemId == _itemId;

        if (!combinations)
            return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new record in <c>RetailInventItemLabel</c> table if the record does not exist for the given parameters; else updates the record
    /// in <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailInventItemLabel.StoreId field.
    /// </param>
    /// <param name="_validOnDate">
    /// ID of the RetailInventItemLabel.ValidOnDate field.
    /// </param>
    /// <param name="_variantId">
    /// ID of the RetailInventItemLabel.VariantId field.
    /// </param>
    /// <param name="_UOM">
    /// ID of the RetailInventItemLabel.UnitID field.
    /// </param>
    /// <param name="_specificQty">
    /// <c>Quantity</c> to initialize <c>qty</c>.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    [SysObsolete('Please use createLabelsBarcode() instead', true, 30\06\2020)]
    public void createLabels(RetailStoreId _storeId,RetailLabelValidOnDate _validOnDate,RetailVariantId _variantId,UnitOfMeasureSymbol _UOM,real _specificQty, RetailInventItemLabelSetup _labelSetup)
    {    
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the record in <c>RetailLabelGeneration</c> table.
    /// </summary>
    /// <param name="_labelType">
    /// <c>RetailLabelType</c>
    /// </param>
    /// <remarks>
    /// RetailLabelUtils.checkLabelSetup method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </remarks>
    public void generateNewLabels(RetailLabelType _labelType)
    {        
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();
        
        this.generateNewLabelsForRetailLabelTypeBase(_labelType, retailSharedParameters);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewLabelsForRetailLabelTypeBase</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Extensible method used for updating the record in <c>RetailLabelGeneration</c> table.
    /// </summary>
    /// <param name="_labelType">
    ///     <c>RetailLabelType</c> enum.
    /// </param>
    /// <param name = "_retailSharedParameters">
    ///     <c>RetailSharedParameters</c> table buffer.
    /// </param>
    [Wrappable(true)]
    protected final void generateNewLabelsForRetailLabelTypeBase(RetailLabelType _labelType, RetailSharedParameters _retailSharedParameters)
    {
        RetailLabelGeneration  rboLabelGeneration;

        ttsbegin;

        if (_labelType == RetailLabelTypeBase::ShelfLabel && (_retailSharedParameters.ShelfLabelCreation != RetailLabelCreationBase::None))
        {
            while select forupdate rboLabelGeneration
                where rboLabelGeneration.shelfLabelGenerated == false
            {
                this.checkLabelSetup(rboLabelGeneration.itemId, _labelType);
                rboLabelGeneration.shelfLabelGenerated = true;
                rboLabelGeneration.update();
            }
        }
        else if (_labelType == RetailLabelTypeBase::ItemLabel && (_retailSharedParameters.ItemLabelCreation != RetailLabelCreationBase::None))
        {
            while select forupdate rboLabelGeneration
                where rboLabelGeneration.itemLabelGenerated == false
            {
                this.checkLabelSetup(rboLabelGeneration.itemId, _labelType);
                rboLabelGeneration.itemLabelGenerated = true;
                rboLabelGeneration.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBarcode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for returning the value in InventItemBarcode.itemBarCode field.
    /// </summary>
    /// <param name="_itemId">
    /// ID of the InventTableModule.ItemId field.
    /// ID of the InventItemBarcode.ItemId field.
    /// </param>
    /// <param name="_variant">
    /// ID of the InventItemBarcode.RetailVariantId field.
    /// </param>
    /// <param name="_UOM">
    /// ID of the InventItemBarcode.UnitID field.
    /// </param>
    /// <returns>
    /// InventItemBarcode.itemBarCode
    /// </returns>
    itemBarcode getBarcode(ItemId _itemId,RetailVariantId _variant,UnitOfMeasureSymbol _UOM)
    {
        UnitOfMeasureSymbol  unitOM;
        InventItemBarcode   inventItemBarcode;

        if (_UOM == "")
            unitOM = InventTableModule::find(_itemId,ModuleInventPurchSales::Sales).UnitId;
        else
            unitOM = _UOM;

        inventItemBarcode = InventItemBarcode::findRetail(_itemId,_variant,unitOM,true);

        if (!inventItemBarcode)
            inventItemBarcode = InventItemBarcode::findRetail(_itemId,_variant,unitOM,false);

        return inventItemBarcode.itemBarCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markLabelGeneration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method updates the record if the record exists in <c>RetailLabelGeneration</c> table; else creates the new record.
    /// </summary>
    /// <param name="_itemId">
    /// ID of the RetailLabelGeneration.itemId field.
    /// </param>
    void markLabelGeneration(ItemId _itemId)
    {
        RetailLabelGeneration  rboLabelGeneration;
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();

        ttsbegin;

        if (RetailLabelGeneration::exist(_itemId))
        {
            rboLabelGeneration = RetailLabelGeneration::find(_itemId, true);

            if (rboLabelGeneration.shelfLabelGenerated == true && retailSharedParameters.ShelfLabelCreation != RetailLabelCreationBase::None)
            {
                rboLabelGeneration.shelfLabelGenerated = false;
                rboLabelGeneration.update();
            }
            if (rboLabelGeneration.itemLabelGenerated == true && retailSharedParameters.ItemLabelCreation != RetailLabelCreationBase::None)
            {
                rboLabelGeneration.itemLabelGenerated = false;
                rboLabelGeneration.update();
            }
        }
        else
        {
            rboLabelGeneration.clear();
            rboLabelGeneration.itemId = _itemId;
            if (retailSharedParameters.ShelfLabelCreation != RetailLabelCreationBase::None)
            {
                rboLabelGeneration.shelfLabelGenerated = false;
            }
            if (retailSharedParameters.ItemLabelCreation != RetailLabelCreationBase::None)
            {
                rboLabelGeneration.itemLabelGenerated = false;
            }
            rboLabelGeneration.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailInventItemLabel.StoreId field.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <remarks>
    /// RetailLabelUtils.updLabels method creates record in <c>RetailInventItemLabel</c> table.
    /// </remarks>
    void processLabels(RetailStoreId _storeId, RetailInventItemLabelSetup _labelSetup)
    {
        InventDimCombination    combinations;
        InventItemBarcode       barcodes;
        InventItemBarcode       variantBarcodes;
        UnitOfMeasureSymbol     unitIdBuffer;
        int barcodeCount;

        unitIdBuffer = InventTableModule::find(_labelSetup.ItemId, ModuleInventPurchSales::Sales).UnitId;

        if (this.checkRetailLabelTypeBaseForProcessLabels(_labelSetup))
        {
            if (variantExists == true)
            {
                while select ItemId, RetailVariantId from combinations
                where combinations.ItemId == _labelSetup.ItemId
                {
                    // find the unitId and ItemBarcode if barcode setup exists for variant.
                    select firstonly UnitID, ItemBarCode, useForPrinting from variantBarcodes
                        where variantBarcodes.RetailVariantId == combinations.RetailVariantId;

                    if (variantBarcodes)
                    {
                        unitIdBuffer = variantBarcodes.UnitID;
                    }

                    if (!variantBarcodes || variantBarcodes.useForPrinting)
                    {
                        this.updateLabels(_storeId, combinations.RetailVariantId, unitIdBuffer, _labelSetup, variantBarcodes.itemBarCode);
                    }

                    // Default it with item's setup if there is no barcode for variant.
                    unitIdBuffer = InventTableModule::find(_labelSetup.ItemId, ModuleInventPurchSales::Sales).UnitId;
                }
            }
            else
            {
                barcodeCount = 0;
                while select UnitID, itemBarCode from barcodes
                    where barcodes.itemId == _labelSetup.ItemId && barcodes.UseforPrinting
                {
                    // for each Unit of Measure (UOM) that has a barcode for the Item...
                    unitIdBuffer = barcodes.UnitID;
                    this.updateLabels(_storeId, '', unitIdBuffer, _labelSetup, barcodes.itemBarCode);
                    barcodeCount += 1;
                }

                if (barcodeCount == 0)
                {
                    RetailInventTable retailInventTable;
                    ItemBarCode _itemBarCode = retailInventTable.defaultBarcode(_labelSetup.ItemId);

                    select firstonly UseforPrinting from barcodes
                        where barcodes.itemId == _labelSetup.ItemId && barcodes.itemBarCode ==_itemBarCode;
                    // There is no barcode - use standard
                    if (!barcodes || barcodes.UseforPrinting)
                    {
                        this.updateLabels(_storeId, '', unitIdBuffer, _labelSetup, _itemBarCode);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRetailLabelTypeBaseForProcessLabels</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks label type in <c>RetailInventItemLabelSetup</c> table buffer.
    /// </summary>
    /// <param name="_labelSetup">
    ///     Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <returns>
    ///     true for known label types; otherwise, false. New label types can also be added to the return expression using this extensible method.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkRetailLabelTypeBaseForProcessLabels(RetailInventItemLabelSetup _labelSetup)
    {
        return _labelSetup.LabelType == RetailLabelTypeBase::ItemLabel || _labelSetup.LabelType == RetailLabelTypeBase::ShelfLabel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method is used for processing the labels if the record exist in <c>RetailStoreTable</c> for the <c>_storeId</c>.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailStoreTable.StoreId field.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <remarks>
    /// RetailUtils::ItemValidInStore method returns true if the RetailInventItemLabelSetup.ItemId is valid for the store <c>_storeId</c>.
    /// RetailLabelUtils.checkVariants method returns false if there is no record in <c>InventDimCombination</c> table for the <c>_itemId</c>; else true.
    /// RetailLabelUtils.processLabels method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </remarks>
    public void runLabels(RetailStoreId _storeId, RetailInventItemLabelSetup _labelSetup)
    {
        RetailStoreTable   rboStoreTable;

        rboStoreTable = RetailStoreTable::find(_storeId);
        if (rboStoreTable.RecId)
        {
            if (RetailUtils::ItemValidInStore(_labelSetup.ItemId,_storeId))
            {
                this.runLabelsForExistingRecords(_storeId, _labelSetup, rboStoreTable);
                this.processLabels(_storeId,_labelSetup);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runLabelsForExistingRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Extensible method used for processing the labels if the record exist in <c>RetailStoreTable</c> for the <c>_storeId</c>.
    /// </summary>
    /// <param name="_storeId">
    ///     ID of the RetailStoreTable.StoreId field.
    /// </param>
    /// <param name="_labelSetup">
    ///     Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <param name = "_rboStoreTable">
    ///     <c>RetailStoreTable</c> table buffer.
    /// </param>
    [Wrappable(true)]
    protected final void runLabelsForExistingRecords(RetailStoreId _storeId, RetailInventItemLabelSetup _labelSetup, RetailStoreTable _rboStoreTable)
    {
        if (_labelSetup.LabelType == RetailLabelTypeBase::ShelfLabel && _rboStoreTable.generatesShelfLabels)
        {
            VariantExists = false;
            if (RetailInventTable::find(_labelSetup.ItemId).printVariantsShelfLabels)
            {
                VariantExists = this.checkVariants(_labelSetup.ItemId);
            }
            shelfLabelReports++;
        }
        else if (_labelSetup.LabelType == RetailLabelTypeBase::ItemLabel && _rboStoreTable.generatesItemLabels)
        {
            VariantExists = this.checkVariants(_labelSetup.ItemId);
            itemLabelReports++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificLabelOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </summary>
    /// <param name="_labelType">
    /// <c>RetailLabelTypeBase</c>
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStoreTable.storeId field.
    /// </param>
    /// <param name="_itemId">
    /// ID of the InventTable.ItemId field.
    /// </param>
    /// <param name="_validDate">
    /// ID of RetailLabelValidOnDate.validDate field.
    /// </param>
    /// <remarks>
    /// this.checkLabelSetup method is called to create the record in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </remarks>
    void specificLabelOrder(RetailLabelTypeBase _labelType,RetailStoreId _storeId, ItemId _itemId, RetailLabelValidOnDate _validDate)
    {
        specificOrder = true;
        this.checkLabelSetup(_itemId,_labelType,_storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdLabelBeforeToday</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the records from the <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_labelType">
    /// <c>RetailLabelType</c>
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailInventItemLabel.StoreId field.
    /// </param>
    /// <remarks>
    /// RetailLabelUtils.checkLabelSetup method is used for creating the records in <c>RetailInventItemLabel</c> for the <c>_itemId</c>.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Throws error if <c>_storeId</c> is blank.
    /// </exception>
    void UpdLabelBeforeToday(RetailLabelType _labelType, RetailStoreId _storeId)
    {
        //Called on opening printing form
        RetailInventItemLabel  rboInventItemLabel;

        ItemId              itemIdBuffer = "";

        if (_storeId == "")
            throw error("@RET4131");

        ttsbegin;

        while select forupdate rboInventItemLabel
        index hint UpdToNewDateIdx
        Order by ItemId                       //Group by ?
        where rboInventItemLabel.LabelType == _labelType
        &&    rboInventItemLabel.StoreId == _storeId
        &&    rboInventItemLabel.ValidOnDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
        &&    rboInventItemLabel.Printed == false
        {
            if (itemIdBuffer != rboInventItemLabel.ItemId)
            {
                itemIdBuffer = rboInventItemLabel.ItemId;
                rboInventItemLabel.delete();
                this.checkLabelSetup(rboInventItemLabel.ItemId,_labelType,_storeId);
            }
            else
                rboInventItemLabel.delete();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method creates the record in <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailInventItemLabel.StoreId field.
    /// </param>
    /// <param name="_variant">
    /// ID of the RetailInventItemLabel.VariantId field.
    /// </param>
    /// <param name="_UOM">
    /// ID of the RetailInventItemLabel.UnitID field.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <param name="_itemBarCode">
    /// Barcode of the Item.
    /// </param>
    void updateLabels(RetailStoreId _storeId, RetailVariantId _variant, UnitOfMeasureSymbol _UOM, RetailInventItemLabelSetup _labelSetup, ItemBarCode _itemBarCode = '')
    {
        RetailInventItemLabel  rboInventItemLabel;
        real    priceOnLabel, compPriceOnLabel;
        real    retailPrice;    //updLabel
        date    dateFromPriceATH;

        select firstonly rboInventItemLabel
            order by ValidOnDate desc
            where rboInventItemLabel.LabelType == _labelSetup.LabelType
            &&    rboInventItemLabel.ItemId == _labelSetup.ItemId
            &&    rboInventItemLabel.StoreId == _storeId
            &&    rboInventItemLabel.VariantId == _variant
            &&    rboInventItemLabel.UnitID == _UOM
            &&    rboInventItemLabel.ReportName == _labelSetup.ReportName
            &&    rboInventItemLabel.ItemBarCode == _itemBarCode;

        if (rboInventItemLabel)
        {
            priceOnLabel = rboInventItemLabel.Price;
            compPriceOnLabel = rboInventItemLabel.CompLabelPrice;
        }

        dateFromPriceATH = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        retailPrice = RetailPricingEngine::getRetailPriceByItem(_storeId, _labelSetup.ItemId, _UOM, InventDimCombination::findVariantId(_variant).InventDimId, DateTimeUtil::newDateTime(dateFromPriceATH, DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone())), _variant);

        if ( (priceOnLabel != retailPrice) ||
             (compPriceOnLabel != RetailPriceUtilities::calcComparisonPrice(_labelSetup.ItemId, retailPrice)))
        {
            this.createLabelsBarcode(_storeId,dateFromPriceATH,_variant,_UOM,0,_labelSetup,_itemBarCode,retailPrice);
            priceOnLabel = retailPrice;
            compPriceOnLabel = RetailPriceUtilities::calcComparisonPrice(_labelSetup.ItemId,retailPrice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemLabelSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds and returns the buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </summary>
    /// <param name="_labelType">
    /// ID of the RetailInventItemLabelSetup.LabelType field.
    /// </param>
    /// <param name="_itemId">
    /// ID of the RetailInventItemLabelSetup.ItemId field.
    /// </param>
    /// <param name="_reportName">
    /// ID of the RetailInventItemLabelSetup.ReportName field.
    /// </param>
    /// <returns>
    /// Table buffer of <c>RetailInventItemLabelSetup</c>.
    /// </returns>

    static RetailInventItemLabelSetup findItemLabelSetup(RetailLabelTypeBase _labelType, ItemId  _itemId, RetailReportName  _reportName)
    {
        RetailInventItemLabelSetup labelSetup2;
        ;
        select firstonly labelSetup2
        where   labelSetup2.LabelType == _labelType
        &&      labelSetup2.ItemId == _itemId

        &&      labelSetup2.ReportName == _reportName;

        return labelSetup2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLabelSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds and returns the buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </summary>
    /// <param name="_labelType">
    /// ID of the RetailInventItemLabelSetup.LabelType field.
    /// </param>
    /// <param name="_itemId">
    /// ID of the RetailInventItemLabelSetup.ItemId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStoreId.storeId field.
    /// </param>
    /// <returns>
    /// Table buffer of <c>RetailInventItemLabelSetup</c>.
    /// </returns>
    static RetailInventItemLabelSetup findLabelSetup(RetailLabelTypeBase _labelType, ItemId  _itemId, RetailStoreId  _storeId)
    {
        RetailInventItemLabelSetup labelSetup2;

        select firstonly labelSetup2
        where   labelSetup2.LabelType == _labelType
        &&      labelSetup2.ItemId == _itemId;

        return labelSetup2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLabelsBarcode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new record in <c>RetailInventItemLabel</c> table if the record does not exist for the given parameters; else updates the record
    /// in <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_storeId">
    /// Store id.
    /// </param>
    /// <param name="_validOnDate">
    /// ValidOnDate field.
    /// </param>
    /// <param name="_variantId">
    /// Variant id of an item.
    /// </param>
    /// <param name="_UOM">
    /// Unit of measure.
    /// </param>
    /// <param name="_specificQty">
    /// <c>Quantity</c> to initialize <c>qty</c>.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <param name="_itemBarCode">
    /// Barcode of an item.
    /// </param>
    /// <param name="_price">
    /// Price of an item.
    /// </param>
    private void createLabelsBarcode(RetailStoreId _storeId,
                                     RetailLabelValidOnDate _validOnDate,
                                     RetailVariantId _variantId,
                                     UnitOfMeasureSymbol _UOM,
                                     real _specificQty, 
                                     RetailInventItemLabelSetup _labelSetup,
                                     ItemBarcode _itemBarCode,
                                     RetailLabelPrice _price)
    {
        progressWindow.setText(strfmt("@RET4130",_labelSetup.ItemId,_variantId));
        progressWindow.incCount();

        if (_labelSetup.LabelType == RetailLabelTypeBase::ShelfLabel)
        {
            // Create shelf labels.
            this.createLabelForTypeShelf(_storeId, _validOnDate, _variantId, _UOM, _specificQty, _labelSetup, _itemBarCode, _price);
        }
        else if(_labelSetup.LabelType == RetailLabelTypeBase::ItemLabel)
        {
            // Create product labels.
            this.createLabelForTypeItem(_storeId, _validOnDate, _variantId, _UOM, _specificQty, _labelSetup, _itemBarCode, _price);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLabelForTypeShelf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new record of type shelf label in <c>RetailInventItemLabel</c> table if the record does not exist for the given parameters; else updates the record
    /// in <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_storeId">
    /// Store id.
    /// </param>
    /// <param name="_validOnDate">
    /// ValidOnDate field.
    /// </param>
    /// <param name="_variantId">
    /// Variant id of an item.
    /// </param>
    /// <param name="_UOM">
    /// Unit of measure.
    /// </param>
    /// <param name="_specificQty">
    /// <c>Quantity</c> to initialize <c>qty</c>.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <param name="_itemBarCode">
    /// Barcode of an item.
    /// </param>
    /// <param name="_price">
    /// Price of an item.
    /// </param>
    [Wrappable(true)]
    protected final void createLabelForTypeShelf(RetailStoreId _storeId,
                                           RetailLabelValidOnDate _validOnDate,
                                           RetailVariantId _variantId,
                                           UnitOfMeasureSymbol _UOM,
                                           real _specificQty, 
                                           RetailInventItemLabelSetup _labelSetup,
                                           ItemBarcode _itemBarCode,
                                           RetailLabelPrice _price)
    {
        InventDimCombination  inventDimCombination;
        real                  qty;
        RetailInventItemLabel rboInventItemLabel;

        qty = _specificQty ? _specificQty : 1;

        rboInventItemLabel = RetailInventItemLabel::findBarcode(_labelSetup.LabelType,_storeId,_labelSetup.ItemId,_variantId,_UOM,_validOnDate,_labelSetup.ReportName,_itemBarCode,true);

        if (rboInventItemLabel)
        {
            if (rboInventItemLabel.Printed == NoYes::Yes)
            {
                rboInventItemLabel.Printed =  NoYes::No;
            }

            rboInventItemLabel.Qty = _specificQty ? (rboInventItemLabel.Qty + qty) : qty;
            rboInventItemLabel.Price = _price;
            rboInventItemLabel.CompLabelPrice = RetailPriceUtilities::calcComparisonPrice(rboInventItemLabel.ItemId,rboInventItemLabel.Price);
            rboInventItemLabel.update();
        }
        else
        {
            rboInventItemLabel.clear();
            rboInventItemLabel.LabelType = _labelSetup.LabelType;
            rboInventItemLabel.ValidOnDate = _validOnDate;
            rboInventItemLabel.VariantId = _variantId;
            rboInventItemLabel.UnitID = _UOM;
            rboInventItemLabel.ItemBarCode = _itemBarCode;
            rboInventItemLabel.StoreId = _storeId;
            rboInventItemLabel.ItemId = _labelSetup.ItemId;
            rboInventItemLabel.ReportName = _labelSetup.ReportName; 
            rboInventItemLabel.Text1 = _labelSetup.Text1 ? _labelSetup.Text1: inventDimCombination.defaultProductName();
            rboInventItemLabel.Qty = qty;
            rboInventItemLabel.Price = _price;
            rboInventItemLabel.CompLabelPrice = RetailPriceUtilities::calcComparisonPrice(rboInventItemLabel.ItemId,rboInventItemLabel.Price);
            rboInventItemLabel.insert();
        }

        shelfLabelCounter += rboInventItemLabel.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLabelForTypeItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new record of type product label in <c>RetailInventItemLabel</c> table if the record does not exist for the given parameters; else updates the record
    /// in <c>RetailInventItemLabel</c> table.
    /// </summary>
    /// <param name="_storeId">
    /// Store id.
    /// </param>
    /// <param name="_validOnDate">
    /// ValidOnDate field.
    /// </param>
    /// <param name="_variantId">
    /// Variant id of an item.
    /// </param>
    /// <param name="_UOM">
    /// Unit of measure.
    /// </param>
    /// <param name="_specificQty">
    /// <c>Quantity</c> to initialize <c>qty</c>.
    /// </param>
    /// <param name="_labelSetup">
    /// Table buffer of <c>RetailInventItemLabelSetup</c> table.
    /// </param>
    /// <param name="_itemBarCode">
    /// Barcode of an item.
    /// </param>
    /// <param name="_price">
    /// Price of an item.
    /// </param>
    [Wrappable(true)]
    protected final void createLabelForTypeItem(RetailStoreId _storeId,
                                          RetailLabelValidOnDate _validOnDate,
                                          RetailVariantId _variantId,
                                          UnitOfMeasureSymbol _UOM,
                                          real _specificQty,
                                          RetailInventItemLabelSetup _labelSetup,
                                          ItemBarcode _itemBarCode,
                                          RetailLabelPrice _price)
    {
        InventDimCombination        inventDimCombination;
        Qty                         qtySoldNotPosted;
        InventQtyAvailPhysical      availPhysical;
        RetailTransactionSalesTrans transactionSalesTrans;
        RetailDescription           tempText1;
        real                        qty;
        RetailInventItemLabel       rboInventItemLabel;

        if (_specificQty)
        {
            qty = _specificQty;
        }
        else
        {
            InventDim inventDim;

            if (_variantId)
            {
                inventDimCombination = InventDimCombination::findVariantId(_variantId);
                inventDim = inventDimCombination.inventDim();
            }

            inventDim.InventLocationId = RetailStoreTable::find(_storeId).inventLocation;
            inventDim.InventSiteId = InventLocation::find(inventDim.InventLocationId).InventSiteId;
            inventDim = InventDim::findOrCreate(inventDim);

            availPhysical = InventAvailabilityProvider::findByItemIdDim(_labelSetup.ItemId, inventDim).parmInventAvailability().availPhysical();

            select sum(qty) from transactionSalesTrans
                where transactionSalesTrans.itemId == _labelSetup.ItemId
                &&    transactionSalesTrans.transactionStatus == RetailEntryStatus::None
                &&    transactionSalesTrans.inventStatusSales == RetailInventStatusSales::None
                &&    transactionSalesTrans.store == _storeId
                &&    transactionSalesTrans.variantId == _variantId;

            qtySoldNotPosted = abs(transactionSalesTrans.qty);

            qty = availPhysical - qtySoldNotPosted;

            if (qty == 0)
            {
                qty = 1;
            }
        }

        rboInventItemLabel = RetailInventItemLabel::findBarcode(_labelSetup.LabelType,_storeId,_labelSetup.ItemId,_variantId,_UOM,_validOnDate,_labelSetup.ReportName,_itemBarCode,true);

        if (rboInventItemLabel)
        {
            if (rboInventItemLabel.Printed == NoYes::Yes)
            {
                rboInventItemLabel.Qty = qty;
                rboInventItemLabel.Printed = NoYes::No;
            }
            else
            {
                rboInventItemLabel.Qty = _specificQty ? (rboInventItemLabel.Qty + qty) : qty;
            }

            rboInventItemLabel.Price = _price;
            rboInventItemLabel.CompLabelPrice = RetailPriceUtilities::calcComparisonPrice(rboInventItemLabel.ItemId,rboInventItemLabel.Price);

            if ((rboInventItemLabel.Qty > 0) || (RetailParameters::find().ItemLabelsForNegativeStock == true) || (_specificQty != 0))
            {
                rboInventItemLabel.update();
                itemLabelCounter += qty;
            }
        }
        else
        {
            rboInventItemLabel.clear();
            rboInventItemLabel.LabelType = _labelSetup.LabelType;
            rboInventItemLabel.ValidOnDate = _validOnDate;
            rboInventItemLabel.ItemBarCode = _itemBarCode;
            rboInventItemLabel.StoreId = _storeId;
            rboInventItemLabel.VariantId = _variantId;
            rboInventItemLabel.UnitID = _UOM;
            rboInventItemLabel.ItemId = _labelSetup.ItemId;
            rboInventItemLabel.ReportName = _labelSetup.ReportName;
            rboInventItemLabel.Text1 = _labelSetup.Text1 ? _labelSetup.Text1: inventDimCombination.defaultProductName();
            rboInventItemLabel.Qty = qty;
            rboInventItemLabel.Price = _price;
            rboInventItemLabel.CompLabelPrice = RetailPriceUtilities::calcComparisonPrice(rboInventItemLabel.ItemId,rboInventItemLabel.Price);

            if ((rboInventItemLabel.Qty > 0) || (RetailParameters::find().ItemLabelsForNegativeStock == true) || (_specificQty != 0))
            {
                rboInventItemLabel.insert();
                itemLabelCounter += qty;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>