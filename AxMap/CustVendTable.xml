<?xml version="1.0" encoding="utf-8"?>
<AxMap xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustVendTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>balanceAllCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes the sum of the transactions in either the <c>VendTrans</c> table, for vendors, or the
    ///    <c>CustTrans</c> table, for customers.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency of the sum to be computed. The default value is the currency of the vendor or customer.
    /// </param>
    /// <returns>
    ///    The sum of the transactions.
    /// </returns>
    display AmountCur balanceAllCurrency(CurrencyCode _currencyCode = this.Currency)
    {
        CustVendTrans custVendTrans = this.transBuffer();
        AmountCur balance;

        while select sum(AmountCur), sum(AmountMST), sum(ExchAdjustment) from custVendTrans
            group by CurrencyCode
            where custVendTrans.AccountNum == this.AccountNum
        {
            if (custVendTrans.CurrencyCode == _currencyCode)
            {
                balance += custVendTrans.AmountCur;
            }
            else
            {
                balance += CurrencyExchangeHelper::curAmount(custVendTrans.AmountMST + custVendTrans.ExchAdjustment, _currencyCode);
            }
        }

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceCurrency</Name>
				<Source><![CDATA[
    AmountCur balanceCurrency(FromDate _fromDate = dateNull(),
                              ToDate _toDate = dateMax(),
                              CurrencyCode _fromCurrency = '',
                              CurrencyCode _toCurrency = '')
    {
        CustVendTrans custVendTrans= this.transBuffer();

        select sum (AmountCur) from custVendTrans
            group by CurrencyCode
            where custVendTrans.AccountNum == this.AccountNum &&
                  custVendTrans.TransDate >= _fromDate &&
                  custVendTrans.TransDate <= _toDate &&
                  custVendTrans.CurrencyCode >= _fromCurrency &&
                  (!_toCurrency || custVendTrans.CurrencyCode <= _toCurrency);

        return custVendTrans.AmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceMST</Name>
				<Source><![CDATA[
    AmountMST balanceMST(FromDate _fromDate = dateNull(),
                         ToDate _toDate = dateMax())
    {
        CustVendTrans custVendTrans = this.transBuffer();

        if (custVendTrans.TableId == tableNum(CustTrans))
        {
            if (!hasFieldAccess(tableNum(CustTrans), fieldNum(CustTrans, AmountMST), AccessType::View))
                throw error("@SYS57330");
        }

        select sum(AmountMST) from custVendTrans
            where custVendTrans.AccountNum == this.AccountNum &&
                  custVendTrans.TransDate >= _fromDate &&
                  custVendTrans.TransDate <= _toDate;

        return custVendTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearingAccount</Name>
				<Source><![CDATA[
    display LedgerAccount clearingAccount(PostingProfile _postingProfile = '',
                                          CustVendAC _accountNum = this.AccountNum)
    {
        return this.clearingAccountGroup(_accountNum, _postingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearingLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount clearingLedgerDimension(PostingProfile _postingProfile = '',
        CustVendAC _accountNum = this.AccountNum)
    {
        return this.clearingLedgerDimensionGroup(_accountNum, _postingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContactForParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether contact for party is correct.
    /// </summary>
    /// <param name = "_allowEmpty">allow empty</param>
    /// <param name = "_contactPersonId">contact persion id to be validated</param>
    /// <param name = "_dirPartyRecId">expected party recid</param>
    /// <returns>True if contact for party is correct; Otherwise false</returns>
    internal static boolean validateContactForParty(boolean _allowEmpty, ContactPersonId _contactPersonId, DirPartyRecId _dirPartyRecId)
    {
        boolean ret = false;
        if (_contactPersonId)
        {
            ret = ContactPerson::find(_contactPersonId).ContactForParty == _dirPartyRecId;
        }
        else
        {
            ret = _allowEmpty;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editContactPersonName</Name>
				<Source><![CDATA[
    edit ContactPersonName editContactPersonName(boolean _set, ContactPersonName _name)
    {
        ContactPerson contactPerson;
        DirPerson person;
        fieldId whereFieldId;
        fieldId partyFieldId;
        Common custVendTable;
        CustTable custTable;
        VendTable vendTable;

        if (_set)
        {
            if (_name)
            {
                contactPerson = ContactPerson::find(_name);
                this.ContactPersonId = contactPerson.ContactPersonId;

                if (CustVendTable::validateContactForParty(false, this.ContactPersonId, this.Party))
                {
                    _name = contactPerson.personName();
                }
                else
                {
                    switch (this.TableId)
                    {
                        case tableNum(CustTable):
                            custVendTable = custTable;
                            whereFieldId = fieldNum(CustTable, AccountNum);
                            partyFieldId = fieldNum(CustTable, Party);
                            break;
                        case tableNum(VendTable):
                            custVendTable = vendTable;
                            whereFieldId = fieldNum(VendTable, AccountNum);
                            partyFieldId = fieldNum(VendTable, Party);
                            break;
                    }

                    select firstonly ContactPersonId from contactPerson
                        join TableId from custVendTable
                            where custVendTable.(whereFieldId)   == this.AccountNum
                                && contactPerson.ContactForParty == custVendTable.(partyFieldId)
                        join Name from person
                            where person.RecId == contactPerson.Party
                                && person.Name like _name;

                    if (contactPerson.ContactPersonId)
                    {
                        this.ContactPersonId = contactPerson.ContactPersonId;
                        _name = person.Name;
                    }
                    else
                    {
                        this.ContactPersonId = '';
                    }
                }
            }
            else
            {
                this.ContactPersonId = '';
            }
        }
        else
        {
            _name = ContactPerson::find(this.ContactPersonId).personName();
        }
        return _name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>email</Name>
				<Source><![CDATA[
    display Email email()
    {
        LogisticsElectronicAddress electronicAddress;

        electronicAddress = DirParty::primaryElectronicAddress(this.Party, LogisticsElectronicAddressMethodType::Email);

        return electronicAddress ? electronicAddress.Locator : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenPayment</Name>
				<Source><![CDATA[
    CustVendTransOpen firstOpenPayment()
    {
        CustVendTransOpen custVendTransOpen;
        SpecTrans specTrans;

        custVendTransOpen = this.transOpenBuffer();

        switch (custVendTransOpen.TableId)
        {
            case tableNum(CustTransOpen) :
                select firstonly crossCompany specTrans
                    where specTrans.SpecTableId == this.TableId
                        && specTrans.SpecRecId == this.RecId
                        && specTrans.SpecCompany == this.company()
                join firstonly custVendTransOpen
                    where custVendTransOpen.TableId == specTrans.RefTableId
                        && custVendTransOpen.RecId == specTrans.RefRecId
                        && custVendTransOpen.DataAreaId == specTrans.RefCompany
                        && custVendTransOpen.AmountCur < 0;
                break;

            case tableNum(VendTransOpen) :
                select firstonly crossCompany RecId from specTrans
                    where specTrans.SpecTableId == this.TableId
                        && specTrans.SpecRecId == this.RecId
                        && specTrans.SpecCompany == this.company()
                join firstonly custVendTransOpen
                    where custVendTransOpen.TableId == specTrans.RefTableId
                        && custVendTransOpen.RecId == specTrans.RefRecId
                        && custVendTransOpen.DataAreaId == specTrans.RefCompany
                        && custVendTransOpen.AmountCur > 0;

                break;

            default :
                throw error(Error::missingRecord(funcName()));
        }

        return custVendTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstSettledPayment</Name>
				<Source><![CDATA[
    CustVendSettlement firstSettledPayment()
    {
        CustVendSettlement custVendSettlement;
        SpecTrans specTrans;

        custVendSettlement = this.settlementBuffer();

        switch (custVendSettlement.TableId)
        {
            case tableNum(CustSettlement) :
                select firstonly crossCompany specTrans
                    where specTrans.SpecTableId == this.TableId
                        && specTrans.SpecRecId == this.RecId
                        && specTrans.SpecCompany == this.company()
                join firstonly custVendSettlement
                    where custVendSettlement.TableId == specTrans.RefTableId
                        && custVendSettlement.RecId == specTrans.RefRecId
                        && custVendSettlement.DataAreaId == specTrans.RefCompany
                        && custVendSettlement.SettleAmountCur < 0;

                break;

            case tableNum(VendSettlement) :
                select firstonly crossCompany SpecTableId, SpecRecId from specTrans
                    where specTrans.SpecTableId == this.TableId
                        && specTrans.SpecRecId == this.RecId
                        && specTrans.SpecCompany == this.company()
                join firstonly TransRecId, TransDate from custVendSettlement
                    where custVendSettlement.TableId == specTrans.RefTableId
                        && custVendSettlement.RecId == specTrans.RefRecId
                        && custVendSettlement.DataAreaId == specTrans.RefCompany
                        && custVendSettlement.SettleAmountCur > 0;

                break;

            default :
                throw error(Error::missingRecord(funcName()));
        }

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freeValueCur</Name>
				<Source><![CDATA[
    CreditFreeValueCur freeValueCur(AmountMST _ajustment = 0)
    {
        return CurrencyExchangeHelper::curAmount(this.freeValueMST(_ajustment), this.Currency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>freeValueMST</Name>
				<Source><![CDATA[
    CreditFreeValueMST freeValueMST(AmountMST _adjustment = 0)
    {
        CustVendTrans custVendTrans;
        CreditFreeValueMST freeValueMST;

        if (this.CreditMax)
        {
            custVendTrans = this.transBuffer();

            switch (custVendTrans.TableId)
            {
                case tableNum(CustTrans): freeValueMST = (this.CreditMax - this.openBalanceMST() - _adjustment);
                    break;

                case tableNum(VendTrans): freeValueMST = (this.CreditMax + this.openBalanceMST() - _adjustment);
                    break;
            }
        }

        return freeValueMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the retrieved table buffer from the query for the concrete table represented by the map.
    /// </summary>
    /// <param name="_queryRun">
    ///    The query that contains the concrete table.
    /// </param>
    /// <returns>
    ///    The retrieved table buffer from the query for the concrete table represented by the map.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The map has not been associated with one of the concrete tables represented by the map.
    /// </exception>
    public CustVendTable getFromQuery(QueryRun _queryRun)
    {
        CustVendTable custVendTable;

        switch (this.TableId)
        {
            case tableNum(CustTable):
                custVendTable = _queryRun.get(tableNum(CustTable));
                break;

            case tableNum(VendTable):
                custVendTable = _queryRun.get(tableNum(VendTable));
                break;

            default:
                throw error(Error::missingRecord(funcName()));
        }

        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleDate</Name>
				<Source><![CDATA[
    TransDate getSettleDate(SettleDatePrinc _saveDatePrinciple = SettleDatePrinc::DateOfPayment,
                            TransDate _saveDate = dateNull())
    {
        SettleDatePrinc datePrinciple;
        TransDate saveDate;
        TransDate settleDate;
        SpecTrans specTrans;
        CustVendTransOpen custVendTransOpen = this.transOpenBuffer();
        CustVendSettlement custVendSettlement = this.settlementBuffer();

        datePrinciple = _saveDatePrinciple;
        saveDate = _saveDate;

        switch (datePrinciple)
        {
            case SettleDatePrinc::DaysDate :
                settleDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                break;

            case SettleDatePrinc::SelectDate :
                settleDate = saveDate;
                break;

            case SettleDatePrinc::DateOfPayment :

                select firstonly crossCompany TransDate, RecId, DataAreaId
                    from custVendTransOpen
                    order by TransDate desc
                        join firstonly SpecTableId, SpecRecId, SpecCompany, RefTableId, RefRecId, RefCompany
                        from specTrans
                        where custVendTransOpen.TableId == specTrans.RefTableId
                            && custVendTransOpen.RecId == specTrans.RefRecId
                            && custVendTransOpen.DataAreaId == specTrans.RefCompany
                            && specTrans.SpecTableId == this.TableId
                            && specTrans.SpecRecId == this.RecId
                            && specTrans.SpecCompany == this.company();

                settleDate = custVendTransOpen.TransDate;

                //if We didn't find any open payments, we will look for closed payments because then we must be in a reversal situation
                if (! settleDate)
                {
                    select firstonly crossCompany TransRecId, TransDate, DataAreaId
                        from custVendSettlement
                        order by TransDate desc
                            join firstonly SpecTableId,SpecRecId,SpecCompany
                            from specTrans
                            where custVendSettlement.TableId == specTrans.RefTableId
                                && custVendSettlement.RecId == specTrans.RefRecId
                                && custVendSettlement.DataAreaId == specTrans.RefCompany
                                && specTrans.SpecTableId == this.TableId
                                && specTrans.SpecRecId == this.RecId
                                && specTrans.SpecCompany == this.company();

                    settleDate = custVendSettlement.TransDate;
                }
                break;

            default :
                settleDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return settleDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStructDepartment_RU</Name>
				<Source><![CDATA[
    public StructDepartment_RU getStructDepartment_RU()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupId</Name>
				<Source><![CDATA[
    SysGroup groupId()
    {
        return this.GroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChangedInQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the concrete table represented by the map has changed in the query.
    /// </summary>
    /// <param name="_queryRun">
    ///    The query that contains the concrete table.
    /// </param>
    /// <returns>
    ///    true if the concrete table represented by the map has changed in the query; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The map has not been associated with one of the concrete tables represented by the map.
    /// </exception>
    public boolean hasChangedInQuery(QueryRun _queryRun)
    {
        boolean hasTransactionChanged = false;

        switch (this.TableId)
        {
            case tableNum(CustTable):
                hasTransactionChanged = _queryRun.changed(tableNum(CustTable));
                break;

            case tableNum(VendTable):
                hasTransactionChanged = _queryRun.changed(tableNum(VendTable));
                break;

            default:
                throw error(Error::missingRecord(funcName()));
        }

        return hasTransactionChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConsDayValid_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether consolidation day is set correctly.
    /// </summary>
    /// <returns>
    /// Returns true when value is between 0 and 31. Otherwise, returns false.
    /// </returns>
    public boolean isConsDayValid_JP()
    {
        #define.MinConsDayZero(0)
        #define.MaxConsDayThirtyOne(31)

        return this.ConsDay_JP >= #MinConsDayZero
            && this.ConsDay_JP <= #MaxConsDayThirtyOne;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastInvoice</Name>
				<Source><![CDATA[
    CustVendInvoiceJour lastInvoice(CustVendInvoiceJour _custVendInvoiceJour,
                                    NoYes _invoiceCustomer = NoYes::Yes)
    {
        select firstonly _custVendInvoiceJour
            order by InvoiceDate desc , InvoiceNum desc
            where (_custVendInvoiceJour.InvoiceAccount == this.AccountNum && _invoiceCustomer) ||
                  (_custVendInvoiceJour.OrderAccount == this.AccountNum && !_invoiceCustomer) &&
                   _custVendInvoiceJour.InvoiceNum;

        return _custVendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedBankCentralBankPurposeCode</Name>
				<Source><![CDATA[
    void modifiedBankCentralBankPurposeCode()
    {
        this.BankCentralBankPurposeText = BankCentralBankPurpose::find(this.BankCentralBankPurposeCode).Text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    Name name()
    {
        return DirPartyTable::findRec(this.Party).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceCur</Name>
				<Source><![CDATA[
    public AmountCur openBalanceCur(TransDate _fromDate = dateNull(),
                                    TransDate _toDate = dateMax(),
                                    TransDate _assessmentDate = dateNull(),
                                    CurrencyCode _currency = CompanyInfoHelper::standardCurrency())
    {
        CustVendTrans custVendTrans;
        CustVendTransOpen custVendTransOpen;
        CustVendSettlement custVendSettlement;
        AmountCur openBalanceCur;

        custVendTrans = this.transBuffer();

        if (_assessmentDate)
        {
            custVendSettlement = this.settlementBuffer();

            select sum(SettleAmountCur)
                from custVendSettlement
                group by AccountNum
                where custVendSettlement.AccountNum == this.AccountNum
                   && custVendSettlement.TransDate > _assessmentDate
            join custVendTrans
                where custVendTrans.RecId == custVendSettlement.TransRecId
                   && custVendTrans.TransDate >= _fromDate
                   && custVendTrans.TransDate <= _toDate
                   && custVendTrans.CurrencyCode == _currency;

            openBalanceCur = custVendSettlement.SettleAmountCur;
            openBalanceCur += this.openBalanceCur(_fromDate, _toDate, dateNull(), _currency);
        }
        else
        {
            custVendTransOpen = this.transOpenBuffer();

            select custVendTrans
                where custVendTrans.AccountNum == this.AccountNum
                   && custVendTrans.CurrencyCode == _currency
            join sum(AmountCur) from custVendTransOpen
                group by AccountNum
                where custVendTransOpen.RefRecId == custVendTrans.RecId
                   && custVendTransOpen.TransDate >= _fromDate
                   && custVendTransOpen.TransDate <= _toDate;

            openBalanceCur = custVendTransOpen.AmountCur;
        }

        return openBalanceCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceMST</Name>
				<Source><![CDATA[
    AmountMST openBalanceMST(FromDate _fromDate = dateNull(),
                             ToDate _toDate = dateMax(),
                             TransDate _assessmentDate = dateNull())
    {
        CustVendTrans custVendTrans;
        CustVendTransOpen custVendTransOpen;
        CustVendSettlement custVendSettlement;
        AmountMST openBalanceMST;
        boolean hasAccess;

        if (_assessmentDate)
        {
            custVendTrans = this.transBuffer();
            custVendSettlement = this.settlementBuffer();

            switch (custVendTrans.TableId)
            {
                case tableNum(CustTrans) :
                    hasAccess = hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, SettleAmountMST));
                    hasAccess = hasAccess && hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, ExchAdjustment));
                    break;

                case tableNum(VendTrans) :
                    hasAccess = true;
                    break;

                default :
                    hasAccess = false;
            }

            if (!hasAccess)
                throw error("@SYS57330");

            select sum(SettleAmountMST),sum(ExchAdjustment) from custVendSettlement
                group by AccountNum
                where custVendSettlement.AccountNum == this.AccountNum &&
                      custVendSettlement.TransDate > _assessmentDate
            join custVendTrans
                where custVendTrans.RecId == custVendSettlement.TransRecId &&
                      custVendTrans.TransDate >= _fromDate &&
                      custVendTrans.TransDate <= _toDate;

            openBalanceMST = custVendSettlement.SettleAmountMST + custVendSettlement.ExchAdjustment;

            openBalanceMST += this.openBalanceMST(_fromDate, _toDate);
        }
        else
        {
            custVendTransOpen = this.transOpenBuffer();

            select sum(AmountMST) from custVendTransOpen
                where custVendTransOpen.AccountNum == this.AccountNum &&
                      custVendTransOpen.TransDate >= _fromDate &&
                      custVendTransOpen.TransDate <= _toDate;

            openBalanceMST = custVendTransOpen.AmountMST;
        }

        return openBalanceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceReportingCurrency</Name>
				<Source><![CDATA[
    public AmountMSTSecondary openBalanceReportingCurrency(FromDate _fromDate = dateNull(),
                                                            ToDate _toDate = dateMax(),
                                                            TransDate _assessmentDate = dateNull())
    {        
        AmountMSTSecondary reportingCurrencyBalance;
        
        if (_assessmentDate)
        {            
            boolean hasAccess;

            CustVendTrans custVendTrans = this.transBuffer();
            CustVendSettlement custVendSettlement = this.settlementBuffer();

            switch (custVendTrans.TableId)
            {
                case tableNum(CustTrans) :
                    hasAccess = hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, SettleAmountReporting));
                    hasAccess = hasAccess && hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, ExchAdjustment));
                    break;

                case tableNum(VendTrans) :
                    hasAccess = true;
                    break;

                default :
                    hasAccess = false;
            }

            if (!hasAccess)
                throw error("@SYS57330");                       

            select sum(SettleAmountReporting),sum(ExchAdjustment) from custVendSettlement                
                where custVendSettlement.AccountNum == this.AccountNum &&
                      custVendSettlement.TransDate > _assessmentDate
            join custVendTrans
                where custVendTrans.RecId == custVendSettlement.TransRecId &&
                      custVendTrans.TransDate >= _fromDate &&
                      custVendTrans.TransDate <= _toDate;

            reportingCurrencyBalance = custVendSettlement.SettleAmountReporting + custVendSettlement.ExchAdjustment;

            reportingCurrencyBalance += this.openBalanceReportingCurrency(_fromDate, _toDate);
        }
        else
        {
            CustVendTransOpen custVendTransOpen = this.transOpenBuffer();

            select sum(ReportingCurrencyAmount) from custVendTransOpen
                where custVendTransOpen.AccountNum == this.AccountNum &&
                      custVendTransOpen.TransDate >= _fromDate &&
                      custVendTransOpen.TransDate <= _toDate;

            reportingCurrencyBalance = custVendTransOpen.ReportingCurrencyAmount;
        }

        return reportingCurrencyBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceMSTDoc</Name>
				<Source><![CDATA[
    AmountMST openBalanceMSTDoc(TransDate _transDate = dateNull(),
                                FromDate _fromDate = dateNull(),
                                ToDate _toDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustVendTrans custVendTrans = this.transBuffer();
        CustVendTransOpen custVendTransOpen = this.transOpenBuffer();

        select sum(AmountMST) from custVendTransOpen
            order by RefRecId
            where custVendTransOpen.AccountNum == this.AccountNum &&
                  custVendTransOpen.TransDate <= _transDate
         exists join custVendTrans
            where custVendTrans.RecId == custVendTransOpen.RefRecId &&
                 ((custVendTrans.DocumentDate &&
                   custVendTrans.DocumentDate >= _fromDate &&
                   custVendTrans.DocumentDate <= _toDate) ||
                  (!custVendTrans.DocumentDate &&
                   custVendTrans.TransDate >= _fromDate &&
                   custVendTrans.TransDate <= _toDate)) ;

        return custVendTransOpen.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceMSTDue</Name>
				<Source><![CDATA[
    AmountMST openBalanceMSTDue(TransDate _transDate = dateNull(),
                                FromDate _fromDate = dateNull(),
                                ToDate _toDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustVendTransOpen custVendTransOpen = this.transOpenBuffer();

        select sum(AmountMST) from custVendTransOpen
            where custVendTransOpen.AccountNum == this.AccountNum &&
                  custVendTransOpen.TransDate <= _transDate &&
                  custVendTransOpen.DueDate >= _fromDate &&
                  custVendTransOpen.DueDate <= _toDate;

        return custVendTransOpen.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyINNasOfDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns customer or vendor INN on specified date
    /// </summary>
    /// <param name="_date">
    /// Date at which data should be retrived
    /// </param>
    /// <returns>
    /// Customer or vendor INN on specified date
    /// </returns>
    public INN_RU partyINNasOfDate_RU(TransDate _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return TaxRegistration::legislationRegistrationValue(this.Party, TaxRegistrationTypesList::INN, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyKPPasOfDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns customer or vendor KPP on specified date
    /// </summary>
    /// <param name="_date">
    /// Date at which data should be retrived
    /// </param>
    /// <returns>
    /// Customer or vendor KPP on specified date
    /// </returns>
    public INN_RU partyKPPasOfDate_RU(TransDate _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return TaxRegistration::legislationRegistrationValue(this.Party, TaxRegistrationTypesList::KPP, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyOKDPasOfDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns customer or vendor OKDP on specified date
    /// </summary>
    /// <param name="_date">
    /// Date at which data should be retrived
    /// </param>
    /// <returns>
    /// Customer or vendor OKDP on specified date
    /// </returns>
    public OKDP_RU partyOKDPasOfDate_RU(TransDate _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return TaxRegistration::legislationRegistrationValue(this.Party, TaxRegistrationTypesList::OKDP, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyOKPOasOfDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns customer or vendor OKPO on specified date
    /// </summary>
    /// <param name="_date">
    /// Date at which data should be retrived
    /// </param>
    /// <returns>
    /// Customer or vendor OKPO on specified date
    /// </returns>
    public OKPO_RU partyOKPOasOfDate_RU(TransDate _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return TaxRegistration::legislationRegistrationValue(this.Party, TaxRegistrationTypesList::OKPO, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeModified</Name>
				<Source><![CDATA[
    void paymModeModified()
    {
        this.PaymModeMap::modifiedPaymMode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymName</Name>
				<Source><![CDATA[
    display Description paymName()
    {
        return PaymTerm::find(this.PaymTermId).Description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>phone</Name>
				<Source><![CDATA[
    display Phone phone()
    {
        LogisticsElectronicAddress electronicAddress;

        electronicAddress = DirParty::primaryElectronicAddress(this.Party, LogisticsElectronicAddressMethodType::Phone);

        return electronicAddress ? electronicAddress.Locator : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>telefax</Name>
				<Source><![CDATA[
    display TeleFax telefax()
    {
        LogisticsElectronicAddress electronicAddress;

        electronicAddress = DirParty::primaryElectronicAddress(this.Party, LogisticsElectronicAddressMethodType::Fax);

        return electronicAddress ? electronicAddress.Locator : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findModule</Name>
				<Source><![CDATA[
    static CustVendTable findModule(ModuleCustVend _moduleCustVend,
                                    CustVendAC _custVendAC,
                                    boolean _forUpdate = false)
    {
        CustVendTable custVendTable;

        if (_custVendAC)
        {
            switch (_moduleCustVend)
            {
                case ModuleCustVend::Cust :
                    custVendTable = CustTable::find(_custVendAC, _forUpdate);
                    break;

                case ModuleCustVend::Vend :
                    custVendTable = VendTable::find(_custVendAC, _forUpdate);
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConsStartDate_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the consolidation start date.
    /// </summary>
    /// <param name="_accountNum">
    /// The account number
    /// </param>
    /// <param name="_consEndDate">
    /// The consolidation end date
    /// </param>
    /// <param name="_custVendACType">
    /// The customer or vendor
    /// </param>
    /// <returns>
    /// The consolidation start date
    /// </returns>
    public static CustVendConsDate_JP getConsStartDate_JP(
        CustVendAC _accountNum,
        CustVendConsDate_JP _consEndDate,
        CustVendACType _custVendACType)
    {
        CustVendConsDay_JP custVendConsDay_JP;

        if (_custVendACType == CustVendACType::Cust)
        {
            custVendConsDay_JP = CustTable::find(_accountNum).ConsDay_JP;
        }
        else
        {
            custVendConsDay_JP = VendTable::find(_accountNum).ConsDay_JP;
        }

        return dateStartMth(prevMth(_consEndDate)) + custVendConsDay_JP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the default dimension.
    /// </summary>
    /// <param name="_moduleCustVend">
    ///    The module consuming the map.
    /// </param>
    /// <param name="_accountNum">
    ///    The account number
    /// </param>
    /// <returns>
    ///    The default dimension.
    /// </returns>
    public static DimensionDefault getDefaultDimension(ModuleCustVend _moduleCustVend, CustVendAC _accountNum)
    {
        CustVendTable custVendTable = CustVendTable::getEmptyTableBuffer(_moduleCustVend);

        select firstonly DefaultDimension from custVendTable
            where custVendTable.AccountNum == _accountNum;

        return custVendTable.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmptyTableBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an empty table buffer for the concrete table represented by the map.
    /// </summary>
    /// <param name="_moduleCustVend">
    ///    The module consuming the map.
    /// </param>
    /// <returns>
    ///    An empty table buffer for the concrete table represented by the map.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The map has not been associated with one of the concrete tables represented by the map.
    /// </exception>
    public static CustVendTable getEmptyTableBuffer(ModuleCustVend _moduleCustVend)
    {
        CustVendTable custVendTable;
        CustTable custTable;
        VendTable vendTable;

        if (_moduleCustVend == ModuleCustVend::Cust)
        {
            custVendTable = custTable.data();
        }
        else
        {
            custVendTable = vendTable.data();
        }

        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTaxInformation_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Get default tax information of current customer's invoice address.
    /// </summary>
    /// <returns>
    /// The tax information from customer's invoice address.
    /// </returns>
    /// <remarks>
    /// If customer has no invoice address, the primary address will be returned.
    /// </remarks>
    public TaxInformation_TH getDefaultTaxInformation_TH()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTaxRegistration_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Get default tax registration of current customer's invoice address.
    /// </summary>
    /// <param name="_transDate">
    /// The effective date of tax registration, default is today.
    /// </param>
    /// <returns>
    /// The tax registration from customer's invoice address.
    /// </returns>
    /// <remarks>
    /// If customer has no invoice address, the primary address will be returned.
    /// </remarks>
    public TaxRegistration getDefaultTaxRegistration_TH(TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrimaryRegistrationNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets registration number for primary address of the given CustVendTable mapped cursor on a date.
    /// </summary>
    /// <param name = "_type">Type of requeried registration number.</param>
    /// <param name = "_date">Date on which to get registration number, by default today.</param>
    /// <returns>
    /// Registration number for primary address of the given CustVendTable mapped cursor on a date
    /// </returns>
    public TaxRegistrationNumber getPrimaryRegistrationNumber(TaxRegistrationTypesList _type,
                                                              date                     _date  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        Common common = this;
        TaxRegistrationNumber registrationNumber;
        if (SysDictTable::isTableMapped(tableNum(DirPartyMap), common.tableId))
        {
            registrationNumber = TaxRegistration::getPrimaryRegistrationNumber(common, _type, _date);
        }

        return registrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBalanceMSTSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the open balances in reporting currency.
    /// </summary>
    /// <param name = "_fromDate">From date; optional.</param>
    /// <param name = "_toDate">To date; optional.</param>
    /// <param name = "_assessmentDate">Assessment date; optional.</param>
    /// <returns>
    /// Returns the open balances in reporting currency.
    /// </returns>
    public AmountMSTSecondary openBalanceMSTSecondary(FromDate _fromDate = dateNull(),
                             ToDate _toDate = dateMax(),
                             TransDate _assessmentDate = dateNull())
    {
        CustVendTrans custVendTrans;
        CustVendTransOpen custVendTransOpen;
        CustVendSettlement custVendSettlement;
        AmountMSTSecondary openBalanceMSTSecondary;
        boolean hasAccess;
    
        if (_assessmentDate)
        {
            custVendTrans = this.transBuffer();
            custVendSettlement = this.settlementBuffer();
    
            switch (custVendTrans.TableId)
            {
                case tableNum(CustTrans) :
                    hasAccess = hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, SettleAmountReporting));
                    hasAccess = hasAccess && hasFieldAccess(tableNum(CustSettlement), fieldNum(CustSettlement, ExchAdjustmentReporting));
                    break;
    
                case tableNum(VendTrans) :
                    hasAccess = true;
                    break;
    
                default :
                    hasAccess = false;
            }
    
            if (!hasAccess)
                throw error("@SYS57330");
    
            select sum(SettleAmountReporting),sum(ExchAdjustmentReporting) from custVendSettlement
                group by AccountNum
                where custVendSettlement.AccountNum == this.AccountNum &&
                      custVendSettlement.TransDate > _assessmentDate
            join custVendTrans
                where custVendTrans.RecId == custVendSettlement.TransRecId &&
                      custVendTrans.TransDate >= _fromDate &&
                      custVendTrans.TransDate <= _toDate;
    
            openBalanceMSTSecondary = custVendSettlement.SettleAmountReporting + custVendSettlement.ExchAdjustmentReporting;
    
            openBalanceMSTSecondary += this.openBalanceMSTSecondary(_fromDate, _toDate);
        }
        else
        {
            custVendTransOpen = this.transOpenBuffer();
    
            select sum(ReportingCurrencyAmount) from custVendTransOpen
                where custVendTransOpen.AccountNum == this.AccountNum &&
                      custVendTransOpen.TransDate >= _fromDate &&
                      custVendTransOpen.TransDate <= _toDate;
    
            openBalanceMSTSecondary = custVendTransOpen.ReportingCurrencyAmount;
        }
    
        return openBalanceMSTSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findModuleByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the customer or vendor record by <c>RecId</c> reference.
    /// </summary>
    /// <param name = "_moduleCustVend">The customer or vendor module.</param>
    /// <param name = "_recId">The <c>RecId</c> for the table record.</param>
    /// <param name = "_forUpdate">Whether to select for update.</param>
    /// <returns>The map for the customer or vendor record.</returns>
    public static CustVendTable findModuleByRecId(
        ModuleCustVend _moduleCustVend,
        RecId _recId,
        boolean _forUpdate = false)
    {
        CustVendTable custVendTable;

        if (_recId)
        {
            switch (_moduleCustVend)
            {
                case ModuleCustVend::Cust :
                    custVendTable = CustTable::findRecId(_recId, _forUpdate);
                    break;

                case ModuleCustVend::Vend :
                    custVendTable = VendTable::findRecId(_recId, _forUpdate);
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        return CustVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRelatedToIncompleteWorkflowWorkItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the customer or vendor is related to incomplete workflow workitems.
    /// </summary>
    /// <returns>true if the customer or vendor is related to incomplete workflow workitems; Otherwise, false.</returns>
    internal boolean isRelatedToIncompleteWorkflowWorkItems()
    {
        WorkflowWorkItemTable workflowWorkItemTable;

        select firstonly RecId from workflowWorkItemTable
            where workflowWorkItemTable.Status != WorkflowWorkItemStatus::Completed
                && workflowWorkItemTable.RefTableId == this.TableId
                && workflowWorkItemTable.RefRecId == this.RecId;

        return workflowWorkItemTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPrimaryRegistrationNumberToVATMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the registration number for the primary address of the given customer or vendor.
    /// And copies the primary registration number, record ID, table ID to a map.
    /// </summary>
    /// <param name = "_vatMapDest">The destination table to copy to.</param>
    /// <param name = "_date">The date to determine primary registration number.</param>
    internal void copyPrimaryRegistrationNumberToVATMap(TaxExemptVATNumMap _vatMapDest, date _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        switch (this.TableId)
        {
            case tableNum(CustTable):
                CustTable custTable = this as CustTable;
                custTable.copyPrimaryRegistrationNumberToVATMap(_vatMapDest, _date);
                break;
            case tableNum(VendTable):
                VendTable vendTable = this as VendTable;
                vendTable.copyPrimaryRegistrationNumberToVATMap(_vatMapDest, _date);
                break;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS125886</DeveloperDocumentation>
	<Label>@SYS86974</Label>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AccountNum</Name>
			<ExtendedDataType>CustVendAC</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>BankAccountId</Name>
			<ExtendedDataType>BankThirdPartyAccountId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>BankCentralBankPurposeCode</Name>
			<ExtendedDataType>BankCentralBankPurposeCode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>BankCentralBankPurposeText</Name>
			<ExtendedDataType>BankCentralBankPurposeText</ExtendedDataType>
			<StringSize>210</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>ConsDay_JP</Name>
			<ExtendedDataType>CustConsDay_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>ContactPersonId</Name>
			<ExtendedDataType>ContactPersonId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>CreditMax</Name>
			<ExtendedDataType>CreditMaxMST</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>Currency</Name>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<StringSize>3</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CustCollectionsContactPersonId</Name>
			<ExtendedDataType>CustCollectionsContactPersonId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CustVendAccount</Name>
			<ExtendedDataType>ExternalAccount</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CustVendAccountExt</Name>
			<ExtendedDataType>CustVendAccountExt</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CustVendCNPJCPF_BR</Name>
			<ExtendedDataType>CNPJCPFNum_BR</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CustVendIE_BR</Name>
			<ExtendedDataType>IENum_BR</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>DefaultDimension</Name>
			<ExtendedDataType>DimensionDefault</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>FactoringAccount</Name>
			<ExtendedDataType>CustVendAC</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>GroupId</Name>
			<ExtendedDataType>CustVendGroupId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>InvoiceAccount</Name>
			<ExtendedDataType>CustVendAC</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>LineOfBusinessId</Name>
			<ExtendedDataType>LineOfBusinessId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>OrgId</Name>
			<ExtendedDataType>OrgId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>Party</Name>
			<ExtendedDataType>DirPartyRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>PartyType</Name>
			<EnumType>DirPartyType</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymDayId</Name>
			<ExtendedDataType>PaymDayId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymId</Name>
			<ExtendedDataType>PaymId</ExtendedDataType>
			<StringSize>200</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymMode</Name>
			<ExtendedDataType>PaymMode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymSchedId</Name>
			<ExtendedDataType>PaymSchedId</ExtendedDataType>
			<StringSize>30</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymSpec</Name>
			<ExtendedDataType>PaymSpec</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymTermId</Name>
			<ExtendedDataType>PaymTermId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxPeriodPaymentCode_PL</Name>
			<ExtendedDataType>PlTaxPeriodPaymentCode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>TaxWithholdCalculate</Name>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS81757</Label>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxWithholdGroup</Name>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>VATNum</Name>
			<ExtendedDataType>VATNum</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>FiscalCode</Name>
			<ExtendedDataType>FiscalCode</ExtendedDataType>
			<StringSize>16</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>CompanyType_MX</Name>
			<EnumType>CompanyType_MX</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>ForeignTaxRegistration_MX</Name>
			<ExtendedDataType>ForeignTaxRegistration_MX</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>Rfc_MX</Name>
			<ExtendedDataType>Rfc_MX</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxGroup</Name>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
		</AxMapBaseField>
	</Fields>
	<Mappings>
		<AxTableMapping>
			<MappingTable>PaymModeMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>PaymMode</MapField>
					<MapFieldTo>PaymMode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PaymSpec</MapField>
					<MapFieldTo>PaymSpec</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
</AxMap>