<?xml version="1.0" encoding="utf-8"?>
<AxMap xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxMap</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Tax.Instrumentation;

public class TaxMap extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getActualTaxExcludingEximTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Actual tax amount excluding the Exim amount.
    /// </summary>
    /// <returns>
    /// Actual Tax Amount.
    /// </returns>
    /// <remarks>
    /// Gets the Actual tax amount excluding the Exim amount.
    /// </remarks>
    public Amount getActualTaxExcludingEximTax_IN()
    {
        TaxUncommitted_IN   taxUncommittedIN;
        EximTaxTrans_IN     eximTaxTrans;
        Amount              actualTax;
        TransDate           customsBillOfEntryDate;

        if (this.TableId == tableNum(TaxTrans))
        {
            eximTaxTrans = EximTaxTrans_IN::findRefRecId(TaxTrans_IN::findRefRecId(this.RecId).RecId);
            actualTax = eximTaxTrans.BalanceTaxCorrectedAmount ? eximTaxTrans.BalanceTaxCorrectedAmount : eximTaxTrans.BalanceTaxAmount;
            if (actualTax && this.CurrencyCode != this.SourceCurrencyCode)
            {
                if (this.SourceTableId == tableNum(vendInvoiceTrans))
                {
                    customsBillOfEntryDate = CustomsVendBoeTrans_IN::getCustomsBillOfEntryDate_IN(this.SourceTableId, this.SourceRecId);
                    if (customsBillOfEntryDate)
                    {
                        actualTax = CurrencyHelper_IN::customsCurAmount_IN(actualTax, this.SourceCurrencyCode, Direction_IN::Import, customsBillOfEntryDate ? customsBillOfEntryDate : this.TransDate);
                    }
                }
            }
            actualTax = actualTax * -1;
        }
        else
        {
            taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);
            actualTax = taxUncommittedIN.EximBalanceTaxCorrectedAmountCur ? taxUncommittedIN.EximBalanceTaxCorrectedAmountCur : taxUncommittedIN.EximBalanceTaxAmountCur;
            actualTax = actualTax * -1;
        }
        return actualTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsExchRate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customs exchange rate.
    /// </summary>
    /// <returns>
    /// The customs exchange rate.
    /// </returns>
    public ExchRate getCustomsExchRate_IN()
    {
        TaxUncommitted_IN           taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);
        TaxUncommitted              taxUncommitteLoc;
        TaxTrans                    taxTrans;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;
        ExchRate                    customsExchRate;
        VendInvoiceInfoLine         vendInvoiceInfoLineCopy;
        TransDate                   documentDate;

        switch (this.TableId)
        {
            case tableNum(TaxUncommitted):
                taxUncommitteLoc = TaxUncommitted::find(this.RecId);
                break;

            case tableNum(TaxTrans):
                taxTrans    = TaxTrans::findRecId_IN(this.RecId);
                break;
        }

        if (taxUncommittedIN)
        {
            if (this.SourceTableId == tableNum(VendInvoiceInfoLine))
            {
                vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findRecId(this.SourceRecId);
                documentDate = vendInvoiceInfoLineCopy.vendInvoiceInfoTable().DocumentDate;
            }

            customsVendBOETrans = VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLineCopy.RecId,
                                                                                vendInvoiceInfoLineCopy.ParmId,
                                                                                vendInvoiceInfoLineCopy.TableId);
            if (customsVendBOETrans)
            {
                select ExchangeRate, RecId from customsVendBOESubTrans
                    where customsVendBOESubTrans.TaxCode       == taxUncommitteLoc.TaxCode
                       && customsVendBOESubTrans.InventTransId == taxUncommitteLoc.InventTransId
                       && customsVendBOESubTrans.boeTransRefRecId == customsVendBOETrans.RecId;
            }
            else
            {
            select ExchangeRate, RecId from customsVendBOESubTrans
                where customsVendBOESubTrans.TaxCode       == taxUncommitteLoc.TaxCode
                   && customsVendBOESubTrans.InventTransId == taxUncommitteLoc.InventTransId;
            }
            customsExchRate = customsVendBOESubTrans.ExchangeRate;

            if (customsExchRate == 0)
            {
                customsExchRate =   TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxUncommitteLoc.SourceCurrencyCode,
                                                                                  taxUncommitteLoc.Source == TaxModuleType::FreeTxtInvoice ? Direction_IN::Export : Direction_IN::Import,
                                                                                  documentDate ? documentDate : taxUncommitteLoc.TransDate);
            }
        }
        else if (taxTrans.taxTrans_W())
        {
            customsExchRate =   TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxTrans.SourceCurrencyCode,
                                                                              taxTrans.Source == TaxModuleType::FreeTxtInvoice ? Direction_IN::Export : Direction_IN::Import,
                                                                              taxTrans.TransDate);
        }

        return customsExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEximIncentiveSchemeTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exim incentive scheme tax.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur getEximIncentiveSchemeTax_IN()
    {
        TaxUncommitted_IN taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);
        TaxUncommitted    taxUncommitteLoc = TaxUncommitted::find(this.RecId);
        TaxAmount         eximTaxAmount;

        eximTaxAmount = (this.TaxAutoGenerated == NoYes::Yes) ? taxUncommittedIN.EximTaxAmount : taxUncommittedIN.EximTaxCorrectedAmount;

        return eximTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEximTaxFromActualTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Exim tax amount from the Actual tax amount.
    /// </summary>
    /// <returns>
    /// Exim Tax Amount.
    /// </returns>
    /// <remarks>
    /// Gets the Exim tax amount from the Actual tax amount.
    /// </remarks>
    public Amount getEximTaxFromActualTax_IN()
    {
        TaxUncommitted_IN   taxUncommittedIN;
        EximTaxTrans_IN     eximTaxTrans;
        Amount              actualEximTax;
        TransDate           customsBillOfEntryDate;
        EximAuthorizationType_IN    authorizationType;
        boolean                     isPostEximVouchers;

        if (this.TableId == tableNum(TaxTrans))
        {
            eximTaxTrans = EximTaxTrans_IN::findRefRecId(TaxTrans_IN::findRefRecId(this.RecId).recId);
            isPostEximVouchers = EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(eximTaxTrans.IncentiveScheme)));
            if (isPostEximVouchers && (eximTaxTrans.TaxCorrectedAmount || eximTaxTrans.TaxAmount))
            {
                actualEximTax = eximTaxTrans.TaxCorrectedAmount ? eximTaxTrans.TaxCorrectedAmount : eximTaxTrans.TaxAmount;
                if (this.CurrencyCode != this.SourceCurrencyCode)
                {
                    if (this.SourceTableId == tableNum(vendInvoiceTrans))
                    {
                        customsBillOfEntryDate = CustomsVendBoeTrans_IN::getCustomsBillOfEntryDate_IN(this.SourceTableId, this.SourceRecId);
                        if (customsBillOfEntryDate)
                        {
                            actualEximTax = CurrencyHelper_IN::customsCurAmount_IN(actualEximTax, this.SourceCurrencyCode, Direction_IN::Import, customsBillOfEntryDate ? customsBillOfEntryDate : this.TransDate);
                        }
                    }
                }
                actualEximTax = actualEximTax * -1;
            }
        }
        else
        {
            taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);
            isPostEximVouchers = EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(taxUncommittedIN.EximIncentiveScheme)));
            if (isPostEximVouchers && (taxUncommittedIN.EximTaxCorrectedAmountCur || taxUncommittedIN.EximTaxAmountCur))
            {
                actualEximTax = taxUncommittedIN.EximTaxCorrectedAmountCur ? taxUncommittedIN.EximTaxCorrectedAmountCur : taxUncommittedIN.EximTaxAmountCur;
                actualEximTax = actualEximTax * -1;
            }
        }
        return actualEximTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the offset ledger dimension from the record.
    /// </summary>
    /// <returns>
    ///   The offset ledger dimension.
    /// </returns>
    public LedgerDimensionAccount getOffsetLedgerDimension_RU()
    {
        LedgerDimensionAccount ledgerDimensionAccount;
        TaxTrans taxTrans;
        TaxUncommitted taxUncommitted;

        switch (this.TableId)
        {
            case tableNum(TaxTrans):
                taxTrans = this;
                ledgerDimensionAccount =  taxTrans.taxTrans_RU().OffsetLedgerDimension_RU;
                break;

            case tableNum(TaxUncommitted):
                taxUncommitted = this;
                ledgerDimensionAccount = taxUncommitted.OffsetLedgerDimension_RU;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceTaxAmount2Distribute_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The payment amount that needs to be reversed during invoice posting.
    /// The reversal can happen to the extent of invoice time tax. ie, less than or equal Invoice Tax.
    /// For cash basis this method will return only LOI amount.
    /// </summary>
    /// <returns>
    /// Container with values holding interim and actual, per TaxCode, upto the selected order line
    /// </returns>
    public container getServiceTaxAmount2Distribute_IN()
    {
        TaxAmountCur        taxAmount2HitIterim;
        TaxAmountCur        taxAmount2HitActual;
        TaxItemGroupHeading taxItemGroupHeadingRev;

        taxItemGroupHeadingRev= TaxItemGroupHeading::find(this.TaxItemGroup);

        if (TaxParameters::isServiceTaxEnable_IN() && taxItemGroupHeadingRev.ServiceTaxBasis_IN != ServiceTaxBasis_IN::None)
        {
            if (taxItemGroupHeadingRev.isGTAVendorTaxItemGroup_IN())
            {
                taxAmount2HitIterim = (this.getTaxAmountBeforeCost() - this.getTaxInCostPrice());
            }
            else
            {
                // if (invoice tax < paym tax), then its servicetax interim tax.So actual will be zero. Else the amount shud be consumed by
                // Standard MonetaryAmount::Tax, so return it to standard caller method.
                [taxAmount2HitActual, taxAmount2HitIterim] = this.TaxMap::interimTax2ReverseByInvoice_IN();
            }
        }

        return [taxAmount2HitActual, taxAmount2HitIterim];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountBeforeCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount before deducting the tax in cost price.
    /// </summary>
    /// <returns>
    /// The tax amount.
    /// </returns>
    public TaxAmountCur getTaxAmountBeforeCost()
    {
        // <GIN>
        TaxUncommitted_IN taxUncommittedIN;
        TaxAmount         eximTaxAmount;
        EximAuthorizationType_IN  authorizationType;

        // For Exim EPCG standard SourceTaxAmountCur(which is customsDuty for customs taxes) is not posted.
        // Instead EximTaxAmount + EximBalaceAmount is posted.
        if (TaxParameters::isCustomsEnable_IN())
        {
            taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);

            if (EximParameters_IN::find().ActivateEPCG
                && taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::EPCG
                && taxUncommittedIN.EximTaxAmount)
            {
                eximTaxAmount = (taxUncommittedIN.EximTaxCorrectedAmount + taxUncommittedIN.EximBalanceTaxCorrectedAmount);
                if (!eximTaxAmount)
                {
                    eximTaxAmount = taxUncommittedIN.EximTaxAmount + taxUncommittedIN.EximBalanceTaxAmount;
                }
                return CurrencyHelper_IN::customsCurAmount_IN(eximTaxAmount,
                                                        TaxUncommitted::find(this.RecId).SourceCurrencyCode,
                                                        Direction_IN::Import,
                                                        this.TransDate);
            }
            // For AAPostVoucher/DFIA PostVoucher is unmarked in EximParameters. do not post EximTaxAmount.
            // Only Exim balance amount should be posted.
            else if (taxUncommittedIN.EximTaxAmount
                    && !EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(taxUncommittedIN.EximIncentiveScheme))))
            {
                eximTaxAmount = taxUncommittedIN.EximBalanceTaxCorrectedAmount ? taxUncommittedIN.EximBalanceTaxCorrectedAmount
                                                                               : taxUncommittedIN.EximBalanceTaxAmount;
                if (eximTaxAmount)
                {
                    return CurrencyHelper_IN::customsCurAmount_IN(eximTaxAmount,
                                                         TaxUncommitted::find(this.RecId).SourceCurrencyCode,
                                                         Direction_IN::Import,
                                                         this.TransDate);
                }
                // When balance amount doesnot exists.
                return 0;
            }
        }
        // </GIN>

        if (this.TaxAutoGenerated == NoYes::Yes)
            return this.SourceTaxAmountCur;
        else
            return this.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the tax in cost price amount of the tax source document line.
    /// </summary>
    /// <returns>
    /// A tax in cost price amount.
    /// </returns>
    public TaxAmountCur getTaxInCostPrice()
    {
        if (this.TaxAutoGenerated == NoYes::Yes)
            return this.TaxInCostPrice;
        else
            return this.TaxInCostPriceRegulated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxReceivableLongTerm_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the post long term receivable tax indicator from the record.
    /// </summary>
    /// <returns>
    ///   The post long term receivable tax indicator.
    /// </returns>
    public TaxReceivableLongTerm_BR getTaxReceivableLongTerm_BR()
    {
        TaxReceivableLongTerm_BR taxReceivableLongTerm_BR;
        TaxTrans taxTrans;
        TaxUncommitted taxUncommitted;

        switch (this.TableId)
        {
            case tableNum(TaxTrans):
                taxTrans = this;
                taxReceivableLongTerm_BR =  taxTrans.taxTrans_BR().TaxReceivableLongTerm_BR;
                break;

            case tableNum(TaxUncommitted):
                taxUncommitted = this;
                taxReceivableLongTerm_BR = taxUncommitted.TaxReceivableLongTerm_BR;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return taxReceivableLongTerm_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVatDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the VAT Due Date from the record.
    /// </summary>
    /// <returns>
    ///   The VATDueDate.
    /// </returns>
    public VatDueDate_W getVatDueDate()
    {
        VatDueDate_W vatDueDate;
        TaxTrans taxTrans;
        TaxUncommitted taxUncommitted;

        switch (this.TableId)
        {
            case tableNum(TaxTrans):
                taxTrans = this;
                vatDueDate =  taxTrans.taxTrans_W().VatDueDate_W;
                break;

            case tableNum(TaxUncommitted):
                taxUncommitted = this;
                vatDueDate = taxUncommitted.VatDueDate_W;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return vatDueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interimTax2ReverseByInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is only for POT. The payment amount that needs to be reversed during invoice posting. The reversal can happen to the extent of invoice time tax. (ie, less than or equal Invoice Tax).
    /// For cash basis this method will return only LOI amount.
    /// </summary>
    /// <returns>
    /// The payment amount that needs to be reversed during invoice posting. The reversal can happen to the extent of invoice time tax. (ie, less than or equal Invoice Tax).
    /// </returns>
    private container interimTax2ReverseByInvoice_IN()
    {
        TaxAmountCur        amount2HitActual;
        TaxAmountCur        amount2HitInterim;
        TaxAmountCur        amount2HitActualOrig;
        TaxAmountCur        serviceTaxLessLOI;
        TaxAmountCur        paymentTaxAmount;
        TaxAmountCur        advanceBaseAmount;
        TaxAmountCur        cumulativeServTaxLessLOI;
        TaxAmountCur        totalTaxBeforeSplit;
        TaxTrans            inVoicedTaxTrans;
        TaxUncommitted      inVoicedTaxUncommitted;
        TaxTrans            currentInvoiceTimeTaxTrans;
        TaxUncommitted      currentInvoiceTimeTaxUncommited;
        TaxModuleType       source;
        CustInvoiceTrans    custInvoiceTrans;
        InventTransId       inventTransId;
        DataAreaId          dataAreaId;
        Qty                 qty;
        PurchLine           purchLine;
        VendInvoiceTrans    vendInvoiceTrans;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        TaxTrans_IN         taxTransIN;
        PurchLineOrigin     purchLineOrigin;
        boolean             creditNote;
        PurchIdBase         purchId;
        InvoiceId           invoiceId;
        Percent             reverseChargePercent;
        TaxUncommitted_IN   taxUncommittedIN;

        if (this.TableId == tableNum(TaxUncommitted))
        {
            currentInvoiceTimeTaxUncommited = this;
            source = currentInvoiceTimeTaxUncommited.Source;
            if (source == TaxModuleType::Purch)
            {
                if (this.SourceTableId == tableNum(PurchLine))
                {
                    purchLine       = PurchLine::findRecId(currentInvoiceTimeTaxUncommited.SourceRecId);
                    inventTransId   = purchLine.InventTransId;
                    dataAreaId      = purchLine.dataAreaId;
                    qty             = purchLine.PurchQty;
                    purchId         = purchLine.PurchId;
                    reverseChargePercent = TaxItemGroupHeading::find(purchLine.TaxItemGroup).ReverseChargePercentage_IN;
                }
                else if (this.SourceTableId == tableNum(VendInvoiceInfoLine))
                {
                   vendInvoiceInfoLine  = VendInvoiceInfoLine::findRecId(currentInvoiceTimeTaxUncommited.SourceRecId);
                   inventTransId        = vendInvoiceInfoLine.InventTransId;
                   dataAreaId           = vendInvoiceInfoLine.dataAreaId;
                   qty                  = vendInvoiceInfoLine.ReceiveNow;
                   purchId              = vendInvoiceInfoLine.purchTable().PurchId;
                   reverseChargePercent = TaxItemGroupHeading::find(vendInvoiceInfoLine.TaxItemGroup).ReverseChargePercentage_IN;
                }
                if (reverseChargePercent > 0)
                {
                    taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(currentInvoiceTimeTaxUncommited.RecId);
                    if (taxUncommittedIN.ServTaxRevChargeOriginAmountCur_IN)
                    {
                        this.SourceRegulateAmountCur = taxUncommittedIN.ServTaxRevChargeOriginAmountCur_IN;
                    }
                    if (taxUncommittedIN.LoadOnInventoryTax)
                    {
                        this.TaxInCostPriceRegulated = taxUncommittedIN.LoadOnInventoryTax;
                    }
                }
                if (qty < 0)
                {
                    creditNote = true;
                    select OriginSourceDocumentLine from purchLineOrigin
                        where purchLineOrigin.PurchLineInventTransId  == inventTransId
                            && purchLineOrigin.PurchLineDataAreaId    == dataAreaId;// Unique record

                    vendInvoiceTrans = VendInvoiceTrans::findSourceDocumentLine(purchLineOrigin.OriginSourceDocumentLine);

                    select firstOnly SourceRegulateAmountCur from inVoicedTaxTrans
                        where inVoicedTaxTrans.SourceRecId     == vendInvoiceTrans.RecId
                            && inVoicedTaxTrans.SourceTableId  == vendInvoiceTrans.TableId
                            && inVoicedTaxTrans.TaxCode        == this.TaxCode
                                exists join taxTransIN
                                    where taxTransIN.RefRecId == inVoicedTaxTrans.RecId
                                        && taxTransIN.InterimRecoverableLedgerDimension != 0;

                    paymentTaxAmount = - inVoicedTaxTrans.SourceRegulateAmountCur;

                    if (reverseChargePercent > 0)
                    {
                        paymentTaxAmount = - TaxTrans_W::findByTaxTrans(inVoicedTaxTrans.RecId).ServiceTaxReverseChargeOriginAmount_IN;
                    }
                }
            }
            if (!creditNote)
            {
                [advanceBaseAmount, paymentTaxAmount] = Tax::getAdvanceAmount_IN(this.TaxCode, currentInvoiceTimeTaxUncommited.HeadingTableId, currentInvoiceTimeTaxUncommited.HeadingRecId, null, currentInvoiceTimeTaxUncommited);
            }
        }
        else if (this.TableId == tableNum(TaxTrans))
        {
            currentInvoiceTimeTaxTrans = this;
            source = currentInvoiceTimeTaxTrans.Source;
            if (currentInvoiceTimeTaxTrans.SourceTableId == tableNum(CustInvoiceTrans))
            {
                custInvoiceTrans = CustInvoiceTrans::findRecId(currentInvoiceTimeTaxTrans.SourceRecId);
                [advanceBaseAmount, paymentTaxAmount] = Tax::getAdvanceAmount_IN(this.TaxCode, tableNum(custInvoiceTrans), custInvoiceTrans.RecId ,null, currentInvoiceTimeTaxTrans);
                invoiceId = custInvoiceTrans.InvoiceId;
            }
            if (currentInvoiceTimeTaxTrans.SourceTableId == tableNum(VendInvoiceTrans))
            {
                purchId        = VendInvoiceTrans::findRecId(currentInvoiceTimeTaxTrans.SourceRecId).PurchID;
                inventTransId  = VendInvoiceTrans::findRecId(currentInvoiceTimeTaxTrans.SourceRecId).InventTransId;
            }
        }

        if (paymentTaxAmount && !creditNote)
        {
            cumulativeServTaxLessLOI = this.TaxMap::invoiceTimeTaxCumulated_IN();
            // PO side always be 0
            if (abs(cumulativeServTaxLessLOI) < abs(paymentTaxAmount))
            {
                paymentTaxAmount = (paymentTaxAmount - cumulativeServTaxLessLOI);
            }
            else
            {
                paymentTaxAmount = 0; // Nothing to hit interim here for POT, when all advance amounts are consumed.
            }
        }
        // Case when distribution is opened for service tax after posting.
        // Only for the cash basis concern

        [amount2HitActual, amount2HitInterim] = this.TaxMap::postedServiceTaxes_IN();
        if ((amount2HitActual + amount2HitInterim) == 0)
        {
            if (source == TaxModuleType::Purch)
            {
                if (taxUncommittedIN.LoadOnInventoryTax && reverseChargePercent > 0)
                {
                    serviceTaxLessLOI = this.SourceRegulateAmountCur - this.TaxInCostPriceRegulated;
                }
                else
                {
                    serviceTaxLessLOI = this.SourceRegulateAmountCur - this.TaxMap::getTaxInCostPrice();
                }

                amount2HitInterim = (abs(paymentTaxAmount) > abs(serviceTaxLessLOI)) ? serviceTaxLessLOI : paymentTaxAmount;
                // if (invoice tax < paym tax), then its GLS interim tax.So dont return to standard caller. Else the amount shud be consumed by
                // Standard MonetaryAmount::Tax, so return it to standard caller method.
                amount2HitActual  = (abs(serviceTaxLessLOI) > abs(amount2HitInterim)) ? (serviceTaxLessLOI - amount2HitInterim) : 0;

                if (reverseChargePercent > 0)
                {
                    if (creditNote)
                    {
                        amount2HitActual  = CurrencyExchangeHelper::amount(serviceTaxLessLOI * (100 - reverseChargePercent) / 100);
                        amount2HitInterim = serviceTaxLessLOI - amount2HitActual;
                    }
                    else
                    {
                        amount2HitActualOrig = amount2HitActual;
                        amount2HitActual     = CurrencyExchangeHelper::amount(amount2HitActual * (100 - reverseChargePercent) / 100);
                        amount2HitInterim    = amount2HitActualOrig - amount2HitActual;
                    }
                }
            }
            else if (source == TaxModuleType::FreeTxtInvoice)
            {
                totalTaxBeforeSplit = this.SourceRegulateAmountCur;
                if (this.TableId == tableNum(TaxTrans))// No partial FTI concept in AX.
                {
                    select sum(SourceRegulateAmountCur) from inVoicedTaxTrans
                        where inVoicedTaxTrans.SourceRecId     == custInvoiceTrans.RecId
                            && inVoicedTaxTrans.SourceTableId  == custInvoiceTrans.TableId
                            && inVoicedTaxTrans.TaxCode        == this.TaxCode;
                    totalTaxBeforeSplit = inVoicedTaxTrans.SourceRegulateAmountCur;
                }
                // case for FTI when posted without openeing distribution or SLJL.
                else if (this.TableId == tableNum(TaxUncommitted)
                   && paymentTaxAmount)
                {
                    select sum(SourceRegulateAmountCur) from inVoicedTaxUncommitted
                        where inVoicedTaxUncommitted.SourceRecId     == this.SourceRecId
                            && inVoicedTaxUncommitted.SourceTableId  == this.SourceTableId
                            && inVoicedTaxUncommitted.TaxCode        == this.TaxCode;
                    totalTaxBeforeSplit = inVoicedTaxUncommitted.SourceRegulateAmountCur;
                }

                if (totalTaxBeforeSplit)// Split total tax when Invoic Tax > Payment tax(Only for POT)
                {
                    amount2HitInterim = (abs(paymentTaxAmount) > abs(totalTaxBeforeSplit)) ? totalTaxBeforeSplit : paymentTaxAmount;

                    amount2HitActual = ((abs(totalTaxBeforeSplit) - abs(amount2HitInterim)) * (this.SourceRegulateAmountCur / abs(this.SourceRegulateAmountCur)));
                }
            }
        }

        return [amount2HitActual, amount2HitInterim];
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceTimeTaxCumulated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the cumulative tax amount per taxcode for the all order lines that are above the current order line.
    /// </summary>
    /// <returns>
    /// The tax amount.
    /// </returns>
    private TaxAmountCur invoiceTimeTaxCumulated_IN()
    {
        TaxUncommitted       currentInvoiceTimeTaxUncommited;
        TaxUncommitted       invoiceTimeTaxCumulated;
        PurchLine            purchLine;
        PurchLine            currentPurchLine;
        VendInvoiceInfoLine  vendInvoiceInfoLine;
        VendInvoiceInfoLine  currentVendInvoiceInfoLine;
        CustInvoiceLine      currentCustInvoiceLine;
        CustInvoiceLine      custInvoiceLine;
        CustInvoiceTrans     custInvoiceTrans;
        CustInvoiceTrans     currentCustInvoiceTrans;
        TaxTrans             currentInvoiceTimeTaxTrans;
        TaxTrans             invoiceTimeCumulatedTaxTrans;
        TaxAmount            serviceTaxAmountWithOutLOI;

        if (this.TableId == tableNum(TaxUncommitted))
        {
            currentInvoiceTimeTaxUncommited = this;

            if (currentInvoiceTimeTaxUncommited.SourceTableId == tableNum(VendInvoiceInfoLine))
            {
                currentVendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(currentInvoiceTimeTaxUncommited.SourceRecId);

                select sum(SourceRegulateAmountCur), sum(TaxInCostPriceRegulated) from invoiceTimeTaxCumulated
                    where invoiceTimeTaxCumulated.HeadingRecId     == currentInvoiceTimeTaxUncommited.HeadingRecId
                        && invoiceTimeTaxCumulated.HeadingTableId  == currentInvoiceTimeTaxUncommited.HeadingTableId
                        && invoiceTimeTaxCumulated.TaxCode         == currentInvoiceTimeTaxUncommited.TaxCode
                            exists join vendInvoiceInfoLine
                                where vendInvoiceInfoLine.Recid      == invoiceTimeTaxCumulated.SourceRecid
                                   && vendInvoiceInfoLine.TableRefId == currentVendInvoiceInfoLine.TableRefId
                                   && vendInvoiceInfoLine.ParmId     == currentVendInvoiceInfoLine.ParmId
                                   && vendInvoiceInfoLine.RecId      <  currentVendInvoiceInfoLine.RecId;
            }
            else if (currentInvoiceTimeTaxUncommited.SourceTableId == tableNum(PurchLine))
            {
                currentPurchLine = PurchLine::findRecId(currentInvoiceTimeTaxUncommited.SourceRecId);

                select sum(SourceRegulateAmountCur), sum(TaxInCostPriceRegulated) from invoiceTimeTaxCumulated
                    where invoiceTimeTaxCumulated.HeadingRecId    == currentInvoiceTimeTaxUncommited.HeadingRecId
                        && invoiceTimeTaxCumulated.HeadingTableId == currentInvoiceTimeTaxUncommited.HeadingTableId
                        && invoiceTimeTaxCumulated.TaxCode        == currentInvoiceTimeTaxUncommited.TaxCode
                            exists join purchLine
                                where purchLine.Recid      == invoiceTimeTaxCumulated.SourceRecid
                                   && purchLine.PurchId    == currentPurchLine.PurchId
                                   && purchLine.RecId      < currentPurchLine.RecId;
            }
            else if (currentInvoiceTimeTaxUncommited.SourceTableId == tableNum(CustInvoiceLine))
            {
                currentCustInvoiceLine = CustInvoiceLine::find(currentInvoiceTimeTaxUncommited.SourceRecId);

                select sum(SourceRegulateAmountCur), sum(TaxInCostPriceRegulated) from invoiceTimeTaxCumulated
                    group by TaxCode
                    where invoiceTimeTaxCumulated.HeadingRecId    == currentInvoiceTimeTaxUncommited.HeadingRecId
                        && invoiceTimeTaxCumulated.HeadingTableId == currentInvoiceTimeTaxUncommited.HeadingTableId
                        && invoiceTimeTaxCumulated.TaxCode        == currentInvoiceTimeTaxUncommited.TaxCode
                        exists join custInvoiceLine
                            where custInvoiceLine.Recid        == invoiceTimeTaxCumulated.SourceRecid
                                && custInvoiceLine.ParentRecId == currentCustInvoiceLine.ParentRecId
                                && custInvoiceLine.RecId       <  currentCustInvoiceLine.RecId;
            }
            // We are deducting LOI in the buffer to avoid doing same in multiple callers of this method.
            serviceTaxAmountWithOutLOI = (invoiceTimeTaxCumulated.SourceRegulateAmountCur
                                          - invoiceTimeTaxCumulated.TaxInCostPriceRegulated);
        }
        else if (this.TableId == tableNum(TaxTrans))
        {
            currentInvoiceTimeTaxTrans = this;
            if (currentInvoiceTimeTaxTrans.SourceTableId == tableNum(CustInvoiceTrans))
            {
                currentCustInvoiceTrans = CustInvoiceTrans::findRecId(currentInvoiceTimeTaxTrans.SourceRecId);

                select sum(SourceRegulateAmountCur), sum(TaxInCostPriceRegulated) from invoiceTimeCumulatedTaxTrans
                    group by TaxCode
                    where invoiceTimeCumulatedTaxTrans.Voucher    == currentInvoiceTimeTaxTrans.Voucher
                        && invoiceTimeCumulatedTaxTrans.TransDate == currentInvoiceTimeTaxTrans.TransDate
                        && invoiceTimeCumulatedTaxTrans.TaxCode   == currentInvoiceTimeTaxTrans.TaxCode
                            exists join CustInvoiceTrans
                                where CustInvoiceTrans.Recid      == invoiceTimeCumulatedTaxTrans.SourceRecID
                                    && CustInvoiceTrans.InvoiceId == currentCustInvoiceTrans.InvoiceId
                                    && CustInvoiceTrans.RecId     <  currentCustInvoiceTrans.RecId;
            }
            serviceTaxAmountWithOutLOI = (invoiceTimeCumulatedTaxTrans.SourceRegulateAmountCur);
        }

        return serviceTaxAmountWithOutLOI;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionEximRelated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// this method checkes if the transaction related to the Exim transaction.
    /// </summary>
    /// <returns>
    /// true if Exim transaction.
    /// </returns>
    /// <remarks>
    /// this method checkes if the transaction related to the Exim transaction.
    /// </remarks>
    public boolean isTransactionEximRelated_IN()
    {
        EximTaxTrans_IN     eximTaxTrans;
        TaxUncommitted_IN   taxUncommittedIN;

        if (this.TableId == tableNum(TaxTrans))
        {
            eximTaxTrans = EximTaxTrans_IN::findRefRecId(TaxTrans_IN::findRefRecId(this.RecId).recId);
            if (eximTaxTrans)
            {
                return eximTaxTrans.IncentiveScheme == EximIncentiveScheme_IN::AA
                    || eximTaxTrans.IncentiveScheme == EximIncentiveScheme_IN::DEPB
                    || eximTaxTrans.IncentiveScheme == EximIncentiveScheme_IN::DFIA
                    || eximTaxTrans.IncentiveScheme == EximIncentiveScheme_IN::EPCG;
            }
        }
        else
        {
            taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(this.RecId);
            if (taxUncommittedIN)
            {
                return taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::AA
                    || taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::DEPB
                    || taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::DFIA
                    || taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::EPCG;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public AccountingDate parmExchangeRateDate()
    {
        SourceDocumentLineImplementation   sourceDocumentLineImplementation;
        DictTable               dictTable;
        AccountingDate          exchangeRateDate;

        if (SysDictTable::isTableMapped(tableNum(SourceDocumentLineImplementation), this.SourceTableId))
        {
            dictTable = new DictTable(this.SourceTableId);
            sourceDocumentLineImplementation = dictTable.makeRecord();

            select RecId from sourceDocumentLineImplementation
            where sourceDocumentLineImplementation.RecId == this.SourceRecId;

            exchangeRateDate = sourceDocumentLineImplementation.parmExchangeRateDate();
        }

        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceDocumentLine</Name>
				<Source><![CDATA[
    public SourceDocumentLine parmParentSourceDocumentLine()
    {
        SourceDocumentLineImplementation   sourceDocumentLineImplementation;
        DictTable               dictTable;
        SourceDocumentLine      parentSourceDocumentLine;

        if (SysDictTable::isTableMapped(tableNum(SourceDocumentLineImplementation), this.SourceTableId))
        {
            dictTable = new DictTable(this.SourceTableId);
            sourceDocumentLineImplementation = dictTable.makeRecord();

            select SourceDocumentLine from sourceDocumentLineImplementation
            where sourceDocumentLineImplementation.RecId == this.SourceRecId;

            parentSourceDocumentLine = SourceDocumentLine::find(sourceDocumentLineImplementation.SourceDocumentLine);
        }

        return parentSourceDocumentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumName</Name>
				<Source><![CDATA[
    public enumName parmSourceDocLineTypeEnumName()
    {
        SourceDocumentLineImplementation   sourceDocumentLineImplementation;
        DictTable               dictTable;
        enumName                typeEnumName;

        if (SysDictTable::isTableMapped(tableNum(SourceDocumentLineImplementation), this.SourceTableId))
        {
            dictTable = new DictTable(this.SourceTableId);
            sourceDocumentLineImplementation = dictTable.makeRecord();

            select RecId from sourceDocumentLineImplementation
            where sourceDocumentLineImplementation.RecId == this.SourceRecId;

            typeEnumName = sourceDocumentLineImplementation.parmSourceDocLineTypeEnumName();
        }

        return typeEnumName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumValue</Name>
				<Source><![CDATA[
    public SourceDocumentTypeEnumValue parmSourceDocLineTypeEnumValue()
    {
        MarkupTrans     markupTrans;
        var             log = TaxEventSource::Get_Log();

        // Insert and reference a source document line
        switch (this.SourceTableId)
        {
            case tableNum(CustInvoiceLine) :
            case tableNum(CustInvoiceTrans) :
                return SourceDocumentLine_CustomerInvoice::CustomerInvoiceTaxLine;
            case tableNum(PurchReqLine) :
                return SourceDocumentLine_ProductRequisition::PurchaseRequisitionTaxLine;
            case tableNum(TrvExpTrans) :
                return SourceDocumentLine_ExpenseReport::ExpenseReportTaxLine;
            case tableNum(ProjAdvancedJournalLine) :
                return SourceDocumentLine_ProjAdvancedJournal::ProjAdvancedJournalTaxLine;
            case tableNum(PurchLine) :
                return SourceDocumentLine_ProductOrder::PurchaseOrderTaxLine;
            case tableNum(VendPackingSlipTrans) :
                return SourceDocumentLine_ProductReceipt::ProductReceiptTaxLine;
            case tableNum(VendInvoiceInfoLine) :
            case tableNum(VendInvoiceTrans):
                return SourceDocumentLine_VendorInvoice::VendorInvoiceTaxLine;
            // <GEERU>
            case tableNum(EmplAdvLine_RU) :
                return SourceDocumentLine_EmplAdvReport_RU::EmplAdvReportTaxLine;
            // </GEERU>
            // <GBR>
            case tableNum(SalesComplementaryInvoiceLine):
                return SourceDocumentLine_SalesComplementaryInv::SalesComplementaryInvoiceTaxLine;
            case tableNum(PurchComplementaryInvoiceLine):
                return SourceDocumentLine_PurchComplementaryInv::PurchComplementaryInvoiceTaxLine;
            // </GBR>
            case tableNum(MarkupTrans) :
                markupTrans = MarkupTrans::findRecId(this.SourceRecId, false, false);
                switch (markupTrans.TransTableId)
                {
                    case tableNum(PurchLine) :
                    case tableNum(PurchTable) :
                        return SourceDocumentLine_ProductOrder::PurchaseOrderTaxLine;
                    case tableNum(CustInvoiceTable) :
                    case tableNum(CustInvoiceJour) :
                    case tableNum(CustInvoiceTrans) :
                        return SourceDocumentLine_CustomerInvoice::CustomerInvoiceTaxLine;
                    case tableNum(PurchReqLine) :
                        return SourceDocumentLine_ProductRequisition::PurchaseRequisitionTaxLine;
                    case tableNum(VendInvoiceInfoTable) :
                    case tableNum(VendInvoiceInfoSubTable) :
                    case tableNum(VendInvoiceTrans) :
                    case tableNum(VendInvoiceJour) :
                    case tableNum(VendInvoiceInfoLine) :
                        return SourceDocumentLine_VendorInvoice::VendorInvoiceTaxLine;
                    default:
                        if (markupTrans.TransTableId == tableNum(CustInvoiceLine) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                        {
                            return SourceDocumentLine_CustomerInvoice::CustomerInvoiceTaxLine;
                        }
                }
                break;
            case tableNum(BankStmtISOReportEntry):
                return SourceDocumentLine_BankStatement::BankStatementTaxLine;
        }

        log.ParmSourceDocLineTypeEnumValueFailed(this.SourceTableId, markupTrans.TransTableId);
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentHeader</Name>
				<Source><![CDATA[
    public SourceDocumentHeader parmSourceDocumentHeader()
    {
        SourceDocumentHeader        sourceDocumentHeader;

        sourceDocumentHeader = SourceDocumentHeader::find(this.parmParentSourceDocumentLine().SourceDocumentHeader);

        return sourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedServiceTaxes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reurns the split information of the total service tax posted. Means, both InterimTax and actual Tax.
    /// </summary>
    /// <returns>
    /// Returns the container with Interim Tax and Actual Tax.
    /// Standard Logic uses both taxUncommitted and taxtrans alterantly for the posted tax call.
    /// </returns>
    public container postedServiceTaxes_IN()
    {
        TaxAmountCur            amount2HitActual;
        TaxAmountCur            amount2HitInterim;
        TaxTrans                currentInvoiceTimeTaxTrans;
        TaxUncommitted          currentInvoiceTimeTaxUncommited;
        AccountingDistribution  accountingDistributionTax;
        AccountingEvent         accountingEvent;
        AccountingDistribution  accountingDistributionTax2;

        if (this.TableId == tableNum(TaxUncommitted))
        {
            currentInvoiceTimeTaxUncommited = this;

            select sum(TransactionCurrencyAmount) from accountingDistributionTax2
                where accountingDistributionTax2.SourceDocumentLine   == currentInvoiceTimeTaxUncommited.SourceDocumentLine
                    && accountingDistributionTax2.AccountingDate       == currentInvoiceTimeTaxUncommited.TransDate
            join accountingDistributionTax
                where accountingDistributionTax.AccountingDate       == currentInvoiceTimeTaxUncommited.TransDate
                    && accountingDistributionTax.MonetaryAmount       == MonetaryAmount::ServiceTaxInterimAmount_IN
                    && accountingDistributionTax.ReferenceDistribution != 0
                    && accountingDistributionTax.ReferenceRole         == AccountingDistributionReferenceRole::Matching
                    && accountingDistributionTax.AccountingEvent       != 0
                    && accountingDistributionTax.ReferenceDistribution    == accountingDistributionTax2.RecId
            exists join accountingEvent
                where accountingEvent.RecId == accountingDistributionTax.AccountingEvent
                    && accountingEvent.State == AccountingEventState::Complete;
            if (accountingDistributionTax2.TransactionCurrencyAmount)
            {
                amount2HitInterim = accountingDistributionTax2.TransactionCurrencyAmount;
            }

            select sum(TransactionCurrencyAmount) from accountingDistributionTax2
                where accountingDistributionTax2.SourceDocumentLine   == currentInvoiceTimeTaxUncommited.SourceDocumentLine
                    && accountingDistributionTax2.AccountingDate       == currentInvoiceTimeTaxUncommited.TransDate
            join accountingDistributionTax
                where accountingDistributionTax.AccountingDate       == currentInvoiceTimeTaxUncommited.TransDate
                    && accountingDistributionTax.MonetaryAmount       == MonetaryAmount::Tax
                    && accountingDistributionTax.ReferenceDistribution != 0
                    && accountingDistributionTax.ReferenceRole         == AccountingDistributionReferenceRole::Matching
                    && accountingDistributionTax.AccountingEvent       != 0
                    && accountingDistributionTax.ReferenceDistribution    == accountingDistributionTax2.RecId
            exists join accountingEvent
                where accountingEvent.RecId == accountingDistributionTax.AccountingEvent
                    && accountingEvent.State == AccountingEventState::Complete;
            if (accountingDistributionTax2.TransactionCurrencyAmount)
            {
                amount2HitActual  = accountingDistributionTax2.TransactionCurrencyAmount;
            }
        }
        else if (this.TableId == tableNum(TaxTrans))
        {
            currentInvoiceTimeTaxTrans = this;

            select sum(TransactionCurrencyAmount) from accountingDistributionTax
                where accountingDistributionTax.SourceDocumentLine   == currentInvoiceTimeTaxTrans.SourceDocumentLine
                   && accountingDistributionTax.AccountingDate       == currentInvoiceTimeTaxTrans.TransDate
                   && accountingDistributionTax.MonetaryAmount       == MonetaryAmount::ServiceTaxInterimAmount_IN
                   && accountingDistributionTax.SourceDocumentHeader == accountingDistributionTax.SourceDocumentHeader;

            amount2HitInterim = accountingDistributionTax.TransactionCurrencyAmount;

            select sum(TransactionCurrencyAmount) from accountingDistributionTax
                where accountingDistributionTax.SourceDocumentLine   == currentInvoiceTimeTaxTrans.SourceDocumentLine
                   && accountingDistributionTax.AccountingDate       == currentInvoiceTimeTaxTrans.TransDate
                   && accountingDistributionTax.MonetaryAmount       == MonetaryAmount::Tax
                   && accountingDistributionTax.SourceDocumentHeader == accountingDistributionTax.SourceDocumentHeader;

            amount2HitActual = accountingDistributionTax.TransactionCurrencyAmount;
        }

        return [amount2HitActual, amount2HitInterim];
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
	<DeveloperDocumentation>@SYS344924</DeveloperDocumentation>
	<Visible>No</Visible>
	<FieldGroups />
	<Fields>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CurrencyCode</Name>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<StringSize>3</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>EUROTriangulation</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>EUROTriangulation</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ExchangeRate</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ExchangeRateSecond</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ExchangeRateSourceRegulateAmount</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ExchangeRateTaxAmount</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>SourceCurrencyCode</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<StringSize>3</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>SourceDocumentLine</Name>
			<ExtendedDataType>SourceDocumentLineRefRecId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>SourceOtherBaseTaxAmount_BR</Name>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>SourceRecId</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>SourceRegulateAmountCur</Name>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>SourceTableId</Name>
			<ExtendedDataType>RefTableId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>SourceTaxAmountCur</Name>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>TaxAmount</Name>
			<CountryRegionCodes>CZ,HU,PL</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>TaxAutoGenerated</Name>
			<ExtendedDataType>TaxAutoGenerated</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxCode</Name>
			<ExtendedDataType>TaxCode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>TaxDirection</Name>
			<EnumType>TaxDirection</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxGroup</Name>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>TaxInCostPrice</Name>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>TaxInCostPriceRegulated</Name>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>TaxItemGroup</Name>
			<CountryRegionCodes>IN,HU</CountryRegionCodes>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>TransDate</Name>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>VATDueDate_W</Name>
			<ExtendedDataType>VatDueDate_W</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>WithoutTaxTrans_RU</Name>
			<ExtendedDataType>WithoutTaxTrans_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>FiscalValue_BR</Name>
			<EnumType>TaxFiscalValue_BR</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>Reason</Name>
			<ExtendedDataType>ReasonCode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>ReasonComment</Name>
			<ExtendedDataType>ReasonComment</ExtendedDataType>
			<StringSize>60</StringSize>
		</AxMapBaseField>
	</Fields>
	<Mappings />
</AxMap>