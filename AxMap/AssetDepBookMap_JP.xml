<?xml version="1.0" encoding="utf-8"?>
<AxMap xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetDepBookMap_JP</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class AssetDepBookMap_JP extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>acceleratedDepreciationProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the accelerated deprecaition profile.
    /// </summary>
    /// <returns>
    /// A record of <C>AssetDepreciationProfile</C>.
    /// </returns>
    public AssetDepreciationProfile acceleratedDepreciationProfile()
    {
        AssetDepreciationProfile depProfile;
        AssetBook assetBook;

        assetBook = this;
        depProfile = assetBook.depreciationAcceleratedProfile_JP();

        return depProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetBookType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets asset book type of the current record
    /// </summary>
    /// <returns>
    /// <c>AssetBookType</c>
    /// </returns>
    public AssetBookType assetBookType()
    {
        return AssetDepCalculationHelper_JP::determineAssetBookType(this.TableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetDepTableMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an implement of <c>AssetDepTableMethodInterface_JP</c> for current record.
    /// </summary>
    /// <param name="_transDate">
    /// Asset transacation date
    /// </param>
    /// <param name="_dualDepreciation">
    /// A Boolean value that indicates whether dual depreciation is used.
    /// </param>
    /// <param name="_depreciationAltProfile">
    /// A Boolean value that indicates whether alternative depreciation profile is used.
    /// </param>
    /// <param name="_depreciationExtProfile">
    /// A Boolean value that indicates whether extraordinary depreciation profile is used.
    /// </param>
    /// <param name="_assetBudgetModelId">
    /// Asset budget model id.
    /// </param>
    /// <returns>
    /// An implement of <c>AssetDepTableMethodInterface_JP</c>
    /// </returns>
    public AssetDepTableMethodInterface_JP assetDepTableMethod(
        AssetTransDate _transDate,
        boolean _dualDepreciation = false,
        boolean _depreciationAltProfile = false,
        boolean _depreciationExtProfile = false,
        AssetBudgetModelId  _assetBudgetModelId = '')
    {
        AssetDepTableMethodInterface_JP ret;
        AssetTableMethod assetTableMethod;

        assetTableMethod = AssetTableMethod::construct(AssetBook::find(this.AssetId, this.AssetBookId), _transDate, _assetBudgetModelId, _dualDepreciation, _depreciationAltProfile, _depreciationExtProfile);
        if (assetTableMethod is AssetTableMethod_JP)
        {
            ret = assetTableMethod as AssetTableMethod_JP;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTableInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of <C>AssetTableInterval</C> for current record.
    /// </summary>
    /// <param name="_transDate">
    /// Transcation date to find the current depreciation profile; default to dateNull()
    /// </param>
    /// <param name="_isCacheTable">
    /// If ture, cache fiscal calendar tables to avoid multiple database call; optional.
    /// </param>
    /// <param name="_depreciationExtProfile">
    /// A Boolean value that indicates whether extraordinary depreciation profile is used, optional.
    /// </param>
    /// <returns>
    /// An instance of <C>AssetTableInterval</C>.
    /// </returns>
    /// <remarks>
    /// Performance consideration:
    ///     a. If multiple instances of <C>AssetTableInterval</C> will be used for the same value model,
    ///        use <C>AssetTableIntervalFactory_JP</C> to contruct instances of <C>AssetTableInterval</C>.
    ///     b. If periods count related functions on <C>AssetTableInterval</C> will be called for multiple times,
    ///        set param _isUseTableCache to true.
    /// </remarks>
    public AssetTableInterval assetTableInterval(
        AssetTransDate _transDate = dateNull(),
        boolean _isCacheTable = false,
        boolean _depreciationExtProfile = false)
    {
        AssetTableInterval ret;

        ret = this.AssetGroupDepBookMap_JP::assetTableInterval(_transDate, _isCacheTable, _depreciationExtProfile);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTableIntervalForAcceleratedDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of <C>AssetTableInterval</C> for accelerated depreciation.
    /// </summary>
    /// <param name="_transDate">
    /// Transcation date to find the current depreciation profile; default to dateNull()
    /// </param>
    /// <param name="_isCacheTable">
    /// If ture, cache fiscal calendar tables to avoid multiple database call; optional.
    /// </param>
    /// <returns>
    /// An instance of <C>AssetTableInterval</C>.
    /// </returns>
    /// <remarks>
    /// Performance consideration:
    ///     a. If multiple instances of <C>AssetTableInterval</C> will be used for the same value model,
    ///        use <C>AssetTableIntervalFactory_JP</C> to contruct instances of <C>AssetTableInterval</C>.
    ///     b. If periods count related functions on <C>AssetTableInterval</C> will be called for multiple times,
    ///        set param _isUseTableCache to true.
    /// </remarks>
    public AssetTableInterval assetTableIntervalForAcceleratedDep(
        AssetTransDate _transDate = dateNull(),
        boolean _isCacheTable = false)
    {
        AssetTableInterval ret;
        AssetDepreciationProfile assetDepreciationProfile;
        AssetDepreciationProfile accleratedDepreciationProfile;

        assetDepreciationProfile = this.AssetDepBookMap_JP::depreciationProfileOnDate(_transDate);
        accleratedDepreciationProfile = this.AssetDepBookMap_JP::acceleratedDepreciationProfile();

        ret = this.AssetDepBookMap_JP::assetTableIntervalForProfile(
            assetDepreciationProfile,
            accleratedDepreciationProfile,
            _isCacheTable);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTableIntervalForProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of <C>AssetTableInterval</C> for depreciation profile.
    /// </summary>
    /// <param name="_mainDepProfile">
    /// Ordinary depreciation profile
    /// </param>
    /// <param name="_secondaryProfile">
    /// Depreciation profile to find <C>AssetTableInterval</C>
    /// </param>
    /// <param name="_isCacheTable">
    /// If ture, cache fiscal calendar tables to avoid multiple database call; optional.
    /// </param>
    /// <returns>
    /// An instance of <C>AssetTableInterval</C>.
    /// </returns>
    /// <remarks>
    /// Performance consideration:
    ///     a. If multiple instances of <C>AssetTableInterval</C> will be used for the same value model,
    ///        use <C>AssetTableIntervalFactory_JP</C> to contruct instances of <C>AssetTableInterval</C>.
    ///     b. If periods count related functions on <C>AssetTableInterval</C> will be called for multiple times,
    ///        set param _isUseTableCache to true.
    /// </remarks>
    private AssetTableInterval assetTableIntervalForProfile(
        AssetDepreciationProfile _mainDepProfile,
        AssetDepreciationProfile _secondaryProfile,
        boolean _isCacheTable = false)
    {
        AssetTableInterval ret;
        AssetDepBookTableMap_JP assetDepBookTableMap;

        if (_mainDepProfile && _secondaryProfile)
        {
            assetDepBookTableMap = AssetDepBookTableMap_JP::find(
                AssetDepCalculationHelper_JP::determineAssetBookType(this.TableId),
                this.AssetBookId);
            if (assetDepreciationProfile::isDepMethodAllowChangeCalendar_JP(_mainDepProfile.Method))
            {
                ret = AssetTableIntervalExt_JP::constructFromCalendarSchedule(
                    _secondaryProfile,
                    assetDepBookTableMap.TableId,
                    assetDepBookTableMap.RecId,
                    _isCacheTable);
            }
            else
            {
                ret = AssetTableInterval::construct(
                    _secondaryProfile,
                    assetDepBookTableMap.getFiscalCalendar(),
                    _isCacheTable);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitForAccuAllocation_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the overall allowable limit for accumulated reserve allocation amount.
    /// </summary>
    /// <param name="_reductionEntryPreAdjustment">
    /// Reduction entry pre-adjustment amount.
    /// </param>
    /// <returns>
    /// The overall allowable limit for accumulated reserve allocation amount.
    /// </returns>
    public AssetAmount calcAllowableLimitForAccuAllocation_JP(
        AssetAmount _reductionEntryPreAdjustment
        )
    {
        AssetAmount ret;
        AssetAmount calculationBase;
        AssetDepreciationMethod depreciationMethod;
        #define.Percent95(0.95)

        calculationBase = _reductionEntryPreAdjustment;
        depreciationMethod = this.depreciationProfile().Method;
        if ((depreciationMethod == AssetDepreciationMethod::OldStraightLine_JP
                || depreciationMethod == AssetDepreciationMethod::OldDecliningBalance_JP)
            && AssetTable::find(this.AssetId).AssetType == AssetType::Tangible)
        {
            switch (this.AllowableLimitForAccumulatedDepType)
            {
                case AssetLimitForAccumulatedDepType_JP::AcquisitionCost95:
                    ret = calculationBase * #Percent95;
                    break;
                case AssetLimitForAccumulatedDepType_JP::AcquisitionCost:
                    ret = calculationBase;
                    break;
                case AssetLimitForAccumulatedDepType_JP::AcquisitionCostMinus1:
                    ret = calculationBase - 1;
                    break;
                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
        else
        {
            ret = calculationBase;
        }
        ret = this.roundOffDepreciation(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitForAccumulatedDep_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the overall allowable limit for accumulated depreciation amount.
    /// </summary>
    /// <param name="reductionEntryAdjustment">
    /// Reduction entry adjustment amount.
    /// </param>
    /// <returns>
    /// The overall allowable limit for accumulated depreciation amount.
    /// </returns>
    public AssetAmount calcAllowableLimitForAccumulatedDep_JP(
        AssetAmount reductionEntryAdjustment = 0
        )
    {
        AssetAmount     ret;
        #define.Percent95(0.95)

        ret = this.AcquisitionPrice;

        // reduction entry
        if (reductionEntryAdjustment)
        {
            ret -= reductionEntryAdjustment;
        }

        if (AllowableLimitForAccumulatedDepShouldIncludeAdjustments_JPFlight::instance().isEnabled()
            || AssetBook::find(this.AssetId, this.AssetBookId).IsTrueUpDepreciation)
        {
            ret += AssetTrans::amountMSTPerDateTransTypes(
                this.AssetId,
                this.AssetBookId,
                [AssetTransType::Revaluation, AssetTransType::WriteDownAdj, AssetTransType::WriteUpAdj],
                dateNull(),
                dateMax());
        }

        // ARO acquisition (adjustment) amount has been added to AcquisitionPrice field. It needs to be excluded.
        if (AssetDocumentUtility_JP::isAssetDocumentEnabled())
        {
            ret -= AssetDepTransMap_JP::calcDocumentTypeAmountToDepreciate(AssetDocumentType_JP::AssetRetirementObligation, this, dateMax());
        }

        switch (this.AllowableLimitForAccumulatedDepType)
        {
            case AssetLimitForAccumulatedDepType_JP::AcquisitionCost95:
                ret = ret * #Percent95;
                break;

            case AssetLimitForAccumulatedDepType_JP::AcquisitionCost:
                break;

            case AssetLimitForAccumulatedDepType_JP::AcquisitionCostMinus1:
                if (this.AcquisitionPrice > 0)
                {
                    ret = ret - 1;
                }
                else
                {
                    ret++;
                }
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        ret = this.roundOffDepreciation(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationAltProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the related record of alternative <C>AssetDepreciationProfile</C>.
    /// </summary>
    /// <returns>
    /// A record of <C>AssetDepreciationProfile</C>.
    /// </returns>
    public AssetDepreciationProfile depreciationAltProfile()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationExtProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the related record of extraordinary <C>AssetDepreciationProfile</C>.
    /// </summary>
    /// <returns>
    /// A record of <C>AssetDepreciationProfile</C>.
    /// </returns>
    public AssetDepreciationProfile depreciationExtProfile()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the related record of <C>AssetDepreciationProfile</C>.
    /// </summary>
    /// <returns>
    /// A record of <C>AssetDepreciationProfile</C>.
    /// </returns>
    public AssetDepreciationProfile depreciationProfile()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationProfileIdOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets depreciation profile id on the specific date
    /// </summary>
    /// <param name="_date">
    /// <c>date</c>
    /// </param>
    /// <returns>
    /// Depreciation profile id
    /// </returns>
    public AssetDepreciationProfileId depreciationProfileIdOnDate(date _date = dateNull())
    {
        AssetDepreciationProfileId  ret;
        AssetDepProfileChange_JP depProfileChange;

        if (AssetParameters::isManuallyChangeDepProfileEnable_JP())
        {
            depProfileChange = AssetDepProfileChange_JP::find(this.TableId, this.RecId, _date);
        }
        if (depProfileChange)
        {
            ret = depProfileChange.DepreciationProfile;
        }
        else
        {
            ret = this.depreciationProfile().Profile;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>depreciationProfileOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets depreciation profile on the specific date
    /// </summary>
    /// <param name="_date">
    /// <c>date</c>
    /// </param>
    /// <returns>
    /// Depreciation profile
    /// </returns>
    public AssetDepreciationProfile depreciationProfileOnDate(date _date = dateNull())
    {
        AssetDepreciationProfile ret;

        ret = this.AssetGroupDepBookMap_JP::depreciationProfileOnDate(_date);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounding the depreciation amount based rounding rules setting for fixed asset depreciation.
    /// </summary>
    /// <param name="_assetAmount">
    /// Fixed asset depreciation amount.
    /// </param>
    /// <returns>
    /// Fixed asset depreciation amount after rounding.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// This method should be overloaded at all tables that maps to this map.
    /// </exception>
    public AssetAmount roundOffDepreciation(AssetAmount _assetAmount)
    {
        throw error(error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllocationStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set allocation start date of value models/ dep books.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date;Optional.
    /// </param>
    public void setAllocationStartDate(AssetTransDate  _transDate = dateNull())
    {
        AssetDocumentEntry_JP documentEntry;
        AssetDocumentTable_JP documentTable;
        AssetReductionEntryProfile_JP profile;
        AssetTableInterval assetTableInterval;
        AssetDocumentTrans_JP documentTrans;
        AssetDepTransMap_JP depTrans = AssetDepTransMap_JP::getEmptyTableBuffer(AssetDepCalculationHelper_JP::determineAssetBookType(this.TableId));

        documentEntry = AssetReductionEntryManager_JP::getAssetReductionEntryByAssetBook(
            this.AssetId, this.AssetBookId, AssetDocumentType_JP::AssetReductionEntry_Reserve);
        documentTable = AssetDocumentTable_JP::find(documentEntry.AssetDocumentTable_JP);
        profile = AssetReductionEntryProfile_JP::find(documentTable.DocumentId);
        assetTableInterval = this.AssetDepBookMap_JP::assetTableInterval();

        if (_transDate)
        {
            switch (profile.AllocationConvention)
            {
                case AssetReductionEntryConvention_JP::None:
                    this.AllocationStartDate = assetTableInterval.endPeriod(_transDate) + 1;
                    break;
                case AssetReductionEntryConvention_JP::FullMonth:
                    this.AllocationStartDate = assetTableInterval.startOfPeriod(_transDate);
                    break;
            }
        }
        else
        {
            select firstOnly TransDate from depTrans
                order by depTrans.TransDate
                join RecId from documentTrans
                    where documentTrans.RefTableId == depTrans.TableId
                        && documentTrans.RefRecId  == depTrans.RecId
                        && documentTrans.AssetDocumentEntry_JP == documentEntry.RecId;

            if (depTrans.TransDate)
            {
                switch (profile.AllocationConvention)
                {
                    case AssetReductionEntryConvention_JP::None:
                        this.AllocationStartDate = assetTableInterval.endPeriod(depTrans.TransDate) + 1;
                        break;
                    case AssetReductionEntryConvention_JP::FullMonth:
                        this.AllocationStartDate = assetTableInterval.startOfPeriod(depTrans.TransDate);
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetRevisedAcquisitionCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// update the field AssetRevisedAcquisitionCost of AssetBook or AssetDepBook
    /// </summary>
    /// <param name="_assetDepTransMap">
    /// Instance of AssetDepTransMap_JP, it represents an instance of AssetTrans or AssetDepBookTrans
    /// </param>
    /// <returns>
    /// True if the field of AssetRevisedAcquisitionCost_JP is updated; otherwise, return false
    /// </returns>
    public boolean updateAssetRevisedAcquisitionCost(AssetDepTransMap_JP _assetDepTransMap)
    {
        boolean ret = false;

        AssetTableIntervalExt_JP assetIntervalExt;
        AssetDepBookTableMap_JP assetDepBookTableMap;
        AssetBookType assetBookType;
        AssetTransDate transDate;
        AssetTransDate firstDayForYear;

        AssetDepreciationProfile depProfile;
        AssetDepreciationMethod  method;
        RefRecId  depRateSchedule;
        AssetDepRate_JP assetDepRate;
        real depRate;
        real guaranteedDepRate;

        AssetDepTableMethodInterface_JP assetDepTableMethodInterface;

        AssetAmount amountToDepreciate;
        AssetAmount remainingBalanceOfCurYear;

        assetBookType = AssetDepCalculationHelper_JP::determineAssetBookType(this.TableId);
        assetDepBookTableMap = AssetDepBookTableMap_JP::find(assetBookType, this.AssetBookId);

        transDate = _assetDepTransMap.TransDate;
        depProfile = this.AssetDepBookMap_JP::depreciationProfileOnDate(transDate);
        method = depProfile.Method;

        if (method == AssetDepreciationMethod::NewDecliningBalance200_JP
            || method == AssetDepreciationMethod::NewDecliningBalance250_JP)
        {
            assetIntervalExt = this.AssetDepBookMap_JP::assetTableInterval(transDate);

            firstDayForYear = assetIntervalExt.findFirstDayOfYear(transDate);

            depRateSchedule = depProfile.AssetDepRateSchedule_JP;
            assetDepRate = AssetDepRate_JP::find(depRateSchedule, method, this.ServiceLife);
            depRate = assetDepRate.DepreciationRate;
            guaranteedDepRate = assetDepRate.GuaranteedDepreciationRate;

            assetDepTableMethodInterface = this.AssetDepBookMap_JP::assetDepTableMethod(transDate);
            if (assetDepTableMethodInterface)
            {
                assetDepTableMethodInterface.parmPeriodEnd_JP(firstDayForYear - 1 );
                amountToDepreciate = assetDepTableMethodInterface.getAmountToDepreciate();

                remainingBalanceOfCurYear = amountToDepreciate -
                            AssetDepTransMap_JP::calcAccumulatedDepAmountMST(this, dateNull(), firstDayForYear);

                if (remainingBalanceOfCurYear * depRate < amountToDepreciate * guaranteedDepRate
                    && remainingBalanceOfCurYear > this.AssetRevisedAcquisitionCost_JP)
                {
                    this.AssetRevisedAcquisitionCost_JP = remainingBalanceOfCurYear;
                    this.AssetRevisedAcquisitionCostStartDate = firstDayForYear;
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEquallyDividedStartDateForTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the field <C>EquallyDividedStartDate</C> based on specified posted transaction.
    /// </summary>
    /// <param name="_assetDepTransMap">
    /// The posted depreciaion transaction.
    /// </param>
    /// <returns>
    /// true if success; otherwise, return false.
    /// </returns>
    public boolean updateEquallyDividedStartDateForTrans(AssetDepTransMap_JP _assetDepTransMap)
    {
        boolean ret = false;
        AssetTableIntervalExt_JP assetIntervalExt;
        AssetTransDate fromDate;
        AssetTransDate toDate;
        AssetTransDate firstDayForYear;

        if (_assetDepTransMap.TransType != AssetTransType::Depreciation
            && _assetDepTransMap.TransType != AssetTransType::DepreciationAdj
            && _assetDepTransMap.TransType != AssetTransType::ExtraordinaryDepreciation)
        {
            // Skip non-depreciation trans.
            return false;
        }

        if (this.EquallyDividedStartDate != dateNull()
            && this.EquallyDividedStartDate <= _assetDepTransMap.TransDate)
        {
            // Skip the trans after current equally divided start date.
            return false;
        }

        fromDate = _assetDepTransMap.TransDate;
        toDate = max(fromDate, this.LastDepreciationDate);
        if (this.EquallyDividedStartDate)
        {
            toDate = this.EquallyDividedStartDate - 1;
        }

        assetIntervalExt = this.AssetDepBookMap_JP::assetTableInterval(_assetDepTransMap.TransDate);

        while (fromDate <= toDate)
        {
            firstDayForYear = assetIntervalExt.findFirstDayOfYear(fromDate);
            if (AssetDepTransMap_JP::calcAccumulatedDepAmountMST(this, dateNull(), firstDayForYear) >= this.AssetDepBookMap_JP::calcAllowableLimitForAccumulatedDep_JP())
            {
                this.EquallyDividedStartDate = firstDayForYear;
                ret = true;
                break;
            }

            fromDate = assetIntervalExt.findLastDayOfYear(fromDate) + 1;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBookId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ID of value model / depreciation book for current buffer.
    /// </summary>
    /// <returns>
    /// true if it is a valid ID; otherwise, return false.
    /// </returns>
    public boolean validateBookId()
    {
        boolean ret;
        AssetDepreciationProfile assetDepreciationProfile;

        if (!assetDepreciationProfile)
        {
            // The reason why not directly use the depreciationProfile() method is:
            // For depreciation book part, the depreciationProfile() method use the DepreciationProfile field,
            // and this field is inited after the AssetBookId field is set. But this validate method is called
            // when setting the AssetBookId field. it means the DepreciationProfile field is not set yet.
            assetDepreciationProfile = AssetDepreciationProfile::find(
                AssetDepBookTableMap_JP::find(
                    AssetDepCalculationHelper_JP::determineAssetBookType(this.TableId),
                    this.AssetBookId).DepreciationProfile);
        }

        ret = AssetTable::find(this.AssetId).AssetGroupMap_JP::validateDepreciationProfile(assetDepreciationProfile);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an record of <C>AssetDepBookMap_JP</C>.
    /// </summary>
    /// <param name="_assetBookType">
    /// Asset book type.
    /// </param>
    /// <param name="_assetId">
    /// Aseet ID.
    /// </param>
    /// <param name="_assetBookId">
    /// Aseet book ID.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// An record of <C>AssetDepBookMap_JP</C>.
    /// </returns>
    public static AssetDepBookMap_JP find(
        AssetBookType _assetBookType,
        AssetId _assetId,
        AssetBookId _assetBookId,
        boolean _forUpdate = false)
    {
        AssetDepBookMap_JP assetDepBookMap;

        assetDepBookMap = AssetDepBookMap_JP::getEmptyTableBuffer();

        if (_assetId && _assetBookId)
        {
            assetDepBookMap.selectForUpdate(_forUpdate);

            select firstOnly assetDepBookMap
                where assetDepBookMap.AssetId       == _assetId
                    && assetDepBookMap.AssetBookId  == _assetBookId;
        }

        return assetDepBookMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAssetIdBookId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an record of <C>AssetDepBookMap_JP</C>.
    /// </summary>
    /// <param name="_assetId">
    /// Aseet ID.
    /// </param>
    /// <param name="_assetBookId">
    /// Aseet book ID.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// An record of <C>AssetDepBookMap_JP</C>.
    /// </returns>
    public static AssetDepBookMap_JP findByAssetIdBookId(
        AssetId _assetId,
        AssetBookId _assetBookId,
        boolean _forUpdate = false)
    {
        AssetDepBookMap_JP assetDepBookMap;

        assetDepBookMap = AssetDepBookMap_JP::find(
            AssetBookType::ValueModel,
            _assetId,
            _assetBookId,
            _forUpdate);

        return assetDepBookMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an record of <C>AssetDepBookMap_JP</C>.
    /// </summary>
    /// <param name="_tableId">
    /// <c>TableId</c>
    /// </param>
    /// <param name="_recId">
    /// <c>RecId</c>
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// An record of <C>AssetDepBookMap_JP</C>.
    /// </returns>
    public static AssetDepBookMap_JP findByRecId(TableId _tableId, RecId _recId, boolean _forUpdate = false)
    {
        AssetDepBookMap_JP assetDepBookMap;

        if (_tableId && _recId)
        {
            assetDepBookMap.selectForUpdate(_forUpdate);
            assetDepBookMap = AssetDepBookMap_JP::getEmptyTableBuffer();
            select firstOnly assetDepBookMap
                where assetDepBookMap.RecId == _recId;
        }

        return assetDepBookMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmptyTableBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns an empty table buffer for the concrete table represented by the map.
    /// </summary>
    /// <returns>
    ///     An empty table buffer for the concrete table represented by the map.
    /// </returns>
    public static AssetDepBookMap_JP getEmptyTableBuffer()
    {
        AssetDepBookMap_JP ret;
        AssetBook assetBook;
        ret = assetBook;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDepProfileSpecialDepComparison</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>AssetSpecialDepComparisonTmp_JP</c> records used in Inquiry>Profile>Special depreciation comparison.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// An <c>AssetGroupDepBookMap_JP</c> record.
    /// </param>
    /// <returns>
    /// <c>AssetSpecialDepComparisonTmp_JP</c> records.
    /// </returns>
    public static AssetSpecialDepComparisonTmp_JP initDepProfileSpecialDepComparison(AssetDepBookMap_JP _assetDepBookMap)
    {
        #isoCountryRegionCodes

        AssetTableInterval assetTableInterval;
        AssetAmount allowableLimit;
        AssetAmount specialDepPostedAmt;
        AssetAmount preAllowableLimit;
        AssetDepreciationProfile depreciationProfileExt;
        AssetDepTableMethodInterface_JP assetDepTableMethod;
        AssetTransDate depreciationStartDate;
        AssetTransDate transDate;
        AssetTransDate reserveEndDate;
        AssetTransDate allocationStartDate;
        AssetTransDate periodStart;
        AssetTransDate periodEnd;
        AssetSpecialDepComparisonTmp_JP tmpData;
        boolean isNewYear;
        boolean isReserveToAllocation;
        boolean isAllocation;
        int directOffPeriods = 0;

        if (_assetDepBookMap.Status == AssetStatus::Open
            || _assetDepBookMap.Status == AssetStatus::NoAcquisition)
        {
            depreciationProfileExt = _assetDepBookMap.depreciationExtProfile();

            if (depreciationProfileExt.Method == AssetDepreciationMethod::AdditionalDepreciation_JP)
            {
                assetDepTableMethod = _assetDepBookMap.AssetDepBookMap_JP::assetDepTableMethod(dateMax(), false, false, true);
                assetDepTableMethod.parmIsCatchUpDepreciation(true);
                assetDepTableMethod.parmIsRecaptureDepreciation(true);

                depreciationStartDate = _assetDepBookMap.SpecialDepStartDate ? _assetDepBookMap.SpecialDepStartDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                assetTableInterval = assetDepTableMethod.getAssetTableInterval(depreciationStartDate);
                assetDepTableMethod.parmPeriodStart_JP(depreciationStartDate);
                assetDepTableMethod.parmPeriodEnd_JP(assetTableInterval.endPeriod(depreciationStartDate));

                while (assetDepTableMethod.next())
                {
                    directOffPeriods++;
                    periodStart = assetDepTableMethod.parmPeriodStart_JP();
                    periodEnd   = assetDepTableMethod.parmPeriodEnd_JP();

                    if (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::DirectOff)
                    {
                        specialDepPostedAmt = AssetDepTransMap_JP::calcAccumulatedExtraDepAmtMst(_assetDepBookMap, assetDepTableMethod.parmPeriodStart_JP(), assetDepTableMethod.parmPeriodEnd_JP(), 0, true);
                    }
                    else
                    {
                        specialDepPostedAmt = -AssetDepTransMap_JP::calcAccumulatedAmtMstPerDateTranstype(_assetDepBookMap, periodStart, periodEnd, AssetTransType::AdditionalDepReserve_JP);
                    }

                    transDate = assetDepTableMethod.parmPeriodEnd_JP();

                    assetDepTableMethod.calc();

                    allowableLimit = assetDepTableMethod.calcAllowableLimitForSumOfDepYTD();

                    tmpData.clear();
                    tmpData.TransDate = transDate;
                    tmpData.SpecialDepAllowableLimit = allowableLimit - preAllowableLimit;
                    tmpData.SpecialDepPostedAmt = specialDepPostedAmt;

                    if (tmpData.SpecialDepAllowableLimit == 0 && tmpData.SpecialDepPostedAmt == 0)
                    {
                        continue;
                    }
                    tmpData.insert();
                }
            }
            // For special depreciation method
            else
            {
                tmpData.ttsbegin();

                assetDepTableMethod = _assetDepBookMap.AssetDepBookMap_JP::assetDepTableMethod(dateMax(), false, false, true);
                assetDepTableMethod.parmIsCatchUpDepreciation(true);
                assetDepTableMethod.parmIsRecaptureDepreciation(true);

                depreciationStartDate = _assetDepBookMap.DepreciationStartDate;
                assetTableInterval = assetDepTableMethod.getAssetTableInterval(depreciationStartDate);
                assetDepTableMethod.parmPeriodStart_JP(depreciationStartDate);
                assetDepTableMethod.parmPeriodEnd_JP(assetTableInterval.endPeriod(depreciationStartDate));

                if (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::Reserve)
                {
                    [reserveEndDate, allocationStartDate] = AssetSpecialDepHelper_JP::calcAllocationStartDate(_assetDepBookMap);
                }

                while (assetDepTableMethod.next())
                {
                    directOffPeriods++;
                    periodStart = assetDepTableMethod.parmPeriodStart_JP();
                    periodEnd   = assetDepTableMethod.parmPeriodEnd_JP();
                    if ((depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::DirectOff
                         && directOffPeriods > depreciationProfileExt.SpecialDepApplyNumOfPeriods_JP)
                        || (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::Reserve
                            && assetDepTableMethod.parmPeriodEnd_JP() > reserveEndDate))
                    {
                        break;
                    }

                    if (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::DirectOff)
                    {
                        specialDepPostedAmt = AssetDepTransMap_JP::calcAccumulatedExtraDepAmtMst(_assetDepBookMap, assetDepTableMethod.parmPeriodStart_JP(), assetDepTableMethod.parmPeriodEnd_JP(), 0, true);
                    }
                    else
                    {
                        specialDepPostedAmt = AssetSpecialDepHelper_JP::calcAccumulatedReserveAmountMst(_assetDepBookMap, periodStart, periodEnd);
                    }

                    transDate = assetDepTableMethod.parmPeriodEnd_JP();
                    isNewYear = (assetTableInterval.findFirstDayOfYear(transDate) == assetDepTableMethod.parmPeriodStart_JP());

                    if (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::Reserve)
                    {
                        isReserveToAllocation = isAllocation;
                        isAllocation = transDate >= allocationStartDate;
                        isReserveToAllocation = isReserveToAllocation != isAllocation;
                    }

                    assetDepTableMethod.calc();

                    if (isNewYear || isReserveToAllocation)
                    {
                        preAllowableLimit = 0;
                    }
                    else if (allowableLimit)
                    {
                        preAllowableLimit = allowableLimit;
                    }

                    allowableLimit = assetDepTableMethod.calcAllowableLimitForSumOfDepYTD();

                    tmpData.clear();
                    tmpData.TransDate = transDate;
                    tmpData.SpecialDepAllowableLimit = allowableLimit - preAllowableLimit;
                    tmpData.SpecialDepPostedAmt = specialDepPostedAmt;

                    if (tmpData.SpecialDepAllowableLimit == 0 && tmpData.SpecialDepPostedAmt == 0)
                    {
                        continue;
                    }
                    tmpData.insert();
                }

                tmpData.ttscommit();
            }
        }

        return tmpData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDepProfileSpecialDepReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>AssetSpecialDepReserveTmp_JP</c> records used in Inquiry>Profile>Special depreciation reserve.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// An <c>AssetGroupDepBookMap_JP</c> record.
    /// </param>
    /// <returns>
    /// <c>AssetSpecialDepReserveTmp_JP</c> records.
    /// </returns>
    public static AssetSpecialDepReserveTmp_JP initDepProfileSpecialDepReserve(AssetDepBookMap_JP _assetDepBookMap)
    {
        #isoCountryRegionCodes
        #AssetDepCalculation_JP

        AssetAmount depreciationAmt;
        AssetTableInterval assetTableInterval;
        AssetTransDate transDate;
        AssetTransDate reserveEndDate, allocationStartDate;
        AssetDepreciationProfile depreciationProfileExt;
        AssetDepTableMethodInterface_JP assetDepTableMethod;
        AssetSpecialDepReserveTmp_JP tmpData;

        AssetSpecialDepDistributionLineTmp_JP  distributionLineTmp;
        AssetSpecialDepDistributionLineTmp_JP  reserveAllocationTmp;
        AssetDepTransMap_JP assetTransMap;
        // Stores additional reserves which will happen in future
        List reserveInfos = new List(Types::Container);
        //Stores additional reserves including exsiting trans
        List reserveTrans = new List(Types::Container);
        container reserveInfo;
        ListEnumerator enumerator;
        AssetTransDate depreciationStartDate;
        int reservePeriods;
        AssetTransDate periodEnd;
        AssetTransdate reserveEffectiveDate;
        AssetAmount amountCur;
        AssetTransType reserveTransType;
        AssetAmount beginningBalance;
        TransactionReversalTrans transReversal;
        real signOfReserve;
        AssetTransDate reserveDate;
        AssetAmount reserveAmount;

        assetTransMap = AssetDepTransMap_JP::getEmptyTableBuffer(AssetDepCalculationHelper_JP::determineAssetBookType(_assetDepBookMap.TableId));
        if (_assetDepBookMap.Status == AssetStatus::Open
            || _assetDepBookMap.Status == AssetStatus::NoAcquisition)
        {
            depreciationProfileExt = _assetDepBookMap.depreciationExtProfile();

            if (depreciationProfileExt.SpecialDepAccountingMethod_JP == AssetSpecialDepAccountingMethod_JP::Reserve)
            {
                if (depreciationProfileExt.Method == AssetDepreciationMethod::AdditionalDepreciation_JP)
                {
                    tmpData.ttsbegin();

                    reserveTransType    = AssetTransType::AdditionalDepReserve_JP;
                    //calculate reserve
                    if (_assetDepBookMap.LastDepreciationDateExtraOrd)
                    {
                        depreciationStartDate =  _assetDepBookMap.LastDepreciationDateExtraOrd + 1;
                    }
                    else
                    {
                        depreciationStartDate = _assetDepBookMap.SpecialDepStartDate ? _assetDepBookMap.SpecialDepStartDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    }

                    // Calcuate reserve first
                    assetDepTableMethod = _assetDepBookMap.AssetDepBookMap_JP::assetDepTableMethod(dateMax(), false, false, true);
                    assetTableInterval = assetDepTableMethod.getAssetTableInterval();
                    assetDepTableMethod.parmPeriodStart_JP(depreciationStartDate);
                    assetDepTableMethod.parmPeriodEnd_JP(assetTableInterval.endPeriod(depreciationStartDate));
                    while (assetDepTableMethod.next())
                    {
                        reservePeriods++;

                        transDate = assetDepTableMethod.parmPeriodEnd_JP();
                        amountCur = -assetDepTableMethod.calc();

                        if (amountCur)
                        {
                            reserveInfos.addEnd([transDate, amountCur, 0, 0]);
                            reserveTrans.addEnd([transDate, amountCur, 0, 0]);
                        }
                    }

                    // Find existing reserve trans
                    reserveEffectiveDate = AssetSpecialDepHelper_JP::calcReserveEffectiveDate(_assetDepBookMap);
                    while select TransDate, AmountMST, TableId, RecId from assetTransMap
                        where assetTransMap.AssetId == _assetDepBookMap.AssetId
                            && assetTransMap.AssetBookId == _assetDepBookMap.AssetBookId
                            && assetTransMap.TransType == reserveTransType
                            && assetTransMap.TransDate >= reserveEffectiveDate
                        notExists join transReversal
                            where transReversal.RefRecId == assetTransMap.RecId
                                && transReversal.RefTableId == assetTransMap.TableId
                                && transReversal.Reversed == NoYes::Yes
                    {
                        reserveTrans.addEnd([assetTransMap.TransDate, assetTransMap.AmountMST, assetTransMap.RecId, assetTransMap.TableId]);
                    }

                    //calculate allocation secondly
                    enumerator = reserveTrans.getEnumerator();
                    while (enumerator.moveNext())
                    {
                        reserveInfo = enumerator.current();
                        reserveDate = conPeek(reserveInfo, #PosForReserveDate);
                        reserveAmount = conPeek(reserveInfo, #PosForReserveAmount);
                        signOfReserve = sign(reserveAmount);
                        assetDepTableMethod = _assetDepBookMap.AssetDepBookMap_JP::assetDepTableMethod(dateMax(), false, false, true);
                        assetTableInterval  = AssetSpecialDepHelper_JP::assetTableIntervalForAllocationWithDepBookMap(_assetDepBookMap);
                        assetDepTableMethod.parmSpecialDepReserveDate(reserveDate);
                        assetDepTableMethod.parmSpecialDepReserveAmount(abs(reserveAmount));
                        assetDepTableMethod.parmSpecialDepReserveRecId(conPeek(reserveInfo, 3));
                        assetDepTableMethod.parmSpecialDepReserveTableId(conPeek(reserveInfo, 4));

                        assetDepTableMethod.initAdditional();
                        depreciationStartDate = assetTableInterval.findLastDayOfYear(reserveDate) + 1;
                        depreciationStartDate = max(_assetDepBookMap.SpecialDepLastAllocationDate + 1, depreciationStartDate);
                        assetDepTableMethod.parmPeriodStart_JP(depreciationStartDate);
                        assetDepTableMethod.parmPeriodEnd_JP(assetTableInterval.endPeriod(depreciationStartDate));

                        while (assetDepTableMethod.next())
                        {
                            periodEnd   = assetDepTableMethod.parmPeriodEnd_JP();

                            amountCur = -1 * signOfReserve * assetDepTableMethod.calc();
                            if (amountCur)
                            {
                                distributionLineTmp.AllocationAmount = amountCur;
                                distributionLineTmp.TransDate = periodEnd;
                                distributionLineTmp.insert();
                            }
                        }
                    }

                    //summerize alloation
                    insert_recordset reserveAllocationTmp(transDate, AllocationAmount)
                        select TransDate, sum(AllocationAmount) from distributionLineTmp
                            group by distributionLineTmp.TransDate;

                    enumerator = reserveInfos.getEnumerator();
                    // insert calculated reserve
                    while (enumerator.moveNext())
                    {
                        reserveInfo = enumerator.current();
                        reserveAllocationTmp.clear();
                        reserveAllocationTmp.TransDate = conPeek(reserveInfo, 1);
                        reserveAllocationTmp.ReserveAmount -= conPeek(reserveInfo, 2);
                        reserveAllocationTmp.AllocationAmount = 0;
                        reserveAllocationTmp.insert();
                    }

                    beginningBalance = -AssetDepTransMap_JP::calcBeginningBalanceOfTransTypes(
                        _assetDepBookMap,
                        max(_assetDepBookMap.LastDepreciationDateExtraOrd, _assetDepBookMap.SpecialDepLastAllocationDate),
                        [AssetTransType::AdditionalDepReserve_JP, AssetTransType::AdditionalDepReserveAllocation_JP]);

                    while select TransDate, sum(ReserveAmount), sum(AllocationAmount) from reserveAllocationTmp
                        group by reserveAllocationTmp.TransDate
                    {
                        tmpData.TransDate = reserveAllocationTmp.TransDate;
                        tmpData.SpecialDepReserveAmt = reserveAllocationTmp.ReserveAmount;
                        tmpData.SpecialDepBeginningBalAmt = beginningBalance + reserveAllocationTmp.ReserveAmount;
                        tmpData.SpecialDepReserveAllocationAmt = reserveAllocationTmp.AllocationAmount;
                        tmpData.SpecialDepEndingBalAmt = tmpData.SpecialDepBeginningBalAmt - tmpData.SpecialDepReserveAllocationAmt;
                        tmpData.insert();
                        beginningBalance  = tmpData.SpecialDepEndingBalAmt;
                    }
                    tmpData.ttscommit();
                }
                // For special depreciation method
                else
                {
                    tmpData.ttsbegin();

                    [reserveEndDate, allocationStartDate] = AssetSpecialDepHelper_JP::calcAllocationStartDate(_assetDepBookMap);

                    assetDepTableMethod = _assetDepBookMap.AssetDepBookMap_JP::assetDepTableMethod(dateMax(), false, false, true);

                    if (_assetDepBookMap.LastDepreciationDateExtraOrd)
                    {
                        depreciationStartDate = _assetDepBookMap.LastDepreciationDateExtraOrd + 1;
                    }
                    else
                    {
                        depreciationStartDate = _assetDepBookMap.DepreciationStartDate;
                    }

                    assetTableInterval  = assetDepTableMethod.getAssetTableInterval(depreciationStartDate);
                    assetDepTableMethod.parmPeriodStart_JP(depreciationStartDate);
                    assetDepTableMethod.parmPeriodEnd_JP(assetTableInterval.endPeriod(depreciationStartDate));

                    beginningBalance = -AssetDepTransMap_JP::calcBeginningBalanceOfTransTypes(
                        _assetDepBookMap,
                        depreciationStartDate,
                        [AssetTransType::SpecialDepReserve_JP, AssetTransType::SpecialDepReserveAllocation_JP]);

                    while (assetDepTableMethod.next())
                    {
                        transDate = assetDepTableMethod.parmPeriodEnd_JP();

                        depreciationAmt = assetDepTableMethod.calc();

                        tmpData.clear();
                        tmpData.TransDate = transDate;

                        if (transDate <= reserveEndDate)
                        {
                            tmpData.SpecialDepReserveAmt = depreciationAmt;
                            tmpData.SpecialDepReserveAllocationAmt = 0;
                        }
                        else
                        {
                            tmpData.SpecialDepReserveAmt = 0;
                            tmpData.SpecialDepReserveAllocationAmt = depreciationAmt;
                        }

                        tmpData.SpecialDepBeginningBalAmt = beginningBalance + tmpData.SpecialDepReserveAmt;
                        tmpData.SpecialDepEndingBalAmt = tmpData.SpecialDepBeginningBalAmt - tmpData.SpecialDepReserveAllocationAmt;
                        beginningBalance = tmpData.SpecialDepEndingBalAmt;

                        if ((tmpData.SpecialDepReserveAmt == 0
                             && tmpData.SpecialDepReserveAllocationAmt == 0)
                            || (_assetDepBookMap.LastDepreciationDateExtraOrd
                             && tmpData.TransDate <= _assetDepBookMap.LastDepreciationDateExtraOrd))
                        {
                            continue;
                        }
                        tmpData.insert();
                    }

                    tmpData.ttscommit();
                }
            }
        }

        return tmpData;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Asset</ConfigurationKey>
	<CountryRegionCodes>JP</CountryRegionCodes>
	<DeveloperDocumentation>@FixedAssets:FA_MessageDeveloper_AssetDepBookMap_JP</DeveloperDocumentation>
	<Label>@FixedAssets:FA_EntityTitle_AssetDepBookMap</Label>
	<FieldGroups />
	<Fields>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>AcquisitionDate</Name>
			<ExtendedDataType>AssetAcquisitionDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AcquisitionPrice</Name>
			<ExtendedDataType>AssetAcquisitionPrice</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>AllocationStartDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>AllowableLimitForAccumulatedDepType</Name>
			<EnumType>AssetLimitForAccumulatedDepType_JP</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AssetBookId</Name>
			<ExtendedDataType>AssetBookId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AssetGroup</Name>
			<ExtendedDataType>AssetGroupId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AssetId</Name>
			<ExtendedDataType>AssetId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AssetRevisedAcquisitionCost_JP</Name>
			<ExtendedDataType>AssetRevisedAcquisitionCost_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>AssetRevisedAcquisitionCostStartDate</Name>
			<CountryRegionCodes>JP</CountryRegionCodes>
			<ExtendedDataType>AssetTransDate</ExtendedDataType>
			<Label>@ApplicationSuite_Localization:AssetRevisedAcquisitionCostStartDate_JP</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>AssetStatus</Name>
			<EnumType>AssetStatus</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>Depreciation</Name>
			<ExtendedDataType>AssetDepreciate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>DepreciationConvention</Name>
			<EnumType>AssetDepreciationConvention</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>DepreciationStartDate</Name>
			<ExtendedDataType>AssetDepreciationStartDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>EquallyDividedStartDate</Name>
			<ExtendedDataType>AssetDepYearsEquallyDividedStartDate_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>LastDepreciationDate</Name>
			<ExtendedDataType>AssetLastDepreciationDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>LastDepreciationDateAccelerated</Name>
			<ExtendedDataType>AssetLastDepreciationDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>LastDepreciationDateExtraOrd</Name>
			<ExtendedDataType>AssetLastDepreciationDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>LastReserveAllocationDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>LifeTime</Name>
			<ExtendedDataType>AssetLifeTime</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>LifeTimeRest</Name>
			<ExtendedDataType>AssetLifeTimeRest</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ScrapValue</Name>
			<ExtendedDataType>AssetScrapValue</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ServiceLife</Name>
			<ExtendedDataType>AssetServiceLife</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>SpecialDepAllocationPeriods_JP</Name>
			<ExtendedDataType>AssetSpecialDepAllocationPeriods_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>SpecialDepAllocationUnit_JP</Name>
			<ExtendedDataType>AssetSpecialDepAllocationUnit_JP</ExtendedDataType>
			<EnumType>AssetAccrualFiscal</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>SpecialDepLastAllocationDate</Name>
			<ExtendedDataType>AssetSpecialDepLastAllocationDate_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>SpecialDepStartDate</Name>
			<ExtendedDataType>AssetSpecialDepStartDate_JP</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>Status</Name>
			<EnumType>AssetStatus</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>UsedFromDate</Name>
			<ExtendedDataType>AssetUsedFromDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>SpecialDepAllocationConvention_JP</Name>
			<EnumType>AssetSpecialDepAllocationConvention_JP</EnumType>
		</AxMapBaseField>
	</Fields>
	<Mappings />
</AxMap>