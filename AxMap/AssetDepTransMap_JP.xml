<?xml version="1.0" encoding="utf-8"?>
<AxMap xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetDepTransMap_JP</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class AssetDepTransMap_JP extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustQueryForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the query to consider the document information.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_query">
    /// The query to adjust.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <param name="_isExcludeDocumentTrans">
    /// Whether to exclude document transactions. Optional.
    /// If it is set, this method only calculates not for documents;
    /// otherwise, this method follows param _assetDocumentEntryRecId rule.
    /// </param>
    private static void adjustQueryForDocument(
        AssetDepBookMap_JP      _assetDepBookMap,
        Query                   _query,
        RefRecId                _assetDocumentEntryRecId,
        boolean                 _isExcludeDocumentTrans = false)
    {
        if (_query)
        {
            AssetDepTransMap_JP assetDepTrans = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            QueryBuildDataSource qbds = _query.dataSourceTable(assetDepTrans.TableId);
            if (qbds)
            {
                FieldName recIdFieldName = fieldStr(AssetTransTmp, RecId);
                FieldName docEntryFieldName = fieldStr(AssetTransTmp, AssetDocumentEntry_JP);
                if (_isExcludeDocumentTrans)
                {
                    qbds.addRange(fieldName2id(assetDepTrans.TableId, docEntryFieldName)).value(SysQuery::value(0));
                }
                else if (_assetDocumentEntryRecId)
                {
                    qbds.addRange(fieldName2id(assetDepTrans.TableId, docEntryFieldName)).value(SysQuery::value(_assetDocumentEntryRecId));
                }
                else
                {
                    // Check whethere there is any document that needs to exclude its trans for normal depreciation.
                    // If no such document exists, then no need to adjust the query.
                    container docTypesToExcludeFromNormalDep = AssetDepTransMap_JP::getDocTypeListToExcludeFromNormalDep();
                    if (AssetDocumentEntry_JP::existDocumentTypesForAsset(
                            _assetDepBookMap.AssetId,
                            _assetDepBookMap.AssetBookId,
                            docTypesToExcludeFromNormalDep))
                    {
                        FieldName docTypeFieldName = fieldStr(AssetTransTmp, Type_JP);
                        qbds.addRange(fieldName2id(assetDepTrans.TableId, docTypeFieldName)).value(queryNotValueCon_W(docTypesToExcludeFromNormalDep));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccumulatedAcceleratedDepAmountMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the accumulated accelerated depreciation amount in accounting currency in specified date range.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <returns>
    /// The accumulated accelrated depreciation amount in accounting currency.
    /// </returns>
    public static AssetAmount calcAccumulatedAcceleratedDepAmountMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _fromDate,
        AssetTransDate      _toDate)
    {
        AssetAmount ret;

        if (_fromDate <= _toDate)
        {
            AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId);

            select sum(AmountMST) from assetTransTmp
                where assetTransTmp.AssetId == _assetDepBookMap.AssetId
                    && assetTransTmp.BookId == _assetDepBookMap.AssetBookId
                    && assetTransTmp.TransDate >= _fromDate
                    && assetTransTmp.TransDate <= _toDate
                    && assetTransTmp.TransType == AssetTransType::ExtraordinaryDepreciation
                    && assetTransTmp.Type_JP == AssetDocumentType_JP::AssetAcceleratedDepreciation;
            ret = assetTransTmp.AmountMST;
        }

        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccumulatedAmtMstPerDateTranstype</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates accumulated amount to specific date and transaction type.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_assetTransType">
    /// Asset transaction type.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <param name="_isExcludeDocumentTrans">
    /// Whether to exclude document transactions. Optional.
    /// If it is set, this method only calculates not for documents;
    /// otherwise, this method follows param _assetDocumentEntryRecId rule.
    /// </param>
    /// <returns>
    /// The accumulated amount.
    /// </returns>
    public static AmountMST calcAccumulatedAmtMstPerDateTranstype(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _fromDate,
        AssetTransDate      _toDate,
        AssetTransType      _assetTransType,
        RefRecId            _assetDocumentEntryRecId  = 0,
        boolean             _isExcludeDocumentTrans = false)
    {
        AssetDepTransMap_JP     assetDepTransMap;

        if (_fromDate <= _toDate)
        {
            assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //     from assetDepTransMap
            //     where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //         && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //         && assetDepTransMap.TransDate   >= _fromDate
            //         && assetDepTransMap.TransDate   <= _toDate
            //         && assetDepTransMap.TransType   == _assetTransType

            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(SysQuery::range(_fromDate, _toDate));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(_assetTransType));

            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId, _isExcludeDocumentTrans);

            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
            }
        }

        return assetDepTransMap.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccumulatedDepAmountMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the accumulated depreciation amount in accounting currency in specified date range.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The accumulated depreciation amount in accounting currency.
    /// </returns>
    public static AssetAmount calcAccumulatedDepAmountMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _fromDate,
        AssetTransDate      _toDate,
        RefRecId            _assetDocumentEntryRecId = 0)
    {
        AssetDepTransMap_JP assetDepTransMap;
        AssetAmount totalAccumulatedDepAmountMst;

        if (_fromDate <= _toDate)
        {
            assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //     from assetDepTransMap
            //     where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //         && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //         && assetDepTransMap.TransDate   >= _fromDate
            //         && assetDepTransMap.TransDate   <= _toDate
            //         && (assetDepTransMap.TransType      == AssetTransType::Depreciation
            //             || assetDepTransMap.TransType   == AssetTransType::DepreciationAdj
            //             || assetDepTransMap.TransType   == AssetTransType::WriteDownAdj)

            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(AssetTransType::Depreciation));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(SysQuery::range(_fromDate, _toDate));

            // Since assetDepTransMap is using AssetTransTmp, which is an In-Memory table, it performs better to run 2 separate queries - one with IsPriorYear and one without.
            // When an In-Memory table is joined to a physical table/View, the joined table is called row by row for each record in the In-Memory table.
            // This is unnecessary for the majority of the records in AssetTrans so only run the query for IsPriorYear in a separate query.
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, IsPriorYear))).value(SysQuery::value(NoYes::No));

            AssetProposalDepreciationContext context = AssetProposalDepreciationContext::current();
            if (context && context.visibleTransTypesSet)
            {
                assetDepTransMap_JP::buildTransTypeQueryRange(context.visibleTransTypesSet, qbds, transMapFieldToTableField);
            }
            else
            {
                qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(AssetTransType::DepreciationAdj));
                qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(AssetTransType::WriteDownAdj));
            }
            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId);

            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
                totalAccumulatedDepAmountMst = assetDepTransMap.AmountMST;
            }

            totalAccumulatedDepAmountMst += AssetDepTransMap_JP::runQueryForIsPriorYear(query, assetDepTransMap, _assetDepBookMap, _fromDate, _toDate);
        }

        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (totalAccumulatedDepAmountMst);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runQueryForIsPriorYear</Name>
				<Source><![CDATA[
    private static AssetAmount runQueryForIsPriorYear(
        Query _query, 
        AssetDepTransMap_JP _assetDepTransMap, 
        AssetDepBookMap_JP _assetDepBookMap,
        AssetTransDate _fromDate,
        AssetTransDate _toDate)
    {
        AssetAmount amount;

        Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), _assetDepTransMap.TableId);

        Query priorYearQuery = new Query(_query);
        QueryBuildDataSource qbds = priorYearQuery.dataSourceTable(_assetDepTransMap.TableId);
        SysQuery::findOrCreateRange(qbds, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, IsPriorYear))).value(SysQuery::value(NoYes::Yes));

        QueryBuildDataSource priorYearEffectiveDate_ds = qbds.addDataSource(tableNum(AssetPriorYearEffectiveDateView));
        priorYearEffectiveDate_ds.addLink(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId)), fieldNum(AssetPriorYearEffectiveDateView, AssetId));
        priorYearEffectiveDate_ds.addLink(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId)), fieldNum(AssetPriorYearEffectiveDateView, BookId));
        priorYearEffectiveDate_ds.addLink(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate)), fieldNum(AssetPriorYearEffectiveDateView, TransDate));
        priorYearEffectiveDate_ds.addLink(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, IsPriorYear)), fieldNum(AssetPriorYearEffectiveDateView, IsPriorYear));
        priorYearEffectiveDate_ds.addRange(fieldNum(AssetPriorYearEffectiveDateView, EffectiveTransDate)).value(SysQuery::range(_fromDate, _toDate));

        QueryRun qr = new QueryRun(priorYearQuery);
        qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
        if (qr.next())
        {
            _assetDepTransMap = qr.get(_assetDepTransMap.TableId);
            amount = _assetDepTransMap.AmountMST;
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTransTypeQueryRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build the query range condition base on provided transaction types
    /// </summary>
    /// <param name = "_transTypesSet">Set of transaction types</param>
    /// <param name = "_qbds">Provided query build data source</param>
    /// <param name = "_transMapFieldToTableField">Field map to table</param>
    private static void buildTransTypeQueryRange(Set _transTypesSet, QueryBuildDataSource _qbds, Map _transMapFieldToTableField)
    {
        SetEnumerator setEnumerator = _transTypesSet.getEnumerator();
        while (setEnumerator.moveNext())
        {
            setEnumerator.current();
            str assetTransTypeValue = SysQuery::value(setEnumerator.current());
            if (assetTransTypeValue)
            {
                _qbds.addRange(_transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(assetTransTypeValue);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccumulatedDepAmountMstInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the accumulated depreciation amount in accounting currency from the first day of current year to specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of an <c>AssetTableInterval</c> subclass.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The accumulated depreciation amount in accounting currency.
    /// </returns>
    /// <remarks>
    /// The fixed asset recapture function will create two depreciation adjument transaction when doing the additional accquisition,
    /// one is the adjustment for current year, the other is for prior years. The transaction date of these two adjustment transaction
    /// are the same to the accquisition date. But the adjustment transaction for prior years should be skipped for the calculation of
    /// this method as it is not for current year.
    /// </remarks>
    public static AssetAmount calcAccumulatedDepAmountMstInCurYear(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTableInterval  _assetTableInterval,
        AssetTransDate      _toDate,
        RefRecId            _assetDocumentEntryRecId = 0)
    {
        AssetDepTransMap_JP     assetDepTransMap;
        AssetTransDate          firstDayOfCurYear;

        if (_assetTableInterval)
        {
            firstDayOfCurYear = _assetTableInterval.findFirstDayOfYear(_toDate);
        }

        if (firstDayOfCurYear != dateNull())
        {
            assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //      from assetDepTransMap
            //      where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //          && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //          && assetDepTransMap.TransDate   <= _toDate
            //          && assetDepTransMap.TransDate   >= firstDayOfCurYear
            //          && (assetDepTransMap.TransType      == AssetTransType::Depreciation
            //              || (assetDepTransMap.TransType      == AssetTransType::DepreciationAdj
            //                  && assetDepTransMap.IsPriorYear == NoYes::No)
            //              || assetDepTransMap.TransType   == AssetTransType::ExtraordinaryDepreciation)
            //      exists join assetDocumentTrans
            //          where assetDocumentTrans.RefTableId             == assetDepTransMap.TableId
            //              && assetDocumentTrans.RefRecId              == assetDepTransMap.RecId
            //              && assetDocumentTrans.AssetDocumentEntry_JP == _assetDocumentEntryRecId;
            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(SysQuery::range(firstDayOfCurYear, _toDate));

            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(AssetTransType::Depreciation));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(
                strFmt(
                    '((%1 == %2) && (%3 == %4))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    any2int(AssetTransType::DepreciationAdj),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, IsPriorYear))),
                    any2int(NoYes::No)));

            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId);

            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
            }
        }

        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (assetDepTransMap.AmountMST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAccumulatedExtraDepAmtMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the accumulated extra depreciation amount in accounting currency in specified date range.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <param name="_isExcludeDocumentTrans">
    /// Whether to exclude document transactions. Optional.
    /// If it is set, this method only calculates not for documents;
    /// otherwise, this method follows param _assetDocumentEntryRecId rule.
    /// </param>
    /// <returns>
    /// The accumulated extra depreciation amount in accounting currency.
    /// </returns>
    public static AssetAmount calcAccumulatedExtraDepAmtMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _fromDate,
        AssetTransDate      _toDate,
        RefRecId            _assetDocumentEntryRecId  = 0,
        boolean             _isExcludeDocumentTrans = false)
    {
        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (AssetDepTransMap_JP::calcAccumulatedAmtMstPerDateTranstype(_assetDepBookMap, _fromDate, _toDate, AssetTransType::ExtraordinaryDepreciation, _assetDocumentEntryRecId, _isExcludeDocumentTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountMstPerDateTransTypeDocType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate accumulated amount of specified <C>AssetTransType</C> and <C>AssetDocumentType_JP</C>
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// Instance of <C>AssetDepBookMap_JP</C>
    /// </param>
    /// <param name="_fromDate">
    /// From date to calculate
    /// </param>
    /// <param name="_toDate">
    /// To date to calculate
    /// </param>
    /// <param name="_assetTransType">
    /// Instance of <C>AssetTransType</C>
    /// </param>
    /// <param name="_docTyppe">
    /// Instance of <C>AssetDocumentType_JP</C>
    /// </param>
    /// <returns>
    /// Accumulated amount of specified <C>AssetTransType</C> and <C>AssetDocumentType_JP</C>
    /// </returns>
    public static AssetAmount calcAmountMstPerDateTransTypeDocType(
        AssetDepBookMap_JP      _assetDepBookMap,
        AssetTransDate          _fromDate,
        AssetTransDate          _toDate,
        AssetTransType          _assetTransType,
        AssetDocumentType_JP    _docTyppe)
    {
        AssetAmount ret;

        if (_fromDate <= _toDate)
        {
            AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId);
            select sum(AmountMST) from assetTransTmp
                where assetTransTmp.AssetId == _assetDepBookMap.AssetId
                    && assetTransTmp.BookId == _assetDepBookMap.AssetBookId
                    && assetTransTmp.TransType == _assetTransType
                    && assetTransTmp.TransDate >= _fromDate
                    && assetTransTmp.TransDate <= _toDate
                    && assetTransTmp.Type_JP == _docTyppe;
            ret = assetTransTmp.AmountMST;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amounts to depreciate for a specified record of <C>AssetDepBookMap_JP</C> based on a specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_transDate">
    /// The date to calculate depreciation amount.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of <C>AssetTableInterval</C>; optional.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The amounts to depreciate.
    /// </returns>
    public static AssetAmount calcAmountToDepreciate(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _transDate,
        AssetTableInterval  _assetTableInterval = null,
        RefRecId            _assetDocumentEntryRecId = 0)
    {

        AssetAmountCalculationContract_JP assetAmountCalculationContract = AssetDepTransMap_JP::doCalcAmountToDepreciate(_assetDepBookMap,
            _transDate,
            _assetTableInterval,
            _assetDocumentEntryRecId);

        return assetAmountCalculationContract.parmAssetDepAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountToDepreciateReporting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amounts to depreciate for a specified record of <C>AssetDepBookMap_JP</C> based on a specified date in reporting currency.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_transDate">
    /// The date to calculate depreciation amount.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of <C>AssetTableInterval</C>; optional.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The amounts to depreciate in reporting currency.
    /// </returns>
    public static AssetAmount calcAmountToDepreciateReporting(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _transDate,
        AssetTableInterval  _assetTableInterval = null,
        RefRecId            _assetDocumentEntryRecId = 0)
    {

        AssetAmountCalculationContract_JP assetAmountCalculationContract = AssetDepTransMap_JP::doCalcAmountToDepreciate(_assetDepBookMap,
            _transDate,
            _assetTableInterval,
            _assetDocumentEntryRecId);

        return assetAmountCalculationContract.parmAssetDepAmountReporting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCalcAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amounts to depreciate for a specified record of <C>AssetDepBookMap_JP</C> based on a specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_transDate">
    /// The date to calculate depreciation amount.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of <C>AssetTableInterval</C>; optional.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The amounts to depreciate.
    /// </returns>
    internal static AssetAmountCalculationContract_JP doCalcAmountToDepreciate(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _transDate,
        AssetTableInterval  _assetTableInterval = null,
        RefRecId            _assetDocumentEntryRecId = 0)
    {
        AssetDepTransMap_JP     assetDepTransMap;
        AssetTableInterval      assetTableInterval = _assetTableInterval;
        AssetTransDate          maxDateForAcquisitionTrans;

        if (assetTableInterval == null)
        {
            assetTableInterval = _assetDepBookMap.AssetDepBookMap_JP::assetTableInterval();
        }

        if (_transDate < dateMax())
        {
            switch (_assetDepBookMap.DepreciationConvention)
            {
                case AssetDepreciationConvention::None:
                    // For Japan, when the convention is "None", it means the depreciation for acquisition amount can only start from next period.
                    // So only the acquisition amuonts before current period can be included.
                    maxDateForAcquisitionTrans = (_transDate == dateNull() ? dateNull() : assetTableInterval.startOfPeriod(_transDate) - 1);
                    break;

                case AssetDepreciationConvention::FullMonth:
                    maxDateForAcquisitionTrans = assetTableInterval.endPeriod(_transDate);
                    break;

                default:
                    maxDateForAcquisitionTrans = _transDate;
            }
        }
        else
        {
            // When the _transDate is set to dateMax(), it means all date trans will be included.
            maxDateForAcquisitionTrans = _transDate;
        }

        if (_transDate || maxDateForAcquisitionTrans)
        {
            assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);
            //
            // Build query
            //
            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //     from assetDepTransMap
            //     where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //         && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //         && ((assetDepTransMap.TransDate     <= maxDateForAcquisitionTrans
            //                 && (assetDepTransMap.TransType      == AssetTransType::Acquisition
            //                     || assetDepTransMap.TransType   == AssetTransType::AcquisitionAdj
            //                     || assetDepTransMap.TransType   == AssetTransType::CapitalReserveTransfer))
            //             || (assetDepTransMap.TransDate  <= _transDate
            //                 && (assetDepTransMap.TransType      == AssetTransType::Revaluation
            //                     || assetDepTransMap.TransType   == AssetTransType::WriteDownAdj
            //                     || assetDepTransMap.TransType   == AssetTransType::WriteUpAdj)))
            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, ReportingCurrencyAmount)), SelectionField::Sum);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(
                strFmt(
                    '((%1 <= %2) && ((%3 == %4) || (%3 == %5) || (%3 == %6)))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))),
                    date2StrXpp(maxDateForAcquisitionTrans),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    enum2int(AssetTransType::Acquisition),
                    enum2int(AssetTransType::AcquisitionAdj),
                    enum2int(AssetTransType::CapitalReserveTransfer)));

            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(
                strFmt(
                    '((%1 <= %2) && ((%3 == %4) || (%3 == %5) || (%3 == %6)))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))),
                    date2StrXpp(_transDate),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    enum2int(AssetTransType::Revaluation),
                    enum2int(AssetTransType::WriteDownAdj),
                    enum2int(AssetTransType::WriteUpAdj)));
           
            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId);

            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
            }
        }

        AssetAmountCalculationContract_JP ret = new AssetAmountCalculationContract_JP();
        ret.parmAssetDepAmount(assetDepTransMap.AmountMST);
        ret.parmAssetDepAmountReporting(assetDepTransMap.ReportingCurrencyAmount);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountToReserveAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amounts to reserve allocation for a specified record of <C>AssetDepBookMap_JP</C> based on a specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_transDate">
    /// The date to calculate depreciation amount.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of <C>AssetTableInterval</C>; optional.
    /// </param>
    /// <returns>
    /// The amounts to depreciate.
    /// </returns>
    public static AssetAmount calcAmountToReserveAllocation(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTransDate      _transDate,
        AssetTableInterval  _assetTableInterval = null)
    {
        AssetAmount             ret;
        AssetDepTransMap_JP     assetDepTransMap;
        AssetTableInterval      assetTableInterval = _assetTableInterval;
        TransDate               transDate;
        AssetDocumentTrans_JP               assetDocumentTrans;
        AssetDocumentReductionEntryTrans_JP assetDocumentReductionEntryTrans;
        AssetDocumentEntry_JP               assetDocumentEntry;
        AssetDocumentTable_JP               assetDocumentTable;
        AssetReductionEntryProfile_JP       reductionEntryProfile;

        if (assetTableInterval == null)
        {
            assetTableInterval = _assetDepBookMap.AssetDepBookMap_JP::assetTableInterval();
        }

        assetDocumentEntry = AssetReductionEntryManager_JP::getAssetReductionEntryByAssetBook(
            _assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId, AssetDocumentType_JP::AssetReductionEntry_Reserve);
        assetDocumentTable = AssetDocumentTable_JP::find(assetDocumentEntry.AssetDocumentTable_JP);
        reductionEntryProfile = AssetReductionEntryProfile_JP::find(assetDocumentTable.DocumentId);

        if (_transDate < dateMax())
        {
            transDate = assetTableInterval.endPeriod(_transDate);
        }
        else
        {
            transDate = _transDate;
        }

        assetDepTransMap = AssetDepTransMap_JP::getEmptyTableBuffer(AssetDepCalculationHelper_JP::determineAssetBookType(_assetDepBookMap.TableId));
        if (transDate)
        {
            select sum(PostAmountMST)
                from assetDocumentReductionEntryTrans
                join RecId from assetDocumentTrans
                where assetDocumentTrans.RecId == assetDocumentReductionEntryTrans.AssetDocumentTrans_JP
                join RecId from assetDepTransMap
                where assetDepTransMap.TableId == assetDocumentTrans.RefTableId
                    && assetDepTransMap.RecId == assetDocumentTrans.RefRecId
                    && assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
                    && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
                    && (assetDepTransMap.TransDate     <= transDate
                        && assetDepTransMap.TransType  == AssetTransType::ReductionEntryReserve_JP);

            ret = assetDocumentReductionEntryTrans.PostAmountMST;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalanceOfTransTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the beginning balance of special depreciation with reserve method
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// Instance of <C>AssetDepBookMap_JP</C>
    /// </param>
    /// <param name="_toDate">
    /// To date of special depreciation
    /// </param>
    /// <param name="_transTypes">
    /// Container of trans types
    /// </param>
    /// <returns>
    /// Returns the balance of the list of trans types
    /// </returns>
    public static AssetAmount calcBeginningBalanceOfTransTypes(
        AssetDepBookMap_JP _assetDepBookMap,
        AssetTransDate _toDate,
        container _transTypes)
    {
        AssetDepTransMap_JP assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
        Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
        qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
        qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
        qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
        qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(SysQuery::range(dateNull(), _toDate));

        int i = 1;
        while (i <= conLen(_transTypes))
        {
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))).value(SysQuery::value(conPeek(_transTypes, i)));
            i++;
        }

        QueryRun qr = new QueryRun(query);
        qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
        if (qr.next())
        {
            assetDepTransMap = qr.get(assetDepTransMap.TableId);
        }

        return assetDepTransMap.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalOfAccuAmtMstPerTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the beginning balance of accumulated transaction amount in accounting currency for specified date and transaction type.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of an <c>AssetTableInterval</c> subclass.
    /// </param>
    /// <param name="_date">
    /// The date to calculate beginning balance.
    /// </param>
    /// <param name="_assetTransType">
    /// Asset transaction type.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <param name="_isExcludeDocumentTrans">
    /// Whether to exclude document transactions. Optional.
    /// If it is set, this method only calculates not for documents;
    /// otherwise, this method follows param _assetDocumentEntryRecId rule.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated transaction amount in accounting currency.
    /// </returns>
    public static AssetAmount calcBeginningBalOfAccuAmtMstPerTransType(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTableInterval  _assetTableInterval,
        AssetTransDate      _date,
        AssetTransType      _assetTransType,
        RefRecId            _assetDocumentEntryRecId = 0,
        boolean             _isExcludeDocumentTrans = false)
    {
        AssetDepTransMap_JP assetDepTransMap;
        AssetTransDate lastDayOfCurYear;

        if (_assetTableInterval)
        {
            lastDayOfCurYear  = _assetTableInterval.findLastDayOfYear(_date);
        }
        if (lastDayOfCurYear && lastDayOfCurYear  >= _date)
        {
            assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //     from assetDepTransMap
            //     where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //         && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //         && assetDepTransMap.TransDate < _date
            //         && assetDepTransMap.TransType   == _assetTransType

            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(
                strFmt(
                    '((%1 < %2) && (%3 == %4))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))),
                    date2StrXpp(_date),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    any2int(_assetTransType)));
            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId, _isExcludeDocumentTrans);
            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
            }
        }

        return (assetDepTransMap.AmountMST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalOfAccumuExtDepAmtMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the beginning balance of accumulated extraordinary depreciation amount in accounting currency for the specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of an <c>AssetTableInterval</c> subclass.
    /// </param>
    /// <param name="_date">
    /// The date to calculate beginning balance.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <param name="_isExcludeDocumentTrans">
    /// Whether to exclude document transactions. Optional.
    /// If it is set, this method only calculates not for documents;
    /// otherwise, this method follows param _assetDocumentEntryRecId rule.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated extraordinary depreciation amount in accounting currency.
    /// </returns>
    public static AssetAmount calcBeginningBalOfAccumuExtDepAmtMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTableInterval  _assetTableInterval,
        AssetTransDate      _date,
        RefRecId            _assetDocumentEntryRecId    = 0,
        boolean             _isExcludeDocumentTrans     = false)
    {
        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (AssetDepTransMap_JP::calcBeginningBalOfAccuAmtMstPerTransType(_assetDepBookMap, _assetTableInterval, _date, AssetTransType::ExtraordinaryDepreciation, _assetDocumentEntryRecId, _isExcludeDocumentTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalOfAccumulatedAlloAmtMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the beginning balance of accumulated allocation amount in accounting currency for the specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of an <c>AssetTableInterval</c> subclass.
    /// </param>
    /// <param name="_date">
    /// The date to calculate beginning balance.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated allocation amount in accounting currency.
    /// </returns>
    public static AssetAmount calcBeginningBalOfAccumulatedAlloAmtMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTableInterval  _assetTableInterval,
        AssetTransDate      _date)
    {
        AmountMST ret;
        if (_date && _assetDepBookMap.AssetId && _assetDepBookMap.AssetBookId)
        {
            AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId);
            select sum(AmountMST) from assetTransTmp
                where assetTransTmp.AssetId == _assetDepBookMap.AssetId
                    && assetTransTmp.BookId == _assetDepBookMap.AssetBookId
                    && assetTransTmp.TransDate < _date
                    && assetTransTmp.TransType == AssetTransType::ReductionEntryReserveAllocation_JP;
            ret = assetTransTmp.AmountMST;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalOfAccumulatedDepAmtMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the beginning balance of accumulated depreciation amount in accounting currency for the specified date.
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// A buffer of a table that mapped to map <C>AssetDepBookMap_JP</C>.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of an <c>AssetTableInterval</c> subclass.
    /// </param>
    /// <param name="_date">
    /// The date to calculate beginning balance.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    /// The record ID of asset document entry. Optional.
    /// If it is set, this method only calculates for this document;
    /// otherwise, this method calculates all transactions except the ones for
    /// document types which should not be included by default.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated depreciation amount in accounting currency.
    /// </returns>
    /// <remarks>
    /// The fixed asset recapture function will create two depreciation adjument transaction when doing the additional accquisition,
    /// one is the adjustment for current year, the other is for prior years. The transaction date of these two adjustment transaction
    /// are the same to the accquisition date. But the adjustment transaction for prior years should be considered as a predreciation
    /// in prior year.
    /// </remarks>
    public static AssetAmount calcBeginningBalOfAccumulatedDepAmtMst(
        AssetDepBookMap_JP  _assetDepBookMap,
        AssetTableInterval  _assetTableInterval,
        AssetTransDate      _date,
        RefRecId            _assetDocumentEntryRecId = 0)
    {
        AssetAmount ret;
        AssetTransDate lastDayOfCurYear;

        if (_assetTableInterval)
        {
            lastDayOfCurYear  = _assetTableInterval.findLastDayOfYear(_date);
        }
        if (lastDayOfCurYear && lastDayOfCurYear  >= _date)
        {
            AssetDepTransMap_JP assetDepTransMap = AssetDepTransMap_JP::getCacheEmptyTableBuffer();
            Map transMapFieldToTableField = VendDocumentUtil::fieldMapping(tableNum(AssetDepTransMap_JP), assetDepTransMap.TableId);

            // Here is the logic for below query before adjustment:
            // select sum(AmountMST)
            //     from assetDepTransMap
            //     where assetDepTransMap.AssetId      == _assetDepBookMap.AssetId
            //         && assetDepTransMap.AssetBookId == _assetDepBookMap.AssetBookId
            //         && ((assetDepTransMap.TransDate < _date
            //                 && (assetDepTransMap.TransType      == AssetTransType::Depreciation
            //                     || assetDepTransMap.TransType   == AssetTransType::DepreciationAdj))
            //             || (assetDepTransMap.TransDate      >= _date
            //                 && assetDepTransMap.TransDate   <= lastDayOfCurYear
            //                 && assetDepTransMap.TransType   == AssetTransType::DepreciationAdj
            //                 && assetDepTransMap.IsPriorYear == NoYes::Yes))
            Query query = new Query();
            QueryBuildDataSource qbds = query.addDataSource(assetDepTransMap.TableId);
            qbds.addSelectionField(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AmountMST)), SelectionField::Sum);
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetId))).value(SysQuery::value(_assetDepBookMap.AssetId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, AssetBookId))).value(SysQuery::value(_assetDepBookMap.AssetBookId));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(
                strFmt(
                    '((%1 < %2) && ((%3 == %4) || (%3 == %5)))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))),
                    date2StrXpp(_date),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    any2int(AssetTransType::Depreciation),
                    any2int(AssetTransType::DepreciationAdj)));
            qbds.addRange(transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))).value(
                strFmt(
                    '((%1 >= %2) && (%1 <= %3) && (%4 == %5) && (%6 == %7))',
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransDate))),
                    date2StrXpp(_date),
                    date2StrXpp(lastDayOfCurYear),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, TransType))),
                    any2int(AssetTransType::DepreciationAdj),
                    fieldId2name(assetDepTransMap.TableId, transMapFieldToTableField.lookup(fieldNum(AssetDepTransMap_JP, IsPriorYear))),
                    any2int(NoYes::Yes)));

            // Adjust the query for document
            assetDepTransMap_JP::adjustQueryForDocument(_assetDepBookMap, query, _assetDocumentEntryRecId);

            // Run
            QueryRun qr = new QueryRun(query);
            qr.setRecord(AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId));
            if (qr.next())
            {
                assetDepTransMap = qr.get(assetDepTransMap.TableId);
            }
            ret = assetDepTransMap.AmountMST;
        }
        // The amount of depreciation transactions are saved as negative value in DB.
        return -1 * (ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDocumentTypeAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amounts to depreciate for a specified document type.
    /// </summary>
    /// <param name="_documentType">
    /// The type of asset document.
    /// </param>
    /// <param name="_assetDepBookMap">
    /// A record of <C>AssetDepBookMap_JP</C>; optional.
    /// </param>
    /// <param name="_transDate">
    /// The date to calculate depreciation amount.
    /// </param>
    /// <param name="_assetTableInterval">
    /// An instance of <C>AssetTableInterval</C>; optional.
    /// </param>
    /// <returns>
    /// The amounts to depreciate.
    /// </returns>
    public static AssetAmount calcDocumentTypeAmountToDepreciate(
        AssetDocumentType_JP    _documentType,
        AssetDepBookMap_JP      _assetDepBookMap,
        AssetTransDate          _transDate,
        AssetTableInterval      _assetTableInterval = null)
    {
        AssetAmount             ret;
        AssetTableInterval      assetTableInterval = _assetTableInterval;
        AssetTransDate          maxDateForAcquisitionTrans;

        if (assetTableInterval == null)
        {
            assetTableInterval = _assetDepBookMap.AssetDepBookMap_JP::assetTableInterval();
        }

        if (_transDate < dateMax())
        {
            switch (_assetDepBookMap.DepreciationConvention)
            {
                case AssetDepreciationConvention::None:
                    // For Japan, when the convention is "None", it means the depreciation for acquisition amount can only start from next period.
                    // So only the acquisition amuonts before current period can be included.
                    maxDateForAcquisitionTrans = assetTableInterval.startOfPeriod(_transDate) - 1;
                    break;

                case AssetDepreciationConvention::FullMonth:
                    maxDateForAcquisitionTrans = assetTableInterval.endPeriod(_transDate);
                    break;

                default:
                    maxDateForAcquisitionTrans = _transDate;
                    break;
            }
        }
        else
        {
            // When the _transDate is set to dateMax(), it means all date trans will be included.
            maxDateForAcquisitionTrans = _transDate;
        }

        if (_transDate || maxDateForAcquisitionTrans)
        {
            AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetDepBookMap.AssetId, _assetDepBookMap.AssetBookId);

            select sum(AmountMST) from assetTransTmp
                where assetTransTmp.AssetId == _assetDepBookMap.AssetId
                    && assetTransTmp.BookId == _assetDepBookMap.AssetBookId
                    && ((assetTransTmp.TransDate <= maxDateForAcquisitionTrans
                    && (assetTransTmp.TransType == AssetTransType::Acquisition
                    || assetTransTmp.TransType == AssetTransType::AcquisitionAdj
                    || assetTransTmp.TransType == AssetTransType::CapitalReserveTransfer))
                    || (assetTransTmp.TransDate <= _transDate
                    && (assetTransTmp.TransType == AssetTransType::Revaluation
                    || assetTransTmp.TransType == AssetTransType::WriteDownAdj
                    || assetTransTmp.TransType == AssetTransType::WriteUpAdj)))
                    && assetTransTmp.Type_JP == _documentType;

            ret = assetTransTmp.AmountMST;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the total amount to depreciate
    /// </summary>
    /// <param name="_assetDepBookMap">
    /// Instance of <C>AssetDepBookMap_JP</C>
    /// </param>
    /// <returns>
    /// Total amount to depreciate
    /// </returns>
    /// <remarks>
    /// If the <C>AssetDepBookMap_JP</C> is not acquired, use the field AcquisitionProce
    /// </remarks>
    public static AssetAmount calcTotalAmountToDepreciate(AssetDepBookMap_JP _assetDepBookMap)
    {
        AssetAmount             totalAmount;

        if (_assetDepBookMap.AssetStatus == AssetStatus::NoAcquisition)
        {
            totalAmount = _assetDepBookMap.AcquisitionPrice;
        }
        else
        {
            totalAmount    = AssetDepTransMap_JP::calcAmountToDepreciate(_assetDepBookMap, dateMax());
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocTypeListToExcludeFromNormalDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of document types which that kind of transactions need
    /// to be exclude from normal depreciation calculation.
    /// </summary>
    /// <returns>
    /// A list of document types.
    /// </returns>
    /// <remarks>
    /// When new document type are added and use existed transaction type, if
    /// its transactions should not be included in normal depreciation calculation,
    /// it should be included into this list.
    /// </remarks>
    private static container getDocTypeListToExcludeFromNormalDep()
    {
        return [AssetDocumentType_JP::AssetRetirementObligation];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmptyTableBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns an empty table buffer for the concrete table represented by the map.
    /// </summary>
    /// <param name="_assetBookType">
    ///    The book type of transaction table that consuming the map.
    /// </param>
    /// <returns>
    ///     An empty table buffer for the concrete table represented by the map.
    /// </returns>
    public static AssetDepTransMap_JP getEmptyTableBuffer(AssetBookType _assetBookType)
    {
        AssetDepTransMap_JP ret;
        AssetTrans          assetTrans;

        ret = assetTrans;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheEmptyTableBuffer</Name>
				<Source><![CDATA[
    internal static AssetDepTransMap_JP getCacheEmptyTableBuffer()
    {
        AssetDepTransMap_JP ret;
        AssetTransTmp assetTrans;

        ret = assetTrans;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNetBookValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates net book value in specify date range.
    /// </summary>
    /// <param name="_assetId">
    /// Asset id that to calculate the net book value.
    /// </param>
    /// <param name="_assetDepBookId">
    /// Asset book id that to calculate the net book value.
    /// </param>
    /// <param name="_startDate">
    /// Start date
    /// </param>
    /// <param name="_endDate">
    /// End date
    /// </param>
    /// <param name="_assetBookType">
    /// Asset book type
    /// </param>
    /// <returns>
    /// Return net book value.
    /// </returns>
    public static AmountMST calcNetBookValue(
        AssetId         _assetId,
        AssetBookId     _assetDepBookId,
        StartDate       _startDate,
        EndDate         _endDate,
        AssetBookType   _assetBookType)
    {
        AmountMST nbvAmount;

        if (_assetId && _assetDepBookId)
        {
            StartDate startDate = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _startDate);
            EndDate endDate = DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), _endDate);
            AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetId, _assetDepBookId);

            select sum(AmountMST) from assetTransTmp
                where assetTransTmp.AssetId == _assetId
                    && assetTransTmp.BookId == _assetDepBookId
                    && (assetTransTmp.TransType == AssetTransType::Acquisition
                    || assetTransTmp.TransType == AssetTransType::AcquisitionAdj
                    || assetTransTmp.TransType == AssetTransType::Depreciation
                    || assetTransTmp.TransType == AssetTransType::DepreciationAdj
                    || assetTransTmp.TransType == AssetTransType::DisposalSale
                    || assetTransTmp.TransType == AssetTransType::DisposalScrap
                    || assetTransTmp.TransType == AssetTransType::WriteUpAdj
                    || assetTransTmp.TransType == AssetTransType::WriteDownAdj
                    || assetTransTmp.TransType == AssetTransType::Revaluation
                    || assetTransTmp.TransType == AssetTransType::CapitalReserve
                    || assetTransTmp.TransType == AssetTransType::CapitalReserveTransfer
                    || assetTransTmp.TransType == AssetTransType::ExtraordinaryDepreciation
                    || assetTransTmp.TransType == AssetTransType::ProfitLoss)
                    && assetTransTmp.TransDate >= startDate
                    && assetTransTmp.TransDate <= endDate;
            nbvAmount = assetTransTmp.AmountMST;
        }
        return nbvAmount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Asset</ConfigurationKey>
	<CountryRegionCodes>JP</CountryRegionCodes>
	<DeveloperDocumentation>@FixedAssets:FA_MessageDeveloper_AssetDepTransMap_JP</DeveloperDocumentation>
	<Label>@SYS4002743</Label>
	<FieldGroups />
	<Fields>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountCur</Name>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountMST</Name>
			<ExtendedDataType>AssetAmount</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AssetBookId</Name>
			<ExtendedDataType>AssetBookId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AssetId</Name>
			<ExtendedDataType>AssetId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CurrencyCode</Name>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<StringSize>3</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>IsPriorYear</Name>
			<AllowEdit>No</AllowEdit>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>TransDate</Name>
			<ExtendedDataType>AssetTransDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>TransType</Name>
			<EnumType>AssetTransType</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>ReportingCurrencyAmount</Name>
			<ExtendedDataType>AssetAmountReportingCurrency</ExtendedDataType>
		</AxMapBaseField>
	</Fields>
	<Mappings />
</AxMap>