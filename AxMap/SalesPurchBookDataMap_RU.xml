<?xml version="1.0" encoding="utf-8"?>
<AxMap xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesPurchBookDataMap_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class SalesPurchBookDataMap_RU extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>commissionAgentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns container, which contains INN and KPP of comission agent at given date at first place and name at second place.
    /// </summary>
    /// <param name="_factureDate">
    /// Date parameter; optional
    /// </param>
    /// <returns>
    /// Container with comission agent information.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If invalid FactureModule for current transaction
    /// </exception>
    public container commissionAgentData(FactureDate_RU _factureDate = this.FactureDate_External)
    {
        CustTable           custTable;
        VendTable           vendTable;
        INN_RU              inn;
        KPPU_RU             kpp;
        Name                name;
        FactureModule_RU    factureModule;
        DirPartyRecId       party;

        if (this.CommissionAgent)
        {
            if (this.TableId == tableNum(SalesBookTrans_RU)
             || this.TableId == tableNum(PurchBookTrans_RU))
            {
                factureModule = FactureJour_RU::findRecId(this.FactureJour_RU).Module;
            }
            else
            {
                factureModule = this.factureModule();
            }

            switch (factureModule)
            {
                case FactureModule_RU::Cust                    :
                case FactureModule_RU::TaxCorrectionSales      :
                case FactureModule_RU::TaxCorrectionPurch_Cust :
                    select firstonly Party from custTable
                        where custTable.AccountNum == this.CommissionAgent;
                    inn = custTable.partyINNasOfDate_RU(_factureDate);
                    kpp = custTable.partyKPPasOfDate_RU(_factureDate);
                    name = custTable.name();
                    party = custTable.Party;
                    break;
                case FactureModule_RU::TaxCorrectionPurch      :
                case FactureModule_RU::TaxCorrectionSales_Vend :
                case FactureModule_RU::Vend                    :
                    select firstonly Party from vendTable
                        where vendTable.AccountNum == this.CommissionAgent;
                    inn = vendTable.partyINNasOfDate_RU(_factureDate);
                    kpp = vendTable.partyKPPasOfDate_RU(_factureDate);
                    name = vendTable.name();
                    party = vendTable.Party;
                    break;
                default                     :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
        return [name, (inn && kpp ? strFmt("@GLS110628", inn, kpp) : inn), party];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAnnulment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates annulment record for current record.
    /// </summary>
    public void createAnnulment()
    {
        SalesPurchBookDataMap_RU    annulment;
        SalesPurchBookDataMap_RU    revisedRow;

        if (this.CorrectionType == FactureCorrectionType_RU::Revision && this.Annulment == NoYes::No && !this.isTmp())
        {
            revisedRow = SalesPurchBookDataMap_RU::getAnnulmentSum(this.data());

            if (revisedRow)
            {
                annulment = this.data();

                annulment.Annulment             = NoYes::Yes;
                annulment.OperationTypeCodes    = revisedRow.OperationTypeCodes;
                annulment.CommissionAgent       = revisedRow.CommissionAgent;
                annulment.AmountCurInclVAT      = -revisedRow.AmountCurInclVAT;
                annulment.AmountInclVAT         = -revisedRow.AmountInclVAT;
                annulment.AmountLiableToVAT0    = -revisedRow.AmountLiableToVAT0;
                annulment.AmountLiableToVAT10   = -revisedRow.AmountLiableToVAT10;
                annulment.AmountLiableToVAT20   = -revisedRow.AmountLiableToVAT20;
                annulment.AmountNotLiableToVAT  = -revisedRow.AmountNotLiableToVAT;
                annulment.TaxAmountVAT10        = -revisedRow.TaxAmountVAT10;
                annulment.TaxAmountVAT20        = -revisedRow.TaxAmountVAT20;
                annulment.FactureDate_External  = revisedRow.FactureDate_External;
                annulment.RevisionSeqNumber     = this.RevisionSeqNumber - 1 > 0 ? this.RevisionSeqNumber - 1 : 0;
                annulment.AccountName           = revisedRow.AccountName;

                if (this.TableId == tablenum(PurchBookTrans_RU))
                {
                    annulment.DeliveryDate      = revisedRow.DeliveryDate;
                }

                annulment.insert();

                this.AmountInclVAT          += revisedRow.AmountInclVAT;
                this.AmountLiableToVAT0     += revisedRow.AmountLiableToVAT0;
                this.AmountLiableToVAT10    += revisedRow.AmountLiableToVAT10;
                this.AmountLiableToVAT20    += revisedRow.AmountLiableToVAT20;
                this.AmountNotLiableToVAT   += revisedRow.AmountNotLiableToVAT;
                this.TaxAmountVAT10         += revisedRow.TaxAmountVAT10;
                this.TaxAmountVAT20         += revisedRow.TaxAmountVAT20;

                this.SalesPurchBookDataMap_RU::initAmountCurInclVAT();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns facture module for given transaction
    /// </summary>
    /// <returns>
    /// Facture module for given transaction
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If not overridden
    /// </exception>
    public FactureModule_RU factureModule()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureOperationTypeCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines facture operation codes for the current VAT processing journal's specification record
    /// based on a related operations.
    /// </summary>
    /// <returns>
    /// The facture operation codes for the current VAT processing journal's specification.
    /// </returns>
    public FactureOperationTypeCodes_RU factureOperationTypeCodes()
    {
        FactureOperationTypeCodes_RU            factureOperationTypeCodes;
        container                               operationTypeCodesCon;
        FactureOperationTypeCodesDelimiter_RU   delimiter;

        container deleteDuplicates(container _con)
        {
            int idx;
            container ret;

            for (idx = 1; idx <= conlen(_con); idx++)
            {
                if (! confind(ret, conpeek(_con, idx)))
                {
                    ret += conpeek(_con, idx);
                }
            }

            return ret;
        }

        operationTypeCodesCon = this.SalesPurchBookDataMap_RU::getFactureTypeCodesFromLogTransOperCon();

        operationTypeCodesCon = deleteDuplicates(operationTypeCodesCon);

        if (conlen(operationTypeCodesCon))
        {
            delimiter = SalesPurchBookDataMap_RU::factureOperationTypeCodesDelimiter_RU();

            factureOperationTypeCodes = con2Str(operationTypeCodesCon, delimiter);
        }

        return factureOperationTypeCodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets container with facture parameters.
    /// </summary>
    /// <param name="_factureJour">
    /// A source facture record associated with this book line.
    /// </param>
    /// <returns>
    /// Container with facture external id and facture external date.
    /// </returns>
    public container getFactureCon(FactureJour_RU _factureJour = null)
    {
        container       factureCon;
        FactureJour_RU  factureJour = _factureJour;

        if (! this.CorrectedFactureExternalId)
        {
            return conNull();
        }

        if (! factureJour)
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);
        }

        if (factureJour)
        {
            factureJour = factureJour.getCorrectedFacture(true);
            while (factureJour)
            {
                factureCon += [factureJour];
                next factureJour;
            }
        }

        return factureCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of original facture numbers with dates.
    /// </summary>
    /// <param name="_delimiter">
    /// A delimiter string between facture number and date.
    /// </param>
    /// <param name="_numDate">
    /// A parameter controlling the contents of the output string.
    /// </param>
    /// <param name="_newLine">
    /// A new line symbol.
    /// </param>
    /// <returns>
    /// A list of original facture numbers with dates.
    /// </returns>

    public str getFactureStr(BookDateNumDelimiter_RU _delimiter, int _numDate = 0, str _newLine = num2char(10))
    {
        FactureExternalId_RU            factureExternalId;
        FactureDate_External_RU         factureDate_External;
        SeparateDivisionId_RU           separateDivisionId;
        FactureJour_RU                  annulmentSourceFacture;
        FactureJour_RU                  factureJour;
        FactureJour_RU                  factureJourOrig;
        FactureJour_RU                  factureJourRev;
        container                       origFactureCon;
        container                       ret;
        int                             idx;

        str buildFactureStr()
        {
            factureExternalId = separateDivisionId  ? strfmt("@GLS111217", factureExternalId, separateDivisionId)
                                                    : factureExternalId;

            switch (_numDate)
            {
                case 1 : return factureExternalId;
                case 2 : return strFmt("@GLS106007", factureDate_External);
            }

            return strfmt('%1%3%2', factureExternalId, factureDate_External, _delimiter);
        }
        ;

        if (this.FactureJour_RU)
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);
        }
        else
        {
            factureJour = FactureJour_RU::find(this.FactureId, this.factureModule());
        }

        if (this.CorrectedFactureExternalId)
        {
            origFactureCon = this.SalesPurchBookDataMap_RU::getFactureCon(factureJour);
        }

        if (!this.CorrectedFactureExternalId || this.RevisionType == FactureRevisionType_RU::RevisionOriginal)
        {
            if (this.Annulment == NoYes::No)
            {
                separateDivisionId = SalesPurchBookDataMap_RU::getSeparateDivisionId(factureJour);
            }
            else
            {
                annulmentSourceFacture = SalesPurchBookDataMap_RU::getAnnulmentSourceFacture(
                        factureJour,
                        FactureJour_RU::findRecId(this.RefRevisedFacture));

                if (annulmentSourceFacture)
                {
                    separateDivisionId = SalesPurchBookDataMap_RU::getSeparateDivisionId(annulmentSourceFacture);
                }
            }

            if (origFactureCon != conNull())
            {
                factureJourOrig      = conPeek(origFactureCon, 1);
                factureExternalId    = factureJourOrig.FactureExternalId;
                factureDate_External = factureJourOrig.FactureDate_External;
            }
            else
            {
                factureExternalId    = this.FactureExternalId;
                factureDate_External = this.FactureDate_External;
            }

            ret += buildFactureStr();
        }
        else
        {
            if (this.Annulment == NoYes::Yes)
            {
                annulmentSourceFacture = SalesPurchBookDataMap_RU::getAnnulmentSourceFacture(
                        factureJour,
                        FactureJour_RU::findRecId(this.RefRevisedFacture));

                if (annulmentSourceFacture)
                {
                    factureJour     = annulmentSourceFacture;
                    origFactureCon  = this.SalesPurchBookDataMap_RU::getFactureCon(factureJour);
                }
            }

            for (idx = 1; idx <= conLen(origFactureCon); idx++)
            {
                factureJourOrig = conPeek(origFactureCon, idx);

                select firstonly factureJourRev
                    order by CreatedDateTime desc, SeqNumber desc
                        where  factureJourRev.RefRevisedFacture == factureJourOrig.RecId       &&
                              (factureJourRev.CreatedDateTime   <  factureJour.CreatedDateTime ||
                              (factureJourRev.CreatedDateTime   == factureJour.CreatedDateTime &&
                               factureJourRev.SeqNumber         <  factureJour.SeqNumber));

                separateDivisionId   = SalesPurchBookDataMap_RU::getSeparateDivisionId(factureJourRev ? factureJourRev : factureJourOrig);
                factureExternalId    = factureJourOrig.FactureExternalId;
                factureDate_External = factureJourOrig.FactureDate_External;

                ret += buildFactureStr();
            }
        }

        return con2Str(ret, _newLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureStrCorrRevision</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of original facture revision numbers with dates.
    /// </summary>
    /// <param name="_delimiter">
    /// A delimiter string between facture revision number and date.
    /// </param>
    /// <param name="_numDate">
    /// A parameter controlling the contents of the output string.
    /// </param>
    /// <param name="_newLine">
    /// A new line symbol.
    /// </param>
    /// <returns>
    /// A list of original facture revision numbers with dates.
    /// </returns>

    public str getFactureStrCorrRevision(BookDateNumDelimiter_RU _delimiter, int _numDate = 0, str _newLine = num2char(10))
    {
        str                     result;
        RevisionNum_RU          revisionNum;
        FactureDate_External_RU revisionDate;
        FactureJour_RU          origFactureLastRevision;
        FactureJour_RU          annulmentSourceFacture;
        FactureJour_RU          factureJour;
        FactureJour_RU          factureJourOrig;
        container               origFactureCon;
        container               ret;
        int                     idx;
        ;

        if (this.FactureJour_RU)
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);
        }
        else
        {
            factureJour = FactureJour_RU::find(this.FactureId, this.factureModule());
        }

        origFactureCon = this.SalesPurchBookDataMap_RU::getFactureCon(factureJour);

        for (idx = 1; idx <= conLen(origFactureCon); idx++)
        {
            factureJourOrig = conPeek(origFactureCon, idx);

            if (this.Annulment == NoYes::Yes)
            {
                annulmentSourceFacture = SalesPurchBookDataMap_RU::getAnnulmentSourceFacture(
                        factureJour,
                        FactureJour_RU::findRecId(this.RefRevisedFacture));

                if (annulmentSourceFacture)
                {
                    origFactureLastRevision = SalesPurchBookDataMap_RU::getAnnulmentSourceFacture(
                            annulmentSourceFacture,
                            factureJourOrig);
                }
            }
            else
            {
                origFactureLastRevision = SalesPurchBookDataMap_RU::getAnnulmentSourceFacture(
                        factureJour,
                        factureJourOrig);
            }

            revisionNum     = origFactureLastRevision.RevisionNum;
            revisionDate    = origFactureLastRevision.FactureDate_External;

            if (revisionNum)
            {
                switch (_numDate)
                {
                    case 1  : result = strFmt("@GLS106007", revisionNum);  break;
                    case 2  : result = strFmt("@GLS106007", revisionDate); break;
                    default : result = strFmt('%1%3%2', revisionNum, revisionDate, _delimiter);
                }
            }
            else
            {
                result = '';
            }

            ret += result;
        }

        return con2Str(ret, _newLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureStrRevisionCorr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of original facture revision numbers with dates.
    /// </summary>
    /// <param name="_delimiter">
    /// A delimiter string between facture revision number and date.
    /// </param>
    /// <param name="_numDate">
    /// A parameter controlling the contents of the output string.
    /// </param>
    /// <param name="_newLine">
    /// A new line symbol.
    /// </param>
    /// <returns>
    /// A list of original facture revision numbers with dates.
    /// </returns>

    public str getFactureStrRevisionCorr(BookDateNumDelimiter_RU _delimiter, int _numDate = 0, str _newLine = num2char(10))
    {
        str                     result;
        FactureJour_RU          factureJour;
        FactureJour_RU          factureJourOrig,
                                factureJourRevOrig;
        container               origFactureCon;
        container               ret;
        int                     idx;

        if (this.FactureJour_RU)
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);

            if (factureJour)
            {
                origFactureCon = this.SalesPurchBookDataMap_RU::getFactureCon(factureJour);

                for (idx = 1; idx <= conLen(origFactureCon); idx++)
                {
                    factureJourOrig = conPeek(origFactureCon, idx);

                    select firstonly RevisionNum, FactureDate_External from factureJourRevOrig
                        index hint RefRevisedFactureIdx
                        order by CreatedDateTime desc, SeqNumber desc
                        where factureJourRevOrig.RefRevisedFacture == factureJourOrig.RecId         &&
                             (factureJourRevOrig.CreatedDateTime   <  factureJour.CreatedDateTime   ||
                             (factureJourRevOrig.CreatedDateTime   == factureJour.CreatedDateTime   &&
                              factureJourRevOrig.SeqNumber         <  factureJour.SeqNumber));

                    if (factureJourRevOrig.RevisionNum)
                    {
                        switch (_numDate)
                        {
                            case 1  : result = strFmt("@GLS106007", factureJourRevOrig.RevisionNum);  break;
                            case 2  : result = strFmt("@GLS106007", factureJourRevOrig.FactureDate_External); break;
                            default : result = strFmt('%1%3%2', factureJourRevOrig.RevisionNum,
                                                                factureJourRevOrig.FactureDate_External, _delimiter);
                        }
                    }
                    else
                    {
                        result = '';
                    }

                    ret += result;
                }
            }
        }
        else
        {
            ret = [''];
        }

        return con2Str(ret, _newLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureTypeCodesFromLogTransOperCon</Name>
				<Source><![CDATA[
    private container getFactureTypeCodesFromLogTransOperCon()
    {
        SalesPurch salesPurch = (this.TableId == tablenum(PurchBookVATProcessLogTrans_RU)) ?
            SalesPurch::Purch :
            SalesPurch::Sales;
        SalesPurchBookVATProcessLogTransOper_RU salesPurchBookVATProcessLogTransOper = new DictTable(salesPurch == SalesPurch::Purch ?
            tablenum(PurchBookVATProcessLogTransOper_RU) :
            tablenum(SalesBookVATProcessLogTransOper_RU)).makeRecord();
        container operationTypeCodesCon;

        if (this.TableId == tablenum(PurchBookVATProcessLogTrans_RU) ||
            this.TableId == tablenum(SalesBookVATProcessLogTrans_RU))
        {
            while select SalesPurchBookVATProcessParameters_RU from salesPurchBookVATProcessLogTransOper
            group by SalesPurchBookVATProcessParameters_RU
                where salesPurchBookVATProcessLogTransOper.RefRecId == this.RecId
                    && salesPurchBookVATProcessLogTransOper.CanceledRefRecId == 0

            {
                operationTypeCodesCon += (salesPurch == SalesPurch::Purch) ?
                PurchBookVATProcessParameters_RU::find(salesPurchBookVATProcessLogTransOper.SalesPurchBookVATProcessParameters_RU).FactureOperationTypeCode :
                SalesBookVATProcessParameters_RU::find(salesPurchBookVATProcessLogTransOper.SalesPurchBookVATProcessParameters_RU).FactureOperationTypeCode;
            }
        }

        return operationTypeCodesCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAmountCurInclVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes currency amount including VAT.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record to be processed; optional.
    /// </param>
    public void initAmountCurInclVAT(FactureJour_RU _factureJour = null)
    {
        if (this.TransType == SalesPurchBookTransType_RU::SumDiff)
        {
            this.AmountCurInclVAT = 0;
        }
        else
        {
            if (this.CurrencyCode == CompanyInfoHelper::standardCurrency())
            {
                this.AmountCurInclVAT = this.AmountInclVAT;
            }
            else
            {
                this.AmountCurInclVAT = _factureJour != null         ?
                                    _factureJour.amountInclTax() :
                                    FactureJour_RU::find(this.FactureID, this.factureModule()).amountInclTax();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRefOriginalFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes reference to original facture.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record to be processed.
    /// </param>
    public void initRefOriginalFacture(FactureJour_RU _factureJour = null)
    {
        FactureJour_RU  factureJour = _factureJour;
        FactureJour_RU  factureJourOrig;
        TransDate       correctedPeriod;

        if (this.CorrectedFactureExternalId && ! this.isTmp())
        {
            if (! factureJour)
            {
                factureJour = FactureJour_RU::find(this.FactureID, this.factureModule());
            }

            correctedPeriod = factureJour.correctedPeriod(this.Annulment);

            this.FactureJour_RU  = factureJour.RecId;
            this.JointCorrection = factureJour.JointCorrection;

            if (correctedPeriod)
            {
                switch (this.TableId)
                {
                    case tablenum(SalesBookTrans_RU):
                        this.CorrectedSalesPurchBookTable_RU = SalesBookTable_RU::findFirstByClosingDate(correctedPeriod).RecId;
                        break;

                    case tablenum(PurchBookTrans_RU):
                        if (! this.ReverseDate)
                        {
                            this.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(correctedPeriod).RecId;
                        }
                        break;
                }
            }

            if (this.CorrectedSalesPurchBookTable_RU == this.SalesPurchBookTable_RU)
            {
                this.CorrectedSalesPurchBookTable_RU = 0;
            }

            if (! this.Annulment)
            {
                this.RefOriginalFacture = factureJour.RefOriginalFacture;

                if (factureJour.CorrectionType == FactureCorrectionType_RU::Unknown)
                {
                     this.CorrectionType = factureJour.CorrectedFactureExternalId
                            ? FactureCorrectionType_RU::Correction
                            : FactureCorrectionType_RU::Unknown;
                }
                else
                {
                    this.CorrectionType = factureJour.CorrectionType;
                }

                switch (this.CorrectionType)
                {
                    case FactureCorrectionType_RU::Correction:
                        if (this.TransType == SalesPurchBookTransType_RU::CreditNote)
                        {
                            this.CorrectedSalesPurchBookTable_RU = 0;
                        }
                        else
                        {
                            if (this.TableId == tablenum(PurchBookTrans_RU))
                            {
                                this.CorrectedSalesPurchBookTable_RU = 0;
                            }
                        }

                        break;

                    case FactureCorrectionType_RU::Revision:
                        this.RevisionSeqNumber = factureJour.RevisionNum;
                        this.RefRevisedFacture = factureJour.RefRevisedFacture;

                        factureJourOrig = FactureJour_RU::findRecId(factureJour.RefRevisedFacture);

                        if (factureJourOrig.CorrectedFactureExternalId)
                        {
                            switch (this.TableId)
                            {
                                case tablenum(SalesBookTrans_RU):
                                    this.RevisionType = SalesBookTable_RU::getFactureRevisionType(
                                                this.CorrectedFactureExternalId,
                                                this.CorrectedFactureDate,
                                                factureJourOrig.FactureId
                                    );

                                    break;
                            }
                        }
                        else
                        {
                            this.RevisionType = FactureRevisionType_RU::RevisionOriginal;
                        }
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesPurchBookDataFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes fields added to sales/purchase books.
    /// </summary>
    public void initSalesPurchBookDataFields()
    {
        FactureJour_RU  factureJour;
        VendTrans       vendTrans;

        if (this.Annulment)
        {
            return;
        }

        if (this.FactureJour_RU)
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);
        }
        else
        {
            factureJour = FactureJour_RU::find(
            this.FactureID,
            this.factureModule());
        }

        this.OperationTypeCodes = factureJour.factureOperationTypeCodes(this.OperationTypeCodes);
        this.CurrencyCode = factureJour.CurrencyCode;

        this.SalesPurchBookDataMap_RU::initAmountCurInclVAT(factureJour);

        if (factureJour.factureHeader().AgencyAgreement != AgencyAgreement_RU::None)
        {
            this.CommissionAgent = factureJour.CustVendInvoiceAccount;
        }

        if (this.TableId == tableNum(PurchBookTrans_RU))
        {
            if (factureJour.FactureType == FactureType_RU::TaxCorrection &&
            factureJour.VATTaxAgent)
            {
                vendTrans = VendTrans::findVoucherDate(factureJour.Voucher, factureJour.FactureDate);

                this.PaymDocumentNum = vendTrans.DocumentNum;
                this.PaymentDate     = vendTrans.DocumentDate;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if field edition should be allowed and user has access to them for current record
    /// </summary>
    /// <param name="_module">
    /// Module of transaction - Cust or Vend
    /// </param>
    /// <returns>
    /// Container where first element shows if user access and second if fields can be edited
    /// </returns>
    public container isEditable(ModuleCustVend _module)
    {
        boolean access, fieldsEditable;

        access = ! this.Reversed                                                &&
                   this.TransType != SalesPurchBookTransType_RU::VATRestoring   &&
                   this.TransType != SalesPurchBookTransType_RU::VATExportConfirmation;

        fieldsEditable = access && ((_module == ModuleCustVend::Vend && this.TransType == SalesPurchBookTransType_RU::Prepayment) ||
                                    (_module == ModuleCustVend::Cust && this.TransType == SalesPurchBookTransType_RU::PrepaymentStorno));

        access = access                                                         &&
                 this.TransType != SalesPurchBookTransType_RU::PrepaymentStorno &&
                 this.TransType != SalesPurchBookTransType_RU::Prepayment;

        if (_module == ModuleCustVend::Vend && this.TransType == SalesPurchBookTransType_RU::SumDiff && this.CorrectedPeriod)
        {
            access         = false;
            fieldsEditable = false;
        }

        return [access, fieldsEditable];
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyINN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns INN of customer or vendor at given date
    /// </summary>
    /// <param name="_factureDate">
    /// Date parameter; optional
    /// </param>
    /// <returns>
    /// INN of customer or vendor at given date
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If invalid FactureModule for current transaction
    /// </exception>
    public INN_RU partyINN(FactureDate_RU _factureDate = this.FactureDate_External)
    {
        CustTable           custTable;
        VendTable           vendTable;
        INN_RU              inn;
        FactureModule_RU    factureModule;

        if (this.TableId == tableNum(SalesBookTrans_RU)
         || this.TableId == tableNum(PurchBookTrans_RU))
        {
            factureModule = FactureJour_RU::findRecId(this.FactureJour_RU).Module;
        }
        else
        {
            factureModule = this.factureModule();
        }

        switch (factureModule)
        {
            case FactureModule_RU::Cust                    :
            case FactureModule_RU::TaxCorrectionSales      :
            case FactureModule_RU::TaxCorrectionPurch_Cust :
                select firstonly Party from custTable
                    where custTable.AccountNum == this.AccountNum;
                inn = custTable.partyINNasOfDate_RU(_factureDate);
                break;
            case FactureModule_RU::TaxCorrectionPurch      :
            case FactureModule_RU::TaxCorrectionSales_Vend :
                select firstonly Party, vatTaxAgent_RU, VATPartnerKind_RU from vendTable
                    where vendTable.AccountNum == this.AccountNum;
                if (vendTable.VATTaxAgent_RU &&
                    vendTable.VATPartnerKind_RU == VATPartnerKind_RU::NonResident)
                {
                    inn = "@GLS111200";
                }
                else
                {
                    inn = vendTable.partyINNasOfDate_RU(_factureDate);
                }
                break;
            case FactureModule_RU::Vend                    :
                select firstonly Party from vendTable
                    where vendTable.AccountNum == this.AccountNum;
                inn = vendTable.partyINNasOfDate_RU(_factureDate);
                break;
            case FactureModule_RU::Empl :
                inn = TaxRegistration::legislationRegistrationValue(HcmWorker::findByPersonnelNumber(this.AccountNum).Person, TaxRegistrationTypesList::INN, _factureDate);
                break;
            default                     :
                throw error(Error::wrongUseOfFunction(funcName()));
        }
        return inn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyINNKPP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns string, which contains INN and KPP of comission agent at given date.
    /// </summary>
    /// <param name="_factureDate">
    /// Date parameter; optional
    /// </param>
    /// <returns>
    /// String with inn/kpp information.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If invalid FactureModule for current transaction
    /// </exception>
    public Description partyINNKPP(FactureDate_RU _factureDate = this.FactureDate_External)
    {
        INN_RU              inn;
        KPPU_RU             kpp;
        Name                name;
        FactureModule_RU    factureModule;
        FactureJour_RU      factureJour;

        if (this.TableId == tableNum(SalesBookTrans_RU) ||
            this.TableId == tableNum(PurchBookTrans_RU))
        {
            factureJour = FactureJour_RU::findRecId(this.FactureJour_RU);
            factureModule = factureJour.Module;
        }
        else
        {
            factureModule = this.factureModule();
            factureJour = FactureJour_RU::find(this.FactureID, factureModule);
        }

        switch (factureModule)
        {
            case FactureModule_RU::Cust                    :
            case FactureModule_RU::TaxCorrectionSales      :
            case FactureModule_RU::TaxCorrectionPurch_Cust :
                if (this.TransType == SalesPurchBookTransType_RU::PrepaymentStorno ||
                    this.TransType == SalesPurchBookTransType_RU::CreditNote ||
                    factureJour.PrepaymTaxCorrection == NoYes::Yes)
                {
                    [name, inn, kpp] =  BookTransCalc_RU::getCompanyData(factureJour);
                }
                else
                {
                    [name, inn, kpp] = BookTransCalc_RU::getContragentData(factureJour);
                }
                break;
            case FactureModule_RU::TaxCorrectionPurch      :
            case FactureModule_RU::TaxCorrectionSales_Vend :
            case FactureModule_RU::Vend                    :
                if (this.TransType == SalesPurchBookTransType_RU::PrepaymentStorno ||
                    this.TransType == SalesPurchBookTransType_RU::CreditNote  ||
                    factureJour.PrepaymTaxCorrection == NoYes::Yes)
                {
                    [name, inn, kpp] = BookTransCalc_RU::getContragentData(factureJour);
                }
                else
                {
                    [name, inn, kpp] =  BookTransCalc_RU::getCompanyData(factureJour);
                }
                break;
            case FactureModule_RU::Empl :
                inn = TaxRegistration::legislationRegistrationValue(HcmWorker::findByPersonnelNumber(this.AccountNum).Person, TaxRegistrationTypesList::INN, _factureDate);
                break;
            default                     :
                throw error(Error::wrongUseOfFunction(funcName()));
        }
        return (inn && kpp ? strFmt("@GLS110628", inn, kpp) : inn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyKPP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns INN of customer or vendor at given date
    /// </summary>
    /// <param name="_factureDate">
    /// Date parameter; optional
    /// </param>
    /// <returns>
    /// INN of customer or vendor at given date
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If invalid FactureModule for current transaction
    /// </exception>
    public KPPU_RU partyKPP(FactureDate_RU _factureDate = this.FactureDate_External)
    {
        CustTable           custTable;
        VendTable           vendTable;
        KPPU_RU             kpp;
        FactureModule_RU    factureModule;

        if (this.TableId == tableNum(SalesBookTrans_RU)
         || this.TableId == tableNum(PurchBookTrans_RU))
        {
            factureModule = FactureJour_RU::findRecId(this.FactureJour_RU).Module;
        }
        else
        {
            factureModule = this.factureModule();
        }

        switch (factureModule)
        {
            case FactureModule_RU::Cust                    :
            case FactureModule_RU::TaxCorrectionSales      :
            case FactureModule_RU::TaxCorrectionPurch_Cust :
                select firstonly Party from custTable
                    where custTable.AccountNum == this.AccountNum;
                kpp = custTable.partyKPPasOfDate_RU(_factureDate);
                break;

            case FactureModule_RU::Vend                    :
            case FactureModule_RU::TaxCorrectionPurch      :
            case FactureModule_RU::TaxCorrectionSales_Vend :
                select firstonly Party from vendTable
                    where vendTable.AccountNum == this.AccountNum;
                kpp = vendTable.partyKPPasOfDate_RU(_factureDate);
                break;

            case FactureModule_RU::Empl :
                break;

            default                     :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return kpp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAddListNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the number of the additional list of the sales/purchase book which is being printed.
    /// </summary>
    /// <param name="_periodStart">
    ///    Start date of the period of the additional list being printed.
    /// </param>
    /// <param name="_periodEnd">
    ///    End date of the period of the additional list being printed.
    /// </param>
    /// <param name="_mapPeriodBooks">
    ///    Map which contains previous periods to be analyzed.
    /// </param>
    /// <param name="_query">
    ///    Query from the additional list printing dialog.
    /// </param>
    /// <param name="_salesPurch">
    ///    Enumeration showing whether sales or purch book additional list is being printed.
    /// </param>
    /// <returns>
    ///    The number of the additional list.
    /// </returns>
    /// <remarks>
    ///    To get the number of the aditional list we should calculate how many times the period of the current additional list was corrected
    ///    in the previous periods which are stored in the mapPeriodBooks. So we are running through this map, and for each period we are
    ///    calculating the set of periods, which are being corrected. And if this set contains the period which is equal to the period of
    ///    the current additional list, we increment the number of the current additional list by one.
    /// </remarks>

    public static int getAddListNumber(FromDate     _periodStart,
                                   ToDate       _periodEnd,
                                   Map          _mapPeriodBooks,
                                   Query        _query,
                                   SalesPurch   _salesPurch = SalesPurch::Sales)
    {
        int             addListNumber = 1;
        MapEnumerator   me;
        TransDate       periodStartLoc, periodEndLoc;
        Set             setPeriodsLoc;
        SetEnumerator   se;
        container       setPeriodsLocPacked;

        me = _mapPeriodBooks.getEnumerator();
        while (me.moveNext())
        {
            [periodStartLoc, periodEndLoc] = me.currentKey();

            if (_salesPurch == SalesPurch::Sales)
            {
                [setPeriodsLocPacked] = SalesBook_AddList_Launcher_RU::initParameters(0,
                                                                                  periodStartLoc,
                                                                                  periodEndLoc,
                                                                                  _query);
            }
            else
            {
                [setPeriodsLocPacked] = PurchBook_AddList_Launcher_RU::initParameters(0,
                                                                                  periodStartLoc,
                                                                                  periodEndLoc,
                                                                                  _query);
            }

            setPeriodsLoc = Set::create(setPeriodsLocPacked);
            se = setPeriodsLoc.getEnumerator();
            while (se.moveNext())
            {
                [periodStartLoc, periodEndLoc] = se.current();
                if (periodStartLoc == _periodStart && periodEndLoc == _periodEnd)
                {
                    addListNumber++;
                }
            }
        }
        
        return addListNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAnnulmentSourceFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns source facture for annulment.
    /// </summary>
    /// <param name="factureJour">
    /// <c>FactureJour</c> record.
    /// </param>
    /// <param name="factureJourOrig">
    /// Original facture journal.
    /// </param>
    /// <returns>
    /// Source facture if is has been found, otherwise original facture.
    /// </returns>
    public static FactureJour_RU getAnnulmentSourceFacture(FactureJour_RU           factureJour,
                                                           FactureJour_RU           factureJourOrig)
    {
        FactureJour_RU          factureJourRev;

        select firstonly factureJourRev
        order by CreatedDateTime desc, SeqNumber desc
        where  factureJourRev.RefRevisedFacture == factureJourOrig.RecId       &&
              (factureJourRev.CreatedDateTime   <  factureJour.CreatedDateTime ||
              (factureJourRev.CreatedDateTime   == factureJour.CreatedDateTime &&
               factureJourRev.SeqNumber         <  factureJour.SeqNumber));

        return factureJourRev ? factureJourRev : factureJourOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAnnulmentSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns <c>SalesPurchBookDataMap_RU</c> record which is the source for annulment.
    /// </summary>
    /// <param name="_revision">
    /// Original source record.
    /// </param>
    /// <returns>
    /// Revised facture if found.
    /// </returns>
    public static SalesPurchBookDataMap_RU getAnnulmentSum(SalesPurchBookDataMap_RU _revision)
    {
        SalesPurchBookDataMap_RU        salesPurchBookTrans = _revision.data();
        FactureJour_RU                  factureJourRevised;

        select firstonly salesPurchBookTrans
            order by RevisionSeqNumber desc
            where  salesPurchBookTrans.FactureExternalId    == _revision.FactureExternalId
               &&  salesPurchBookTrans.CorrectedFactureDate == _revision.CorrectedFactureDate
               &&  salesPurchBookTrans.RevisionSeqNumber     < _revision.RevisionSeqNumber
               &&  salesPurchBookTrans.Annulment            == NoYes::No
               &&  salesPurchBookTrans.RefRevisedFacture    == _revision.RefRevisedFacture;

        if (! salesPurchBookTrans)
        {
            factureJourRevised = FactureJour_RU::findRecId(_revision.RefRevisedFacture);

            select count(RecId) from salesPurchBookTrans
                where salesPurchBookTrans.FactureExternalId == factureJourRevised.FactureExternalId
                    && salesPurchBookTrans.FactureDate == factureJourRevised.FactureDate
                    && salesPurchBookTrans.FactureID == factureJourRevised.FactureId;

            if (salesPurchBookTrans.RecId > 1)
            {
                VendTrans revisionVendTrans = VendTrans::find(_revision.InvoiceRecIdRef);
                VendInvoiceJour revisionVendInvoice = VendInvoiceJour::findFromVendTrans(
                    revisionVendTrans.Invoice,
                    revisionVendTrans.TransDate,
                    revisionVendTrans.AccountNum);
                VendInvoiceJour correctedVendInvoice = VendInvoiceJour::findFromVendTrans(
                    revisionVendInvoice.CorrectedInvoiceId_RU,
                    revisionVendInvoice.CorrectedInvoiceDate_RU,
                    revisionVendTrans.AccountNum);
                VendTrans correctedVendTrans = correctedVendInvoice.vendTrans();

                select firstonly salesPurchBookTrans
                    where salesPurchBookTrans.FactureExternalId == factureJourRevised.FactureExternalId
                        && salesPurchBookTrans.FactureDate == factureJourRevised.FactureDate
                        && salesPurchBookTrans.FactureID == factureJourRevised.FactureId
                        && salesPurchBookTrans.InvoiceRecIdRef == correctedVendTrans.RecId;
            }
            else
            {
                select firstonly salesPurchBookTrans
                    where salesPurchBookTrans.FactureExternalId == factureJourRevised.FactureExternalId
                        && salesPurchBookTrans.FactureDate == factureJourRevised.FactureDate
                        && salesPurchBookTrans.FactureID == factureJourRevised.FactureId;
            }
        }

        return salesPurchBookTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSeparateDivisionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns <c>SeparateDivisionId_RU</c> value for facture journal.
    /// </summary>
    /// <param name="_factureJour_RU">
    /// <c>FactureJour_RU</c> record.
    /// </param>
    /// <returns>
    /// <c>SeparateDivisionId_RU</c> value.
    /// </returns>
    public static SeparateDivisionId_RU getSeparateDivisionId(FactureJour_RU _factureJour_RU)
    {
        #FactureHeader_RU
        FactureHeaderData_RU            headerData;
        FactureJourParm_RU              factureJourParm;

        factureJourParm = FactureJourParm_RU::newParameters(_factureJour_RU);
        headerData  = FactureHeaderData_RU::newFromCaller(factureJourParm);

        return headerData.getHeaderAttribute(#SeparateDivisionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureOperationTypeCodesDelimiter_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines facture operation codes delimiter.
    /// </summary>
    /// <returns>
    /// The facture operation codes delimiter defined in the ledger parameters or default delimeter.
    /// </returns>
    public static FactureOperationTypeCodesDelimiter_RU factureOperationTypeCodesDelimiter_RU()
    {
        const str defaultDelimiter = '/';
        FactureOperationTypeCodesDelimiter_RU delimiter = LedgerParameters::find().FactureOperationTypeCodesDelimiter_RU;

        return delimiter ? delimiter : defaultDelimiter;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
	<CountryRegionCodes>RU</CountryRegionCodes>
	<Label>@GLS104852</Label>
	<TableGroup>Transaction</TableGroup>
	<FieldGroups />
	<Fields>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AccountName</Name>
			<ExtendedDataType>VendName</ExtendedDataType>
			<StringSize>100</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>AccountNum</Name>
			<ExtendedDataType>VendAccount</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountInclVAT</Name>
			<ExtendedDataType>AmountMSTinclVAT_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountLiableToVAT0</Name>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@GLS101207</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountLiableToVAT10</Name>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@GLS101205</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountLiableToVAT20</Name>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@GLS101203</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountNotLiableToVAT</Name>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@GLS101209</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>Annulment</Name>
			<ExtendedDataType>SalesPurchBookAnnulment_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>CorrectedFactureDate</Name>
			<ExtendedDataType>FactureDate_RU</ExtendedDataType>
			<Label>@GLS104542</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CorrectedFactureExternalId</Name>
			<ExtendedDataType>FactureExternalId_RU</ExtendedDataType>
			<StringSize>30</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>CorrectedPeriod</Name>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@GLS111794</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>CorrectedSalesPurchBookTable_RU</Name>
			<ExtendedDataType>SalesPurchBookRecId_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CorrectingFactureId</Name>
			<ExtendedDataType>FactureId_RU</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>CorrectionType</Name>
			<EnumType>FactureCorrectionType_RU</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CountryGTD</Name>
			<ExtendedDataType>CountryGTD_RU</ExtendedDataType>
			<StringSize>60</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>DeliveryDate</Name>
			<ExtendedDataType>DlvDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldContainer">
			<Name>FactureAmounts</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>BookAmounts_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>FactureDate</Name>
			<ExtendedDataType>FactureDate_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>FactureDate_External</Name>
			<ExtendedDataType>FactureDate_External_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>FactureExternalId</Name>
			<ExtendedDataType>FactureExternalId_RU</ExtendedDataType>
			<StringSize>30</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>FactureID</Name>
			<ExtendedDataType>FactureId_RU</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>FactureJour_RU</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>InvoiceCompany</Name>
			<ExtendedDataType>CompanyId</ExtendedDataType>
			<Label>@SYS106983</Label>
			<StringSize>4</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>InvoiceRecIdRef</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS111296</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>JointCorrection</Name>
			<ExtendedDataType>FactureJointCorrection_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>LineNum</Name>
			<ExtendedDataType>SalesPurchBookLineNum_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>LogTableRefRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>LogTableRefRecId_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>Marked</Name>
			<Label>@SYS67841</Label>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymentCompany</Name>
			<ExtendedDataType>CompanyId</ExtendedDataType>
			<Label>@SYS106984</Label>
			<StringSize>4</StringSize>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>PaymentDate</Name>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS16653</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>PaymentRecIdRef</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS22514</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>RefOriginalFacture</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>RefRevisedFacture</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>RefTableId</Name>
			<ExtendedDataType>RefTableId</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>Reversed</Name>
			<ExtendedDataType>Cancelled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>ReverseDate</Name>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt">
			<Name>RevisionSeqNumber</Name>
			<ExtendedDataType>RevisionNum_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>RevisionType</Name>
			<EnumType>FactureRevisionType_RU</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldInt64">
			<Name>SalesPurchBookTable_RU</Name>
			<ExtendedDataType>SalesPurchBookRecId_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldContainer">
			<Name>SettledAmounts</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>BookAmounts_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>SettlementDate</Name>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS16693</Label>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>TaxAmountVAT10</Name>
			<ExtendedDataType>TaxAmountVAT10_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>TaxAmountVAT20</Name>
			<ExtendedDataType>TaxAmountVAT20_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldDate">
			<Name>TransDate</Name>
			<ExtendedDataType>PurchBookTransDate_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldEnum">
			<Name>TransType</Name>
			<EnumType>SalesPurchBookTransType_RU</EnumType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldContainer">
			<Name>UsedAmounts</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>BookAmounts_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldReal">
			<Name>AmountCurInclVAT</Name>
			<ExtendedDataType>AmountCurInclVAT_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CommissionAgent</Name>
			<ExtendedDataType>CustVendAC</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>CurrencyCode</Name>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>OperationTypeCodes</Name>
			<ExtendedDataType>FactureOperationTypeCodes_RU</ExtendedDataType>
		</AxMapBaseField>
		<AxMapBaseField xmlns=""
			i:type="AxMapFieldString">
			<Name>PaymDocumentNum</Name>
			<ExtendedDataType>DocumentNum</ExtendedDataType>
		</AxMapBaseField>
	</Fields>
	<Mappings />
</AxMap>