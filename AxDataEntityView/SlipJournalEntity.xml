<?xml version="1.0" encoding="utf-8"?>
<AxDataEntityView xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SlipJournalEntity</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class SlipJournalEntity extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>persistEntity</Name>
				<Source><![CDATA[
    public void persistEntity(DataEntityRuntimeContext _entityCtx)
    {
        this.skipDataSourceValidateField(fieldnum(SlipJournalEntity, JournalType), true);
        super(_entityCtx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapEntityToDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maps the entity to the backing datasources.
    /// </summary>
    /// <param name = "entityCtx">The context of the entity.</param>
    /// <param name = "dataSourceCtx">The context of the datasource being mapped.</param>
    public void mapEntityToDataSource(DataEntityRuntimeContext entityCtx, DataEntityDataSourceRuntimeContext dataSourceCtx)
    {
        if (entityCtx.getDatabaseOperation() == DataEntityDatabaseOperation::Insert
            || entityCtx.getDatabaseOperation() == DataEntityDatabaseOperation::Update)
        {
            // When editing through the entity, always delay tax calculation to avoid
            // a O(n^2) tax calculation while importing multiple lines. The journal will
            // automatically calculate taxes later at posting time or when necessary.
            this.DelayTaxCalculation = NoYes::Yes;

            switch (dataSourceCtx.name())
            {
                case dataEntityDataSourceStr(LedgerJournalEntity, LedgerJournalTable):
                    dataSourceCtx.setBuffer(LedgerJournalEntityBase::findOrCreateLedgerJournalHeader(this));
                    break;

                case dataEntityDataSourceStr(SlipJournalEntity, LedgerJournalTable_W):
                    LedgerJournalTable_W ledgerJournalTable_W;
                    LedgerJournalTable ledgerJournalTable;

                    select firstonly ledgerJournalTable_W
                        exists join ledgerJournalTable
                            where
                    ledgerJournalTable_W.LedgerJournalTable == ledgerJournalTable.RecId
                    && ledgerJournalTable.journalNum == this.JournalBatchNumber;

                    if (ledgerJournalTable_W.RecId)
                    {
                        dataSourceCtx.setDatabaseOperation(DataEntityDatabaseOperation::Update);
                        dataSourceCtx.setBuffer(ledgerJournalTable_W);
                    }
                    break;
            }

            super(entityCtx, dataSourceCtx);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCustomStagingToTarget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a custom copy from the staging table to the target environment.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <returns>A container of counts of [new records, updated records].</returns>
    /// <remarks>
    /// When doing set-based inserts, the full defaulting logic from LedgerJournalTrans is not
    /// run. In order to get full defaulting, row-by-row processing must be performed. Since
    /// this method is called specifically from the DIXF framework, the entity in
    /// DIXF can be marked as AllowSetBased=False in order to force row-by-row defaulting
    /// and validation. The trade off is a significant degradation in copy performance.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static container copyCustomStagingToTarget(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        // clear out any validation errors from previous runs.
        DMFStagingValidationLog log;
        log.skipDataMethods(true);

        delete_from log
            where log.DefinitionGroupName == _dmfDefinitionGroupExecution.DefinitionGroup
               && log.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId;

        LedgerJournalEntityStaging staging;

        // Set all Validated records back to NotStarted so they will be attempted again.
        update_recordset staging setting TransferStatus = DMFTransferStatus::NotStarted
            where staging.TransferStatus == DMFTransferStatus::Validated
                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId;

        // If a Ledger account type is provided, ignore any default dimension value that was provided as we require
        // the dimensions to be on the ledger account
        update_recordset staging setting DefaultDimensionDisplayValue = ''
            where staging.AccountType == LedgerJournalACType::Ledger
                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::NotStarted;

        update_recordset staging setting OffsetDefaultDimensionDisplayValue = ''
            where staging.OffsetAccountType == LedgerJournalACType::Ledger
                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::NotStarted;

        // resolve accounts and log errors.
        DimensionDataEntitySFKCacheTmp dimCacheTmp = LedgerDimensionDynamicAccountSetBasedResolver::Resolve(
                _dmfDefinitionGroupExecution,
                staging,
                fieldStr(LedgerJournalEntityStaging, AccountDisplayValue),
                fieldStr(LedgerJournalEntityStaging, OffsetAccountDisplayValue),
                tableStr(LedgerJournalEntityStaging),
                "@GeneralLedger:LedgerJournalEntityLabel");

        ExtendedDataTypeName dataType = identifierstr(DimensionDynamicAccount);

        DimensionDataEntitySFKCacheTmp dimCacheTmpRef;
        dimCacheTmpRef.linkPhysicalTableInstance(dimCacheTmp);

        DimensionDataEntitySFKCacheTmp defaultDimCacheTmp = DimensionDefaultSetBasedResolver::Resolve(_dmfDefinitionGroupExecution, staging, true);
        DimensionDataEntitySFKCacheTmp defaultDimCacheTmpRef;
        defaultDimCacheTmpRef.linkPhysicalTableInstance(defaultDimCacheTmp);

        ttsbegin;

        // Put any rows that have unresolved accounts in an error state first.
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join dimCacheTmp
                where dimCacheTmp.IntegrationString == staging.AccountDisplayValue
                   && dimCacheTmp.EnumValue == staging.AccountType
                   && dimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                   && dimCacheTmp.ExtendedDataType == dataType
                   && dimCacheTmp.Found == NoYes::No;

        // Offset accounts.
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join dimCacheTmp
                where dimCacheTmp.IntegrationString == staging.OffsetAccountDisplayValue
                   && dimCacheTmp.EnumValue == staging.OffsetAccountType
                   && dimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                   && dimCacheTmp.ExtendedDataType == dataType
                   && dimCacheTmp.Found == NoYes::No;

        // Default dimension

        ExtendedDataTypeName defaultDimensionDataType = extendedTypeStr(DimensionDefault);

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join defaultDimCacheTmp
                where defaultDimCacheTmp.IntegrationString == staging.DefaultDimensionDisplayValue
                   && defaultDimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                   && defaultDimCacheTmp.ExtendedDataType == defaultDimensionDataType
                   && defaultDimCacheTmp.Found == NoYes::No;

        // Offset default dimension
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join defaultDimCacheTmp
                where defaultDimCacheTmp.IntegrationString == staging.OffsetDefaultDimensionDisplayValue
                   && defaultDimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                   && defaultDimCacheTmp.ExtendedDataType == defaultDimensionDataType
                   && defaultDimCacheTmp.Found == NoYes::No;

        SlipJournalEntity::validateJournalType(_dmfDefinitionGroupExecution, log);
        SlipJournalEntity::validateAndUpdateExchangeRates(_dmfDefinitionGroupExecution, log);
        SlipJournalEntity::validateAccountTypes(_dmfDefinitionGroupExecution, log);

        // Now that all invalid rows are in an error state, any remaining NotStarted
        // rows should successfully transfer to the target tables.
        //
        // Since an insert_recordset call to the LedgerJournalEntity will automatically degrade
        // to row-by-row operations, the insert to the header and line tables must be done
        // individually with data methods skipped.
        LedgerJournalTable ledgerJournalTable;
        ledgerJournalTable ledgerJournalTable_Exists;
        ledgerJournalTable.skipDataMethods(true);

        LedgerJournalName ledgerJournalName;

        insert_recordset ledgerJournalTable (JournalName, JournalNum, CurrentOperationsTax, Name, VoucherAllocatedAtPosting)
            select JournalName, JournalBatchNumber, PostingLayer, Description from staging
                group by JournalName, JournalBatchNumber, PostingLayer, Description, ledgerJournalName.VoucherAllocatedAtPosting
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                   && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                   && staging.TransferStatus == DMFTransferStatus::NotStarted
            join VoucherAllocatedAtPosting from ledgerJournalName
                where staging.JournalName == ledgerJournalName.JournalName
            notexists join ledgerJournalTable_Exists
                where ledgerJournalTable_Exists.JournalNum == staging.JournalBatchNumber;

        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans ledgerJournalTrans_Exists;
        // <GCN>
        LedgerVoucherType_CN voucherType_CN;
        // </GCN>
        ledgerJournalTrans.skipDataMethods(true);
        SelectableDataArea currentCompany = curExt();

        update_recordset ledgerJournalTrans setting
                Txt = staging.Text,
                OffsetTxt = staging.OffsetText,
                Voucher = staging.Voucher,
                // <GCN>
                Voucher_CN = staging.ChineseVoucher,
                LedgerVoucherType_CN = voucherType_CN.RecId,
                // </GCN>
                TransDate = staging.TransDate,
                AmountCurCredit = staging.CreditAmount,
                AmountCurDebit = staging.DebitAmount,
                CurrencyCode = staging.CurrencyCode,
                ExchRate = staging.ExchangeRate,
                ExchrateSecond = staging.ExchangeRateSecondary,
                CashDiscAmount = staging.CashDiscountAmount,
                CashDiscPercent = staging.DiscountPercentage,
                AccountType = staging.AccountType,
                OffsetAccountType = staging.AccountType,
                Qty = staging.Quantity,
                TaxWithholdCalculate_TH = staging.IsWithholdingCalculationEnabled,
                Invoice = staging.Invoice,
                Due = staging.DueDate,
                PaymId = staging.PaymentId,
                VATNumJournal = staging.TaxExemptNumber,
                TaxCode = staging.SalesTaxCode,
                TaxItemGroup = staging.ItemSalesTaxGroup,
                CashDiscCode = staging.CashDiscount,
                DateCashDisc = staging.CashDiscountDate,
                DocumentNum = staging.Document,
                PaymMode = staging.PaymentMethod,
                PostingProfile = staging.PostingProfile,
                TaxGroup = staging.SalesTaxGroup,
                PaymReference = staging.PaymentReference,
                LedgerDimension = dimCacheTmp.ResolvedReference,
                OffsetLedgerDimension = dimCacheTmpRef.ResolvedReference,
                DefaultDimension = defaultDimCacheTmp.ResolvedReference,
                OffsetDefaultDimension = defaultDimCacheTmpRef.ResolvedReference
            join staging
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::NotStarted
                    && staging.JournalBatchNumber == ledgerJournalTrans.JournalNum
                    && staging.LineNumber == ledgerJournalTrans.LineNum
            join ResolvedReference from dimCacheTmp
                where dimCacheTmp.IntegrationString == staging.AccountDisplayValue
                    && dimCacheTmp.EnumValue == staging.AccountType
                    && dimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                    && dimCacheTmp.ExtendedDataType == dataType
            join ResolvedReference from dimCacheTmpRef
                where dimCacheTmpRef.IntegrationString == staging.OffsetAccountDisplayValue
                    && dimCacheTmpRef.EnumValue == staging.OffsetAccountType
                    && dimCacheTmpRef.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                    && dimCacheTmpRef.ExtendedDataType == dataType
            join ResolvedReference from defaultDimCacheTmp
                where defaultDimCacheTmp.IntegrationString == staging.DefaultDimensionDisplayValue
                    && defaultDimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                    && defaultDimCacheTmp.ExtendedDataType == defaultDimensionDataType
            join ResolvedReference from defaultDimCacheTmpRef
                where defaultDimCacheTmpRef.IntegrationString == staging.OffsetDefaultDimensionDisplayValue
                    && defaultDimCacheTmpRef.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                    && defaultDimCacheTmpRef.ExtendedDataType == defaultDimensionDataType
            // <GCN>
            outer join RecId from voucherType_CN
                where voucherType_CN.Id == staging.ChineseVoucherType
            // </GCN>
            notexists join ledgerJournalTable_Exists
                where ledgerJournalTable_Exists.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTable_Exists.Posted == NoYes::Yes;

        // Get the number of records updated.
        int64 updatedRecords = ledgerJournalTrans.RowCount();

        insert_recordset ledgerJournalTrans (
            JournalNum, Txt, OffsetTxt, Voucher, TransDate, LineNum,
            Company, OffsetCompany, CashDiscPercent, CashDiscAmount,
            AmountCurCredit, AmountCurDebit, CurrencyCode,
            ExchRate, ExchRateSecond,
            AccountType, OffsetAccountType,
            Qty, TaxWithholdCalculate_TH, Voucher_CN,
            Invoice, Due, PaymId, VATNumJournal, TaxCode,
            TaxItemGroup, CashDiscCode, DateCashDisc, DocumentNum,
            PaymMode, PostingProfile, TaxGroup, PaymReference,
            LedgerDimension, OffsetLedgerDimension,
            DefaultDimension, OffsetDefaultDimension
            )
        select
            JournalBatchNumber, Text, OffsetText, Voucher, TransDate, LineNumber,
            currentCompany, currentCompany, DiscountPercentage, CashDiscountAmount,
            CreditAmount, DebitAmount, CurrencyCode,
            ExchangeRate, ExchangeRateSecondary,
            AccountType, OffsetAccountType,
            Quantity, IsWithholdingCalculationEnabled, ChineseVoucher,
            Invoice, DueDate, PaymentId, TaxExemptNumber, SalesTaxCode,
            ItemSalesTaxGroup, CashDiscount, CashDiscountDate, Document,
            PaymentMethod, PostingProfile, SalesTaxGroup, PaymentReference
        from staging
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::NotStarted
            join ResolvedReference from dimCacheTmp
                where dimCacheTmp.IntegrationString == staging.AccountDisplayValue
                    && dimCacheTmp.EnumValue == staging.AccountType
                    && dimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                    && dimCacheTmp.ExtendedDataType == dataType
            join ResolvedReference from dimCacheTmpRef
                where dimCacheTmpRef.IntegrationString == staging.OffsetAccountDisplayValue
                    && dimCacheTmpRef.EnumValue == staging.OffsetAccountType
                    && dimCacheTmpRef.HierarchyType == DimensionHierarchyType::DataEntityLedgerDimensionFormat
                    && dimCacheTmpRef.ExtendedDataType == dataType
            join ResolvedReference from defaultDimCacheTmp
                where defaultDimCacheTmp.IntegrationString == staging.DefaultDimensionDisplayValue
                    && defaultDimCacheTmp.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                    && defaultDimCacheTmp.ExtendedDataType == defaultDimensionDataType
            join ResolvedReference from defaultDimCacheTmpRef
                where defaultDimCacheTmpRef.IntegrationString == staging.OffsetDefaultDimensionDisplayValue
                    && defaultDimCacheTmpRef.HierarchyType == DimensionHierarchyType::DataEntityDefaultDimensionFormat
                    && defaultDimCacheTmpRef.ExtendedDataType == defaultDimensionDataType
            notexists join ledgerJournalTrans_Exists
                where ledgerJournalTrans_Exists.JournalNum == staging.JournalBatchNumber &&
                    ledgerJournalTrans_Exists.LineNum == staging.LineNumber;

        // Get the number of records inserted.
        int64 newRecords = ledgerJournalTrans.RowCount();

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            update_recordset ledgerJournalTrans
                setting LedgerVoucherType_CN = voucherType_CN.RecId
            join staging
                    where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::NotStarted
                    && staging.JournalBatchNumber == ledgerJournalTrans.JournalNum
                    && staging.LineNumber == ledgerJournalTrans.LineNum
            join voucherType_CN
                where staging.ChineseVoucherType == voucherType_CN.Id;
        }
        // </GCN>

        // Update transferred records to success status.
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Completed
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted;

        ttscommit;

        return [newRecords, updatedRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountTypes</Name>
				<Source><![CDATA[
    private static void validateAccountTypes(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DMFStagingValidationLog _log)
    {
        // Only Ledger, customer, vendor, and bank account types are supported by this entity. All other records get set to error status.

        LedgerJournalEntityStaging staging;

        ErrorMsg error = "@GeneralLedger:EntityMessage_LedgerJournalEntityAccountTypeNotSupported";
        TableName tableName = tableStr(LedgerJournalEntityStaging);
        TableName entityName = "@GeneralLedger:LedgerJournalEntityLabel";
        DMFSourceTarget sourceTarget = DMFSourceTarget::Target;
        FieldName fieldName = fieldStr(LedgerJournalEntityStaging, AccountType);

        insert_recordset _log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
            select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, error from staging
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::NotStarted
                    && staging.AccountType != LedgerJournalACType::Ledger
                    && staging.AccountType != LedgerJournalACType::Bank
                    && staging.AccountType != LedgerJournalACType::Cust
                    && staging.AccountType != LedgerJournalACType::Vend;

        fieldName = fieldStr(LedgerJournalEntityStaging, OffsetAccountType);

        insert_recordset _log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
            select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, error from staging
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::NotStarted
                    && staging.OffsetAccountType != LedgerJournalACType::Ledger
                    && staging.OffsetAccountType != LedgerJournalACType::Bank
                    && staging.OffsetAccountType != LedgerJournalACType::Cust
                    && staging.OffsetAccountType != LedgerJournalACType::Vend;

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join _log
                where _log.StagingRecId == staging.RecId
                    && _log.StagingTableName == tableName
                    && _log.ErrorMessage == error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndUpdateExchangeRates</Name>
				<Source><![CDATA[
    private static void validateAndUpdateExchangeRates(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DMFStagingValidationLog _log)
    {
        // Entity lines that require an exchange rate to be looked up but one doesn't exist will be set to Error

        CurrencyCode ledgerCurrency = Ledger::accountingCurrency();
        ExchangeRateTypeRecId exchangeRateType = Ledger::defaultExchangeRateType();
        ExchangeRateEffectiveView exchangeRateView;
        LedgerJournalEntityStaging staging;

        ErrorMsg error = "@GeneralLedger:EntityMessage_LedgerJournalEntityExchangeRateNotFound";

        LedgerJournalEntityLog entityLog;

        insert_recordset entityLog (LedgerJournalEntityRecId, ErrorMessage)
            select RecId, error from staging
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
               && staging.ExchangeRate == 0
            notexists join exchangeRateView
                where exchangeRateView.ExchangeRateType == exchangeRateType
                    && exchangeRateView.FromCurrencyCode == staging.CurrencyCode
                    && exchangeRateView.ToCurrencyCode == ledgerCurrency
                    && exchangeRateView.ValidFrom <= staging.TransDate
                    && exchangeRateView.ValidTo >= staging.TransDate;

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
        exists join entityLog
            where staging.RecId == entityLog.LedgerJournalEntityRecId;

        // write errors to DMF validation log
        FieldName fieldName = fieldStr(LedgerJournalEntityStaging, CurrencyCode);
        TableName tableName = tableStr(LedgerJournalEntityStaging);
        TableName entityName = "@GeneralLedger:LedgerJournalEntityLabel";
        DMFSourceTarget sourceTarget = DMFSourceTarget::Target;

        insert_recordset _log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
            select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName from staging
        join ErrorMessage from entityLog
            where staging.RecId == entityLog.LedgerJournalEntityRecId;

        // Update the exchange rates where a rate exists.
        update_recordset staging
            setting ExchangeRate = exchangeRateView.ExchangeRate1,
                ExchangeRateSecondary = exchangeRateView.ExchangeRate2
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
               && staging.ExchangeRate == 0 // Don't update the exchange rate if one is provided
            join exchangeRateView
                where exchangeRateView.ExchangeRateType == exchangeRateType
                    && exchangeRateView.FromCurrencyCode == staging.CurrencyCode
                    && exchangeRateView.ToCurrencyCode == ledgerCurrency
                    && exchangeRateView.ValidFrom <= staging.TransDate
                    && exchangeRateView.ValidTo >= staging.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalType</Name>
				<Source><![CDATA[
    private static void validateJournalType(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DMFStagingValidationLog _log)
    {
        // Put any rows that are not of the RCash type into error state
        LedgerJournalName ledgerJournalName;
        LedgerJournalEntityStaging staging;

        LedgerJournalEntityLog entityLog;

        ErrorMsg error = "@GeneralLedger:EntityMessage_LedgerJournalEntityInvalidJournalName";

        insert_recordset entityLog (LedgerJournalEntityRecId, ErrorMessage)
            select RecId, error from staging
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted
            exists join ledgerJournalName
                where staging.JournalName == ledgerJournalName.JournalName
                   && ledgerJournalName.JournalType != LedgerJournalType::RCash;

        // write errors to DMF validation log
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
        exists join entityLog
            where staging.RecId == entityLog.LedgerJournalEntityRecId;

        FieldName fieldName = fieldStr(LedgerJournalEntityStaging, JournalName);
        TableName tableName = tableStr(LedgerJournalEntityStaging);
        TableName entityName = "@GeneralLedger:LedgerJournalEntityLabel";
        DMFSourceTarget sourceTarget = DMFSourceTarget::Target;

        insert_recordset _log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
            select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName from staging
        join ErrorMessage from entityLog
            where staging.RecId == entityLog.LedgerJournalEntityRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean isValid = LedgerJournalEntityBase::validateJournal(this);

        if (isValid)
        {
            isValid = super();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean isValid = LedgerJournalEntityBase::validateJournal(this);

        if (isValid)
        {
            isValid = super();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEntityDataSource</Name>
				<Source><![CDATA[
    public boolean updateEntityDataSource(DataEntityRuntimeContext _entityCtx, DataEntityDataSourceRuntimeContext _dataSourceCtx)
    {
        switch (_dataSourceCtx.name())
        {
            case dataEntityDataSourceStr(LedgerJournalEntity, LedgerJournalTrans):
                LedgerJournalTrans ledgerJournalTrans = _dataSourceCtx.getBuffer();
                ledgerJournalTrans originalLedgerJournalTrans = ledgerJournalTrans.orig();

                // When the journal setup voucher setting is set to "in connection with balance", the update
                // operation must revert to the original voucher number provided by defaulting in the
                // case where a new voucher number is provided as a consumer input value.
                if (ledgerJournalTrans.ledgerJournalTable().ledgerJournalName().NewVoucher == NewVoucher::BalanceSheet)
                {
                    if (ledgerJournalTrans.Voucher != originalLedgerJournalTrans.Voucher)
                    {
                        ledgerJournalTrans.Voucher = originalLedgerJournalTrans.Voucher;

                        _dataSourceCtx.setBuffer(ledgerJournalTrans);
                    }
                }

                break;
        }

        return super(_entityCtx, _dataSourceCtx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGetStagingData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the general journal staging table after population.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">A data management framework definition group being executed.</param>
    /// <remarks>This method is called automatically by the data management framework.</remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void postGetStagingData(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        LedgerJournalEntityStaging staging;
        LedgerJournalEntityBaseTmp journalBatchNumberMap = LedgerJournalEntityBase::generateJournalNumbers(_dmfDefinitionGroupExecution, staging);

        update_recordset staging
            setting JournalBatchNumber = journalBatchNumberMap.NewJournalBatchNumber
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::NotStarted
        join NewJournalBatchNumber from journalBatchNumberMap
            where staging.JournalBatchNumber == journalBatchNumberMap.OldJournalBatchNumber;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<FormRef>LedgerJournalTable</FormRef>
	<Label>@GLS104353</Label>
	<Tags>Journal</Tags>
	<DataManagementEnabled>Yes</DataManagementEnabled>
	<DataManagementStagingTable>SlipJournalStaging</DataManagementStagingTable>
	<IsPublic>Yes</IsPublic>
	<Modules>GeneralLedger</Modules>
	<PrimaryCompanyContext>DataAreaId</PrimaryCompanyContext>
	<PrimaryKey>EntityKey</PrimaryKey>
	<PublicCollectionName>SlipJournalTables</PublicCollectionName>
	<PublicEntityName>SlipJournalTable</PublicEntityName>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ApprovedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Currency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostingLayer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DetailLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Document</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SecondaryExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FixedRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrivateForUserGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InUseBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalBatchNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountsIncludeSalesTax</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LinesLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Log</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyAccounting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalJournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Posted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostedOn</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RejectedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportedAsReadyBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LockedBySystem</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LegalEntityForIntercompanyTaxPosting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberAllocatedAtPosting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkflowApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Approver_FK_PersonnelNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimensionDisplayValue</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ApprovedBy</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>Approver</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Currency</Name>
			<DataField>CurrencyCode</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PostingLayer</Name>
			<DataField>CurrentOperationsTax</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DetailLevel</Name>
			<DataField>DetailSummaryPosting</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Document</Name>
			<DataField>DocumentNum</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ExchangeRate</Name>
			<DataField>ExchRate</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>SecondaryExchangeRate</Name>
			<DataField>ExchrateSecondary</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FixedRate</Name>
			<DataField>FixedExchRate</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PrivateForUserGroup</Name>
			<DataField>GroupBlockId</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InUseBy</Name>
			<DataField>InUseBy</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>JournalName</Name>
			<DataField>JournalName</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>JournalBatchNumber</Name>
			<DataField>JournalNum</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>JournalType</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<DataField>JournalType</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>AmountsIncludeSalesTax</Name>
			<DataField>LedgerJournalInclTax</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LinesLimit</Name>
			<DataField>LinesLimitBeforeDistribution</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Log</Name>
			<DataField>Log</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Description</Name>
			<DataField>Name</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>AccountType</Name>
			<DataField>OffsetAccountType</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OffsetLedgerDimension</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>OffsetLedgerDimension</DataField>
			<DataSource>LedgerJournalTable</DataSource>
			<DimensionLegalEntityContextField>DataAreaId</DimensionLegalEntityContextField>
			<DynamicDimensionEnumerationField>OffsetLedgerDimensionDisplayValue</DynamicDimensionEnumerationField>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InterCompanyAccounting</Name>
			<DataField>OriginalCompany</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OriginalJournalNum</Name>
			<DataField>OriginalJournalNum</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Posted</Name>
			<DataField>Posted</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PostedOn</Name>
			<DataField>PostedDateTime</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>RejectedBy</Name>
			<DataField>RejectedBy</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ReportedAsReadyBy</Name>
			<DataField>ReportedAsReadyBy</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LockedBySystem</Name>
			<DataField>SystemBlocked</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LegalEntityForIntercompanyTaxPosting</Name>
			<DataField>TaxObligationCompany</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>NumberAllocatedAtPosting</Name>
			<DataField>VoucherAllocatedAtPosting</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>WorkflowApprovalStatus</Name>
			<DataField>WorkflowApprovalStatus</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Approver_FK_PersonnelNumber</Name>
			<Mandatory>No</Mandatory>
			<DataField>PersonnelNumber</DataField>
			<DataSource>Approver_FK</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OffsetLedgerDimensionDisplayValue</Name>
			<DataField>DisplayValue</DataField>
			<DataSource>OffsetLedgerDimensionDAVC</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DelayTaxCalculation</Name>
			<DataField>DelayTaxCalculation</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LineNumber</Name>
			<DataField>LineNum</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CreditAmount</Name>
			<DataField>AmountCurCredit</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DebitAmount</Name>
			<DataField>AmountCurDebit</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>TransAccountType</Name>
			<DataField>AccountType</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OffsetAccountType</Name>
			<DataField>OffsetAccountType</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Qty</Name>
			<DataField>Qty</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>TransDate</Name>
			<DataField>TransDate</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Text</Name>
			<DataField>Txt</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Voucher</Name>
			<DataField>Voucher</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CurrencyCode</Name>
			<DataField>CurrencyCode</DataField>
			<DataSource>LedgerJournalTrans</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashCollBagNum_RU</Name>
			<DataField>CashCollBagNum_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashCollBankContributor_RU</Name>
			<DataField>CashCollBankContributor_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashCollCreditAccountNum_RU</Name>
			<DataField>CashCollCreditAccountNum_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashCollDebitAccountNum_RU</Name>
			<DataField>CashCollDebitAccountNum_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashCollStoreId_RU</Name>
			<DataField>CashCollStoreId_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashDocId</Name>
			<DataField>CashDocId</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashReceiptNumLV</Name>
			<DataField>CashReceiptNumLV</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashSourceCode_RU</Name>
			<DataField>CashSourceCode_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashSourceDescription_RU</Name>
			<DataField>CashSourceDescription_RU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DocType</Name>
			<DataField>DocType</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ExcludeExchAdj_PL</Name>
			<DataField>ExcludeExchAdj_PL</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LvCashReceiptTable</Name>
			<DataField>LvCashReceiptTable</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ManualRounding_HU</Name>
			<DataField>ManualRounding_HU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>RoundOffCashAmount_HU</Name>
			<DataField>RoundOffCashAmount_HU</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>TransRegDate_PL</Name>
			<DataField>TransRegDate_PL</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>RCashTransStatus</Name>
			<DataField>TransStatus</DataField>
			<DataSource>LedgerJournalTrans_RCash</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ReportingCurrencyExchRate</Name>
			<DataField>ReportingCurrencyExchRate</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ReportingCurrencyExchRateSecondary</Name>
			<DataField>ReportingCurrencyExchRateSecondary</DataField>
			<DataSource>LedgerJournalTable</DataSource>
		</AxDataEntityViewField>
	</Fields>
	<Keys>
		<AxDataEntityViewKey>
			<Name>EntityKey</Name>
			<Fields>
				<AxDataEntityViewKeyField>
					<DataField>JournalBatchNumber</DataField>
				</AxDataEntityViewKeyField>
				<AxDataEntityViewKeyField>
					<DataField>LineNumber</DataField>
				</AxDataEntityViewKeyField>
			</Fields>
		</AxDataEntityViewKey>
	</Keys>
	<Mappings>
		<AxTableMapping>
			<MappingTable>LedgerJournalEntityBase</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefinitionGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Description</MapField>
					<MapFieldTo>Description</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExecutionId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalBatchNumber</MapField>
					<MapFieldTo>JournalBatchNumber</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalName</MapField>
					<MapFieldTo>JournalName</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransferStatus</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Ranges />
	<Relations>
		<AxDataEntityViewRelation xmlns=""
			i:type="AxDataEntityViewRelationForeignKey">
			<Name>OffsetLedgerDimensionCombination</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedDataEntity>DimensionCombinationEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>OffsetLedgerDimension</Name>
					<Field>OffsetLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
		</AxDataEntityViewRelation>
	</Relations>
	<StateMachines />
	<ViewMetadata>
		<Name>Metadata</Name>
		<SourceCode>
			<Methods>
				<Method>
					<Name>classDeclaration</Name>
					<Source><![CDATA[
[Query]
public class Metadata extends QueryRun
{
}
]]></Source>
				</Method>
			</Methods>
		</SourceCode>
		<DataSources>
			<AxQuerySimpleRootDataSource>
				<Name>LedgerJournalTable</Name>
				<DynamicFields>Yes</DynamicFields>
				<Table>LedgerJournalTable</Table>
				<DataSources>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>Approver_FK</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>HcmWorker</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>Approver_FK</Name>
								<JoinRelationName>HcmWorker</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>OffsetLedgerDimensionDAVC</Name>
						<AllowAdd>No</AllowAdd>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>DimensionCombinationEntity</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>OffsetLedgerDimensionDAVC</Name>
								<Field>OffsetLedgerDimension</Field>
								<JoinDataSource>LedgerJournalTable</JoinDataSource>
								<RelatedField>RecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>LedgerJournalTable_W</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>LedgerJournalTable_W</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>RecId</Field>
								<JoinDataSource>LedgerJournalTable</JoinDataSource>
								<RelatedField>LedgerJournalTable</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>LedgerJournalTrans</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>LedgerJournalTrans</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>JournalNum</Field>
								<JoinDataSource>LedgerJournalTable</JoinDataSource>
								<RelatedField>JournalNum</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>LedgerJournalTrans_RCash</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>LedgerJournalTrans_RCash</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>RecId</Field>
								<JoinDataSource>LedgerJournalTrans</JoinDataSource>
								<RelatedField>RefRecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
				</DataSources>
				<DerivedDataSources />
				<Fields />
				<Ranges>
					<AxQuerySimpleDataSourceRange>
						<Name>JournalType</Name>
						<Field>JournalType</Field>
						<Value>RCash</Value>
					</AxQuerySimpleDataSourceRange>
				</Ranges>
				<GroupBy />
				<Having />
				<OrderBy />
			</AxQuerySimpleRootDataSource>
		</DataSources>
	</ViewMetadata>
</AxDataEntityView>