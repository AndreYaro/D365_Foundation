<?xml version="1.0" encoding="utf-8"?>
<AxDataEntityView xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetRegisterEntryEntity</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BudgetRegisterEntryEntity extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getAccountingCurrencyAmountSQL</Name>
				<Source><![CDATA[
    private static str getAccountingCurrencyAmountSQL()
    {
        DictDataEntity budgetRegisterEntryEntity = new DictDataEntity(tableNum(BudgetRegisterEntryEntity));

        // Get the data source name that contains the accounting currency amount details.
        str lineDataSourceName = budgetRegisterEntryEntity.query().dataSourceTable(tablenum(BudgetTransactionLine)).name();

        // Get the field name that contains the accounting currency amount.
        str accountingCurrencyAmount = budgetRegisterEntryEntity.computedColumnString(lineDataSourceName, fieldStr(BudgetTransactionLine, AccountingCurrencyAmount), FieldNameGenerationMode::WhereClause);

        // Get the field name that contains the amount type.
        str amountType = budgetRegisterEntryEntity.computedColumnString(lineDataSourceName, fieldStr(BudgetTransactionLine, BudgetType), FieldNameGenerationMode::WhereClause);

        return SysComputedColumn::if(
            SysComputedColumn::equalExpression(amountType, int2Str(enum2int(BudgetType::Revenue))),
            SysComputedColumn::multiply(accountingCurrencyAmount, int2Str(-1)),
            accountingCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCurrencyAmountSQL</Name>
				<Source><![CDATA[
    private static str getTransactionCurrencyAmountSQL()
    {
        DictDataEntity budgetRegisterEntryEntity = new DictDataEntity(tableNum(BudgetRegisterEntryEntity));

        // Get the data source name that contains the transaction currency amount details.
        str lineDataSourceName = budgetRegisterEntryEntity.query().dataSourceTable(tablenum(BudgetTransactionLine)).name();

        // Get the field name that contains the transaction currency amount.
        str transactionCurrencyAmount = budgetRegisterEntryEntity.computedColumnString(lineDataSourceName, fieldStr(BudgetTransactionLine, TransactionCurrencyAmount), FieldNameGenerationMode::WhereClause);

        // Get the field name that contains the amount type.
        str amountType = budgetRegisterEntryEntity.computedColumnString(lineDataSourceName, fieldStr(BudgetTransactionLine, BudgetType), FieldNameGenerationMode::WhereClause);

        return SysComputedColumn::if(
            SysComputedColumn::equalExpression(amountType, int2Str(enum2int(BudgetType::Revenue))),
            SysComputedColumn::multiply(transactionCurrencyAmount, int2Str(-1)),
            transactionCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapEntityToDataSource</Name>
				<Source><![CDATA[
    public void mapEntityToDataSource(DataEntityRuntimeContext _entityCtx, DataEntityDataSourceRuntimeContext _dataSourceCtx)
    {
        super(_entityCtx, _dataSourceCtx);

        if (_dataSourceCtx.getDatabaseOperation() == DataEntityDatabaseOperation::Insert)
        {
            switch (_dataSourceCtx.name())
            {
                case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionHeader):
                    BudgetTransactionHeader header = _dataSourceCtx.getBuffer();

                    this.setEntryNumber(header);

                    break;

                case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionLine):
                    BudgetTransactionLine line = _dataSourceCtx.getBuffer();

                    line.AccountingCurrencyAmount = this.AccountingCurrencyAmount;
                    line.TransactionCurrencyAmount = this.TransactionCurrencyAmount;

                    if (!line.BudgetType)
                    {
                        MainAccountNum mainAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(this.Dimension);
                        if (mainAccount)
                        {
                            line.BudgetType = BudgetTransactionLine::determineBudgetTypeFromMainAccount(mainAccount);
                        }
                    }

                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapHeaderForUpsert</Name>
				<Source><![CDATA[
    private void mapHeaderForUpsert(BudgetTransactionHeader _header)
    {
        changecompany(this.LegalEntityId)
        {
            if (this.fieldState(fieldNum(BudgetRegisterEntryEntity, BudgetModelId)) == FieldState::Set)
            {
                _header.BudgetSubModelId = this.BudgetModelId;
                _header.BudgetModelDataAreaId = this.LegalEntityId;
                _header.BudgetModelType = HeadingSub::Heading;

                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetSubModelId), FieldState::Set);
                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetModelDataAreaId), FieldState::Set);
                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetModelType), FieldState::Set);

                _header.setIncludeInCashFlowForecast();
            }

            if (this.fieldState(fieldNum(BudgetRegisterEntryEntity, BudgetCode)) == FieldState::Set
                || this.fieldState(fieldNum(BudgetRegisterEntryEntity, BudgetType)) == FieldState::Set)
            {
                BudgetTransHeaderType budgetTransHeaderType = _header.type();

                if (budgetTransHeaderType)
                {
                    // Default the BudgetTransactionCode and BudgetTransactionType fields based on what the entity has set.
                    budgetTransHeaderType.defaultField(fieldNum(BudgetTransactionHeader, BudgetTransactionCode));
                    budgetTransHeaderType.defaultField(fieldNum(BudgetTransactionHeader, BudgetTransactionType));

                    this.BudgetCode = BudgetTransactionCode::find(_header.BudgetTransactionCode).Name;
                }

                // Direct updates to the BudgetTransactionType field are not allowed on the BudgetTransactionHeader table.
                // Resetting the state of this field and setting the state of the BudgetTransactionCode field ensures
                // the correct information is published via the entity.
                this.fieldState(fieldNum(BudgetRegisterEntryEntity, BudgetType), FieldState::NotSet);
                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetTransactionType), FieldState::NotSet);
                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetTransactionCode), FieldState::Set);
            }

            this.setReasonFields(_header);

            _header.Date = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEntityDataSource</Name>
				<Source><![CDATA[
    public boolean updateEntityDataSource(DataEntityRuntimeContext _entityCtx, DataEntityDataSourceRuntimeContext _dataSourceCtx)
    {
        boolean isValid = true;

        isValid = BudgetTransactionManager::validateInUseBy(this.InUseBy, this.EntryNumber) && isValid;

        switch (_dataSourceCtx.name())
        {
            case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionHeader):
                BudgetTransactionHeader header = _dataSourceCtx.getBuffer();

                this.mapHeaderForUpsert(header);

                isValid = BudgetTransactionManager::checkWorkflowStatusForUpdate(this.DocumentWorkflowStatus, this.EntryNumber) && isValid;

                // We perform the validation here because we can't get BudgetTransactionHeader buffer
                // from the entity's validateWrite().
                isValid = BudgetRegisterEntryEntity::validateBudgetTransactionCode(header) && isValid;

                break;
        }

        if (!isValid)
        {
            // methods above will log errors, throw an exception to stop the update.
            throw Exception::Error;
        }

        return super(_entityCtx, _dataSourceCtx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteEntityDataSource</Name>
				<Source><![CDATA[
    public boolean deleteEntityDataSource(DataEntityRuntimeContext _entityCtx, DataEntityDataSourceRuntimeContext _dataSourceCtx)
    {
        switch (_dataSourceCtx.name())
        {
            case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionHeader):
                BudgetTransactionHeader header = _dataSourceCtx.getBuffer();

                if (!BudgetRegisterEntryEntity::validateBudgetTransactionCode(header))
                {
                    throw Exception::Error;
                }

                break;
        }

        return super(_entityCtx, _dataSourceCtx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEntityDataSource</Name>
				<Source><![CDATA[
    public boolean insertEntityDataSource(DataEntityRuntimeContext _entityCtx, DataEntityDataSourceRuntimeContext _dataSourceCtx)
    {
        BudgetTransactionHeader header;

        switch (_dataSourceCtx.name())
        {
            case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionHeader):
                header = _dataSourceCtx.getBuffer();

                this.mapHeaderForUpsert(header);

                if (!BudgetRegisterEntryEntity::validateBudgetTransactionCode(header))
                {
                    throw Exception::Error;
                }

                break;
        }

        boolean isInserted = super(_entityCtx, _dataSourceCtx);

        switch (_dataSourceCtx.name())
        {
            case dataentitydatasourcestr(BudgetRegisterEntryEntity, BudgetTransactionLine):
                // After processing the BudgetTransactionLine data source,
                // remove the one-time event handler that was added for an insert header failure.
                // BudgetTransactionLine is the root data source for this entity and thus the last to be processed.
                appl.onTtsNotifyAbort -= eventhandler(this.onInsertTtsNotifyAbort);

                break;
        }

        return isInserted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetTransactionCode</Name>
				<Source><![CDATA[
    private static boolean validateBudgetTransactionCode(BudgetTransactionHeader _header)
    {
        SelectableDataArea currentDataArea = CompanyInfo::getDataArea(Ledger::primaryForLegalEntity(_header.PrimaryLedger));

        boolean isValid;

        changecompany(currentDataArea)
        {
            BudgetTransHeaderType budgetTransHeaderType = _header.type();

            // Validate the private key field directly after it has been mapped.
            isValid = budgetTransHeaderType.validateField(fieldNum(BudgetTransactionHeader, BudgetTransactionCode));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReasonCodeSql</Name>
				<Source><![CDATA[
    private static str getReasonCodeSql()
    {
        str reasonCodeSql = strFmt('SELECT REASON FROM REASONTABLEREF WHERE RECID = %1',
            SysComputedColumn::returnField(
                tableStr(BudgetRegisterEntryEntity),
                dataEntityDataSourceStr(BudgetRegisterEntryEntity, BudgetTransactionHeader),
                fieldStr(BudgetTransactionHeader, ReasonTableRef)));

        return reasonCodeSql;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReasonCommentSql</Name>
				<Source><![CDATA[
    private static str getReasonCommentSql()
    {
        str reasonCommentSql = strFmt('SELECT REASONCOMMENT FROM REASONTABLEREF WHERE RECID = %1',
            SysComputedColumn::returnField(
                tableStr(BudgetRegisterEntryEntity),
                dataEntityDataSourceStr(BudgetRegisterEntryEntity, BudgetTransactionHeader),
                fieldStr(BudgetTransactionHeader, ReasonTableRef)));

        return reasonCommentSql;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReasonFields</Name>
				<Source><![CDATA[
    private void setReasonFields(BudgetTransactionHeader _header)
    {
        boolean isReasonCodeSet = this.fieldState(fieldNum(BudgetRegisterEntryEntity, ReasonCode)) == FieldState::Set;

        ReasonCode reasonCode = _header.editReasonCode(isReasonCodeSet, this.ReasonCode);

        if (isReasonCodeSet && this.ReasonCode != reasonCode)
        {
            // The specified reason code was not set on the header.
            // The edit method will log errors, throw the exception to stop the update.
            throw Exception::Error;
        }

        _header.editReasonComment(this.fieldState(fieldNum(BudgetRegisterEntryEntity, ReasonComment)) == FieldState::Set, this.ReasonComment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean isValid;

        isValid = BudgetTransactionManager::validateInUseBy(this.InUseBy, this.EntryNumber);

        isValid = isValid && super();

        if (!isValid)
        {
            // methods above will log errors, throw the exception to stop the delete.
            throw Exception::Error;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEntryNumberSql</Name>
				<Source><![CDATA[
    private static str getEntryNumberSql()
    {
        DictDataEntity budgetRegisterEntryEntity = new DictDataEntity(tableNum(BudgetRegisterEntryEntity));

        // Get the data source name that contains the entry number details.
        str headerDataSourceName = budgetRegisterEntryEntity.query().dataSourceTable(tablenum(BudgetTransactionHeader)).name();

        // Get the field name that contains the entry number.
        str transactionNumber = budgetRegisterEntryEntity.computedColumnString(headerDataSourceName, fieldStr(BudgetTransactionHeader, TransactionNumber), FieldNameGenerationMode::WhereClause);

        return SysComputedColumn::if(
            SysComputedColumn::isNullExpression(transactionNumber),
            SysComputedColumn::returnLiteral(''),
            transactionNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEntryNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces a temporary entry number with an entry number allocated from number sequences.
    /// </summary>
    /// <param name = "_header">
    /// The <c>BudgetTransactionHeader</c> record.
    /// </param>
    public void setEntryNumber(BudgetTransactionHeader _header)
    {
        LedgerRecId primaryLedgerRecId = Ledger::primaryLedger(CompanyInfo::current(this.LegalEntityId));

        if(!this.scopeIdentifier())
        {
            this.scopeIdentifier(_header.scopeIdentifier());
        }

        container cacheKey = [primaryLedgerRecId, this.EntryNumber, this.scopeIdentifier()];
        container cachedResult = BudgetCache::getValue(BudgetCacheScope::BudgetRegisterEntryEntityEntryNumber, cacheKey);

        if (cachedResult == conNull())
        {
            BudgetTransactionHeader existingHeader = BudgetTransactionHeader::findByTransactionNumber(this.EntryNumber, primaryLedgerRecId);

            if (!existingHeader && this.isContinuousNumberSequence())
            {
                changecompany(this.LegalEntityId)
                {
                    // Generate an entry number for the provided value when a continuous number sequence value does not exist.
                    BudgetRegisterEntryEntityNumSeqHandler::enableNumberSequenceControl
                        (this,
                        fieldNum(BudgetRegisterEntryEntity, EntryNumber),
                        BudgetParameters::numRefBudgetTransactionId(),
                        _header);

                    // Call initValue to generate the number sequence value.
                    this.initValue();
                }

                cachedResult = [this.EntryNumber];

                BudgetCache::insertValue(BudgetCacheScope::BudgetRegisterEntryEntityEntryNumber, cacheKey, cachedResult);

                // Register the notify abort event to release the generated number sequence value if the insert fails.
                appl.onTtsNotifyAbort += eventhandler(this.onInsertTtsNotifyAbort);
            }
        }
        else
        {
            this.EntryNumber = conpeek(cachedResult, 1);
        }

        if (_header.TransactionNumber != this.EntryNumber)
        {
            _header.TransactionNumber = this.EntryNumber;

            // Reset the read-only fields for the updated budget transaction header reference.
            BudgetTransactionHeader header = BudgetTransactionHeader::findByTransactionNumber(this.EntryNumber, primaryLedgerRecId);

            if (header)
            {
                this.BudgetType = header.BudgetTransactionType;
                this.fieldState(fieldNum(BudgetRegisterEntryEntity, BudgetType), FieldState::NotSet);

                _header.BudgetTransactionType = header.BudgetTransactionType;
                _header.fieldState(fieldNum(BudgetTransactionHeader, BudgetTransactionType), FieldState::NotSet);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onInsertTtsNotifyAbort</Name>
				<Source><![CDATA[
    private void onInsertTtsNotifyAbort()
    {
        if (this.EntryNumber)
        {
            LedgerRecId primaryLedgerRecId = Ledger::primaryLedger(CompanyInfo::current(this.LegalEntityId));

            BudgetTransactionHeader existingHeader = BudgetTransactionHeader::findByTransactionNumber(this.EntryNumber, primaryLedgerRecId);

            if (!existingHeader && this.isContinuousNumberSequence())
            {
                changecompany(this.LegalEntityId)
                {
                    // Release the entry number value when a continuous number sequence value
                    // was generated but the insert is aborted for the record and no other header reference exists.
                    NumberSeq::releaseNumber(
                        BudgetParameters::numRefBudgetTransactionId().NumberSequenceId,
                        this.EntryNumber);
                }
            }
        }

        // Remove the one time event handler that was added for the insert failure to ensure there is only one registered.
        appl.onTtsNotifyAbort -= eventhandler(this.onInsertTtsNotifyAbort);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContinuousNumberSequence</Name>
				<Source><![CDATA[
    private boolean isContinuousNumberSequence()
    {
        boolean isContinuousNumberSequence;

        changecompany(this.LegalEntityId)
        {
            NumberSequenceReference numberSequenceReference = BudgetParameters::numRefBudgetTransactionId();

            if (numberSequenceReference)
            {
                NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

                if (numberSequenceTable
                    && numberSequenceTable.Continuous
                    && !numberSequenceTable.Blocked)
                {
                    // The number sequence that is setup is continuous and not on hold.
                    isContinuousNumberSequence = true;
                }
            }
        }

        return isContinuousNumberSequence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEntryNumberForStaging</Name>
				<Source><![CDATA[
    private static BudgetTransactionId setEntryNumberForStaging(BudgetRegisterEntryStaging _staging, BudgetTransactionHeader _header)
    {
        BudgetRegisterEntryEntity entity;
        entity.EntryNumber = _staging.EntryNumber;
        entity.LegalEntityId = _staging.LegalEntityId;
        entity.setEntryNumber(_header);
        _header.TransactionNumber = entity.EntryNumber;

        return entity.EntryNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStagingForHeaderResult</Name>
				<Source><![CDATA[
    private static void updateStagingForHeaderResult(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, List _list)
    {
        ListEnumerator enumerator;
        BudgetTransactionId stagingNumber;
        BudgetTransactionHeader budgetTransactionHeaderResult;
        boolean isValid;
        BudgetRegisterEntryStaging staging;
        str errorMessage;

        if (_list)
        {
            enumerator = _list.getEnumerator();
        }

        if (enumerator)
        {
            while (enumerator.moveNext())
            {
                [budgetTransactionHeaderResult, stagingNumber, isValid, errorMessage] = enumerator.current();

                SelectableDataArea currentDataArea = CompanyInfo::getDataArea(Ledger::primaryForLegalEntity(budgetTransactionHeaderResult.PrimaryLedger));

                changecompany(currentDataArea)
                {
                    BudgetTransactionCode BudgetTransactionCode = BudgetTransactionCode::find(budgetTransactionHeaderResult.BudgetTransactionCode);

                    update_recordset staging
                        setting EntryNumber = budgetTransactionHeaderResult.TransactionNumber,
                            BudgetType = budgetTransactionHeaderResult.BudgetTransactionType,
                            BudgetCode = BudgetTransactionCode.Name
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.EntryNumber == stagingNumber
                            && staging.LegalEntityId == currentDataArea;
                }

                if (!isValid)
                {
                    // this is a header error so all staging records for that header are marked.
                    update_recordset staging
                        setting TransferStatus = DMFTransferStatus::Error
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.EntryNumber == budgetTransactionHeaderResult.TransactionNumber
                            && staging.LegalEntityId == currentDataArea;

                    // Write error string to DMF validation log
                    TableName tableName = tableStr(BudgetRegisterEntryStaging);
                    DMFSourceTarget sourceTarget = DMFSourceTarget::Target;
                    str entityName = "@Budget:EntityTitle_BudgerRegisterEntryEntityTitle";
                    FieldName fieldName = '';
                    DMFStagingValidationLog log;

                    insert_recordset log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
                        select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, errorMessage from staging
                            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && staging.EntryNumber == budgetTransactionHeaderResult.TransactionNumber
                                && staging.LegalEntityId == currentDataArea;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFields</Name>
				<Source><![CDATA[
    private static boolean validateFields(BudgetTransactionHeader _header)
    {
        boolean isValid;

        isValid = _header.validateField(fieldNum(BudgetTransactionHeader, BudgetTransactionCode));
        isValid = _header.validateField(fieldNum(BudgetTransactionHeader, BudgetModelId)) && isValid;
        isValid = _header.validateField(fieldNum(BudgetTransactionHeader, IsOneTimeAmendment)) && isValid;
        isValid = _header.validateField(fieldNum(BudgetTransactionHeader, ReasonTableRef)) && isValid;

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertHeader</Name>
				<Source><![CDATA[
    private static void upsertHeader(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        BudgetTransactionHeader budgetTransactionHeader;
        BudgetRegisterEntryStaging staging;
        List entryNumberList = new List(Types::Container);

        TransDate currentDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());

        BudgetTransactionId id;
        boolean isValid;
        int initialLineCount;
        str error;

        while select staging
            group by BudgetModelId,
                        BudgetCode,
                        BudgetType,
                        OneTimeRevision,
                        ReasonCode,
                        ReasonComment,
                        EntryNumber,
                        Status,
                        LegalEntityId
            order by EntryNumber
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
        {
            changecompany(staging.LegalEntityId)
            {
                isValid = true;
                initialLineCount = Global::infologLine();
                budgetTransactionHeader.clear();
                LedgerRecId currentLedger = Ledger::current();

                if (staging.EntryNumber)
                {
                    budgetTransactionHeader = BudgetTransactionHeader::findByTransactionNumber(staging.EntryNumber, currentLedger, true);
                }

                if (!budgetTransactionHeader.RecId)
                {
                    budgetTransactionHeader.TransactionNumber = staging.EntryNumber;
                    budgetTransactionHeader.scopeIdentifier(_dmfDefinitionGroupExecution.scopeIdentifier());

                    // replace temporary number with allocated number.
                    id = BudgetRegisterEntryEntity::setEntryNumberForStaging(staging, budgetTransactionHeader);
                    budgetTransactionHeader = BudgetTransactionHeader::findByTransactionNumber(budgetTransactionHeader.TransactionNumber, currentLedger, true);
                    if (!budgetTransactionHeader.RecId)
                    {
                        // find clears the transaction number when not found so we need to put it back.
                        budgetTransactionHeader.TransactionNumber = id;
                    }
                }

                budgetTransactionHeader.BudgetModelId = staging.BudgetModelId;
                budgetTransactionHeader.BudgetSubModelId = staging.BudgetModelId;
                budgetTransactionHeader.IsOneTimeAmendment = staging.OneTimeRevision;
                budgetTransactionHeader.BudgetModelDataAreaId = staging.LegalEntityId;

                if (staging.BudgetCode)
                {
                    budgetTransactionHeader.BudgetTransactionCode = BudgetTransactionCode::findByBudgetTransactionCode(staging.BudgetCode).RecId;
                }

                // Use the BudgetType from staging rather than from the budget code to ensure correct defaulting below.
                budgetTransactionHeader.BudgetTransactionType = staging.BudgetType;

                budgetTransactionHeader.Date = currentDate;
                budgetTransactionHeader.PrimaryLedger = currentLedger;

                budgetTransactionHeader.defaultRow();

                // Validate
                isValid = BudgetTransactionManager::validateInUseBy(budgetTransactionHeader.InUseBy, budgetTransactionHeader.TransactionNumber) && isValid;
                isValid = BudgetRegisterEntryEntity::validateBudgetTransactionCode(budgetTransactionHeader) && isValid;
                isValid = BudgetTransactionManager::checkWorkflowStatusForUpdate(budgetTransactionHeader.WorkflowStatus, budgetTransactionHeader.TransactionNumber) && isValid;

                isValid = budgetTransactionHeader.validateWrite() && isValid;
                isValid = BudgetRegisterEntryEntity::validateFields(budgetTransactionHeader) && isValid;

                try
                {
                    if (isValid)
                    {
                        if (budgetTransactionHeader.RecId)
                        {
                            if (budgetTransactionHeader.orig().BudgetModelId != budgetTransactionHeader.BudgetModelId)
                            {
                                budgetTransactionHeader.setIncludeInCashFlowForecast();
                            }

                            budgetTransactionHeader.update();
                        }
                        else
                        {
                            budgetTransactionHeader.insert();
                        }
                    }
                }
                catch
                {
                    isValid = false;
                    continue;
                }
            }

            // get errors from infolog so we can write them to DMF validation log
            for (int infoLogLine = initialLineCount + 1; infoLogLine <= Global::infologLine(); infoLogLine++)
            {
                if (infologLine != initialLineCount + 1)
                {
                    error += "\r\n";
                }

                error += infolog.text(infoLogLine);
            }

            entryNumberList.addEnd([budgetTransactionHeader, staging.EntryNumber, isValid, error]);

            error = '';
        }

        // Mark staging with errors and write errors to validation log
        BudgetRegisterEntryEntity::updateStagingForHeaderResult(_dmfDefinitionGroupExecution, entryNumberList);

        BudgetRegisterEntryStaging stagingLegalEntityLoop;

        while select stagingLegalEntityLoop
            group by LegalEntityId
            where stagingLegalEntityLoop.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && stagingLegalEntityLoop.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
        {
            changecompany(stagingLegalEntityLoop.LegalEntityId)
            {
                LedgerRecId currentLedger = Ledger::current();

                // write reason codes
                ReasonTable reasonTable, reasonTableSelect;
                reasonTable.skipDataMethods(true);
                NoYes ledgerReason = NoYes::Yes;
                insert_recordset reasonTable (Reason, Description, Ledger)
                    select ReasonCode, ReasonComment, ledgerReason from staging
                        group by ReasonCode, ReasonComment
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                           && staging.ReasonCode != ''
                    notexists join reasonTableSelect
                        where reasonTableSelect.Reason == staging.ReasonCode;

                ReasonTableRef reasonTableRef;
                reasonTableRef.skipDataMethods(true);
                insert_recordset reasonTableRef (Reason, ReasonComment)
                    select ReasonCode, ReasonComment from staging
                        group by ReasonCode, ReasonComment
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                           && staging.ReasonCode != '';

                BudgetTransactionHeader budgetTransactionHeaderJoin;

                budgetTransactionHeader.skipDataMethods(true);
                update_recordset budgetTransactionHeader
                    setting ReasonTableRef = reasonTableRef.RecId
                    where budgetTransactionHeader.PrimaryLedger == currentLedger
                    join firstonly staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.EntryNumber == budgetTransactionHeader.TransactionNumber
                            && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                            && staging.ReasonCode != ''
                    join reasonTableRef
                        where reasonTableRef.Reason == staging.ReasonCode
                            && reasonTableRef.ReasonComment == staging.ReasonComment
                    notexists join budgetTransactionHeaderJoin
                        where budgetTransactionHeaderJoin.ReasonTableRef == reasonTableRef.RecId
                            && budgetTransactionHeaderJoin.TransactionNumber == staging.EntryNumber
                            && budgetTransactionHeaderJoin.PrimaryLedger == currentLedger;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertLine</Name>
				<Source><![CDATA[
    private static container upsertLine(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DimensionDataEntitySFKCacheTmp _dimCacheTmpLedgerAccount)
    {
        BudgetTransactionHeader header;
        BudgetTransactionLine line;
        BudgetRegisterEntryStaging staging;

        ExtendedDataTypeName dataType = identifierstr(LedgerDimensionBudget);
        const DimensionHierarchyType hierarchyType = DimensionHierarchyType::DataEntityBudgetDimensionFormat;

        int64 updatedRecords;
        int64 newRecords;

        BudgetRegisterEntryStaging stagingLegalEntityLoop;

        while select stagingLegalEntityLoop
            group by LegalEntityId
            where stagingLegalEntityLoop.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && stagingLegalEntityLoop.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
        {
            changecompany(stagingLegalEntityLoop.LegalEntityId)
            {
                LedgerRecId currentLedger = Ledger::current();

                // update existing lines
                line.skipDataMethods(true);
                update_recordset line
                    setting BudgetType = staging.AmountType,
                            Comment = staging.Comment,
                            IncludeInCashFlowForecast = staging.IncludeInCashFlowForecast,
                            LineNumber = staging.LineNumber,
                            Price = staging.Price,
                            Quantity = staging.Quantity,
                            @Date = staging.Date,
                            TransactionCurrency = staging.CurrencyCode,
                            TransactionCurrencyAmount = staging.TransactionCurrencyAmount,
                            LedgerDimension = _dimCacheTmpLedgerAccount.ResolvedReference,
                            BudgetTransactionHeader = header.RecId
                    join header
                        where header.RecId == line.BudgetTransactionHeader
                           && header.PrimaryLedger == currentLedger
                    join staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                           && header.TransactionNumber == staging.EntryNumber
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                           && line.LineNumber == staging.LineNumber
                    join ResolvedReference from _dimCacheTmpLedgerAccount
                        where _dimCacheTmpLedgerAccount.IntegrationString == staging.DimensionDisplayValue
                           && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                           && _dimCacheTmpLedgerAccount.HierarchyType == hierarchyType
                           && _dimCacheTmpLedgerAccount.ExtendedDataType == dataType;

                // get the number of records updated
                updatedRecords += line.RowCount();

                // insert new lines
                BudgetTransactionLine lineJoin;
                insert_recordset line (BudgetType,
                                        Comment,
                                        IncludeInCashFlowForecast,
                                        LineNumber,
                                        Price,
                                        Quantity,
                                        TransactionCurrency,
                                        TransactionCurrencyAmount,
                                        @Date,
                                        LedgerDimension,
                                        BudgetTransactionHeader,
                                        WorkflowStatus)
                    select AmountType, Comment, IncludeInCashFlowForecast, LineNumber, Price, Quantity, CurrencyCode,
                           TransactionCurrencyAmount, @Date from staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                            && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    join ResolvedReference from _dimCacheTmpLedgerAccount
                        where _dimCacheTmpLedgerAccount.IntegrationString == staging.DimensionDisplayValue
                            && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                            && _dimCacheTmpLedgerAccount.HierarchyType == hierarchyType
                            && _dimCacheTmpLedgerAccount.ExtendedDataType == dataType
                    join RecId, WorkflowStatus from header
                        where header.TransactionNumber == staging.EntryNumber
                            && header.PrimaryLedger == currentLedger
                    notexists join lineJoin
                        where lineJoin.BudgetTransactionHeader == header.RecId
                            && lineJoin.LineNumber == staging.LineNumber;

                // Get the number of records inserted.
                newRecords += line.RowCount();

                // Convert transactional to accounting
                CurrencyCode accountingCurrency = ledger::find(currentLedger).AccountingCurrency;
                ExchangeRateTypeId rateType = Ledger::budgetExchangeRateType();
                ExchangeRateEffectiveView exchangeRateView;
                staging.skipDataMethods(true);
                update_recordset staging
                    setting AccountingCurrencyAmount = staging.TransactionCurrencyAmount * (exchangeRateView.CrossRate / 100)
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                            && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    join exchangeRateView
                        where exchangeRateView.ExchangeRateType == rateType
                            && exchangeRateView.FromCurrencyCode == staging.CurrencyCode
                            && exchangeRateView.TOCURRENCYCODE == accountingCurrency
                            && exchangeRateView.VALIDFROM <= staging.DATE
                            && exchangeRateView.VALIDTO >= staging.DATE;

                // Round the accounting amount using the currency set based API's
                if (CurrencyExchange::doAllowSetBasedRoundingForCurrencyCode(accountingCurrency))
                {
                    update_recordset staging
                        setting AccountingCurrency = accountingCurrency
                            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                                && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId;

                    BudgetRegisterEntryStagingRoundingView view;
                    update_recordset line
                        setting AccountingCurrencyAmount = view.RoundedAccountingCurrencyAmount
                        join header
                            where header.RecId == line.BudgetTransactionHeader
                                && header.PrimaryLedger == currentLedger
                        join staging
                            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                                && staging.EntryNumber == header.TransactionNumber
                                && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                                && line.LineNumber == staging.LineNumber
                        join view
                        where view.StagingRecId == staging.RecId;

                    // if quantity * price does not equal net amount then clear quantity and price.
                    // Currency set based rounding currency does not support rounding multiple currencies so
                    // do this row by row.
                    while select forupdate Quantity, TransactionCurrencyAmount, TransactionCurrency, Price from line
                        where (line.Quantity != 0
                            || line.Price != 0)
                        join header
                            where header.RecId == line.BudgetTransactionHeader
                                && header.PrimaryLedger == currentLedger
                        join staging
                            where staging.EntryNumber == header.TransactionNumber
                                && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                                && staging.LineNumber == line.LineNumber
                                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                    {
                        AmountCur netAmount = line.Quantity * line.Price;
                        netAmount = CurrencyExchange::round(netAmount, line.TransactionCurrency);

                        if (netAmount != line.TransactionCurrencyAmount)
                        {
                            line.Quantity = 0;
                            line.Price = 0;
                            line.update();
                        }
                    }
                }
                else
                {
                    // Currency doesn't support rounding transactional currency to accounting currency via set
                    // based logic due to rounding settings set on the accounting currency.
                    AmountMST oldAccountingAmount;
                    boolean update;

                    // Currency set based API doesn't support this currency.  Round row by row
                    while select forupdate Quantity, TransactionCurrencyAmount, TransactionCurrency, Price from line
                        join header
                            where header.RecId == line.BudgetTransactionHeader
                                && header.PrimaryLedger == currentLedger
                        join staging
                            where staging.EntryNumber == header.TransactionNumber
                                && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                                && staging.LineNumber == line.LineNumber
                                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                    {
                        if (Line.Quantity != 0 || line.Price != 0)
                        {
                            AmountCur netAmount = line.Quantity * line.Price;
                            netAmount = CurrencyExchange::round(netAmount, line.TransactionCurrency);

                            if (netAmount != line.TransactionCurrencyAmount)
                            {
                                update = true;
                                line.Quantity = 0;
                                line.Price = 0;
                            }
                        }

                        oldAccountingAmount = line.AccountingCurrencyAmount;
                        line.AccountingCurrencyAmount = CurrencyExchange::round(line.AccountingCurrencyAmount, accountingCurrency);

                        if (oldAccountingAmount != line.AccountingCurrencyAmount
                            || update)
                        {
                            line.update();
                        }
                        update = false;
                    }
                }

                // Adjust the sign for revenue amounts.
                update_recordset line
                    setting TransactionCurrencyAmount = line.TransactionCurrencyAmount * -1,
                            AccountingCurrencyAmount = line.AccountingCurrencyAmount * -1
                    join header
                        where header.RecId == line.BudgetTransactionHeader
                           && header.PrimaryLedger == currentLedger
                    join staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                           && header.TransactionNumber == staging.EntryNumber
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                           && line.LineNumber == staging.LineNumber
                           && staging.AmountType == BudgetType::Revenue;
            }
        }

        return [newRecords, updatedRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>performSetBasedValidation</Name>
				<Source><![CDATA[
    private static void performSetBasedValidation(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DimensionDataEntitySFKCacheTmp _dimCacheTmpLedgerAccount)
    {
        BudgetRegisterEntryStaging stagingLegalEntityLoop;
        BudgetRegisterEntryStaging staging;
        ExtendedDataTypeName dataType = extendedTypeStr(LedgerDimensionBudget);

        while select stagingLegalEntityLoop
            group by LegalEntityId
            where stagingLegalEntityLoop.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && stagingLegalEntityLoop.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
        {
            changecompany(stagingLegalEntityLoop.LegalEntityId)
            {
                if (Ledger::budgetExchangeRateType() == 0)
                {
                    throw error("@Budget:EntityError_InvalidBudgetRateType");
                }

                LedgerRecId currentLedger = Ledger::current();

                // Put any rows that have unresolved accounts in an error state first.
                staging.skipDataMethods(true);
                update_recordset staging
                    setting TransferStatus = DMFTransferStatus::Error
                    where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                        && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    exists join _dimCacheTmpLedgerAccount
                        where _dimCacheTmpLedgerAccount.IntegrationString == staging.DimensionDisplayValue
                            && _dimCacheTmpLedgerAccount.HierarchyName == staging.DimensionAccountStructure
                            && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                            && _dimCacheTmpLedgerAccount.HierarchyType == DimensionHierarchyType::DataEntityBudgetDimensionFormat
                            && _dimCacheTmpLedgerAccount.ExtendedDataType == dataType
                            && _dimCacheTmpLedgerAccount.Found == NoYes::No;

                // Put any rows that were not processed by the resolver in an error state first.
                update_recordset staging
                    setting TransferStatus = DMFTransferStatus::Error
                    where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                        && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    notexists join _dimCacheTmpLedgerAccount
                        where _dimCacheTmpLedgerAccount.IntegrationString == staging.DimensionDisplayValue
                            && _dimCacheTmpLedgerAccount.HierarchyName == staging.DimensionAccountStructure
                            && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                            && _dimCacheTmpLedgerAccount.HierarchyType == DimensionHierarchyType::DataEntityBudgetDimensionFormat
                            && _dimCacheTmpLedgerAccount.ExtendedDataType == dataType;

                // put any rows which do not have a valid currency in an error state
                Currency currency;
                update_recordset staging
                    setting TransferStatus = DMFTransferStatus::Error
                    where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                        && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    notexists join currency
                    where staging.CurrencyCode == Currency.CurrencyCode;

                // write errors to DMF validation log
                str error = "@Budget:EntityError_InvalidCurrency";
                FieldName fieldName = fieldStr(BudgetRegisterEntryStaging, CurrencyCode);
                TableName tableName = tableStr(BudgetRegisterEntryStaging);
                TableName entityName = "@Budget:EntityTitle_BudgerRegisterEntryEntityTitle";
                DMFSourceTarget sourceTarget = DMFSourceTarget::Target;

                DMFStagingValidationLog log;
                log.skipDataMethods(true);
                insert_recordset log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
                    select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, error from staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    notexists join currency
                    where staging.CurrencyCode == Currency.CurrencyCode;

                // if Transfer then the amount type has to be the same value for all rows for the budget register document.
                BudgetTransactionHeader header;
                BudgetRegisterEntryStaging stagingJoin;

                update_recordset staging
                    setting TransferStatus = DMFTransferStatus::Error
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                           && staging.BudgetType == BudgetTransactionType::Transfer
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    exists join stagingJoin
                        where stagingJoin.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && stagingJoin.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && stagingJoin.EntryNumber == staging.EntryNumber
                           && stagingJoin.LegalEntityId == staging.LegalEntityId
                           && stagingJoin.AmountType != staging.AmountType;

                // write errors to DMF validation log
                error = "@Budget:EntityError_InvalidAmountTypeForTransfer";
                fieldName = fieldStr(BudgetRegisterEntryStaging, BudgetType);
                insert_recordset log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
                    select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, error from staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && staging.BudgetType == BudgetTransactionType::Transfer
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    exists join stagingJoin
                        where stagingJoin.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && stagingJoin.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && stagingJoin.EntryNumber == staging.EntryNumber
                           && stagingJoin.LegalEntityId == staging.LegalEntityId
                           && stagingJoin.AmountType != staging.AmountType;

                // if status is completed then don't allow update.
                update_recordset staging
                    setting TransferStatus = DMFTransferStatus::Error
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                            && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    join header
                        where header.TransactionNumber == staging.EntryNumber
                           && header.PrimaryLedger == currentLedger
                           && header.TransactionStatus == BudgetTransactionStatus::Completed;

                // write errors to DMF validation log
                error = "@Budget:EntityError_InvalidDocumentStatus";
                fieldName = fieldStr(BudgetRegisterEntryStaging, Status);
                insert_recordset log (DefinitionGroupName, ExecutionId, StagingRecId, StagingTableName, StagingColumnName, SourceTarget, EntityName, ErrorMessage)
                    select DefinitionGroup, ExecutionId, RecId, tableName, fieldName, sourceTarget, entityName, error from staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    join header
                        where header.TransactionNumber == staging.EntryNumber
                           && header.PrimaryLedger == currentLedger
                           && header.TransactionStatus == BudgetTransactionStatus::Completed;

                CurrencyCode accountingCurrency = Ledger::accountingCurrency();
                ExchangeRateTypeId rateType = Ledger::budgetExchangeRateType();
                ExchangeRateEffectiveView exchangeRateView;
                fieldName = fieldStr(BudgetRegisterEntryStaging, CurrencyCode);
                while select forupdate staging
                        where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                           && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                           && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                           && staging.LegalEntityId == stagingLegalEntityLoop.LegalEntityId
                    notexists join exchangeRateView
                        where exchangeRateView.ExchangeRateType == rateType
                           && exchangeRateView.FromCurrencyCode == staging.CurrencyCode
                           && exchangeRateView.TOCURRENCYCODE == accountingCurrency
                           && exchangeRateView.VALIDFROM <= staging.Date
                           && exchangeRateView.VALIDTO >= staging.Date
                {
                    // insert error into DMF validation log.
                    log.DefinitionGroupName = staging.DefinitionGroup;
                    log.ExecutionId = staging.ExecutionId;
                    log.StagingRecId = staging.RecId;
                    log.StagingTableName = tableName;
                    log.StagingColumnName = fieldName;
                    log.SourceTarget = sourceTarget;
                    log.EntityName = entityName;
                    log.ErrorMessage = strFmt("@CurrencyExchange:Currency_EntityMessage_MissingRate", rateType, staging.CurrencyCode, accountingCurrency, staging.Date);
                    log.insert();

                    staging.TransferStatus = DMFTransferStatus::Error;
                    staging.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCustomStagingToTarget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a custom copy from the staging table to the target environment.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <returns>A container of counts of [new records, updated records].</returns>
    public static container copyCustomStagingToTarget(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        BudgetRegisterEntryStaging staging;
        DMFStagingValidationLog log;
        int64 updatedRecordsTotal;
        int64 newRecordsTotal;
        int64 updatedRecords;
        int64 newRecords;

        // clear out any validation errors from previous runs.
        log.skipDataMethods(true);
        delete_from log
            where log.DefinitionGroupName == _dmfDefinitionGroupExecution.DefinitionGroup
               && log.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId;

        ttsbegin;

        update_recordset staging
            setting LegalEntityId = curExt()
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.LegalEntityId == '';

        while select staging
            group by LegalEntityId
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
        {
            changecompany(staging.LegalEntityId)
            {
                BudgetRegisterEntryStaging stagingForDimensionResolver;

                // check accounts and account structure for errors.
                DimensionDataEntitySFKCacheTmp dimCacheTmpLedgerAccount = BudgetAccountDimensionSetBasedResolver::Resolve(
                            _dmfDefinitionGroupExecution,
                            stagingForDimensionResolver,
                            fieldStr(BudgetRegisterEntryStaging, DimensionDisplayValue),
                            tableStr(BudgetRegisterEntryStaging),
                            "@Budget:EntityTitle_BudgerRegisterEntryEntityTitle");

                // upsert header records
                BudgetRegisterEntryEntity::upsertHeader(_dmfDefinitionGroupExecution);

                // validate business rules
                BudgetRegisterEntryEntity::performSetBasedValidation(_dmfDefinitionGroupExecution, dimCacheTmpLedgerAccount);

                // upsert line records
                [newRecords, updatedRecords] = BudgetRegisterEntryEntity::upsertLine(_dmfDefinitionGroupExecution, dimCacheTmpLedgerAccount);

                updatedRecordsTotal += updatedRecords;
                newRecordsTotal += newRecords;
            }
        }

        // Update transferred records to success status.
        staging.skipDataMethods(true);
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Completed
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && staging.TransferStatus == DMFTransferStatus::NotStarted;

        ttscommit;

        return [newRecordsTotal, updatedRecordsTotal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBudgetModelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of budget model IDs.
    /// </summary>
    /// <param name="_entityFields">
    /// The <c>Array</c> of entity fields values on the instance performing the lookup.
    /// </param>
    /// <returns>
    /// The serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of budget model IDs.
    /// </returns>
    [SysODataActionAttribute("BudgetRegisterEntryEntityBudgetModelIdLookup", false),
     SysODataCollectionAttribute("_fields", Types::String),
     SysODataFieldLookupAttribute("BudgetModelId")]
    public static str lookupBudgetModelId(Array _fields)
    {
        LegalEntityDataAreaId legalEntityId = BudgetEntityHelper::getLegalEntityIdFromOfficeAppCustomLookupFields(
            tableStr(BudgetRegisterEntryEntity),
            fieldStr(BudgetRegisterEntryEntity, LegalEntityId),
            _fields);

        List lookupList = BudgetRegisterEntryEntityHelper::getBudgetModelIDs(legalEntityId);

        return BudgetEntityHelper::getSerializedOfficeAppCustomLookupListResult(lookupList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBudgetCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of budget codes.
    /// </summary>
    /// <param name="_entityFields">
    /// The <c>Array</c> of entity fields values on the instance performing the lookup.
    /// </param>
    /// <returns>
    /// The serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of budget codes.
    /// </returns>
    [SysODataActionAttribute("BudgetRegisterEntryEntityBudgetCodeLookup", false),
     SysODataCollectionAttribute("_fields", Types::String),
     SysODataFieldLookupAttribute("BudgetCode")]
    public static str lookupBudgetCode(Array _fields)
    {
        LegalEntityDataAreaId legalEntityId = BudgetEntityHelper::getLegalEntityIdFromOfficeAppCustomLookupFields(
            tableStr(BudgetRegisterEntryEntity),
            fieldStr(BudgetRegisterEntryEntity, LegalEntityId),
            _fields);

        List lookupList = BudgetRegisterEntryEntityHelper::getBudgetCodes(legalEntityId);

        return BudgetEntityHelper::getSerializedOfficeAppCustomLookupListResult(lookupList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of reason codes.
    /// </summary>
    /// <param name="_entityFields">
    /// The <c>Array</c> of entity fields values on the instance performing the lookup.
    /// </param>
    /// <returns>
    /// The serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of reason codes.
    /// </returns>
    [SysODataActionAttribute("BudgetRegisterEntryEntityReasonCodeLookup", false),
     SysODataCollectionAttribute("_fields", Types::String),
     SysODataFieldLookupAttribute("ReasonCode")]
    public static str lookupReasonCode(Array _fields)
    {
        LegalEntityDataAreaId legalEntityId = BudgetEntityHelper::getLegalEntityIdFromOfficeAppCustomLookupFields(
            tableStr(BudgetRegisterEntryEntity),
            fieldStr(BudgetRegisterEntryEntity, LegalEntityId),
            _fields);

        List lookupList = BudgetRegisterEntryEntityHelper::getReasonCodes(legalEntityId);

        return BudgetEntityHelper::getSerializedOfficeAppCustomLookupListResult(lookupList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupDimensionAccountStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of account structure IDs.
    /// </summary>
    /// <param name="_entityFields">
    /// The <c>Array</c> of entity fields values on the instance performing the lookup.
    /// </param>
    /// <returns>
    /// The serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of account structure IDs.
    /// </returns>
    [SysODataActionAttribute("BudgetRegisterEntryEntityDimensionAccountStructureLookup", false),
     SysODataCollectionAttribute("_fields", Types::String),
     SysODataFieldLookupAttribute("DimensionAccountStructure")]
    public static str lookupDimensionAccountStructure(Array _fields)
    {
        LegalEntityDataAreaId legalEntityId = BudgetEntityHelper::getLegalEntityIdFromOfficeAppCustomLookupFields(
            tableStr(BudgetRegisterEntryEntity),
            fieldStr(BudgetRegisterEntryEntity, LegalEntityId),
            _fields);

        List lookupList = BudgetRegisterEntryEntityHelper::getDimensionAccountStructures(legalEntityId);

        return BudgetEntityHelper::getSerializedOfficeAppCustomLookupListResult(lookupList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupEntryNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of entry numbers.
    /// </summary>
    /// <param name="_entityFields">
    /// The <c>Array</c> of entity fields values on the instance performing the lookup.
    /// </param>
    /// <returns>
    /// The serialized string of the <c>OfficeAppCustomLookupListResult</c> object for the list of entry numbers.
    /// </returns>
    [SysODataActionAttribute("BudgetRegisterEntryEntityEntryNumberLookup", false),
     SysODataCollectionAttribute("_fields", Types::String),
     SysODataFieldLookupAttribute("EntryNumber")]
    public static str lookupEntryNumber(Array _fields)
    {
        LegalEntityDataAreaId legalEntityId = BudgetEntityHelper::getLegalEntityIdFromOfficeAppCustomLookupFields(
            tableStr(BudgetRegisterEntryEntity),
            fieldStr(BudgetRegisterEntryEntity, LegalEntityId),
            _fields);

        List lookupList = BudgetRegisterEntryEntityHelper::getEntryNumbers(legalEntityId);

        return BudgetEntityHelper::getSerializedOfficeAppCustomLookupListResult(lookupList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>persistEntity</Name>
				<Source><![CDATA[
    public void persistEntity(DataEntityRuntimeContext _entityCtx)
    {
        if (!this.LegalEntityId)
        {
            this.LegalEntityId = curExt();
        }

        changecompany(this.LegalEntityId)
        {
            super(_entityCtx);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasicBudget</ConfigurationKey>
	<Label>@Budget:EntityTitle_BudgerRegisterEntryEntityTitle</Label>
	<Tags>Journal</Tags>
	<DataManagementEnabled>Yes</DataManagementEnabled>
	<DataManagementStagingTable>BudgetRegisterEntryStaging</DataManagementStagingTable>
	<IsPublic>Yes</IsPublic>
	<Modules>Budgeting</Modules>
	<PrimaryCompanyContext>LegalEntityId</PrimaryCompanyContext>
	<PrimaryKey>EntityKey</PrimaryKey>
	<PublicCollectionName>BudgetRegisterEntries</PublicCollectionName>
	<PublicEntityName>BudgetRegisterEntry</PublicEntityName>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldReal">
			<Name>AccountingCurrencyAmount</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<Label>@Budget:EntityField_AccountingCurrencyAmount</Label>
			<ComputedFieldMethod>getAccountingCurrencyAmountSQL</ComputedFieldMethod>
			<ExtendedDataType>AmountMST</ExtendedDataType>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>AmountType</Name>
			<DataField>BudgetType</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BudgetCode</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Mandatory>No</Mandatory>
			<DataField>Name</DataField>
			<DataSource>BudgetTransactionCode</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BudgetModelId</Name>
			<DataField>BudgetModelId</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Status</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<DataField>TransactionStatus</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BudgetTransactionCode</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>BudgetTransactionCode</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BudgetTransactionHeaderRecId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>BudgetTransactionHeader</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BudgetType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<DataField>BudgetTransactionType</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Comment</Name>
			<DataField>Comment</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CurrencyCode</Name>
			<DataField>TransactionCurrency</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Date</Name>
			<Mandatory>No</Mandatory>
			<DataField>Date</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Dimension</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>LedgerDimension</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
			<DimensionLegalEntityContextField>LegalEntityId</DimensionLegalEntityContextField>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DimensionAccountStructure</Name>
			<Label>@Budget:EntityField_DimensionAccountStructure</Label>
			<DataField>AccountStructure</DataField>
			<DataSource>DimensionValuesDAVC</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DimensionDisplayValue</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Label>@Budget:EntityField_DimensionValues</Label>
			<DataField>DisplayValue</DataField>
			<DataSource>DimensionValuesDAVC</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldString">
			<Name>EntryNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Mandatory>No</Mandatory>
			<ComputedFieldMethod>getEntryNumberSql</ComputedFieldMethod>
			<ExtendedDataType>BudgetTransactionId</ExtendedDataType>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>IncludeInCashFlowForecast</Name>
			<DataField>IncludeInCashFlowForecast</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InUseBy</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>InUseBy</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PrimaryLedgerId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>PrimaryLedger</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LegalEntityId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Mandatory>No</Mandatory>
			<DataField>DataArea</DataField>
			<DataSource>CompanyInfo</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LineNumber</Name>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Mandatory>No</Mandatory>
			<DataField>LineNumber</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OneTimeRevision</Name>
			<DataField>IsOneTimeAmendment</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Price</Name>
			<DataField>Price</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Quantity</Name>
			<DataField>Quantity</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldString">
			<Name>ReasonCode</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Label>@Budget:EntityField_ReasonCode</Label>
			<ComputedFieldMethod>getReasonCodeSql</ComputedFieldMethod>
			<ExtendedDataType>ReasonCode</ExtendedDataType>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldString">
			<Name>ReasonComment</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Label>@Budget:EntityField_ReasonComment</Label>
			<ComputedFieldMethod>getReasonCommentSql</ComputedFieldMethod>
			<ExtendedDataType>ReasonComment</ExtendedDataType>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ReasonTableRef</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>ReasonTableRef</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldReal">
			<Name>TransactionCurrencyAmount</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Label>@SYS152258</Label>
			<ComputedFieldMethod>getTransactionCurrencyAmountSQL</ComputedFieldMethod>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LineWorkflowStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<Label>@Budget:EntityField_LineWorkFlowStatus</Label>
			<DataField>WorkflowStatus</DataField>
			<DataSource>BudgetTransactionLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DocumentWorkflowStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<Label>@Budget:EntityField_DocumentWorkflowStatus</Label>
			<DataField>WorkflowStatus</DataField>
			<DataSource>BudgetTransactionHeader</DataSource>
		</AxDataEntityViewField>
	</Fields>
	<Keys>
		<AxDataEntityViewKey>
			<Name>EntityKey</Name>
			<Fields>
				<AxDataEntityViewKeyField>
					<DataField>EntryNumber</DataField>
				</AxDataEntityViewKeyField>
				<AxDataEntityViewKeyField>
					<DataField>LegalEntityId</DataField>
				</AxDataEntityViewKeyField>
				<AxDataEntityViewKeyField>
					<DataField>LineNumber</DataField>
				</AxDataEntityViewKeyField>
			</Fields>
		</AxDataEntityViewKey>
	</Keys>
	<Mappings />
	<Ranges />
	<Relations>
		<AxDataEntityViewRelation xmlns=""
			i:type="AxDataEntityViewRelationForeignKey">
			<Name>DimensionValuesCombination</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedDataEntity>DimensionCombinationEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>DimensionValues</Name>
					<Field>Dimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation>
			<Name>CurrencyEntity</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedDataEntity>CurrencyEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>RelationConstraintField1</Name>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation>
			<Name>LedgerEntity</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedDataEntity>LedgerEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>RelationConstraintField1</Name>
					<Field>PrimaryLedgerId</Field>
					<RelatedField>RecId</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation>
			<Name>DimensionHierarchy</Name>
			<RelatedDataEntity>LedgerAccountStructureEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ExactlyOne</RelatedDataEntityCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>RelationConstraintField1</Name>
					<Field>DimensionAccountStructure</Field>
					<RelatedField>AccountStructureName</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation xmlns=""
			i:type="AxDataEntityViewRelationForeignKey">
			<Name>BudgetCodeEntity</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedDataEntity>BudgetCodeEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<RelatedDataEntityRole>BudgetCodes</RelatedDataEntityRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BudgetRegisterEntryBudgetCode</Role>
			<Validate>No</Validate>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>BudgetCodeEntity_BudgetCode</Name>
					<Field>BudgetCode</Field>
					<RelatedField>BudgetCode</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
			<Key>EntityKey</Key>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation xmlns=""
			i:type="AxDataEntityViewRelationForeignKey">
			<Name>BudgetModelEntity</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedDataEntity>BudgetModelEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<RelatedDataEntityRole>BudgetModels</RelatedDataEntityRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BudgetRegisterEntryBudgetModel</Role>
			<Validate>No</Validate>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>BudgetModelEntity_BudgetModel</Name>
					<Field>BudgetModelId</Field>
					<RelatedField>BudgetModel</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
			<Key>EntityKey</Key>
		</AxDataEntityViewRelation>
		<AxDataEntityViewRelation xmlns=""
			i:type="AxDataEntityViewRelationForeignKey">
			<Name>BudgetRegisterEntryHeaderEntity</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedDataEntity>BudgetRegisterEntryHeaderEntity</RelatedDataEntity>
			<RelatedDataEntityCardinality>ZeroOne</RelatedDataEntityCardinality>
			<RelatedDataEntityRole>BudgetRegisterEntryHeaders</RelatedDataEntityRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BudgetRegisterEntryBudgetRegisterEntryHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>BudgetRegisterEntryHeaderEntity_LegalEntityId</Name>
					<Field>LegalEntityId</Field>
					<RelatedField>LegalEntityId</RelatedField>
				</AxDataEntityViewRelationConstraint>
				<AxDataEntityViewRelationConstraint xmlns=""
					i:type="AxDataEntityViewRelationConstraintField">
					<Name>BudgetRegisterEntryHeaderEntity_EntryNumber</Name>
					<Field>EntryNumber</Field>
					<RelatedField>EntryNumber</RelatedField>
				</AxDataEntityViewRelationConstraint>
			</Constraints>
			<Key>EntityKey</Key>
		</AxDataEntityViewRelation>
	</Relations>
	<StateMachines />
	<ViewMetadata>
		<Name>Metadata</Name>
		<SourceCode>
			<Methods>
				<Method>
					<Name>classDeclaration</Name>
					<Source><![CDATA[
[Query]
public class Metadata extends QueryRun
{
}
]]></Source>
				</Method>
			</Methods>
		</SourceCode>
		<DataSources>
			<AxQuerySimpleRootDataSource>
				<Name>BudgetTransactionLine</Name>
				<DynamicFields>Yes</DynamicFields>
				<Table>BudgetTransactionLine</Table>
				<DataSources>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>BudgetTransactionHeader</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>BudgetTransactionHeader</Table>
						<DataSources>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>Ledger</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>Ledger</Table>
								<DataSources>
									<AxQuerySimpleEmbeddedDataSource>
										<Name>CompanyInfo</Name>
										<DynamicFields>Yes</DynamicFields>
										<IsReadOnly>Yes</IsReadOnly>
										<Table>CompanyInfo</Table>
										<DataSources />
										<DerivedDataSources />
										<Fields />
										<Ranges />
										<UseRelations>Yes</UseRelations>
										<Relations>
											<AxQuerySimpleDataSourceRelation>
												<Name>CompanyInfo</Name>
												<JoinRelationName>CompanyInfo</JoinRelationName>
											</AxQuerySimpleDataSourceRelation>
										</Relations>
									</AxQuerySimpleEmbeddedDataSource>
								</DataSources>
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<UseRelations>Yes</UseRelations>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>Ledger</Name>
										<JoinRelationName>Ledger</JoinRelationName>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>BudgetTransactionCode</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>BudgetTransactionCode</Table>
								<DataSources />
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<JoinMode>OuterJoin</JoinMode>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>QueryDataSourceRelation1</Name>
										<Field>BudgetTransactionCode</Field>
										<JoinDataSource>BudgetTransactionHeader</JoinDataSource>
										<RelatedField>RecId</RelatedField>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
						</DataSources>
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<UseRelations>Yes</UseRelations>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>BudgetTransactionHeader</Name>
								<JoinRelationName>BudgetTransactionHeader</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>DimensionValuesDAVC</Name>
						<AllowAdd>No</AllowAdd>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>DimensionCombinationEntity</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>DimensionValuesDAVC</Name>
								<Field>LedgerDimension</Field>
								<JoinDataSource>BudgetTransactionLine</JoinDataSource>
								<RelatedField>RecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
				</DataSources>
				<DerivedDataSources />
				<Fields />
				<Ranges />
				<GroupBy />
				<Having />
				<OrderBy />
			</AxQuerySimpleRootDataSource>
		</DataSources>
	</ViewMetadata>
</AxDataEntityView>