<?xml version="1.0" encoding="utf-8"?>
<AxDataEntityView xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FreeTextInvoiceEntity</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class FreeTextInvoiceEntity extends common
{
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>copyCustomStagingToTarget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a custom copy from the staging table to the target environment.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <returns>A container of counts of [new records, updated records].</returns>
    public static container copyCustomStagingToTarget(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        DimensionDataEntitySFKCacheTmp dimCacheTmpLedgerAccount = LedgerDimensionDefaultAccountSetBasedResolver::Resolve(_dmfDefinitionGroupExecution, staging);
        DimensionDataEntitySFKCacheTmp dimCacheTmpDefaultDimension = DimensionDefaultSetBasedResolver::Resolve(_dmfDefinitionGroupExecution, staging);

        DimensionDataEntitySFKCacheTmp dimCacheTmpHeaderDefaultDimension = DimensionDynamicSetBasedResolver::resolve(
            _dmfDefinitionGroupExecution,
            tableNum(FreeTextInvoiceStaging),
            fieldStr(FreeTextInvoiceStaging, HeaderDefaultDimensionDisplayValue),
            fieldNum(FreeTextInvoiceStaging, HeaderDefaultDimensionDisplayValue),
            fieldNum(FreeTextInvoiceStaging, DefinitionGroup),
            fieldNum(FreeTextInvoiceStaging, ExecutionId),
            fieldNum(FreeTextInvoiceStaging, TransferStatus));
    
        FreeTextInvoiceEntity::unresolvedLedgerAccountsToErrorState(_dmfDefinitionGroupExecution, dimCacheTmpLedgerAccount);
        FreeTextInvoiceEntity::unresolvedDefaultDimensionsToErrorState(_dmfDefinitionGroupExecution, dimCacheTmpDefaultDimension);        
        FreeTextInvoiceEntity::unresolvedHeaderDefaultDimensionsToErrorState(_dmfDefinitionGroupExecution, dimCacheTmpHeaderDefaultDimension);

        FreeTextInvoiceEntity::validateCustomerAccount(_dmfDefinitionGroupExecution);
        FreeTextInvoiceEntity::validateFTIImportData(_dmfDefinitionGroupExecution);

        // Now that all invalid rows are in an error state, any remaining NotStarted
        // rows should successfully transfer to the target tables.

        ttsbegin;

        FreeTextInvoiceSourceDocumentHeaderStaging sourceDocumentFTIMap = FreeTextInvoiceEntity::insertSourceDocumentHeaders(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::insertSourceDocumentTotalsLine(sourceDocumentFTIMap);

        FreeTextInvoiceEntity::insertFreeTextInvoiceHeaderV2(_dmfDefinitionGroupExecution, sourceDocumentFTIMap, dimCacheTmpHeaderDefaultDimension);

        FreeTextInvoiceEntity::insertFreeTextInvoiceLines(_dmfDefinitionGroupExecution, sourceDocumentFTIMap, dimCacheTmpLedgerAccount, dimCacheTmpDefaultDimension);

        FreeTextInvoiceEntity::updateSourceDocumentLines(sourceDocumentFTIMap);

        FreeTextInvoiceEntity::updateTransferredRecordsToSuccessStatus(_dmfDefinitionGroupExecution);

        ttscommit;

        container completedRecords = FreeTextInvoiceEntity::getCompletedRecordsFromStaging(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::postTargetProcessSetBased(_dmfDefinitionGroupExecution);

        return completedRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unresolvedLedgerAccountsToErrorState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Places any <c>FreeTextInvoiceStaging</c> rows that have unresolved ledger accounts in an error state.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_dimCacheTmpLedgerAccount">The <c>DimensionDataEntitySFKCacheTmp</c> buffer for ledger accounts.</param>
    protected static void unresolvedLedgerAccountsToErrorState(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DimensionDataEntitySFKCacheTmp _dimCacheTmpLedgerAccount)
    {
        FreeTextInvoiceStaging staging;

        const DimensionHierarchyType hierarchyTypeLedgerAccount = DimensionHierarchyType::DataEntityLedgerDimensionFormat;
        ExtendedDataTypeName dataTypeLedgerAccount = extendedTypeStr(LedgerDimensionDefaultAccount);
        
        // Put any rows that have unresolved accounts in an error state first.
        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            exists join _dimCacheTmpLedgerAccount
                where _dimCacheTmpLedgerAccount.IntegrationString == staging.LedgerDimensionDisplayValue
                   && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                   && _dimCacheTmpLedgerAccount.HierarchyType == hierarchyTypeLedgerAccount
                   && _dimCacheTmpLedgerAccount.ExtendedDataType == dataTypeLedgerAccount
                   && _dimCacheTmpLedgerAccount.Found == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unresolvedDefaultDimensionsToErrorState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Places any <c>FreeTextInvoiceStaging</c> rows that have unresolved default dimensions in an error state.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_dimCacheTmpLedgerAccount">The <c>DimensionDataEntitySFKCacheTmp</c> buffer for default dimensions.</param>
    protected static void unresolvedDefaultDimensionsToErrorState(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DimensionDataEntitySFKCacheTmp _dimCacheTmpDefaultDimension)
    {
        FreeTextInvoiceStaging staging;
        const DimensionHierarchyType hierarchyTypeDimensionDefault = DimensionHierarchyType::DataEntityDefaultDimensionFormat;
        ExtendedDataTypeName dataTypeDimensionDefault = extendedTypeStr(DimensionDefault);

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            exists join _dimCacheTmpDefaultDimension
                where _dimCacheTmpDefaultDimension.IntegrationString == staging.DefaultDimensionDisplayValue
                   && _dimCacheTmpDefaultDimension.EnumValue == enum2int(LedgerJournalACType::Ledger)
                   && _dimCacheTmpDefaultDimension.HierarchyType == hierarchyTypeDimensionDefault
                   && _dimCacheTmpDefaultDimension.ExtendedDataType == dataTypeDimensionDefault
                   && _dimCacheTmpDefaultDimension.Found == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unresolvedHeaderDefaultDimensionsToErrorState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Places any <c>FreeTextInvoiceStaging</c> rows that have unresolved default dimensions in an error state.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_dimCacheTmpLedgerAccount">The <c>DimensionDataEntitySFKCacheTmp</c> buffer for default dimensions.</param>
    private static void unresolvedHeaderDefaultDimensionsToErrorState(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, DimensionDataEntitySFKCacheTmp _dimCacheTmpDefaultDimension)
    {
        FreeTextInvoiceStaging staging;
        const DimensionHierarchyType hierarchyTypeDimensionDefault = DimensionHierarchyType::DataEntityDefaultDimensionFormat;
        ExtendedDataTypeName dataTypeDimensionDefault = extendedTypeStr(DimensionDefault);

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            exists join _dimCacheTmpDefaultDimension
                where _dimCacheTmpDefaultDimension.IntegrationString == staging.HeaderDefaultDimensionDisplayValue
                   && _dimCacheTmpDefaultDimension.EnumValue == enum2int(LedgerJournalACType::Ledger)
                   && _dimCacheTmpDefaultDimension.HierarchyType == hierarchyTypeDimensionDefault
                   && _dimCacheTmpDefaultDimension.ExtendedDataType == dataTypeDimensionDefault
                   && _dimCacheTmpDefaultDimension.Found == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferredRecordsToSuccessStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update transferred records to success status.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateTransferredRecordsToSuccessStatus(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;

        update_recordset staging
            setting TransferStatus = DMFTransferStatus::Completed
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
               && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
               && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletedRecordsFromStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container that holds the number of records that were completed for the given <c>DMFDefinitionGroupExecution</c>
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution"The definition group.></param>
    /// <returns>A container indicating the number of records that were completed during import.</returns>
    protected static container getCompletedRecordsFromStaging(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;

        select count(RecId) from staging
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::Completed;

        return [staging.RecId, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inserted source document lines with setting Exchange rate date, state container and cleans up parent source document line field.
    /// </summary>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and and staging table lines.</param>
    protected static void updateSourceDocumentLines(FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        // Since an insert_recordset call to the FreeTextInvoiceEntity will automatically degrade
        // to row-by-row operations, the insert to the header and line tables must be done
        // individually with data methods and database logging skipped.

        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(SourceDocumentLine, true);
        
        // state container stores source document line state, i.e.
        // 1st container - data about monetary amounts (currency, accounting date, amounts)
        // 2st container - data about main accounts for various participating amounts (main account in line, taxes, fixed assets, etc.)
        // 3rd container - data about line default dimensions
        // However we don't care about exact contents at this moment, because we need to provide valid starting state after insertion as close to the user input as possible,
        // so that either posting document in Ax or distributing it or calculating taxes from Ax would trigger StateContainer recalculation correctly.
        var stateContainer = [conNull(), conNull(), conNull()];

        // StateContainer assignment in insert-recordset (at the moment of sourceDocumentLine inserting) is not supported, SQL throws an exception.
        // Both "header" and "line" sourcedocumentlines have to have ExchangeRateDate, but the queries can be restructured so that
        // at the moment of source document line insertion we already have custinvoicetable and invoicedate, so it doesn't have to have to be in update.
        update_recordset sourceDocumentLine
            setting
                ExchangeRateDate = custInvoiceTable.InvoiceDate,
                StateContainer = stateContainer,
                ParentSourceDocumentLine = 0
            join custInvoiceTable
                where sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader
            exists join _sourceDocumentFTIMap
                where _sourceDocumentFTIMap.SourceDocumentHeader == sourceDocumentLine.SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentTotalsLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts source document "totals" line for each header.
    /// </summary>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and and staging table lines.</param>
    protected static void insertSourceDocumentTotalsLine(FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);
        
        CustInvoiceTable custInvoiceTable;
        var headerTableId = custInvoiceTable.TableId;
        var lineDraftAccountingStatus = SourceDocumentLineAccountingStatus::Draft;
        var lineTotalsTypeEnumName = custInvoiceTable.parmSourceDocLineTypeEnumName();
        var lineTotalsTypeEnumValue = custInvoiceTable.parmSourceDocLineTypeEnumValue();

        // Every source document with FTI with single line has at least 2 source document lines:
        // below query inserts "totals" sourcedocumentline which is a link to header amounts (charges and rounding).
        // That is why SourceRelationType equals to headerTableId and data is grouped by SourceDocumentHeader.
        // All the auxiliary lines (i.e. taxes) will be calculated and created in posting or distribution process.
        insert_recordset sourceDocumentLine
            (AccountingStatus, SourceRelationType, TypeEnumName, TypeEnumValue, SourceDocumentHeader)
            select
                lineDraftAccountingStatus, headerTableId, lineTotalsTypeEnumName, lineTotalsTypeEnumValue, SourceDocumentHeader
            from _sourceDocumentFTIMap
                group by SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts source document headers.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <returns>Temporary table with a mapping between Free text numbers, source document headers and and staging table lines.</returns>
    private static FreeTextInvoiceSourceDocumentHeaderStaging insertSourceDocumentHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;

        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        var headerInProcessAccountingStatus = SourceDocumentAccountingStatus::InProcess;
        var headerTableId = custInvoiceTable.TableId;
        var headerTypeEnumName = custInvoiceTable.parmSourceDocHeaderTypeEnumName();
        var headerTypeEnumValue = custInvoiceTable.parmSourceDocHeaderTypeEnumValue();

        SourceDocumentHeader sourceDocumentHeader;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentHeader, true, true);

        // Before we insert free text invoice headers we need to have a actual set of source documents recid because SourceDocumentHeader is a unique index in CustInvoiceTable.
        // At the same time in current datamodel there is no way to map source documents to invoices, only backwards, invoices to source documents,
        // that is why together with inserting Source documents we keep invoice number in TypeEnumName field.
        insert_recordset sourceDocumentHeader
            (AccountingStatus, SourceRelationType, TypeEnumName, TypeEnumValue)
            select
                headerInProcessAccountingStatus, headerTableId, FreeTextNumber, headerTypeEnumValue
            from staging
            group by FreeTextNumber
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);

        // Writing a mapping table to source document headers and invoices
        FreeTextInvoiceSourceDocumentHeaderStaging sourceDocumentFTIMap;

        // sourceDocumentFTIMap.SourceDocumentLine stores link to each line in staging table which is the same as each invoice line
        insert_recordset sourceDocumentFTIMap (SourceDocumentHeader, FreeTextNumber, SourceDocumentLine)
            select RecId from sourceDocumentHeader
                where sourceDocumentHeader.AccountingStatus == headerInProcessAccountingStatus
                    && sourceDocumentHeader.SourceRelationType == headerTableId
                    && sourceDocumentHeader.TypeEnumValue == headerTypeEnumValue
                join FreeTextNumber, RecId from staging
                    where sourceDocumentHeader.TypeEnumName == staging.FreeTextNumber
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                notexists join custInvoiceTable
                    where sourceDocumentHeader.RecId == custInvoiceTable.SourceDocumentHeader;

        // Since mapping is now in FreeTextInvoiceSourceDocumentHeaderStaging tempdb table, we can fix SourceDocumentHeader table now to contain proper TypeEnumName for FTI header.
        update_recordset sourceDocumentHeader
            setting
                TypeEnumName = headerTypeEnumName
            exists join sourceDocumentFTIMap
                where sourceDocumentHeader.RecId == sourceDocumentFTIMap.SourceDocumentHeader;

        return sourceDocumentFTIMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertFreeTextInvoiceHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and updates FTI headers (custInvoiceTable) with necessary information.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    [SysObsoleteAttribute('Use insertFreeTextInvoiceHeaderV2 instead', true, 30\6\2020)]
    protected static void insertFreeTextInvoiceHeader(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertFreeTextInvoiceHeaderV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and updates FTI headers (custInvoiceTable) with necessary information.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    /// <param name = "_dimCacheTmpHeaderDefaultDimension">Temporary table containing found or unfound dimensions.</param>
    protected static void insertFreeTextInvoiceHeaderV2(
        DMFDefinitionGroupExecution _dmfDefinitionGroupExecution,
        FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpHeaderDefaultDimension)
    {
        FreeTextInvoiceEntity::insertHeader(_dmfDefinitionGroupExecution, _sourceDocumentFTIMap);

        FreeTextInvoiceEntity::updateHeaderForDirectDebitMandate(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateHeaderForBillingClassification(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateHeaderForEInvoice(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateHeaderForInvoiceAddress(_dmfDefinitionGroupExecution, _sourceDocumentFTIMap);

        FreeTextInvoiceEntity::updateHeaderForWorkflow(_dmfDefinitionGroupExecution, _sourceDocumentFTIMap);

        FreeTextInvoiceEntity::updateHeaderForDefaultDimension(_dmfDefinitionGroupExecution, _dimCacheTmpHeaderDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts FTI headers (custInvoiceTable) with necessary information.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    protected static void insertHeader(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        FreeTextInvoiceStaging staging;

        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);
        
        var headerTableId = custInvoiceTable.TableId;

        // Note that this query contains setting SourceDocumentHeader and SourceDocumentLine, where source document line is a "totals" line
        if (CustInvoiceEnforceQueryPlanOrderEntityFlight::instance().isEnabled())
        {
            insert_recordset custInvoiceTable (
                InvoiceId, SourceDocumentHeader, SourceDocumentLine)
            select forceSelectOrder
                FreeTextNumber
            from staging
            group by FreeTextNumber
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            join SourceDocumentHeader from _sourceDocumentFTIMap
                group by SourceDocumentHeader
                    where _sourceDocumentFTIMap.FreeTextNumber == staging.FreeTextNumber
            join RecId from sourceDocumentLine
                group by RecId
                    where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentFTIMap.SourceDocumentHeader
                        && sourceDocumentLine.SourceRelationType == headerTableId;
        }
        else
        {
            insert_recordset custInvoiceTable (
                InvoiceId, SourceDocumentHeader, SourceDocumentLine)
            select
                FreeTextNumber
            from staging
            group by FreeTextNumber
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            join SourceDocumentHeader from _sourceDocumentFTIMap
                group by SourceDocumentHeader
                    where _sourceDocumentFTIMap.FreeTextNumber == staging.FreeTextNumber
            join RecId from sourceDocumentLine
                group by RecId
                    where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentFTIMap.SourceDocumentHeader
                        && sourceDocumentLine.SourceRelationType == headerTableId;
        } 
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForDefaultDimension</Name>
				<Source><![CDATA[
    private static void updateHeaderForDefaultDimension(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpHeaderDefaultDimension)
    {
        FreeTextInvoiceStaging staging;

        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);

        DimensionHierarchyType hierarchyTypeDimensionDefault = DimensionHierarchyType::DataEntityDefaultDimensionFormat;
        ExtendedDataTypeName dataTypeDimensionDefault = extendedTypeStr(DimensionDefault);
        
        update_recordset custInvoiceTable
            setting DefaultDimension = _dimCacheTmpHeaderDefaultDimension.ResolvedReference
            join staging
                where custInvoiceTable.InvoiceId == staging.FreeTextNumber
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            join ResolvedReference from _dimCacheTmpHeaderDefaultDimension
                where _dimCacheTmpHeaderDefaultDimension.IntegrationString == staging.HeaderDefaultDimensionDisplayValue
                    && _dimCacheTmpHeaderDefaultDimension.EnumValue == enum2int(LedgerJournalACType::Ledger)
                    && _dimCacheTmpHeaderDefaultDimension.HierarchyType == hierarchyTypeDimensionDefault
                    && _dimCacheTmpHeaderDefaultDimension.ExtendedDataType == dataTypeDimensionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForDirectDebitMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustInvoiceTable</c> record for Direct debit mandate specific fields.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateHeaderForDirectDebitMandate(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustDirectDebitMandate custDirectDebitMandate;
        CustTable custTable;
        TransportationDocument transportationDocument;
        PaymTerm paymTerm;

        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        update_recordset custInvoiceTable
                setting
                    InvoiceDate = staging.InvoiceDate,
                    OrderAccount = staging.CustomerAccount,
                    InvoiceAccount = staging.InvoiceAccount,
                    PostingProfile = staging.PostingProfile,
                    CurrencyCode = staging.CurrencyCode,
                    Payment = staging.TermsOfPayment,
                    PaymMode = staging.MethodOfPayment,
                    DueDate = staging.DueDate,
                    InclTax = staging.InclTax,
                    CashDiscCode = staging.CashDiscountCode,
                    CashDiscDate = staging.CashDiscountDate,
                    CashDiscPercent = staging.DiscountPercentage,
                    DeliveryDate_ES = staging.DeliveryDate,
                    DocumentDate = staging.DocumentDate,
                    CustomerRef = staging.CustomerReference,
                    PurchOrderFormNum = staging.CustomerRequisition,
                    EInvoiceLineSpec = staging.EInvoiceIsLineSpecific,
                    GiroType = staging.GiroType,
                    PrintOverdueFineTxt_FR = staging.IsLumpSumRecoveryTextPrinted,
                    OrderAccountRefRecId = custTable.RecId,
                    DirectDebitMandate = custDirectDebitMandate.RecId,
                    TransportationDocument = transportationDocument.RecId,
                    PaymentSched = paymTerm.PaymSched
                join staging
                    where custInvoiceTable.InvoiceId == staging.FreeTextNumber
                        && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                join RecId from custTable
                    where custTable.AccountNum == staging.CustomerAccount
                outer join custDirectDebitMandate
                    where custDirectDebitMandate.MandateReference == staging.DirectDebitMandateId
                        && custDirectDebitMandate.CustAccount == staging.InvoiceAccount
                outer join transportationDocument
                    where transportationDocument.LineId == staging.TransportationDocumentLineId
                outer join PaymSched from paymTerm
                    where paymTerm.PaymTermId == staging.TermsOfPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustInvoiceTable</c> record for Billing classification specific fields.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateHeaderForBillingClassification(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        if (CustParameters::isBillingClassificationEnabled())
        {
            FreeTextInvoiceStaging staging;
            CustBillingClassification billingClassification;
            CustInvoiceTable custInvoiceTable;
            FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
            update_recordset custInvoiceTable
                setting CustBillingClassification = billingClassification.RecId
                join staging
                    where custInvoiceTable.InvoiceId == staging.FreeTextNumber
                        && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                outer join billingClassification
                    where billingClassification.BillingClassification == staging.BillingClassification;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForEInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustInvoiceTable</c> record for EInvoice specific fields.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateHeaderForEInvoice(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        // set the EInvoiceAccountCode for invoices where the code is not line specific
        update_recordset custInvoiceTable
            setting EInvoiceAccountCode = staging.EInvoiceAccountCode
            where custInvoiceTable.EInvoiceLineSpec == NoYes::No
            join staging
                where custInvoiceTable.InvoiceId == staging.FreeTextNumber
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                    && staging.EInvoiceAccountCode != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForInvoiceAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustInvoiceTable</c> record for invoice address specific fields.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    protected static void updateHeaderForInvoiceAddress(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        CustTable custTable;
        LogisticsPostalAddress logisticsPostalAddress;
        DirPartyLocation partyLocation;
        DirPartyTable dirPartyTable;
        DirPartyLocationRole partyLocationRole;
        LogisticsLocationRole locationRole;
        
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);
        
        utcdatetime dateToday = DateTimeUtil::getSystemDateTime();

        // try setting an active invoice address where possible, otherwise address will be filled in Customer invoice journal while posting
        update_recordset custInvoiceTable
            setting
                PostalAddress = logisticsPostalAddress.RecId,
                CustGroup = custTable.CustGroup,
                LanguageId = dirPartyTable.LanguageId,
                NumberSequenceGroup = custTable.numberSequenceGroup,
                Name = dirPartyTable.name
            join CustGroup, numberSequenceGroup from custTable
                where (custTable.InvoiceAddress == InvoiceOrderAccount::OrderAccount && CustTable.AccountNum == custInvoiceTable.OrderAccount) || 
                    (custTable.InvoiceAddress == InvoiceOrderAccount::InvoiceAccount && CustTable.AccountNum == custInvoiceTable.InvoiceAccount)
            join dirPartyTable
                where dirPartyTable.RecId == custTable.Party
            join partyLocation
                where partyLocation.Party == custTable.Party
            join partyLocationRole
                where partyLocationRole.PartyLocation == partyLocation.RecId
            join locationRole
                where locationRole.RecId == partyLocationRole.LocationRole &&
                        locationRole.Type == LogisticsLocationRoleType::Invoice
            join logisticsPostalAddress
                where logisticsPostalAddress.Location == partyLocation.Location &&
                    logisticsPostalAddress.ValidFrom <= dateToday &&
                    logisticsPostalAddress.ValidTo >= dateToday
            exists join _sourceDocumentFTIMap
                where custInvoiceTable.SourceDocumentHeader == _sourceDocumentFTIMap.SourceDocumentHeader;

        update_recordset custInvoiceTable
            setting
                PostalAddress = logisticsPostalAddress.RecId,
                CustGroup = custTable.CustGroup,
                LanguageId = dirPartyTable.LanguageId,
                NumberSequenceGroup = custTable.numberSequenceGroup,
                Name = dirPartyTable.name
                where custInvoiceTable.PostalAddress == 0
            join CustGroup, numberSequenceGroup from custTable
                where custInvoiceTable.InvoiceAccount == custTable.AccountNum
            join dirPartyTable
                where dirPartyTable.RecId == custTable.Party
            join partyLocation
                where custTable.Party == partyLocation.Party
                    && partyLocation.IsPrimary == true
                    && partyLocation.IsPostalAddress == true
            join logisticsPostalAddress
                where partyLocation.Location == logisticsPostalAddress.Location
                   && logisticsPostalAddress.ValidFrom <= dateToday
                   && logisticsPostalAddress.ValidTo >= dateToday
            exists join _sourceDocumentFTIMap
                where custInvoiceTable.SourceDocumentHeader == _sourceDocumentFTIMap.SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderForWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustInvoiceTable</c> record to ready unposted free text invoices for workflow submission.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    protected static void updateHeaderForWorkflow(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution, FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);

        if (WorkflowTable::findActiveWorkflowTemplate(workFlowTypeStr(CustFreeTextInvoiceTemplate), curExt()))
        {
            update_recordset custInvoiceTable
            setting workflowApprovalState = CustFreeInvoiceWFApprovalState::NotSubmitted,
                workflowApprovalStatus = CustFreeInvoiceWFApprovalStatus::Draft
                where custInvoiceTable.Posted == NoYes::No
            exists join staging
                where custInvoiceTable.InvoiceId == staging.FreeTextNumber
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertFreeTextInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and updates invoice lines and corresponding source document lines.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_sourceDocumentFTIMap">Temporary table with a mapping between Free text numbers, source document headers and staging table lines.</param>
    /// <param name = "_dimCacheTmpLedgerAccount"></param>
    /// <param name = "_dimCacheTmpDefaultDimension"></param>
    protected static void insertFreeTextInvoiceLines(
        DMFDefinitionGroupExecution _dmfDefinitionGroupExecution,
        FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpLedgerAccount,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpDefaultDimension)
    {
        FreeTextInvoiceEntity::insertSourceDocumentLines(_sourceDocumentFTIMap);
                
        FreeTextInvoiceEntity::insertLines(_dmfDefinitionGroupExecution, _dimCacheTmpLedgerAccount, _dimCacheTmpDefaultDimension);

        FreeTextInvoiceEntity::updateLinesForBillingClassification();

        FreeTextInvoiceEntity::updateLinesForEInvoice();

        FreeTextInvoiceEntity::updateLines_FR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentLines</Name>
				<Source><![CDATA[
    private static void insertSourceDocumentLines(FreeTextInvoiceSourceDocumentHeaderStaging _sourceDocumentFTIMap)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceLine custInvoiceLine;
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);

        var lineTypeEnumName = custInvoiceLine.parmSourceDocLineTypeEnumName();
        var lineTypeEnumValue = custInvoiceLine.parmSourceDocLineTypeEnumValue();
        var lineTableId = custInvoiceLine.TableId;
        var lineDraftAccountingStatus = SourceDocumentLineAccountingStatus::Draft;

        // An ordinary source document line for Free text invoice in a draft status.
        insert_recordset sourceDocumentLine
            (AccountingStatus, SourceRelationType, TypeEnumName, TypeEnumValue, SourceDocumentHeader, ParentSourceDocumentLine)
            select lineDraftAccountingStatus, lineTableId, lineTypeEnumName, lineTypeEnumValue, SourceDocumentHeader
                from _sourceDocumentFTIMap
            join RecId from staging
                where staging.RecId == _sourceDocumentFTIMap.SourceDocumentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts invoice lines (<c>CustInvoiceLine</c>) and corresponding <c>SourceDocumentLine</c> records.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <param name = "_dimCacheTmpLedgerAccount"></param>
    /// <param name = "_dimCacheTmpDefaultDimension"></param>
    protected static void insertLines(
        DMFDefinitionGroupExecution _dmfDefinitionGroupExecution,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpLedgerAccount,
        DimensionDataEntitySFKCacheTmp _dimCacheTmpDefaultDimension)
    {
        FreeTextInvoiceStaging staging;

        CustInvoiceLine custInvoiceLine;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true, true, true, true, true, true);
        
        CustInvoiceTable custInvoiceTable;
        SourceDocumentLine sourceDocumentLine;

        var lineTableId = custInvoiceLine.TableId;
                
        const DimensionHierarchyType hierarchyTypeLedgerAccount = DimensionHierarchyType::DataEntityLedgerDimensionFormat;
        ExtendedDataTypeName dataTypeLedgerAccount = extendedTypeStr(LedgerDimensionDefaultAccount);

        const DimensionHierarchyType hierarchyTypeDimensionDefault = DimensionHierarchyType::DataEntityDefaultDimensionFormat;
        ExtendedDataTypeName dataTypeDimensionDefault = extendedTypeStr(DimensionDefault);

        if (CustInvoiceEnforceQueryPlanOrderEntityFlight::instance().isEnabled())
        {
            insert_recordset custInvoiceLine (
                    LineNum, Description, Quantity, UnitPrice, AmountCur, TaxGroup, TaxItemGroup, OverrideSalesTax, PropertyNumber_MX, InvoiceTxt, ParentRecId,
                    SourceDocumentLine, LedgerDimension, DefaultDimension)
                select forceSelectOrder LineNumber, Description, Quantity, UnitPrice, AmountCur, SalesTaxGroup, SalesTaxItemGroup, OverrideSalesTax, PropertyNumber, InvoiceTxt from staging
                    where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                join RecId from custInvoiceTable
                    where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                join RecId from sourceDocumentLine
                    where sourceDocumentLine.SourceRelationType == lineTableId
                        && sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader
                        && sourceDocumentLine.ParentSourceDocumentLine == staging.RecId
                join ResolvedReference from _dimCacheTmpLedgerAccount
                    where _dimCacheTmpLedgerAccount.IntegrationString == staging.LedgerDimensionDisplayValue
                        && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                        && _dimCacheTmpLedgerAccount.HierarchyType == hierarchyTypeLedgerAccount
                        && _dimCacheTmpLedgerAccount.ExtendedDataType == dataTypeLedgerAccount
                join ResolvedReference from _dimCacheTmpDefaultDimension
                    where _dimCacheTmpDefaultDimension.IntegrationString == staging.DefaultDimensionDisplayValue
                        && _dimCacheTmpDefaultDimension.EnumValue == enum2int(LedgerJournalACType::Ledger)
                        && _dimCacheTmpDefaultDimension.HierarchyType == hierarchyTypeDimensionDefault
                        && _dimCacheTmpDefaultDimension.ExtendedDataType == dataTypeDimensionDefault;
        }
        else
        {
            insert_recordset custInvoiceLine (
                    SourceDocumentLine, LineNum, Description, Quantity, UnitPrice, AmountCur, TaxGroup, TaxItemGroup, OverrideSalesTax, PropertyNumber_MX, InvoiceTxt,
                    LedgerDimension, DefaultDimension, ParentRecId)
                select RecId from sourceDocumentLine
                    where sourceDocumentLine.SourceRelationType == lineTableId
               join LineNumber, Description, Quantity, UnitPrice, AmountCur, SalesTaxGroup, SalesTaxItemGroup, OverrideSalesTax, PropertyNumber, InvoiceTxt from staging
                    where staging.RecId == sourceDocumentLine.ParentSourceDocumentLine
                       && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                       && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                       && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                join ResolvedReference from _dimCacheTmpLedgerAccount
                    where _dimCacheTmpLedgerAccount.IntegrationString == staging.LedgerDimensionDisplayValue
                       && _dimCacheTmpLedgerAccount.EnumValue == enum2int(LedgerJournalACType::Ledger)
                       && _dimCacheTmpLedgerAccount.HierarchyType == hierarchyTypeLedgerAccount
                       && _dimCacheTmpLedgerAccount.ExtendedDataType == dataTypeLedgerAccount
                join ResolvedReference from _dimCacheTmpDefaultDimension
                    where _dimCacheTmpDefaultDimension.IntegrationString == staging.DefaultDimensionDisplayValue
                       && _dimCacheTmpDefaultDimension.EnumValue == enum2int(LedgerJournalACType::Ledger)
                       && _dimCacheTmpDefaultDimension.HierarchyType == hierarchyTypeDimensionDefault
                       && _dimCacheTmpDefaultDimension.ExtendedDataType == dataTypeDimensionDefault
                join RecId from custInvoiceTable
                    where sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader
                       && staging.FreeTextNumber == custInvoiceTable.InvoiceId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTableMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls skip methods on a table buffer.
    /// </summary>
    /// <param name = "_table">The table to call skip methods on.</param>
    /// <param name = "_methods">skip methods setting option</param>
    /// <param name = "_databaseLog">skip database log setting option</param>
    /// <param name = "_events">skip events setting option</param>
    /// <param name = "_numberSequenceCheck">skip number sequence check setting option</param>
    /// <param name = "_postLoad">skip post load setting option</param>
    /// <param name = "_ttscheck">skip tts check setting option</param>
    protected static void skipTableMethods(
        Common _table, 
        boolean _methods = false, 
        boolean _databaseLog = false, 
        boolean _events = false, 
        boolean _numberSequenceCheck = false, 
        boolean _postLoad = false, 
        boolean _ttscheck = false)
    {
        _table.skipDataMethods(_methods);
        _table.skipDatabaseLog(_databaseLog);
        _table.skipEvents(_events);
        _table.skipNumberSequenceCheck(_numberSequenceCheck);
        _table.skipPostLoad(_postLoad);
        _table.skipTTSCheck(_ttscheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLinesForBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>CustInvoiceLine</c> records for Billing classification specific fields.
    /// </summary>
    protected static void updateLinesForBillingClassification()
    {
        if (CustParameters::isBillingClassificationEnabled())
        {
            FreeTextInvoiceStaging staging;
            CustBillingCode billingCode;
            SourceDocumentLine sourceDocumentLine;
            CustInvoiceLine custInvoiceLine;
            FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

            update_recordset custInvoiceLine
                setting
                    BillingCode = billingCode.BillingCode,
                    Description = billingcode.Description,
                    CustBillingCode = billingCode.RecId
                join sourceDocumentLine
                    where sourceDocumentLine.recid == custInvoiceLine.SourceDocumentLine
                join staging
                    where staging.RecId == sourceDocumentLine.ParentSourceDocumentLine
                        && staging.LineNumber == custInvoiceLine.LineNum
                        && staging.BillingCode != ''
                join billingCode
                    where billingCode.billingCode == staging.BillingCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLinesForEInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>CustInvoiceLine</c> records for EInvoice specific fields.
    /// </summary>
    protected static void updateLinesForEInvoice()
    {
        FreeTextInvoiceStaging staging;
        SourceDocumentLine sourceDocumentLine;
        CustInvoiceLine custInvoiceLine;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

        // set the EInvoiceAccountCode for invoices where the code is line specific
        update_recordset custInvoiceLine
            setting
                EInvoiceAccountCode = staging.EInvoiceAccountCode
            join sourceDocumentLine
                where sourceDocumentLine.RecId == custInvoiceLine.SourceDocumentLine
            join EInvoiceAccountCode from staging
                where staging.RecId == sourceDocumentLine.ParentSourceDocumentLine
                    && staging.EInvoiceIsLineSpecific == NoYes::Yes
                    && staging.EInvoiceAccountCode != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLines_FR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>CustInvoiceLine</c> records for FR specific functionality.
    /// </summary>
    protected static void updateLines_FR()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceFR00015, funcName());

            FreeTextInvoiceStaging staging;
            NGPCodesTable_FR ngpCodesTable_FR;
            SourceDocumentLine sourceDocumentLine;
            CustInvoiceLine custInvoiceLine;
            FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

            update_recordset custInvoiceLine
                setting
                    NGPCodesTable_FR = ngpCodesTable_FR.RecId
                join sourceDocumentLine
                    where sourceDocumentLine.RecId == custInvoiceLine.SourceDocumentLine
                join staging
                    where staging.RecId == sourceDocumentLine.ParentSourceDocumentLine
                join ngpCodesTable_FR
                    where staging.NGPCode == ngpCodesTable_FR.NGPCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preTargetProcessSetBased</Name>
				<Source><![CDATA[
    /// <summary>
    /// 1) Sets the invalid records to Error state when Mandate id filled in in the file but payment method is not SEPA
    /// 2) If payment method is SEPA and Mandate is not filled in, fill it in from default mandate for customer
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    public static void preTargetProcessSetBased(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceEntity::updateStagingTableBasedOnMethodOfPayment(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateStagingTableForDirectDebitMandate(_dmfDefinitionGroupExecution);

        // Validate the billing classification and billing code as needed
        if (CustParameters::isBillingClassificationEnabled())
        {
            FreeTextInvoiceEntity::validateBillingClassificationAndBillingCode(_dmfDefinitionGroupExecution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStagingTableBasedOnMethodOfPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>FreeTextInvoiceStaging</c> table records based on settings from the method of payment.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateStagingTableBasedOnMethodOfPayment(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        CustPaymModeTable paymentMethod;
        FreeTextInvoiceStaging staging;

        update_recordset staging
            setting
                TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                && staging.DirectDebitMandateId != ''
            exists join paymentMethod
                    where staging.MethodOfPayment == paymentMethod.PaymMode
                        && paymentMethod.IsSEPA == false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStagingTableForDirectDebitMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>FreeTextInvoiceStaging</c> table records based on settings for Direct debit mandate.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateStagingTableForDirectDebitMandate(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        // defaults a direct debit mandate
        CustPaymModeTable paymentMethod;
        FreeTextInvoiceStaging staging;
        CustTable custTable;
        CustDirectDebitMandate custDirectDebitMandate;

        update_recordset staging
            setting
                DirectDebitMandateId = custDirectDebitMandate.MandateReference
            where staging.DirectDebitMandateId == ''
                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            join custTable
                where staging.InvoiceAccount == custTable.AccountNum
            join custDirectDebitMandate
                where custDirectDebitMandate.RecId == custTable.DefaultDirectDebitMandate
                    exists join paymentMethod
                        where staging.MethodOfPayment == paymentMethod.PaymMode
                            && paymentMethod.IsSEPA == true;

        update_recordset staging
            setting
                TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
                && staging.DirectDebitMandateId != ''
                exists join paymentMethod
                    where staging.MethodOfPayment == paymentMethod.PaymMode
                        && paymentMethod.IsSEPA == true
                    notexists join custDirectDebitMandate
                        where custDirectDebitMandate.MandateReference == staging.DirectDebitMandateId
                            && custDirectDebitMandate.CustAccount == staging.InvoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTargetProcessSetBased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate that there are no empty headers or orphan lines imported.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    public static void postTargetProcessSetBased(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        // Because at the moment after import is done taxes are not yet calculated and charges are not imported in set-based and distributions are not done yet,
        // there is no need to do cleanup for any source document lines which have Parent source document line != 0.

        ttsbegin;

        FreeTextInvoiceEntity::deleteInvoiceLinesWithoutSourceDocumentLines(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteSourceDocumentLinesWithoutTotalsLine(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteInvoiceLinesWithoutTotalSourceDocumentLines(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteSourceDocumentLinesForInvoiceLinesWithNoSourceDocumentHeaders(_dmfDefinitionGroupExecution);
        
        FreeTextInvoiceEntity::deleteSourceDocumentLinesForInvoiceHeadersWithoutSourceDocumentHeaders(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteInvoiceLinesWithHeadersWithoutSourceDocumentHeaders(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteInvoiceHeadersWithoutSourceDocumentHeaders(_dmfDefinitionGroupExecution);
        
        FreeTextInvoiceEntity::deleteSourceDocumentHeadersForInvoiceHeadersWithoutLines(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::deleteInvoiceHeadersWithoutLines(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateStagingRecordsWithoutInvoiceHeaders(_dmfDefinitionGroupExecution);

        FreeTextInvoiceEntity::updateInvoiceHeaderToRemoveInvoiceId(_dmfDefinitionGroupExecution);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvoiceLinesWithoutSourceDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustInvoiceLine</c> records that don't have <c>SourceDocumentLine</c> records.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteInvoiceLinesWithoutSourceDocumentLines(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

        // invoice lines without source document lines
        delete_from custInvoiceLine
            where custInvoiceLine.SourceDocumentLine == 0
                exists join custInvoiceTable
                    where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                        exists join staging
                            where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                                && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSourceDocumentLinesWithoutTotalsLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>SourceDocumentLine</c> records for invoice lines for headers which do not have "totals" sourcedocument line.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteSourceDocumentLinesWithoutTotalsLine(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);
        
        delete_from sourceDocumentLine
            exists join custInvoiceLine
                where sourceDocumentLine.RecId == custInvoiceLine.SourceDocumentLine
                    exists join custInvoiceTable
                        where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                            && custInvoiceTable.SourceDocumentLine == 0
                            exists join staging
                                where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                    && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvoiceLinesWithoutTotalSourceDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustInvoiceLine</c> records that don't have <c>SourceDocumentLine</c> records.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteInvoiceLinesWithoutTotalSourceDocumentLines(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

        // Invoice lines for headers which do not have "totals" sourcedocument line.
        delete_from custInvoiceLine
            exists join custInvoiceTable
                where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                    && custInvoiceTable.SourceDocumentLine == 0
                    exists join staging
                        where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                            && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSourceDocumentLinesForInvoiceLinesWithNoSourceDocumentHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>SourceDocumentLine</c> records for invoice lines for headers which do not have source document headers.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteSourceDocumentLinesForInvoiceLinesWithNoSourceDocumentHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);
        
        delete_from sourceDocumentLine
            exists join custInvoiceLine
                where sourceDocumentLine.RecId == custInvoiceLine.SourceDocumentLine
                    exists join custInvoiceTable
                        where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                            && custInvoiceTable.SourceDocumentHeader == 0
                            exists join staging
                                where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                                    && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvoiceLinesWithHeadersWithoutSourceDocumentHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustInvoiceLine</c> records for invoice headers without source document headers.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteInvoiceLinesWithHeadersWithoutSourceDocumentHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceLine, true);

        // Invoice lines for invoice headers without source document headers
        delete_from custInvoiceLine
            exists join custInvoiceTable
                where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                    && custInvoiceTable.SourceDocumentHeader == 0
                    exists join staging
                        where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                            && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSourceDocumentLinesForInvoiceHeadersWithoutSourceDocumentHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>SourceDocumentLine</c> records for invoice headers which do not have source document headers.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteSourceDocumentLinesForInvoiceHeadersWithoutSourceDocumentHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        SourceDocumentLine sourceDocumentLine;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentLine, true);
        
        // Source document "totals" lines for invoice headers without source document headers
        delete_from sourceDocumentLine
            exists join custInvoiceTable
                where custInvoiceTable.SourceDocumentLine == sourceDocumentLine.RecId
                    && custInvoiceTable.SourceDocumentHeader == 0
                    exists join staging
                        where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                            && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvoiceHeadersWithoutSourceDocumentHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustInvoiceTable</c> records without source document headers.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteInvoiceHeadersWithoutSourceDocumentHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);

        delete_from custInvoiceTable
            where custInvoiceTable.SourceDocumentHeader == 0
                exists join staging
                    where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                        && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                        && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                        && staging.TransferStatus == DMFTransferStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSourceDocumentHeadersForInvoiceHeadersWithoutLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>SourceDocumentHeader</c> records for invoice headers which do not have lines.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteSourceDocumentHeadersForInvoiceHeadersWithoutLines(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        SourceDocumentHeader sourceDocumentHeader;
        FreeTextInvoiceEntity::skipTableMethods(sourceDocumentHeader, true);

        delete_from sourceDocumentHeader
            exists join custInvoiceTable
                where custInvoiceTable.SourceDocumentHeader == sourceDocumentHeader.RecId
                    exists join staging
                        where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                            && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                            && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                            && staging.TransferStatus == DMFTransferStatus::Completed
                                notexists join custInvoiceLine
                                    where custInvoiceLine.ParentRecId == custInvoiceTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvoiceHeadersWithoutLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustInvoiceTable</c> records without invoice lines.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void deleteInvoiceHeadersWithoutLines(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceLine custInvoiceLine;
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);

        delete_from custInvoiceTable
            exists join staging
                where staging.FreeTextNumber == custInvoiceTable.InvoiceId
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::Completed
                    notexists join custInvoiceLine
                        where custInvoiceLine.ParentRecId == custInvoiceTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStagingRecordsWithoutInvoiceHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>FreeTextInvoiceStaging</c> records without invoice headers to an error state.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    protected static void updateStagingRecordsWithoutInvoiceHeaders(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceStaging staging;
        FreeTextInvoiceEntity::skipTableMethods(staging, true);

        update_recordset staging
            setting
                TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                && staging.TransferStatus == DMFTransferStatus::Completed
                notexists join custInvoiceTable
                    where custInvoiceTable.InvoiceId == staging.FreeTextNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceHeaderToRemoveInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>CustInvoiceTable</c> records by removing any InvoiceId values.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <remarks>
    /// Free text invoices are imported unposted. Users are expected to go and post them in a new system afterwards.
    /// Since InvoiceId for free text invoices is updated on posting, query below is erasing invoiceIds for invoices imported in current session.
    /// This provides user experience similar to as if invoice was created manually in the system.
    /// </remarks>
    protected static void updateInvoiceHeaderToRemoveInvoiceId(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        CustInvoiceTable custInvoiceTable;
        FreeTextInvoiceEntity::skipTableMethods(custInvoiceTable, true);

        update_recordset custInvoiceTable
            setting
                InvoiceId = ''
            exists join staging
                where staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && staging.TransferStatus == DMFTransferStatus::Completed
                    && staging.FreeTextNumber == custInvoiceTable.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateFreeTextInvoiceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates Free text number which is unique for all invoices being exported or imported in scope of each Partition and DataAreaId.
    /// </summary>
    /// <returns>
    /// If export of posted invoices is done then it returns just the invoice number itself.
    /// Otherwise sets it to be "Not posted 1", "Not posted 2" and etc.
    /// </returns>
    public static str generateFreeTextInvoiceNumber()
    {
        str sql = 'IIF(';

        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, InvoiceId));

        sql += '=\'\',';
        sql += 'CONCAT(\'';
        sql += "@SYS11670";
        sql += ' \',CONVERT(nvarchar(10), DENSE_RANK() OVER (PARTITION BY ';
        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, Partition));
        sql += ',';
        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, DataAreaId));
        sql += ',';
        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, InvoiceId));
        sql += ' ORDER BY ';
        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, RecId));
        sql += '),1)),';
        sql += SysComputedColumn::returnField(tablestr(FreeTextInvoiceEntity), dataEntityDataSourceStr(FreeTextInvoiceEntity, CustInvoiceTable), fieldstr(FreeTextInvoiceEntity, InvoiceId));
        sql += ')';

        return sql;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBillingClassificationAndBillingCode</Name>
				<Source><![CDATA[
    private static void validateBillingClassificationAndBillingCode(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        FreeTextInvoiceStagingTmp freeTextInvoiceStagingError, uniqueFreeTextInvoiceAndClassification, freeTextInvoiceWithClassificationCount;
        DMFExecutionId executionId = _dmfDefinitionGroupExecution.ExecutionId;
        DMFDefinitionGroupName executionGroup = _dmfDefinitionGroupExecution.DefinitionGroup;

        // 1) When the billing classification is missed.
        FreeTextInvoiceBillingValidationError errorLevel = FreeTextInvoiceBillingValidationError::NoBillingClassification;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, DefinitionGroup, ExecutionId, errorLevel
                from staging
                group by FreeTextNumber, DefinitionGroup, ExecutionId
                where staging.BillingClassification == ''
                    && staging.DefinitionGroup == executionGroup
                    && staging.ExecutionId == executionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);

        // 2) When there are more than one billing classification for one invoice
        errorLevel = FreeTextInvoiceBillingValidationError::NotSameBillingClassification;

        insert_recordset uniqueFreeTextInvoiceAndClassification (FreeTextNumber, BillingClassification)
            select FreeTextNumber, BillingClassification from staging
                group by FreeTextNumber, BillingClassification
                where staging.BillingClassification != ''
                    && staging.DefinitionGroup == executionGroup
                    && staging.ExecutionId == executionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);

        insert_recordset freeTextInvoiceWithClassificationCount(FreeTextNumber, BillingClassificationCount)
            select FreeTextNumber, count(RecId)
                from uniqueFreeTextInvoiceAndClassification
                group by FreeTextNumber;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, DefinitionGroup, ExecutionId, errorLevel
                from staging
                exists join freeTextInvoiceWithClassificationCount
                    where freeTextInvoiceWithClassificationCount.FreeTextNumber == staging.FreeTextNumber
                        && freeTextInvoiceWithClassificationCount.BillingClassificationCount > 1;

        // 3) When the billing classification does not exist.
        CustBillingClassification custBillingClassification;
        errorLevel = FreeTextInvoiceBillingValidationError::BillingclassificationNotExist;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, BillingClassification, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, BillingClassification, DefinitionGroup, ExecutionId, errorLevel
                from staging
                group by FreeTextNumber, BillingClassification, DefinitionGroup, ExecutionId
                where staging.BillingClassification != ''
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            Notexists join custBillingClassification
                where staging.BillingClassification == custBillingClassification.BillingClassification;

        // 4) When the billing code does not exist.
        CustBillingCode custBillingCode;
        errorLevel = FreeTextInvoiceBillingValidationError::BillingCodeNotExist;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, errorLevel
                from staging
                group by FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId
                where staging.BillingClassification != ''
                    && staging.BillingCode != ''
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            Notexists join custBillingCode
                where staging.BillingCode == custBillingCode.BillingCode;

        // 5) When the billing code does not belong to the billing classification.
        CustBillingClassificationCode bilingClassificationCode;
        errorLevel = FreeTextInvoiceBillingValidationError::BillingCodeNotInClassification;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, errorLevel
                from staging
                group by FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId
                where staging.BillingCode != ''
                    && staging.BillingClassification != ''
                    && staging.DefinitionGroup == _dmfDefinitionGroupExecution.DefinitionGroup
                    && staging.ExecutionId == _dmfDefinitionGroupExecution.ExecutionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            Notexists join bilingClassificationCode
            exists join custBillingClassification
            exists join custBillingCode
                where bilingClassificationCode.CustBillingClassification == custBillingClassification.RecId
                    && bilingClassificationCode.CustBillingCode == custBillingCode.RecId
                    && staging.BillingClassification == custBillingClassification.BillingClassification
                    && staging.BillingCode == custBillingCode.BillingCode;

        // 6) When the billing code is not valid for the invoice date.
        CustBillingCodeVersion custBillingCodeVersion;
        errorLevel = FreeTextInvoiceBillingValidationError::BillingCodeExpired;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, ErrorLevel)
            select FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId, errorLevel
                from staging
                group by FreeTextNumber, BillingClassification, BillingCode, DefinitionGroup, ExecutionId
                where staging.BillingCode != ''
                    && staging.BillingClassification != ''
                    && staging.DefinitionGroup == executionGroup
                    && staging.ExecutionId == executionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            join custBillingCode
                where staging.BillingCode == custBillingCode.BillingCode
            exists join custBillingCodeVersion
                where custBillingCodeVersion.CustBillingCode == custBillingCode.RecId
                    && (staging.InvoiceDate < custBillingCodeVersion.ValidFrom || staging.InvoiceDate > custBillingCodeVersion.ValidTo);

        // Set the error status in staging table
        update_recordset staging
            setting
                TransferStatus = DMFTransferStatus::Error
            exists join freeTextInvoiceStagingError
                where staging.FreeTextNumber == freeTextInvoiceStagingError.FreeTextNumber
                        && staging.DefinitionGroup == executionGroup
                        && staging.ExecutionId == executionId
                        && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated);

        // Get the error message for each invoice failed to be imported
        while select FreeTextNumber, minof(BillingClassification), minof(BillingCode), minof(ErrorLevel)
            From freeTextInvoiceStagingError
            group by freeTextNumber
            where freeTextInvoiceStagingError.DefinitionGroup == executionGroup
                && freeTextInvoiceStagingError.ExecutionId == executionId
        {
            switch (freeTextInvoiceStagingError.ErrorLevel)
            {
                case FreeTextInvoiceBillingValidationError::NoBillingClassification:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingClassification_Required", freeTextInvoiceStagingError.FreeTextNumber));
                    break;
                case FreeTextInvoiceBillingValidationError::NotSameBillingClassification:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingClassification_NotTheSame", freeTextInvoiceStagingError.FreeTextNumber));
                    break;
                case FreeTextInvoiceBillingValidationError::BillingclassificationNotExist:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingClassification_NotExisted",
                                freeTextInvoiceStagingError.FreeTextNumber,
                                freeTextInvoiceStagingError.BillingClassification));
                    break;
                case FreeTextInvoiceBillingValidationError::BillingCodeNotExist:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingCode_NotExisted",
                                freeTextInvoiceStagingError.FreeTextNumber,
                                freeTextInvoiceStagingError.BillingCode));
                    break;
                case FreeTextInvoiceBillingValidationError::BillingCodeNotInClassification:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingCode_NotInClassification",
                                freeTextInvoiceStagingError.FreeTextNumber,
                                freeTextInvoiceStagingError.BillingCode,
                                freeTextInvoiceStagingError.BillingClassification));
                    break;
                case FreeTextInvoiceBillingValidationError::BillingCodeExpired:
                    error(strFmt("@Publicsector:FreeTextInvoice_BillingCode_Expired",
                                freeTextInvoiceStagingError.FreeTextNumber,
                                freeTextInvoiceStagingError.BillingCode));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerAccount</Name>
				<Source><![CDATA[
    private static void validateCustomerAccount(DMFDefinitionGroupExecution _dmfDefinitionGroupExecution)
    {
        FreeTextInvoiceStaging staging;
        FreeTextInvoiceStagingTmp freeTextInvoiceStagingError;
        DMFExecutionId executionId = _dmfDefinitionGroupExecution.ExecutionId;
        DMFDefinitionGroupName executionGroup = _dmfDefinitionGroupExecution.DefinitionGroup;
        CustTable custTable;
        
        TableName entityName = _dmfDefinitionGroupExecution.Entity;

        insert_recordset freeTextInvoiceStagingError
            (FreeTextNumber, CustomerAccount, DefinitionGroup, ExecutionId)
            select FreeTextNumber, CustomerAccount, DefinitionGroup, ExecutionId
                from staging
                group by FreeTextNumber, CustomerAccount, DefinitionGroup, ExecutionId
                where staging.CustomerAccount != ''
                    && staging.DefinitionGroup == executionGroup
                    && staging.ExecutionId == executionId
                    && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            notexists join custTable
                where staging.CustomerAccount == custTable.AccountNum;

        // Set the error status in staging table
        update_recordset staging
            setting
                TransferStatus = DMFTransferStatus::Error
            where staging.DefinitionGroup == executionGroup
                && staging.ExecutionId == executionId
                && (staging.TransferStatus == DMFTransferStatus::NotStarted || staging.TransferStatus == DMFTransferStatus::Validated)
            exists join freeTextInvoiceStagingError
                where staging.FreeTextNumber == freeTextInvoiceStagingError.FreeTextNumber
                    && staging.CustomerAccount == freeTextInvoiceStagingError.CustomerAccount;

        // Get the error message for each invoice failed to be imported
        while select CustomerAccount
            from freeTextInvoiceStagingError
        join staging
            where staging.FreeTextNumber == freeTextInvoiceStagingError.FreeTextNumber
                && staging.CustomerAccount == freeTextInvoiceStagingError.CustomerAccount
        {
            ErrorMsg error = strFmt("@SYP4986038", fieldPName(CustTable, AccountNum), freeTextInvoiceStagingError.CustomerAccount, tablePName(CustTable));

            DMFStagingValidationLog::insertLogs(
                staging.DefinitionGroup,
                staging.ExecutionId,
                DMFEntity::find(entityName),
                staging.RecId,
                '',
                error,
                DMFSourceTarget::Target);

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFTIImportData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the error message if existing FTI are getting updated while importing file,failed to be imported.
    /// </summary>
    /// <param name = "_dmfDefinitionGroupExecution">The definition group.</param>
    /// <remarks>
    /// Free text invoices are imported unposted. Users are expected to go and post them in a new system afterwards.
    /// Since InvoiceId for free text invoices is updated on re- importing,the same free text invoices again
    /// Query below is to failed the import if free text invoices already exist.
    /// </remarks>
    private static void validateFTIImportData(dmfdefinitiongroupexecution _dmfdefinitiongroupexecution)
    {
        freetextinvoicestaging staging;
        freetextinvoicestagingtmp freetextinvoicestagingerror;
        dmfexecutionid executionid = _dmfdefinitiongroupexecution.executionid;
        dmfdefinitiongroupname executiongroup = _dmfdefinitiongroupexecution.definitiongroup;
        dmfstagingvalidationlog log;
        custinvoicetable custinvoicetable;

        tablename entityname = _dmfdefinitiongroupexecution.entity;

        insert_recordset freetextinvoicestagingerror
            (freetextnumber, customeraccount, definitiongroup, executionid)
            select freetextnumber, customeraccount, definitiongroup, executionid
                from staging
                group by freetextnumber, customeraccount, definitiongroup, executionid
                where staging.customeraccount != ''
                    && staging.definitiongroup == executiongroup
                    && staging.executionid == executionid
                    && (staging.transferstatus == dmftransferstatus::notstarted || staging.transferstatus == dmftransferstatus::validated)
            exists join custinvoicetable
                where staging.freetextnumber == custinvoicetable.invoiceid;

        // set the error status in staging table
        update_recordset staging
            setting
                transferstatus = dmftransferstatus::error
            where staging.definitiongroup == executiongroup
                && staging.executionid == executionid
                && (staging.transferstatus == dmftransferstatus::notstarted || staging.transferstatus == dmftransferstatus::validated)
            exists join freetextinvoicestagingerror
                where staging.freetextnumber == freetextinvoicestagingerror.freetextnumber;

        // get the error message for each duplicate fti failed to be imported
        while select freetextnumber, CustomerAccount
            from freetextinvoicestagingerror
        {
            errormsg error = "@AccountsReceivable:FTIEntity_validationFTI";
            insert_recordset log (definitiongroupname, executionid, stagingrecid, entityname, errormessage)
            select definitiongroup, executionid, recid, entityname, error from staging
                where staging.definitiongroup == executiongroup
                    && staging.executionid == executionid
                    && staging.transferstatus == DMFTransferStatus::Error
                    && staging.FreeTextNumber == freetextinvoicestagingerror.FreeTextNumber
                    && staging.CustomerAccount == freetextinvoicestagingerror.CustomerAccount;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<FormRef>CustFreeInvoice</FormRef>
	<Label>@SYS60858</Label>
	<Tags>Invoice</Tags>
	<DataManagementEnabled>Yes</DataManagementEnabled>
	<DataManagementStagingTable>FreeTextInvoiceStaging</DataManagementStagingTable>
	<EntityCategory>Document</EntityCategory>
	<Modules>AccountsReceivable</Modules>
	<PrimaryCompanyContext>DataAreaId</PrimaryCompanyContext>
	<PrimaryKey>EntityKey</PrimaryKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PropertyNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EInvoiceAccountCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EInvoiceIsLineSpecific</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewUnmappedFieldString">
			<Name>FreeTextNumber</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Label>@AccountsReceivable:FreeTextNumber</Label>
			<Mandatory>Yes</Mandatory>
			<ComputedFieldMethod>generateFreeTextInvoiceNumber</ComputedFieldMethod>
			<StringSize>20</StringSize>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InvoiceDate</Name>
			<DataField>InvoiceDate</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CustomerAccount</Name>
			<DataField>OrderAccount</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InvoiceAccount</Name>
			<DataField>InvoiceAccount</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PostingProfile</Name>
			<DataField>PostingProfile</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CurrencyCode</Name>
			<DataField>CurrencyCode</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>MethodOfPayment</Name>
			<DataField>PaymMode</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>TermsOfPayment</Name>
			<DataField>Payment</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DueDate</Name>
			<DataField>DueDate</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashDiscountCode</Name>
			<DataField>CashDiscCode</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CashDiscountDate</Name>
			<DataField>CashDiscDate</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DocumentDate</Name>
			<DataField>DocumentDate</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LineNumber</Name>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<Mandatory>Yes</Mandatory>
			<DataField>LineNum</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Description</Name>
			<DataField>Description</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LedgerDimension</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>LedgerDimension</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>LedgerDimensionDisplayValue</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<DataField>DisplayValue</DataField>
			<DataSource>LedgerDefaultAccountDAVC</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>Quantity</Name>
			<DataField>Quantity</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>UnitPrice</Name>
			<DataField>UnitPrice</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>AmountCur</Name>
			<DataField>AmountCur</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>SalesTaxGroup</Name>
			<DataField>TaxGroup</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>SalesTaxItemGroup</Name>
			<DataField>TaxItemGroup</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DefaultDimension</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>DefaultDimension</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DefaultDimensionDisplayValue</Name>
			<AllowEdit>Yes</AllowEdit>
			<AllowEditOnCreate>Yes</AllowEditOnCreate>
			<DataField>DisplayValue</DataField>
			<DataSource>DefaultDimensionDAVS</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DirectDebitMandateId</Name>
			<DataField>MandateReference</DataField>
			<DataSource>CustDirectDebitMandate</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CustomerReference</Name>
			<DataField>CustomerRef</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CustomerRequisition</Name>
			<DataField>PurchOrderFormNum</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InvoiceId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>InvoiceId</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BillingClassification</Name>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<Mandatory>No</Mandatory>
			<DataField>BillingClassification</DataField>
			<DataSource>CustBillingClassification</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>BillingCode</Name>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<Mandatory>No</Mandatory>
			<DataField>BillingCode</DataField>
			<DataSource>CustBillingCode</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>EInvoiceAccountCode</Name>
			<DataField>EInvoiceAccountCode</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>EInvoiceIsLineSpecific</Name>
			<DataField>EInvoiceLineSpec</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>GiroType</Name>
			<DataField>GiroType</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>IsLumpSumRecoveryTextPrinted</Name>
			<DataField>PrintOverdueFineTxt_FR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>NGPCode</Name>
			<DataField>NGPCode</DataField>
			<DataSource>NGPCodesTable_FR</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PropertyNumber</Name>
			<DataField>PropertyNumber_MX</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InclTax</Name>
			<DataField>InclTax</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>PostponedVAT</Name>
			<DataField>PostponeVAT</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DeliveryDate</Name>
			<DataField>DeliveryDate_ES</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DiscountPercentage</Name>
			<DataField>CashDiscPercent</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CFOPTableRecId</Name>
			<AccessModifier>Private</AccessModifier>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<DataField>CFOPTable_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CFPSCode</Name>
			<DataField>CFPSId_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>IsFinalUser</Name>
			<DataField>CustFinalUser_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CustomerPaymentFineCode</Name>
			<DataField>FineCode_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalDocumentTypeRecId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>FiscalDocumentType_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalEstablishmentRecId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>FiscalEstablishment_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CustomerPaymentFinancialInterestCode</Name>
			<DataField>InterestCode_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalOperationPresenceType</Name>
			<DataField>PresenceType_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>SalesPurchOperationTypeRecId</Name>
			<AccessModifier>Private</AccessModifier>
			<DataField>SalesPurchOperationType_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>IsServiceDeliveryAddressBased</Name>
			<DataField>ServiceCodeOnDlvAddress_BR</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CFOPCode</Name>
			<DataField>CFOPId</DataField>
			<DataSource>CFOPTable_BR</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalDocumentTypeId</Name>
			<DataField>FiscalDocumentTypeId</DataField>
			<DataSource>FiscalDocumentType_BR</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalEstablishmentId</Name>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<Mandatory>No</Mandatory>
			<DataField>FiscalEstablishmentId</DataField>
			<DataSource>FiscalEstablishment_BR</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>FiscalDocumentOperationTypeId</Name>
			<DataField>OperationTypeID</DataField>
			<DataSource>SalesPurchOperationType_BR</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ComplementaryFiscalDocumentType</Name>
			<DataField>InvoiceComplementaryType</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>TransportationDocumentLineId</Name>
			<DataField>LineId</DataField>
			<DataSource>TransportationDocument</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>InvoiceTxt</Name>
			<DataField>InvoiceTxt</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ConsigneeAccount</Name>
			<DataField>ConsigneeAccount_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>ConsignorAccount</Name>
			<DataField>ConsignorAccount_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>IsCorrection</Name>
			<DataField>Correct_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectedFactureDate</Name>
			<DataField>CorrectedFactureDate_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectedFactureExternalId</Name>
			<DataField>CorrectedFactureExternalId_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectedInvoiceDate</Name>
			<DataField>CorrectedInvoiceDate_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectedInvoiceId</Name>
			<DataField>CorrectedInvoiceId_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectedPeriod</Name>
			<DataField>CorrectedPeriod_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>CorrectionType</Name>
			<DataField>CorrectionType_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>VATOnPayment</Name>
			<DataField>VATOnPayment_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>NonRealRevenue</Name>
			<DataField>NonRealRevenue_RU</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>HeaderDefaultDimensionDisplayValue</Name>
			<Label>@AccountsReceivable:FreeTextInvoiceEntityHeaderLedgerAccount</Label>
			<DataField>DisplayValue</DataField>
			<DataSource>DimensionSetEntity</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>DateOfVATRegister</Name>
			<CountryRegionCodes>PL,CZ,HU,EE,LT,LV</CountryRegionCodes>
			<Label>@GLS109142</Label>
			<DataField>VatDueDate_W</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>SalesDate</Name>
			<CountryRegionCodes>PL,CZ,HU,EE,LT,LV</CountryRegionCodes>
			<Label>@GLS109510</Label>
			<DataField>SalesDate_W</DataField>
			<DataSource>CustInvoiceTable</DataSource>
		</AxDataEntityViewField>
		<AxDataEntityViewField xmlns=""
			i:type="AxDataEntityViewMappedField">
			<Name>OverrideSalesTax</Name>
			<DataField>OverrideSalesTax</DataField>
			<DataSource>CustInvoiceLine</DataSource>
		</AxDataEntityViewField>
	</Fields>
	<Keys>
		<AxDataEntityViewKey>
			<Name>EntityKey</Name>
			<Fields>
				<AxDataEntityViewKeyField>
					<DataField>FreeTextNumber</DataField>
				</AxDataEntityViewKeyField>
				<AxDataEntityViewKeyField>
					<DataField>LineNumber</DataField>
				</AxDataEntityViewKeyField>
			</Fields>
		</AxDataEntityViewKey>
	</Keys>
	<Mappings />
	<Ranges />
	<Relations />
	<StateMachines />
	<ViewMetadata>
		<Name>Metadata</Name>
		<SourceCode>
			<Methods>
				<Method>
					<Name>classDeclaration</Name>
					<Source><![CDATA[
[Query]
public class Metadata extends QueryRun
{
}
]]></Source>
				</Method>
			</Methods>
		</SourceCode>
		<DataSources>
			<AxQuerySimpleRootDataSource>
				<Name>CustInvoiceTable</Name>
				<DynamicFields>Yes</DynamicFields>
				<Table>CustInvoiceTable</Table>
				<DataSources>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>CustInvoiceLine</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>CustInvoiceLine</Table>
						<DataSources>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>LedgerDefaultAccountDAVC</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>DimensionCombinationEntity</Table>
								<DataSources />
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<JoinMode>OuterJoin</JoinMode>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>QueryDataSourceRelation1</Name>
										<Field>LedgerDimension</Field>
										<JoinDataSource>CustInvoiceLine</JoinDataSource>
										<RelatedField>RecId</RelatedField>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>DefaultDimensionDAVS</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>DimensionSetEntity</Table>
								<DataSources />
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<JoinMode>OuterJoin</JoinMode>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>QueryDataSourceRelation1</Name>
										<Field>DefaultDimension</Field>
										<JoinDataSource>CustInvoiceLine</JoinDataSource>
										<RelatedField>RecId</RelatedField>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>CustBillingCode</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>CustBillingCode</Table>
								<DataSources />
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<JoinMode>OuterJoin</JoinMode>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>QueryDataSourceRelation1</Name>
										<Field>CustBillingCode</Field>
										<JoinDataSource>CustInvoiceLine</JoinDataSource>
										<RelatedField>RecId</RelatedField>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
							<AxQuerySimpleEmbeddedDataSource>
								<Name>NGPCodesTable_FR</Name>
								<DynamicFields>Yes</DynamicFields>
								<IsReadOnly>Yes</IsReadOnly>
								<Table>NGPCodesTable_FR</Table>
								<DataSources />
								<DerivedDataSources />
								<Fields />
								<Ranges />
								<JoinMode>OuterJoin</JoinMode>
								<Relations>
									<AxQuerySimpleDataSourceRelation>
										<Name>QueryDataSourceRelation1</Name>
										<Field>NGPCodesTable_FR</Field>
										<JoinDataSource>CustInvoiceLine</JoinDataSource>
										<RelatedField>RecId</RelatedField>
									</AxQuerySimpleDataSourceRelation>
								</Relations>
							</AxQuerySimpleEmbeddedDataSource>
						</DataSources>
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>RecId</Field>
								<JoinDataSource>CustInvoiceTable</JoinDataSource>
								<RelatedField>ParentRecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>CustDirectDebitMandate</Name>
						<DynamicFields>Yes</DynamicFields>
						<Table>CustDirectDebitMandate</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>DirectDebitMandate</Field>
								<JoinDataSource>CustInvoiceTable</JoinDataSource>
								<RelatedField>RecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>CustBillingClassification</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>CustBillingClassification</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>CustBillingClassification</Field>
								<JoinDataSource>CustInvoiceTable</JoinDataSource>
								<RelatedField>RecId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>CFOPTable_BR</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>CFOPTable_BR</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<JoinRelationName>CFOPTable_BR</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>FiscalDocumentType_BR</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>FiscalDocumentType_BR</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<JoinRelationName>FiscalDocumentType_BR</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>FiscalEstablishment_BR</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>FiscalEstablishment_BR</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<JoinRelationName>FiscalEstablishment_BR</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>SalesPurchOperationType_BR</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>SalesPurchOperationType_BR</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<JoinRelationName>SalesPurchOperationType_BR</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>TransportationDocument</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>TransportationDocument</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<JoinRelationName>TransportationDocument</JoinRelationName>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
					<AxQuerySimpleEmbeddedDataSource>
						<Name>DimensionSetEntity</Name>
						<DynamicFields>Yes</DynamicFields>
						<IsReadOnly>Yes</IsReadOnly>
						<Table>DimensionSetEntity</Table>
						<DataSources />
						<DerivedDataSources />
						<Fields />
						<Ranges />
						<JoinMode>OuterJoin</JoinMode>
						<Relations>
							<AxQuerySimpleDataSourceRelation>
								<Name>QueryDataSourceRelation1</Name>
								<Field>DefaultDimension</Field>
								<JoinDataSource>CustInvoiceTable</JoinDataSource>
								<RelatedField>RecordId</RelatedField>
							</AxQuerySimpleDataSourceRelation>
						</Relations>
					</AxQuerySimpleEmbeddedDataSource>
				</DataSources>
				<DerivedDataSources />
				<Fields />
				<Ranges />
				<GroupBy />
				<Having />
				<OrderBy />
			</AxQuerySimpleRootDataSource>
		</DataSources>
	</ViewMetadata>
</AxDataEntityView>